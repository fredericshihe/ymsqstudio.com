<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>耶胡迪梅纽因学校琴房管理系统</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<style>
:root {
    --primary-color:#3498db;
    --secondary-color:#2ecc71;
    --background-color:#f5f7fa;
    --text-color:#34495e;
    --border-color:#bdc3c7;
    --hover-color:#2980b9;
    --queue-color:#9b59b6;
    --success-color:#27ae60;
    --warning-color:#f39c12;
    --danger-color:#e74c3c;
    --muted-color:#95a5a6;
    --panel-radius:16px;
    --transition:0.3s ease;
    --shadow-sm:0 2px 5px rgba(0,0,0,.1);
    --shadow-md:0 4px 8px rgba(0,0,0,.15);
    --shadow-lg:0 10px 30px rgba(0,0,0,.25);
    font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
}

/* ========== 基础布局与标题 ========== */
body {
    margin:0 auto;
    max-width:1200px;
    padding:20px;
    background:var(--background-color);
    color:var(--text-color);
    font-size:14px;
}
h1,h2,h3,h4 {text-align:center;color:var(--primary-color);margin:0 0 15px;}
h3{font-size:1.2em} h1{margin-top:10px;}
button {
    background:var(--primary-color);
    color:#fff;
    border:none;
    padding:10px 15px;
    border-radius:6px;
    cursor:pointer;
    transition:background .25s;
    font-size:14px;
}
button:hover{background:var(--hover-color)}
small{font-size:.8em;}
.hidden{display:none!important;}
.flex{display:flex;}
.center{justify-content:center;align-items:center;}
.pointer{cursor:pointer;}
.text-muted{color:#666;}
.text-danger{color:var(--danger-color);}
.text-success{color:var(--success-color);}
.text-warning{color:var(--warning-color);}
.bold{font-weight:700;}
.panel {
    background:#fff;
    border-radius:var(--panel-radius);
    box-shadow:var(--shadow-sm);
    padding:20px;
    margin:20px 0;
    border-left:4px solid var(--primary-color);
}
.panel.secondary{border-left-color:var(--secondary-color);}
.panel.queue{border-left-color:var(--queue-color);}
.panel.warning{border-left-color:var(--warning-color);}
.panel.orange{border-left-color:#e67e22;}
.panel.no-pad{padding:0;}
.separator{height:1px;background:#eee;margin:15px 0;}
.inline-block{display:inline-block;}
.grid{display:grid;gap:15px;}
.fade-in{animation:fadeIn .4s;}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}
@keyframes shake{0%,100%{transform:translateX(0)}10%,30%,50%,70%,90%{transform:translateX(-5px)}20%,40%,60%,80%{transform:translateX(5px)}}
@keyframes queueFlash{0%,50%{background:#fff3cd;border-color:#ffeaa7}51%,100%{background:#f8f9fa;border-color:var(--border-color)}}
@keyframes overtimeGlow{0%,100%{box-shadow:0 1px 3px rgba(0,0,0,.1)}50%{box-shadow:0 1px 3px rgba(231,76,60,.3),0 0 8px rgba(231,76,60,.2)}}
@keyframes preparingGlow{0%,100%{box-shadow:0 1px 3px rgba(0,0,0,.1)}50%{box-shadow:0 1px 3px rgba(243,156,18,.3),0 0 8px rgba(243,156,18,.2)}}
@keyframes timelineIconPulse{0%,100%{transform:scale(1)}50%{transform:scale(1.1)}}
@keyframes searchStatusPulse{0%{opacity:1}50%{opacity:.7}100%{opacity:1}}
@keyframes flash{0%{background:#fff3cd}100%{background:transparent}}
@keyframes pulseExpired{0%{box-shadow:0 0 0 0 rgba(231,76,60,.4)}70%{box-shadow:0 0 0 8px rgba(231,76,60,0)}100%{box-shadow:0 0 0 0 rgba(231,76,60,0)}}

/* ========== 通用表单/输入 ========== */
input[type=text],input[type=password],select{
    padding:8px 10px;
    border:1px solid var(--border-color);
    border-radius:6px;
    font-size:14px;
    box-sizing:border-box;
}
input:focus,select:focus{outline:none;border-color:var(--primary-color);}
textarea{font-family:inherit;font-size:14px;}
.clear-btn{background:#95a5a6}
.clear-btn:hover{background:#7f8c8d}

/* ========== 颜色状态标签 ========== */
/* 搜索结果中的状态（只有文字颜色） */
.status-preparing{color:var(--warning-color);font-weight:600;}
.status-practicing{color:#3498db;font-weight:600;}
.status-overtime{color:var(--danger-color)!important;font-weight:600;animation:pulse 2s infinite;}
.status-queuing{color:var(--queue-color)!important;font-weight:600;}
.status-available{color:var(--success-color)!important;font-weight:600;}
.status-free{color:var(--muted-color)!important;font-weight:400;}

/* 房间卡片中的状态（有背景色） - 改为更具体的选择器 */
.room .room-status-preparing,
.room-status-chip.preparing{color:#fff;background:var(--warning-color);font-weight:600;}
.room .room-status-practicing,
.room-status-chip.in-use{color:#fff;background:#3498db;font-weight:600;}
.room .room-status-overtime,
.room-status-chip.expired{color:var(--danger-color)!important;font-weight:600;animation:pulse 2s infinite;}
.attendance-status{display:inline-block;padding:2px 8px;border-radius:12px;font-size:11px;font-weight:700;text-align:center;color:#fff;}
.attendance-status.status-absent{background:var(--danger-color);}
.attendance-status.status-present{background:var(--success-color);}
.attendance-status.status-low_efficiency{background:var(--warning-color);}
.attendance-status.status-under_review{background:var(--warning-color);}
.attendance-status.status-excused{background:var(--muted-color);}

/* 学生状态徽章（列表中） */
.student-status-badge{
    background:#7f8c8d;
    color:#fff;
    font-size:11px;
    padding:3px 8px;
    border-radius:12px;
    white-space:nowrap;
    max-width:140px;
    overflow:hidden;
    text-overflow:ellipsis;
}
.student-status-badge.practicing{background:#3498db;}
.student-status-badge.preparing{background:var(--warning-color);}
.student-status-badge.overtime{background:var(--danger-color);}
.student-status-badge.queuing{background:var(--queue-color);}

/* ========== Toast ========== */
.toast{
    position:fixed;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    background:rgba(0,0,0,.7);
    color:#fff;
    padding:10px 20px;
    border-radius:6px;
    display:none;
    z-index:2000;
    font-size:14px;
}

/* ========== 琴房卡片 ========== */
/* ========== 琴房卡片统一样式（优化版） ========== */
.room-container{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(220px,1fr));
  gap:12px;
  margin-top:15px;
  padding:4px;
}

.room{
  position:relative;
  background:#fff;
  border:1px solid #dbe1e5;
  border-radius:12px;
  padding:14px;
  display:flex;
  flex-direction:column;
  gap:8px;
  font-size:13px;
  line-height:1.4;
  box-shadow:0 2px 6px rgba(0,0,0,.08);
  transition:.22s ease;
  min-height:95px;
  cursor:pointer;
  overflow:hidden; /* 防止内容溢出 */
}

.room:hover{
  box-shadow:0 6px 16px rgba(0,0,0,.15);
  border-color:#c8d0d6;
  transform:translateY(-2px);
  z-index:2;
}

/* 琴房类型左边框样式 */
.room.type-grand{
  border-left:4px solid #9b59b6;
}
.room.type-upright{
  border-left:4px solid #3498db;
}
.room.type-none{
  border-left:4px solid #95a5a6;
}

/* Hover 强调效果 */
.room.type-grand:hover{
  box-shadow:0 6px 16px rgba(155,89,182,.2);
}
.room.type-upright:hover{
  box-shadow:0 6px 16px rgba(52,152,219,.2);
}
.room.type-none:hover{
  box-shadow:0 6px 16px rgba(149,165,166,.2);
}

/* 琴房名称样式 - 适中显示 */
.room-name{
  font-weight:700;
  font-size:15px; /* 从16px调整到15px */
  color:#2c3e50;
  margin-bottom:2px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* 琴房状态区域 */
.room-status{
  flex:1;
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  gap:6px;
}

/* 学生信息行 - 适中显示 */
.room-student-info{
  font-size:13px; /* 从15px调整到13px */
  color:#2f4150;
  font-weight:600;
  display:flex;
  align-items:center;
  gap:6px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
  margin-bottom:4px;
}

.room-student-dot{
  width:6px; /* 从8px调整到6px */
  height:6px;
  border-radius:50%;
  background:#27ae60;
  flex-shrink:0;
}

.room.preparing .room-student-dot{
  background:#f39c12;
}

.room.in-use .room-student-dot{
  background:#3498db;
}

.room.expired .room-student-dot{
  background:#e74c3c;
}

/* 底部状态和操作区域 - 紧凑布局 */
.room-bottom-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-top:auto;
  gap:8px;
  padding-top:6px;
  border-top:1px solid #f1f3f4;
  min-height:28px; /* 确保最小高度 */
}

/* 状态芯片 - 缩小尺寸 */
.room-status-chip{
  padding:3px 8px; /* 从5px 12px调整 */
  font-size:11px; /* 从12px调整到11px */
  line-height:1.2;
  border-radius:6px; /* 从8px调整 */
  font-weight:600; /* 从700调整 */
  letter-spacing:0.1px;
  white-space:nowrap;
  flex-shrink:0;
  max-width:120px; /* 限制最大宽度 */
  overflow:hidden;
  text-overflow:ellipsis;
}

.room-status-chip.preparing{
  background:#fff3cd;
  color:#856404;
  border:1px solid #ffeaa7;
}

.room-status-chip.in-use{
  background:#cce7ff;
  color:#0066cc;
  border:1px solid #99d6ff;
}

.room-status-chip.expired{
  background:#f8d7da;
  color:#721c24;
  border:1px solid #f1aeb5;
}

.room-status-chip.available{
  background:#d5f4e6;
  color:#0d7337;
  border:1px solid #a3e9c4;
}

/* 操作按钮区域 */
.room-actions{
  display:flex;
  justify-content:flex-end;
  flex-shrink:0;
}

/* 清空按钮 - 缩小尺寸 */
.room-clear-btn{
  background:#e74c3c;
  color:#fff;
  border:none;
  padding:4px 8px; /* 从6px 12px调整 */
  border-radius:4px; /* 从6px调整 */
  font-size:10px; /* 从11px调整 */
  font-weight:600;
  cursor:pointer;
  transition:all .2s ease;
  display:flex;
  align-items:center;
  gap:2px; /* 从4px调整 */
  opacity:0.9;
  white-space:nowrap;
  min-width:40px; /* 确保最小宽度 */
}

.room-clear-btn:hover{
  background:#c0392b;
  opacity:1;
  transform:translateY(-1px);
}

.room-clear-btn:active{
  transform:translateY(0);
}

/* 清空按钮图标和文字 */
.room-clear-btn span:first-child{
  font-size:8px; /* X图标更小 */
}

.room-clear-btn span:last-child{
  font-size:10px; /* 文字大小 */
}
/* ==== 双击清空 & 续琴房 功能新增样式 BEGIN ==== */
.room-remark{
  font-size:11px;
  color:#666;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  margin:2px 0 4px;
}
.room-renew-btn{
  background:#27ae60;
  color:#fff;
  border:none;
  padding:4px 8px;
  border-radius:4px;
  font-size:10px;
  font-weight:600;
  cursor:pointer;
  transition:all .2s ease;
  display:flex;
  align-items:center;
  gap:2px;
  opacity:0.9;
  white-space:nowrap;
  min-width:40px;
  margin-left:4px;
}
.room-renew-btn:hover{
  background:#1e8449;
  opacity:1;
  transform:translateY(-1px);
}
.room-renew-btn:active{
  transform:translateY(0);
}
/* 鼠标提示：支持双击清空 */
.room[data-has-student="1"]{
  cursor:pointer;
}
.room[data-has-student="1"]::after{
  content:'双击清空';
  position:absolute;
  top:6px;
  right:8px;
  font-size:10px;
  color:#999;
  pointer-events:none;
}
/* ==== 双击清空 & 续琴房 功能新增样式 END ==== */

/* 空闲状态的琴房不显示底部行 */
.room:not(.preparing):not(.in-use):not(.expired) .room-bottom-row{
  display:none;
}

/* 响应式调整 */
@media (max-width: 768px) {
  .room-container{
    grid-template-columns:repeat(auto-fill,minmax(180px,1fr));
    gap:10px;
  }
  
  .room{
    padding:12px;
    min-height:85px;
  }
  
  .room-name{
    font-size:14px;
  }
  
  .room-student-info{
    font-size:12px;
  }
  
  .room-status-chip{
    font-size:10px;
    padding:2px 6px;
    max-width:100px;
  }
  
  .room-clear-btn{
    padding:3px 6px;
    font-size:9px;
    min-width:35px;
  }
}

@media (max-width: 480px) {
  .room-container{
    grid-template-columns:1fr 1fr;
    gap:8px;
  }
  
  .room{
    padding:10px;
    min-height:80px;
  }
  
  .room-name{
    font-size:13px;
  }
  
  .room-student-info{
    font-size:11px;
  }
  
  .room-bottom-row{
    gap:6px;
  }
  
  .room-status-chip{
    font-size:9px;
    padding:2px 5px;
    max-width:80px;
  }
  
  .room-clear-btn{
    padding:2px 5px;
    font-size:8px;
    min-width:30px;
  }
}


/* ========== 楼层概览按钮 ========== */
.floor-buttons{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:15px;margin:15px 0;}
.floor-btn{
    padding:18px 14px;
    background:var(--primary-color);
    color:#fff;
    border:none;
    border-radius:12px;
    font-size:16px;
    font-weight:700;
    text-align:center;
    transition:var(--transition);
    position:relative;
}
.floor-btn:hover{background:var(--hover-color);transform:translateY(-3px);box-shadow:var(--shadow-md);}
.floor-info{font-size:12px;margin-top:6px;opacity:.95;line-height:1.3;}

/* ========== 需求面板按钮 ========== */
.demand-buttons{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;margin-top:15px;}
.demand-btn{
    border:none;
    border-radius:14px;
    color:#fff;
    font-weight:700;
    padding:18px 20px;
    cursor:pointer;
    font-size:16px;
    transition:var(--transition);
    text-align:center;
}
.demand-btn:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.2);}
.demand-btn.grand-piano{background:linear-gradient(135deg,#9b59b6,#8e44ad);}
.demand-btn.upright-piano{background:linear-gradient(135deg,#3498db,#2980b9);}
.demand-btn.no-piano{background:linear-gradient(135deg,#95a5a6,#7f8c8d);}
/* ==== 快速需求按钮状态文字统一白色 BEGIN ==== */
/* 仅影响放在 .demand-btn 内部的状态行，不改其它位置的同类状态色 */
.demand-btn .status-available,
.demand-btn .status-overtime,
.demand-btn .status-queue,
.demand-btn .status-queuing,
.demand-btn .status-preparing,
.demand-btn .status-practicing,
.demand-btn .status-free {
  color:#fff !important;
  text-shadow:0 1px 2px rgba(0,0,0,.25); /* 提升在亮/浅色渐变上的可读性，可按需删除 */
}
/* 如果未来还会出现新的 status-* 类，也一并变白，可用通配写法（可二选一） */
/*
.demand-btn [class^="status-"],
.demand-btn [class*=" status-"]{
  color:#fff !important;
  text-shadow:0 1px 2px rgba(0,0,0,.25);
}
*/
/* ==== 快速需求按钮状态文字统一白色 END ==== */
/* ========== 琴房选择网格 ========== */
.room-select-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 12px;
  max-height: 400px;
  overflow-y: auto;
  padding: 8px 4px;
}

.room-select-card {
  background: #fff;
  border: 2px solid #e3f2fd;
  border-radius: 12px;
  padding: 12px;
  cursor: pointer;
  transition: all 0.25s ease;
  position: relative;
  min-height: 80px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.room-select-card:hover {
  border-color: var(--primary-color);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
}

.room-select-card.available {
  border-color: var(--success-color);
  background: linear-gradient(135deg, #e8f8f5, #fff);
}

.room-select-card.overtime {
  border-color: var(--danger-color);
  background: linear-gradient(135deg, #fdeaea, #fff);
}

.room-card-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
}

.room-type-icon {
  font-size: 16px;
  flex-shrink: 0;
}

.room-card-name {
  font-weight: 700;
  font-size: 14px;
  color: var(--text-color);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}

.room-card-location {
  font-size: 12px;
  color: #666;
  margin-bottom: 6px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.room-overtime-info {
  font-size: 11px;
  line-height: 1.3;
}

.room-select-arrow {
  position: absolute;
  bottom: 8px;
  right: 10px;
  color: var(--primary-color);
  font-weight: 600;
  font-size: 16px;
}

/* 响应式调整 */
@media (max-width: 768px) {
  .room-select-grid {
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 8px;
  }
  
  .room-select-card {
    padding: 10px;
    min-height: 70px;
  }
}

@media (max-width: 480px) {
  .room-select-grid {
    grid-template-columns: 1fr 1fr;
  }
}

/* ========== 排队系统 ========== */
.queue-section .queue-subsection{margin-bottom:20px;padding:15px;border:1px solid var(--border-color);border-radius:10px;background:#f9f9f9;}
.queue-header,.queue-subheader{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;}
.queue-title{color:var(--queue-color);margin:0;}
.queue-list{min-height:50px;border:2px dashed var(--border-color);border-radius:8px;padding:10px;background:#f9f9f9;}
.queue-item{
    display:flex;align-items:center;gap:8px;
    padding:8px 10px;
    margin-bottom:6px;
    background:#fff;
    border:1px solid var(--border-color);
    border-radius:8px;
    transition:.2s;
}
.queue-item:last-child{margin-bottom:0;}
.queue-item:hover{background:#f0f0f0;transform:translateX(5px);}
.queue-item.has-available-rooms{animation:queueFlash 2s infinite;cursor:pointer;}
.queue-number{
    background:var(--queue-color);
    color:#fff;
    width:25px;height:25px;
    display:flex;align-items:center;justify-content:center;
    border-radius:50%;font-size:.75em;font-weight:700;flex-shrink:0;
}
.queue-student-info{flex:1;display:flex;flex-direction:column;min-width:0;}
.queue-student-name{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.queue-wait{font-size:.68em;color:#555;margin-top:4px;white-space:nowrap;}
.queue-actions{display:flex;gap:4px;}
.queue-btn{
    border:none;
    background:#eee;
    width:28px;height:28px;
    border-radius:6px;
    cursor:pointer;
    font-size:14px;
    display:flex;justify-content:center;align-items:center;
    transition:.25s;
}
/* 队列容器明确使用列布局，避免重排错位 */
.queue-list{
  display:flex;
  flex-direction:column;
}

/* 避免 hover 位移导致快速删除时布局闪烁，可改为背景高亮 */
.queue-item{
  position:relative;
  transition:background .25s, box-shadow .25s;
  /* 移除 transform 相关视觉抖动 */
}
.queue-item:hover{
  background:#eef2f5;
  box-shadow:0 2px 6px rgba(0,0,0,.08);
  transform:none;
}

/* 可点击（ready=1）时统一指针样式 */
.queue-item.has-available-rooms{
  cursor:pointer;
  /* 若 animation 造成错位，可临时关闭： */
  /* animation:none; */
  outline:2px solid #ffe28a; /* 更稳定显示 */
}

/* 若仍怀疑 animation 引起错位，可取消 */
@keyframes queueFlash{
  0%,50%{background:#fffbe6;border-color:#ffd666;}
  51%,100%{background:#f9f9f9;border-color:var(--border-color);}
}

.queue-btn:hover{background:#ddd;}
.queue-btn.up{color:var(--secondary-color);}
.queue-btn.down{color:var(--warning-color);}
.queue-btn.remove{color:var(--danger-color);}
.empty-queue{text-align:center;color:#999;font-style:italic;padding:12px;font-size:.85em;}

/* ========== 搜索 ========== */
.search-section{padding:20px;background:#fff;border-radius:var(--panel-radius);box-shadow:var(--shadow-sm);border-left:4px solid var(--primary-color);}
.search-container{display:flex;gap:10px;align-items:center;margin-bottom:15px;}
#globalSearch{flex:1;padding:12px 16px;border:2px solid var(--border-color);border-radius:8px;font-size:16px;transition:.3s;}
#globalSearch:focus{border-color:var(--primary-color);outline:none;}
.search-results{
    background:#f8f9fa;
    border:1px solid var(--border-color);
    border-radius:8px;
    max-height:420px;
    overflow-y:auto;
}
.search-category{background:var(--primary-color);color:#fff;padding:8px 14px;font-weight:700;font-size:.9em;position:sticky;top:0;z-index:1;}
.search-item{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:10px 14px;
    border-bottom:1px solid #e0e0e0;
    transition:.2s;
}
.search-item:hover{background:#e3f2fd;}
.search-item:last-child{border-bottom:none;}
.search-item-name{font-weight:700;font-size:1.05em;}
.search-item-status{font-size:.85em;color:#666;}
.search-item-actions{display:flex;gap:6px;}
.search-action-btn{
    padding:6px 10px;
    border:none;
    border-radius:4px;
    cursor:pointer;
    font-size:.75em;
    font-weight:600;
}
.search-clear-btn{background:var(--danger-color);color:#fff;}
.search-clear-btn:hover{background:#c0392b;}
.search-queue-btn{background:var(--queue-color);color:#fff;}
.search-queue-btn:hover{background:#8e44ad;}
.search-assign-btn{background:var(--secondary-color);color:#fff;}
.search-assign-btn:hover{background:#27ae60;}
.search-no-results{text-align:center;padding:30px;color:#999;font-style:italic;}

/* ========== 学生选择/数据库/时间段 ========== */
/* 年级徽章样式 */
.grade-badge {
    display: inline-block;
    background: #e67e22;
    color: #fff;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    white-space: nowrap;
    margin-left: 4px;
    font-weight: 600;
}

/* 年级筛选器样式 */
#gradeFilter {
    padding: 6px 8px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 12px;
    min-width: 100px;
}

/* 年级输入框提示样式 */
#editStudentGrade {
    font-family: monospace;
}

#editStudentGrade::placeholder {
    font-family: inherit;
    color: #999;
    font-style: italic;
}

.student-item{
    display:flex;align-items:center;gap:10px;padding:8px 12px;cursor:pointer;transition:.2s;width:100%;box-sizing:border-box;border-radius:6px;
}
.student-item:hover{background:#e0e0e0;}
.student-item.disabled-student{opacity:.55;cursor:not-allowed;}
/* 🔥 新增：键盘选中状态样式 */
.student-item.keyboard-selected{
    background:#007acc !important;
    color:#fff !important;
    box-shadow:0 0 0 2px rgba(0,122,204,0.3);
}
.student-item.keyboard-selected .student-name-text{
    color:#fff;
}
.student-name-text{flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:500;}
/* 在现有CSS中添加以下样式 */

/* 可强制替换的学生项样式 */
.student-item.force-replaceable {
    border-left: 3px solid #f39c12;
    background: linear-gradient(135deg, #fff3cd, #ffffff);
}

.student-item.force-replaceable:hover {
    background: linear-gradient(135deg, #ffeaa7, #fff3cd);
    cursor: pointer;
}

/* 强制替换提示图标 */
.force-replace-hint {
    color: #f39c12;
    font-weight: bold;
    margin-left: 8px;
    animation: pulse 2s infinite;
}

/* 脉冲动画 */
@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

/* 禁用状态但可强制替换的特殊样式 */
.student-item.disabled-student.force-replaceable {
    opacity: 0.8;
    cursor: pointer;
}

.student-item.disabled-student.force-replaceable:hover {
    opacity: 1;
}

.time-slot-badge,.weekly-summary-slot{display:inline-block;background:#e3f2fd;color:var(--primary-color);padding:2px 8px;border-radius:12px;font-size:.75em;margin:2px 4px 2px 0;}
.time-slot-item{display:flex;justify-content:space-between;align-items:center;padding:10px;margin-bottom:8px;background:#fff;border:1px solid var(--border-color);border-radius:6px;}
.delete-time-slot{background:var(--danger-color);color:#fff;padding:4px 8px;font-size:12px;border:none;border-radius:4px;cursor:pointer;}
.delete-time-slot:hover{background:#c0392b;}
.weekly-summary{background:#f8f9fa;padding:15px;border-radius:8px;margin:20px 0;border:1px solid var(--border-color);}
.weekly-summary-day{margin-bottom:12px;padding:10px;background:#fff;border-radius:6px;border-left:4px solid var(--primary-color);}
.weekly-summary-day-title{font-weight:700;margin-bottom:5px;}
.weekly-summary-empty{text-align:center;color:#999;font-style:italic;padding:25px;}
/* 优化学生库按钮显示 */
.student-db-item .student-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.student-db-item .student-action-btn {
    padding: 6px 5px;
    font-size: 12px;
    min-width: 70px;
    white-space: nowrap;
    border-radius: 6px;
}

/* ========== 时间段管理模态框样式优化 ========== */
.weekday-buttons{
  display:grid;
  grid-template-columns:repeat(5,1fr);
  gap:12px; /* 增加间距 */
  margin-bottom:20px;
}

.weekday-btn{
  padding:14px 16px; /* 增加内边距 */
  border:2px solid var(--border-color);
  background:#fff;
  border-radius:10px; /* 更圆润 */
  cursor:pointer;
  font-size:16px; /* 增大字体 */
  font-weight:600; /* 加粗 */
  color:#2c3e50; /* 深色文字 */
  transition:all .25s ease;
  min-height:50px; /* 确保最小高度 */
  display:flex;
  align-items:center;
  justify-content:center;
}

.weekday-btn:hover{
  border-color:var(--primary-color);
  background:#e3f2fd;
  color:var(--primary-color);
  transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(52,152,219,.2);
}

.weekday-btn.active{
  background:var(--primary-color);
  color:#fff;
  border-color:var(--primary-color);
  font-weight:700;
  box-shadow:0 4px 12px rgba(52,152,219,.3);
}

.weekday-btn.active:hover{
  background:var(--hover-color);
  border-color:var(--hover-color);
}
@keyframes pulse-green{
    0%,100%{box-shadow:0 0 0 0 rgba(46,204,113,.4)}
    50%{box-shadow:0 0 0 4px rgba(46,204,113,0)}
}

/* ========== 时间轴、预测与分类统计 ========== */
.timeline-control-container{display:flex;justify-content:center;margin:15px 0;}
.timeline-control-btn{
    background:linear-gradient(135deg,#e67e22,#d35400);
    color:#fff;
    padding:12px 24px;
    border-radius:25px;
    display:flex;
    align-items:center;
    gap:8px;
    font-size:14px;
    font-weight:500;
    box-shadow:0 2px 8px rgba(230,126,34,.3);
    cursor:pointer;
    border:none;
    min-width:180px;
    transition:.3s;
}
/* ==== Focus 监控：一行 4 个卡片，超出竖向滚动 ==== */
.focus-group-body{
  display:grid;
  grid-template-columns:repeat(4,1fr) !important;
  gap:12px;
  max-height:160px;         /* 增加高度以容纳 hover 效果 */
  overflow-y:auto;
  padding:4px 4px 8px 4px;  /* 增加上下内边距 */
}

.focus-group-body::-webkit-scrollbar{
  width:8px;
}
.focus-group-body::-webkit-scrollbar-thumb{
  background:#d0d4d8;
  border-radius:4px;
}
.focus-group-body::-webkit-scrollbar-thumb:hover{
  background:#b5bbc0;
}

.focus-card{
  padding:8px 8px 8px;
  min-height:86px;
  font-size:12px;
  /* 关键：确保 hover 时不被遮挡 */
  position:relative;
  z-index:1;
}

/* 优化 hover 效果，避免边缘遮挡 */
.focus-card:hover{
  box-shadow:0 6px 16px rgba(0,0,0,.15);
  border-color:#c8d0d6;
  transform:translateY(-4px);
  z-index:2; /* hover 时提升层级 */
}

/* 响应式降级：屏幕窄时自动减少列数 */
@media (max-width:1100px){
  .focus-group-body{
    grid-template-columns:repeat(3,1fr) !important;
    max-height:180px; /* 3列时需要更多高度 */
  }
}
@media (max-width:780px){
  .focus-group-body{
    grid-template-columns:repeat(2,1fr) !important;
    max-height:none;              /* 小屏直接全部展开，触控更友好 */
    overflow-y:visible;
    padding:4px;
  }
}
@media (max-width:460px){
  .focus-group-body{
    grid-template-columns:repeat(1,1fr) !important;
    max-height:none;
    overflow-y:visible;
  }
}

/* === 聚焦：15分钟内释放 + 超时 样式 优化版 === */
.focus-groups{
  display:flex;
  flex-direction:column;
  gap:20px;
}
.focus-group{
  background:#fff;
  border:1px solid #e3e6e9;
  border-radius:16px;
  padding:16px 18px 18px;
  box-shadow:var(--shadow-sm);
  display:flex;
  flex-direction:column;
  gap:14px;
  position:relative;
}
.focus-group.soon{border-left:6px solid #3498db;}
.focus-group.overtime{border-left:6px solid var(--danger-color);}
.focus-group-header{
  display:flex;
  flex-direction:column;
  gap:4px;
}
.focus-group-title{
  font-size:16px;
  font-weight:700;
  color:#2c3e50;
  display:flex;
  align-items:center;
  gap:8px;
}
.focus-group-title span{
  font-weight:600;
  font-size:14px;
  color:#666;
  margin-left:2px;
}
.focus-group-sub{
  font-size:12px;
  color:#8b98a3;
  line-height:1.4;
}

/* 🔥 关键修改：统一使用琴房卡片的网格布局 */
.focus-group-body{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(220px,1fr));
  gap:12px;
  margin-top:15px;
  padding:4px;
}

/* 🔥 关键修改：统一卡片样式与琴房卡片保持一致 */
.focus-card{
  position:relative;
  background:#fff;
  border:1px solid #dbe1e5;
  border-radius:12px;
  padding:14px;
  display:flex;
  flex-direction:column;
  gap:8px;
  font-size:13px;
  line-height:1.4;
  box-shadow:0 2px 6px rgba(0,0,0,.08);
  transition:.22s ease;
  min-height:95px;
  cursor:default;
  overflow:hidden;
}

.focus-card:hover{
  box-shadow:0 6px 16px rgba(0,0,0,.15);
  border-color:#c8d0d6;
  transform:translateY(-2px);
  z-index:2;
}

/* 琴房类型左边框样式 */
.focus-card.soon{
  border-left:4px solid #3498db;
}
.focus-card.overtime{
  border-left:4px solid var(--danger-color);
}

/* Hover 强调效果 */
.focus-card.soon:hover{
  box-shadow:0 6px 16px rgba(52,152,219,.2);
}
.focus-card.overtime:hover{
  box-shadow:0 6px 16px rgba(231,76,60,.2);
}

/* 琴房名称样式 - 与琴房卡片一致 */
.focus-card .fc-room{
  font-weight:700;
  font-size:15px;
  color:#2c3e50;
  margin-bottom:2px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* 类型标签优化 - 更小更简洁 */
.fc-tag{
  background:#f0f3f6;
  color:#556270;
  padding:2px 6px;
  border-radius:8px;
  font-size:9px;
  font-weight:700;
  flex-shrink:0;
  letter-spacing:0.2px;
  margin-left:6px;
}
.fc-tag.grand{background:#fff3e0;color:#b06000;border:1px solid #f4d03f;}
.fc-tag.upright{background:#e8f4fd;color:#1a628f;border:1px solid #aed6f1;}
.fc-tag.none{background:#f4f4f4;color:#555;border:1px solid #d5d8dc;}

/* 学生信息行 - 与琴房卡片一致 */
.fc-stu{
  font-size:13px;
  color:#2f4150;
  font-weight:600;
  display:flex;
  align-items:center;
  gap:6px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
  margin-bottom:4px;
}
.fc-stu .dot{
  width:6px;
  height:6px;
  border-radius:50%;
  background:#3498db;
  flex-shrink:0;
}
.focus-card.overtime .fc-stu .dot{
  background:var(--danger-color);
}
.focus-card.soon .fc-stu .dot{
  background:#3498db;
}

/* 状态信息区域 - 简化布局 */
.focus-card .fc-status{
  flex:1;
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  gap:6px;
}

/* 底部状态行 - 仿照琴房卡片 */
.focus-card .fc-bottom-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-top:auto;
  gap:8px;
  padding-top:6px;
  border-top:1px solid #f1f3f4;
  min-height:28px;
}

/* 状态芯片 - 与琴房卡片样式一致 */
.fc-chip{
  padding:3px 8px;
  font-size:11px;
  line-height:1.2;
  border-radius:6px;
  font-weight:600;
  letter-spacing:0.1px;
  white-space:nowrap;
  flex-shrink:0;
  max-width:120px;
  overflow:hidden;
  text-overflow:ellipsis;
}

.fc-chip.remain{
  background:#d5f4e6;
  color:#0d7337;
  border:1px solid #a3e9c4;
}
.fc-chip.soon{
  background:#cce7ff;
  color:#0066cc;
  border:1px solid #99d6ff;
}
.fc-chip.overtime{
  background:#f8d7da;
  color:#721c24;
  border:1px solid #f1aeb5;
}
.fc-chip.location{
  background:#f8f9fa;
  color:#687580;
  font-weight:500;
  max-width:100%;
  overflow:hidden;
  text-overflow:ellipsis;
}

/* 空状态优化 */
.focus-empty{
  grid-column:1/-1;
  font-size:13px;
  color:#999;
  text-align:center;
  padding:24px 12px;
  border:2px dashed #d5dadd;
  border-radius:12px;
  background:#fafbfc;
  font-style:italic;
}

/* 过滤结果为空时的提示 */
.focus-empty-filter{
  grid-column:1/-1;
  text-align:center;
  font-size:13px;
  padding:18px 12px;
  border:2px dashed #d5dadd;
  border-radius:12px;
  color:#999;
  background:#fafbfc;
  font-style:italic;
}

/* 脚注说明优化 */
.focus-foot-note{
  margin-top:16px;
  font-size:12px;
  color:#82909a;
  line-height:1.6;
  background:#f8f9fa;
  padding:12px 16px;
  border-radius:12px;
  border:1px solid #e1e5e8;
  text-align:center;
}

/* 响应式优化 */
@media (max-width: 768px) {
  .focus-group-body{
    grid-template-columns:repeat(auto-fill,minmax(180px,1fr));
    gap:10px;
  }
  
  .focus-card{
    padding:12px;
    min-height:85px;
  }
  
  .focus-card .fc-room{
    font-size:14px;
  }
  
  .fc-stu{
    font-size:12px;
  }
  
  .fc-chip{
    font-size:10px;
    padding:2px 6px;
    max-width:100px;
  }
}

@media (max-width: 480px) {
  .focus-group-body{
    grid-template-columns:1fr 1fr;
    gap:8px;
  }
  
  .focus-card{
    padding:10px;
    min-height:80px;
  }
  
  .focus-card .fc-room{
    font-size:13px;
  }
  
  .fc-stu{
    font-size:11px;
  }
  
  .fc-bottom-row{
    gap:6px;
  }
  
  .fc-chip{
    font-size:9px;
    padding:2px 5px;
    max-width:80px;
  }
}

/* ================ 聚焦：15分钟内释放 + 超时 样式 end ================ */

.timeline-control-btn:hover{background:linear-gradient(135deg,#d35400,#c0392b);transform:translateY(-2px);box-shadow:0 4px 12px rgba(230,126,34,.4);}
.timeline-control-btn.active{background:linear-gradient(135deg,#27ae60,#229954);box-shadow:0 2px 8px rgba(39,174,96,.3);}
.timeline-control-btn.active:hover{background:linear-gradient(135deg,#229954,#1e8449);}
.timeline-control-icon{font-size:16px;animation:timelineIconPulse 2s infinite;}
.timeline-section{display:none;margin:20px 0;padding:20px;background:#fff;border-radius:var(--panel-radius);box-shadow:var(--shadow-sm);border-left:4px solid #e67e22;}
.timeline-main{display:grid;grid-template-columns:1fr 1fr 1fr;gap:20px;margin-bottom:10px;}
.timeline-category{background:#f8f9fa;border-radius:12px;padding:15px;border:2px solid transparent;display:flex;flex-direction:column;min-height:360px;}
.timeline-category.grand{border-color:#f39c12;background:linear-gradient(135deg,#fef9e7,#f8f9fa);}
.timeline-category.upright{border-color:#3498db;background:linear-gradient(135deg,#e8f4fd,#f8f9fa);}
.timeline-category.other{border-color:#95a5a6;background:linear-gradient(135deg,#f4f4f4,#f8f9fa);}
.timeline-category-header{display:flex;justify-content:space-between;align-items:center;padding-bottom:10px;margin-bottom:10px;border-bottom:1px solid rgba(0,0,0,.1);}
.timeline-category-count{background:rgba(0,0,0,.1);padding:4px 8px;border-radius:12px;font-size:.75em;font-weight:700;}
.timeline-rooms-container{display:flex;flex-direction:column;flex:1;}
.timeline-rooms-list{flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:8px;padding-right:5px;}
.timeline-room-item{
    background:#fff;
    border-radius:8px;
    padding:12px;
    box-shadow:0 1px 3px rgba(0,0,0,.1);
    cursor:pointer;
    border-left:4px solid transparent;
    transition:.2s;
}
.timeline-room-item.available{border-left-color:var(--success-color);background:linear-gradient(135deg,#e8f8f5,#fff);}
.timeline-room-item.preparing{border-left-color:#f39c12;background:linear-gradient(135deg,#fef9e7,#fff);animation:preparingGlow 2s infinite;}
.timeline-room-item.practicing{border-left-color:#3498db;background:linear-gradient(135deg,#e8f4fd,#fff);}
.timeline-room-item.overtime{border-left-color:var(--danger-color);background:linear-gradient(135deg,#fdeaea,#fff);animation:overtimeGlow 1.5s infinite;}
.timeline-room-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;}
.timeline-room-name{font-weight:700;color:#2c3e50;}
.timeline-room-status{font-size:.7em;padding:3px 8px;border-radius:12px;font-weight:700;text-transform:uppercase;color:#fff;}
.timeline-room-status.available{background:var(--success-color);}
.timeline-room-status.preparing{background:var(--warning-color);}
.timeline-room-status.practicing{background:#3498db;}
.timeline-room-status.overtime{background:var(--danger-color);}
.timeline-room-info{display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:.85em;color:#666;}
.timeline-room-prediction{grid-column:1/-1;margin-top:5px;padding:6px 8px;background:rgba(52,152,219,.1);border-radius:6px;font-size:.75em;text-align:center;font-style:italic;color:#2980b9;}
.timeline-room-prediction.soon{background:rgba(39,174,96,.1);color:var(--success-color);}
.timeline-room-prediction.overtime-pred{background:rgba(231,76,60,.1);color:var(--danger-color);}
.category-stats{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;padding:10px;background:rgba(255,255,255,.95);border-radius:8px;border:1px solid rgba(0,0,0,.1);margin-top:10px;flex-shrink:0;}
.category-stat-item{text-align:center;padding:6px;background:#fff;border-radius:6px;box-shadow:0 1px 3px rgba(0,0,0,.1);}
.stat-number{display:block;font-size:1.2em;font-weight:700;margin-bottom:2px;}
.stat-number.available{color:var(--success-color);}
.stat-number.will-free{color:#3498db;}
.stat-number.overtime{color:var(--danger-color);}
.stat-label{font-size:.7em;color:#666;}

/* ========== 超时管理 ========== */
.overtime-item.highlight-expired{animation:pulseExpired 1.5s infinite;}
.overtime-category{margin-bottom:20px;border:1px solid var(--border-color);border-radius:8px;overflow:hidden;}
.overtime-category-header{background:var(--primary-color);color:#fff;padding:12px 15px;font-weight:700;display:flex;justify-content:space-between;align-items:center;}
.overtime-category-count{background:rgba(255,255,255,.2);padding:2px 8px;border-radius:12px;font-size:.8em;}
.overtime-list-header,.overtime-item{
    display:grid;
    grid-template-columns:100px 120px 120px 120px 1fr 120px;
    gap:8px;
    padding:8px 12px;
    font-size:13px;
    align-items:center;
}
.overtime-list-header{font-weight:700;background:#f8f9fa;border-bottom:1px solid var(--border-color);}
.overtime-item{border-bottom:1px solid #eee;background:#fff;}
.overtime-item:nth-child(even){background:#fafafa;}
.overtime-badge{display:inline-block;padding:2px 6px;border-radius:12px;font-size:11px;background:var(--danger-color);color:#fff;margin-left:4px;}
.btn-mini-primary,.btn-mini-danger{
    padding:4px 8px;
    font-size:11px;
    border:none;
    border-radius:4px;
    cursor:pointer;
}
.btn-mini-primary{background:#3498db;color:#fff;}
.btn-mini-primary:hover{background:#2178b8;}
.btn-mini-danger{background:var(--danger-color);color:#fff;}
.btn-mini-danger:hover{background:#c0392b;}

/* ========== 考勤 ========== */
.attendance-category{margin-bottom:25px;border:1px solid var(--border-color);border-radius:8px;overflow:hidden;}
.attendance-category-header{background:linear-gradient(135deg,#e67e22,#d35400);color:#fff;padding:12px 15px;font-weight:700;display:flex;justify-content:space-between;align-items:center;}
.attendance-category-count{background:rgba(255,255,255,.2);padding:2px 8px;border-radius:12px;font-size:.8em;}
.attendance-list-header,.attendance-item{
    display:grid;
    grid-template-columns:120px 150px 150px 120px 1fr 100px; /* 移除了子段数列 */
    gap:8px;
    padding:8px 12px;
    font-size:13px;
    align-items:center;
}
.attendance-list-header{font-weight:700;background:#f8f9fa;border-bottom:1px solid var(--border-color);}
.attendance-item{border-bottom:1px solid #eee;background:#fff;}
.attendance-item:nth-child(even){background:#fafafa;}
.attendance-item.absent{background:linear-gradient(135deg,#fdeaea,#fff);border-left:4px solid var(--danger-color);}
.attendance-summary{background:#ecf0f1;border-radius:8px;padding:15px;margin-top:15px;display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;}
.attendance-summary-item{text-align:center;background:#fff;padding:10px;border-radius:6px;box-shadow:0 1px 3px rgba(0,0,0,.1);}
.attendance-summary-number{font-size:1.4em;font-weight:700;margin-bottom:4px;}
.attendance-summary-number.absent-count{color:var(--danger-color);}
.attendance-summary-number.present-count{color:var(--success-color);}
.attendance-summary-number.total-count{color:var(--text-color);}
.attendance-empty{text-align:center;padding:40px;color:#999;font-style:italic;}
.attendance-auto-check{background:#e8f5e8;border:1px solid var(--success-color);border-radius:6px;padding:10px;margin-bottom:15px;font-size:12px;color:var(--success-color);text-align:center;}
/* ========== 请假样式 ========== */
/* 🔥 新增：请假选项的选中状态样式 */
.excuse-reason-option input[type="radio"]:checked + span {
    font-weight: 600;
    color: #2c3e50;
}

.excuse-reason-option:has(input[type="radio"]:checked) {
    border-color: #3498db !important;
    background-color: #e3f2fd !important;
}

#excuseDurationOptions label:has(input[type="radio"]:checked) {
    border-color: #3498db !important;
    background-color: #e3f2fd !important;
}

#excuseDurationOptions label input[type="radio"]:checked + span {
    font-weight: 600;
    color: #2c3e50;
}

/* 确保未选中状态的默认样式 */
.excuse-reason-option:not(:has(input[type="radio"]:checked)) {
    border-color: #ddd;
    background-color: transparent;
}

#excuseDurationOptions label:not(:has(input[type="radio"]:checked)) {
    border-color: #ddd;
    background-color: transparent;
}

/* ========== 设置模态框样式优化 ========== */
.settings-modal-content {
  max-width: 700px;
  width: 95%;
  max-height: 90vh;
  overflow-y: auto;
  margin: 2% auto;
  padding: 25px 30px;
}

.settings-section {
  margin-bottom: 35px;
  padding: 25px;
  background: linear-gradient(135deg, #f8f9fa, #ffffff);
  border-radius: 12px;
  border: 1px solid #e9ecef;
  border-left: 4px solid var(--primary-color);
  box-shadow: 0 2px 8px rgba(0,0,0,.05);
}

.settings-section h3 {
  margin: 0 0 20px 0;
  color: var(--primary-color);
  font-size: 18px;
  font-weight: 700;
  display: flex;
  align-items: center;
  gap: 8px;
}

.setting-item {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 25px;
  align-items: start;
  margin-bottom: 25px;
  padding: 20px;
  background: #fff;
  border-radius: 10px;
  border: 1px solid #f0f0f0;
  transition: all 0.2s ease;
}

.setting-item:hover {
  border-color: #d0d7de;
  box-shadow: 0 2px 8px rgba(0,0,0,.08);
}

.setting-item:last-child {
  margin-bottom: 0;
}

.setting-info {
  flex: 1;
}

.setting-label {
  font-weight: 700;
  font-size: 16px;
  color: #2c3e50;
  margin-bottom: 8px;
}

.setting-description {
  font-size: 14px;
  color: #6c757d;
  line-height: 1.5;
  margin-bottom: 8px;
}

.setting-description.admin-required {
  color: var(--danger-color);
  font-weight: 600;
}

.setting-preview {
  font-size: 13px;
  color: #e67e22;
  font-weight: 600;
  font-style: italic;
  background: #fff3cd;
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid #ffeaa7;
  display: inline-block;
}

.setting-control {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 8px;
  min-width: 200px;
}

/* 输入组件样式 */
.input-group {
  display: flex;
  align-items: center;
  gap: 8px;
  background: #fff;
  border: 2px solid #e9ecef;
  border-radius: 8px;
  padding: 4px 12px;
  transition: border-color 0.2s ease;
}

.input-group:focus-within {
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.setting-input {
  border: none;
  outline: none;
  padding: 8px 4px;
  font-size: 14px;
  text-align: center;
  background: transparent;
  min-width: 60px;
}

.input-unit {
  font-size: 13px;
  color: #6c757d;
  font-weight: 500;
  white-space: nowrap;
}

.setting-range {
  font-size: 11px;
  color: #999;
  text-align: right;
}

/* 时间输入组件 */
.time-input-group {
  display: flex;
  align-items: center;
  gap: 8px;
  background: #fff;
  border: 2px solid #e9ecef;
  border-radius: 8px;
  padding: 8px 12px;
  transition: border-color 0.2s ease;
}

.time-input-group:focus-within {
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.time-input {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.time-input-field {
  width: 50px;
  text-align: center;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  padding: 6px 4px;
  font-size: 14px;
  font-weight: 600;
}

.time-input label {
  font-size: 11px;
  color: #6c757d;
  font-weight: 500;
}

.time-separator {
  font-size: 18px;
  font-weight: 700;
  color: var(--primary-color);
  margin: 0 4px;
}

/* 安全设置特殊样式 */
.security-section {
  border-left-color: var(--danger-color);
}

.security-section h3 {
  color: var(--danger-color);
}

.security-notice {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  background: linear-gradient(135deg, #fff5f5, #fef2f2);
  border: 1px solid #fecaca;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 20px;
}

.notice-icon {
  font-size: 20px;
  flex-shrink: 0;
}

.notice-text {
  font-size: 14px;
  line-height: 1.5;
  color: #dc2626;
}

.password-input-group {
  display: flex;
  align-items: center;
  background: #fff;
  border: 2px solid #e9ecef;
  border-radius: 8px;
  overflow: hidden;
  transition: border-color 0.2s ease;
  min-width: 220px;
}

.password-input-group:focus-within {
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.password-field {
  flex: 1;
  border: none;
  outline: none;
  padding: 10px 12px;
  font-size: 14px;
  background: transparent;
}

.password-toggle {
  background: #f8f9fa;
  border: none;
  padding: 10px 12px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s ease;
  border-left: 1px solid #e9ecef;
}

.password-toggle:hover {
  background: #e9ecef;
}

/* 操作按钮区域 */
.settings-actions {
  display: flex;
  justify-content: flex-end;
  gap: 15px;
  padding: 25px 0 5px;
  border-top: 2px solid #f8f9fa;
  margin-top: 30px;
  position: sticky;
  bottom: 0;
  background: #fff;
}

.settings-save-btn, .settings-cancel-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 20px;
  font-size: 14px;
  font-weight: 600;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 120px;
  justify-content: center;
}

.settings-save-btn {
  background: linear-gradient(135deg, var(--secondary-color), #27ae60);
  color: #fff;
  box-shadow: 0 2px 4px rgba(46, 204, 113, 0.3);
}

.settings-save-btn:hover {
  background: linear-gradient(135deg, #27ae60, #229954);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(46, 204, 113, 0.4);
}

.settings-cancel-btn {
  background: linear-gradient(135deg, #95a5a6, #7f8c8d);
  color: #fff;
  box-shadow: 0 2px 4px rgba(149, 165, 166, 0.3);
}

.settings-cancel-btn:hover {
  background: linear-gradient(135deg, #7f8c8d, #6c7b7d);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(149, 165, 166, 0.4);
}

.btn-icon {
  font-size: 16px;
}

/* 响应式设计 */
@media (max-width: 768px) {
  .settings-modal-content {
    width: 98%;
    padding: 20px 15px;
    margin: 1% auto;
  }
  
  .settings-section {
    padding: 20px 15px;
    margin-bottom: 25px;
  }
  
  .setting-item {
    grid-template-columns: 1fr;
    gap: 15px;
    padding: 15px;
  }
  
  .setting-control {
    align-items: stretch;
    min-width: auto;
  }
  
  .password-input-group,
  .input-group,
  .time-input-group {
    min-width: auto;
    width: 100%;
  }
  
  .settings-actions {
    flex-direction: column;
    gap: 10px;
  }
  
  .settings-save-btn, .settings-cancel-btn {
    width: 100%;
  }
}

@media (max-width: 480px) {
  .settings-section h3 {
    font-size: 16px;
  }
  
  .setting-label {
    font-size: 15px;
  }
  
  .setting-description {
    font-size: 13px;
  }
  
  .time-input-group {
    justify-content: center;
  }
}

/* ========== 设置、模态、可复用容器 ========== */
.modal-content{
    background:#fff;
    margin:8% auto;
    padding:20px;
    border:1px solid #888;
    width:80%;
    max-width:500px;
    border-radius:16px;
    box-shadow:var(--shadow-md);
    position:relative;
}
.modal-content.large{max-width:900px;}
.modal-content.mid{max-width:700px;}
.modal-content.wide{max-width:800px;}
.close{
    position:absolute;
    top:15px;
    right:20px;  /* 增加右边距，避免与按钮组重叠 */
    font-size:26px;
    font-weight:700;
    color:#aaa;
    cursor:pointer;
    z-index:1001;  /* 确保在最上层 */
    background:rgba(255,255,255,0.8);  /* 添加半透明背景 */
    border-radius:50%;
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    line-height:1;
}
.close:hover{
    color:#000;
    background:rgba(255,255,255,1);
}

/* 所有模态容器基类 */
[id$="Modal"]{
    display:none;
    position:fixed;
    z-index:1000;
    left:0;top:0;width:100%;height:100%;
    background:rgba(0,0,0,.4);
    overflow:auto;
}
#unlockModal{z-index:10000;}
.replaceable-room-item,.available-room-item{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:12px 15px;
    margin-bottom:10px;
    background:#f8f9fa;
    border:1px solid var(--border-color);
    border-radius:8px;
    transition:.2s;
}
.replaceable-room-item:hover,.available-room-item:hover{
    background:#e0e0e0;
}
.replace-btn{
    background:var(--primary-color);
    border:none;
    color:#fff;
    padding:8px 16px;
    border-radius:6px;
    cursor:pointer;
}
.replace-btn:hover{background:var(--hover-color);}
.time-slot-modal-content{max-width:600px;width:90%;max-height:80vh;overflow-y:auto;margin:2% auto;}
.settings-modal-content{max-width:600px;width:90%;max-height:85vh;overflow-y:auto;margin:3% auto;}
.settings-section{margin-bottom:25px;padding:20px;background:#f8f9fa;border-radius:8px;border-left:4px solid var(--primary-color);}
.setting-item{display:flex;justify-content:space-between;align-items:flex-start;gap:20px;margin-bottom:18px;}
.setting-label{font-weight:600;}
.setting-description{font-size:.85em;color:#666;margin-top:4px;}
.setting-control{display:flex;align-items:center;gap:8px;}
.setting-input{width:90px;text-align:center;}
.setting-preview{font-size:.75em;color:#e67e22;margin-top:6px;font-style:italic;}
.settings-actions{display:flex;justify-content:flex-end;gap:12px;padding-top:15px;border-top:1px solid var(--border-color);position:sticky;bottom:0;background:#fff;}
.settings-save-btn{background:var(--secondary-color);}
.settings-save-btn:hover{background:#27ae60;}
.settings-cancel-btn{background:#95a5a6;}
.settings-cancel-btn:hover{background:#7f8c8d;}

/* ========== 学生 DB、琴房 DB 列表 ========== */
.student-db-item,.room-db-item{
    display:flex;
    align-items:center;
    padding:12px 15px;
    border-bottom:1px solid #eee;
    transition:.15s;
    font-size:13px;
}
.student-db-item:hover,.room-db-item:hover{background:#f8f9fa;}
.student-db-item:last-child,.room-db-item:last-child{border-bottom:none;}
.student-info{flex:1;}
.student-name{font-weight:700;font-size:1.05em;}
.student-details{font-size:.8em;color:#666;margin-top:4px;}
.student-actions,.ot-actions{display:flex;gap:8px;flex-wrap:wrap;}
.student-action-btn{
    border:none;
    border-radius:4px;
    padding:5px 10px;
    cursor:pointer;
    font-size:.75em;
    font-weight:600;
}
.edit-btn{background:var(--primary-color);color:#fff;}
.edit-btn:hover{background:var(--hover-color);}
.delete-btn{background:var(--danger-color);color:#fff;}
.delete-btn:hover{background:#c0392b;}
.major-badge{display:inline-block;background:var(--primary-color);color:#fff;padding:2px 8px;border-radius:12px;font-size:.7em;margin-left:6px;}
.student-db-stats,.room-db-stats{
    background:#f8f9fa;
    padding:12px 15px;
    border-radius:8px;
    border:1px solid var(--border-color);
    font-size:.85em;
    color:#666;
    margin-top:8px;
    line-height:1.5;
}
.empty-database{padding:40px;text-align:center;font-style:italic;color:#999;}
.room-db-item{display:grid;grid-template-columns:90px 90px 110px 1fr 140px;gap:8px;}
.room-db-item.header{background:#e8f2fb;font-weight:700;position:sticky;top:0;z-index:2;}
.room-tag{display:inline-block;padding:2px 6px;border-radius:10px;font-size:11px;background:#eee;margin-left:4px;}
.tag-grand{background:#f39c12;color:#fff;}
.tag-upright{background:#2980b9;color:#fff;}
.tag-none{background:#7f8c8d;color:#fff;}
.room-edit-btn,.room-del-btn,.room-save-btn,.room-cancel-btn{
    padding:4px 8px;
    border:none;
    border-radius:4px;
    cursor:pointer;
    font-size:12px;
    margin:2px 0;
}
.room-edit-btn{background:var(--primary-color);color:#fff;}
.room-del-btn{background:var(--danger-color);color:#fff;}
.room-save-btn{background:var(--success-color);color:#fff;}
.room-cancel-btn{background:#95a5a6;color:#fff;}
.room-inline-input,.room-inline-select{width:100%;box-sizing:border-box;padding:4px 6px;font-size:12px;}
.add-room-btn{background:var(--secondary-color);color:#fff;}
.add-room-btn:hover{background:#27ae60;}
.import-room-btn{background:#16a085;color:#fff;}
.import-room-btn:hover{background:#12836c;}
.export-btn{background:#8e44ad;color:#fff;}
.export-btn:hover{background:#732d91;}
/* === 琴房类型颜色区分 === */
.room.type-grand{
  background:linear-gradient(135deg,#f9f1ff,#f2e3ff);
  border:1px solid #e1ccfa;
  border-left:6px solid #9b59b6;
}
.room.type-upright{
  background:linear-gradient(135deg,#eef7ff,#dff0ff);
  border:1px solid #c8e2f7;
  border-left:6px solid #3498db;
}
.room.type-none{
  background:linear-gradient(135deg,#f4f6f7,#eceff1);
  border:1px solid #d6dadd;
  border-left:6px solid #95a5a6;
}

/* Hover 强调（保留原位移阴影，但颜色不变形） */
.room.type-grand:hover{
  box-shadow:0 6px 18px rgba(155,89,182,.25);
}
.room.type-upright:hover{
  box-shadow:0 6px 18px rgba(52,152,219,.25);
}
.room.type-none:hover{
  box-shadow:0 6px 18px rgba(149,165,166,.25);
}

/* ========== 可用 / 替换琴房模态列表 ========== */
.replaceable-room-name,.room-name-large{font-weight:700;font-size:1.05em;}
.replaceable-room-details,.room-details{font-size:.85em;color:#666;margin-top:4px;}
.replaceable-room-status{font-size:.7em;color:var(--danger-color);margin-top:3px;}

/* ========== Unlock 弹窗特殊样式（独立生成时覆盖） ========== */

/* ========== 缓存监视组件 ========== */
.cache-info{
    position:fixed;
    top:10px;right:10px;
    background:rgba(255,255,255,.95);
    border:1px solid var(--border-color);
    border-radius:8px;
    padding:8px 12px;
    font-size:12px;
    color:var(--text-color);
    box-shadow:0 2px 8px rgba(0,0,0,.1);
    z-index:999;
    min-width:120px;
    transition:.3s;
}
.cache-info:hover{background:#fff;box-shadow:0 4px 12px rgba(0,0,0,.15);}
.cache-size{font-weight:700;margin-bottom:2px;}
.cache-size.warning{color:var(--warning-color);}
.cache-size.danger{color:var(--danger-color);}
.cache-percentage{font-size:10px;color:#666;}
.cache-details{font-size:10px;color:#999;margin-top:3px;border-top:1px solid #eee;padding-top:3px;line-height:1.2;}

/* ========== 自适应 ========== */
@media (max-width:900px){
    .attendance-list-header,.attendance-item{
        grid-template-columns:100px 80px 120px 100px 1fr 90px; /* 移除了子段数列 */
        font-size:12px;
    }
    .overtime-list-header,.overtime-item{grid-template-columns:80px 100px 100px 100px 1fr 90px;font-size:12px;}
    .room-db-item{grid-template-columns:70px 70px 90px 1fr 110px;font-size:12px;}
    .setting-item{flex-direction:column;align-items:flex-start;}
    .settings-actions{position:static;}
}
@media (max-width:600px){
    .search-item{flex-direction:column;align-items:flex-start;gap:6px;}
    .search-item-actions{align-self:flex-end;}
    .timeline-room-info{grid-template-columns:1fr;}
    .category-stats{grid-template-columns:repeat(2,1fr);}
    .weekday-buttons{grid-template-columns:repeat(3,1fr);}
}
/* === 练琴状态检查提醒面板 美化版 BEGIN === */
.overrun-panel{
  position:fixed;
  top:72px;
  right:0;
  bottom:16px;
  width:380px;
  display:flex;
  flex-direction:column;
  background:linear-gradient(145deg, #ffffff, #f8f9fa);
  border:1px solid #e8ecef;
  border-right:none;
  border-top-left-radius:20px;
  border-bottom-left-radius:20px;
  box-shadow:0 8px 32px rgba(231,76,60,.15), 0 2px 8px rgba(0,0,0,.08);
  font-size:13px;
  z-index:1500;
  transition:all .4s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter:blur(10px);
}

.overrun-panel.collapsed{
  transform:translateX(calc(100% - 50px));
  opacity:.9;
  box-shadow:0 4px 16px rgba(231,76,60,.12);
}

.overrun-panel-header{
  user-select:none;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:16px 18px;
  background:linear-gradient(135deg, #e74c3c, #c0392b, #a93226);
  color:#fff;
  border-top-left-radius:20px;
  cursor:pointer;
  position:relative;
  min-height:50px;
  box-shadow:0 2px 8px rgba(231,76,60,.3);
  transition:all .3s ease;
}

.overrun-panel-header:hover{
  background:linear-gradient(135deg, #c0392b, #a93226, #922b21);
  transform:translateY(-1px);
}

.overrun-panel-header h4{
  margin:0;
  font-size:15px;
  font-weight:700;
  display:flex;
  align-items:center;
  gap:8px;
  color: #fff !important;
}

.overrun-panel-header .header-subtitle{
  font-size:11px;
  opacity:.85;
  font-weight:400;
  margin-top:2px;
}

.overrun-panel-body{
  overflow-y:auto;
  padding:16px 12px 18px;
  flex:1;
  min-height:0;
  background:rgba(255,255,255,.6);
}

.overrun-panel-toggle-tip{
  position:absolute;
  right:-36px;
  top:50%;
  transform:translateY(-50%);
  background:linear-gradient(135deg, #c0392b, #a93226);
  color:#fff;
  width:32px;
  height:70px;
  border-top-left-radius:8px;
  border-bottom-left-radius:8px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:11px;
  font-weight:600;
  writing-mode:vertical-rl;
  letter-spacing:1px;
  cursor:pointer;
  box-shadow:0 4px 12px rgba(192,57,43,.4);
  transition:all .3s ease;
}

.overrun-panel-toggle-tip:hover{
  background:linear-gradient(135deg, #a93226, #922b21);
  transform:translateY(-50%) translateX(-2px);
  box-shadow:0 6px 16px rgba(192,57,43,.5);
}

.overrun-panel-body::-webkit-scrollbar{
  width:6px;
}
.overrun-panel-body::-webkit-scrollbar-track{
  background:rgba(0,0,0,.05);
  border-radius:3px;
}
.overrun-panel-body::-webkit-scrollbar-thumb{
  background:linear-gradient(180deg, #e74c3c, #c0392b);
  border-radius:3px;
  transition:all .3s ease;
}
.overrun-panel-body::-webkit-scrollbar-thumb:hover{
  background:linear-gradient(180deg, #c0392b, #a93226);
}

/* 异常项目卡片样式 */
.overrun-item{
  background:linear-gradient(135deg, #fff, #fefefe);
  border:1px solid #f1c2c2;
  border-radius:12px;
  padding:14px 16px;
  margin-bottom:12px;
  box-shadow:0 2px 8px rgba(231,76,60,.08);
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
  position:relative;
  overflow:hidden;
}

.overrun-item::before{
  content:'';
  position:absolute;
  top:0;
  left:0;
  width:4px;
  height:100%;
  background:linear-gradient(180deg, #e74c3c, #c0392b);
  border-radius:0 2px 2px 0;
}

.overrun-item:hover{
  transform:translateY(-2px) translateX(4px);
  box-shadow:0 8px 24px rgba(231,76,60,.15);
  border-color:#e8b4b4;
}

.overrun-item-header{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  margin-bottom:10px;
  gap:12px;
}

.overrun-item-header > div:first-child{
  font-weight:700;
  font-size:14px;
  color:#2c3e50;
  line-height:1.3;
  flex:1;
}

.overrun-item-header .student-major{
  color:#7f8c8d;
  font-weight:500;
  font-size:12px;
  margin-left:6px;
}

.overrun-over{
  background:linear-gradient(135deg, #e74c3c, #c0392b);
  color:#fff;
  padding:4px 10px;
  border-radius:8px;
  font-size:12px;
  font-weight:700;
  white-space:nowrap;
  box-shadow:0 2px 6px rgba(231,76,60,.3);
  animation:overrunPulse 2s infinite;
}

@keyframes overrunPulse{
  0%, 100%{ transform:scale(1); }
  50%{ transform:scale(1.05); }
}

.overrun-item-room, .overrun-slot{
  font-size:12px;
  color:#5a6c7d;
  margin-bottom:6px;
  display:flex;
  align-items:center;
  gap:6px;
}

.overrun-item-room::before{
  content:'🏠';
  font-size:11px;
}

.overrun-slot::before{
  content:'⏰';
  font-size:11px;
}

.overrun-actions{
  display:flex;
  gap:8px;
  margin-top:12px;
  padding-top:10px;
  border-top:1px solid #f8f9fa;
}

.overrun-btn-ignore, .overrun-btn-record{
  flex:1;
  padding:8px 12px;
  border:none;
  border-radius:8px;
  font-size:12px;
  font-weight:600;
  cursor:pointer;
  transition:all .3s ease;
  position:relative;
  overflow:hidden;
}

.overrun-btn-ignore{
  background:linear-gradient(135deg, #95a5a6, #7f8c8d);
  color:#fff;
}

.overrun-btn-ignore:hover{
  background:linear-gradient(135deg, #7f8c8d, #6c7b7d);
  transform:translateY(-1px);
  box-shadow:0 4px 12px rgba(149,165,166,.3);
}

.overrun-btn-record{
  background:linear-gradient(135deg, #3498db, #2980b9);
  color:#fff;
}

.overrun-btn-record:hover{
  background:linear-gradient(135deg, #2980b9, #21618c);
  transform:translateY(-1px);
  box-shadow:0 4px 12px rgba(52,152,219,.3);
}

.overrun-btn-ignore:active, .overrun-btn-record:active{
  transform:translateY(0);
}

.overrun-empty{
  text-align:center;
  padding:40px 20px;
  color:#95a5a6;
  font-style:italic;
  font-size:14px;
  background:linear-gradient(135deg, rgba(255,255,255,.8), rgba(248,249,250,.6));
  border:2px dashed #ddd;
  border-radius:12px;
  margin:20px 0;
}

.overrun-count-badge{
  background:linear-gradient(135deg, #fff, #f8f9fa);
  color:#e74c3c;
  font-size:11px;
  font-weight:700;
  padding:3px 8px;
  border-radius:10px;
  margin-left:8px;
  border:1px solid rgba(255,255,255,.3);
  box-shadow:0 2px 4px rgba(0,0,0,.1);
  animation:badgePulse 2s infinite;
}

@keyframes badgePulse{
  0%, 100%{ transform:scale(1); opacity:1; }
  50%{ transform:scale(1.1); opacity:.9; }
}

.overrun-panel-footer{
  padding:12px 16px;
  background:rgba(248,249,250,.8);
  border-top:1px solid #e9ecef;
  font-size:11px;
  line-height:1.4;
  color:#6c757d;
  border-bottom-left-radius:20px;
}
/* === 练琴状态检查提醒面板 美化版 END === */
/* =======在现有CSS中添加云同步样式==== */
.connection-online {
    background: linear-gradient(135deg, #27ae60, #2ecc71);
    color: white;
    box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
}

.connection-offline {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    color: white;
    box-shadow: 0 2px 8px rgba(231, 76, 60, 0.3);
}

.connection-online:hover,
.connection-offline:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* 🔥 新增：自动锁定警告样式 */
.auto-lock-warning {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    color: white;
    padding: 25px 35px;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(231, 76, 60, 0.4);
    z-index: 10001;
    text-align: center;
    min-width: 350px;
    animation: autoLockPulse 1s infinite;
}

.auto-lock-warning h3 {
    margin: 0 0 15px 0;
    color: white !important;
    font-size: 18px;
}

.auto-lock-warning p {
    margin: 0 0 20px 0;
    font-size: 16px;
    line-height: 1.4;
}

.auto-lock-countdown {
    font-size: 24px;
    font-weight: bold;
    color: #fff;
    margin: 10px 0;
}

.auto-lock-buttons {
    display: flex;
    gap: 12px;
    justify-content: center;
}

.auto-lock-continue-btn {
    background: #27ae60;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.auto-lock-continue-btn:hover {
    background: #229954;
    transform: translateY(-1px);
}

.auto-lock-lock-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 12px 24px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.auto-lock-lock-btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

@keyframes autoLockPulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.02); }
}
/* ===== 批量时间段管理（BTM） ===== */

#bulkTimeManagerModal{
  position:fixed;
  left:0;top:0;right:0;bottom:0;
  background:rgba(0,0,0,.55);
  z-index:3000;
  display:none;
  backdrop-filter:blur(4px);
}
#bulkTimeManagerModal .btm-wrapper{
  width:90%;
  height:90%;
  margin:auto;
  background:#fff;
  border-radius:16px;
  display:flex;
  flex-direction:column;
  box-shadow:0 6px 30px rgba(0,0,0,.25);
  overflow:hidden;
  font-size:14px;
}
#bulkTimeManagerModal .btm-header{
  flex:0 0 auto;
  padding:14px 20px;
  background:linear-gradient(135deg,#007AFF,#5856D6);
  color:#fff;
  display:flex;
  justify-content:space-between;
  align-items:center;
}
#bulkTimeManagerModal .btm-title{
  font-size:18px;
  font-weight:700;
  letter-spacing:.5px;
}
#bulkTimeManagerModal .btm-actions{display:flex;gap:10px;flex-wrap:wrap;}
#bulkTimeManagerModal .btm-btn{
  padding:8px 14px;
  border:none;
  border-radius:6px;
  cursor:pointer;
  font-weight:600;
  font-size:13px;
  letter-spacing:.5px;
  transition:.25s;
}
#bulkTimeManagerModal .btm-btn:hover{opacity:.9;transform:translateY(-2px);}
#bulkTimeManagerModal .btm-primary{background:#007AFF;color:#fff;}
#bulkTimeManagerModal .btm-secondary{background:#4e5d78;color:#fff;}
#bulkTimeManagerModal .btm-danger{background:#e74c3c;color:#fff;}
#bulkTimeManagerModal .btm-body{flex:1;display:flex;overflow:hidden;}
#bulkTimeManagerModal .btm-left{flex:1;display:flex;flex-direction:column;padding:16px;overflow:hidden;}
#bulkTimeManagerModal .btm-right{width:320px;border-left:1px solid #eee;padding:16px;display:flex;flex-direction:column;gap:12px;background:#f8f9fb;}
#bulkTimeManagerModal .btm-student-bar{display:flex;align-items:center;gap:10px;margin-bottom:10px;}
#bulkTimeManagerModal .btm-select{
  flex:1;
  padding:8px 10px;
  border:2px solid #d6dae2;
  border-radius:8px;
  font-size:14px;
  outline:none;
  transition:.25s;
}
#bulkTimeManagerModal .btm-select:focus{border-color:#007AFF;box-shadow:0 0 0 3px rgba(0,122,255,.15);}
#bulkTimeManagerModal .btm-stu-nav button{
  padding:6px 10px;
  border:none;
  background:#007AFF;
  color:#fff;
  border-radius:6px;
  cursor:pointer;
  font-weight:600;
  transition:.25s;
}
#bulkTimeManagerModal .btm-stu-nav button:hover{opacity:.85;}
#bulkTimeManagerModal .btm-stu-info{
  font-size:13px;
  color:#555;
  margin-bottom:10px;
  line-height:1.5;
  min-height:32px;
}
#bulkTimeManagerModal .btm-legend{
  display:flex;
  gap:18px;
  flex-wrap:wrap;
  font-size:12px;
  color:#333;
  padding:8px 10px;
  background:#f2f5f9;
  border:1px solid #e0e4ea;
  border-radius:8px;
  margin-bottom:10px;
}
#bulkTimeManagerModal .btm-table-wrap{
  flex:1;
  overflow:auto;
  border:1px solid #e0e4ea;
  border-radius:10px;
  background:#fff;
  box-shadow:0 2px 6px rgba(0,0,0,.05) inset;
}
#bulkTimeManagerModal .btm-table{
  width:100%;
  border-collapse:separate;
  border-spacing:0;
  min-width:900px;
  font-size:12px;
  user-select:none;
}
#bulkTimeManagerModal .btm-table thead th{
  background:#f0f3f7;
  position:sticky;
  top:0;
  z-index:2;
  padding:10px 8px;
  font-weight:700;
  border-bottom:1px solid #d6dae2;
  color:#2c3e50;
}
#bulkTimeManagerModal .btm-time-col{width:120px;}

/* 统一单元格基础样式 */
#bulkTimeManagerModal .btm-table tbody td{
  text-align:center;
  padding:8px 6px;
  border-bottom:1px solid #eef1f5;
  border-right:1px solid #eef1f5;
  position:relative;
  line-height:1.3;
  transition: all 0.25s ease;
  cursor: pointer;
  font-weight: 500;
  color: #2f4150;
}
#bulkTimeManagerModal .btm-table tbody td:last-child{border-right:none;}
#bulkTimeManagerModal .btm-table tbody tr:last-child td{border-bottom:none;}

/* 统一未选中状态 */
#bulkTimeManagerModal .btm-cell:not(.btm-cell-selected):not(.btm-cell-rest) {
  background: #fff;
  color: #2f4150;
  border-color: #eef1f5;
}

/* 统一悬停效果 */
#bulkTimeManagerModal .btm-cell:hover:not(.btm-cell-rest):not(.btm-cell-selected) {
  background: #e6f1ff;
  border-color: #b1d3ff;
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
  z-index: 1;
}

/* 统一选中状态 */
#bulkTimeManagerModal .btm-cell-selected {
  background: linear-gradient(135deg, #007AFF, #5856D6);
  color: #fff;
  font-weight: 700;
  border-color: #3366cc;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15) inset;
}

/* 统一休息状态 */
#bulkTimeManagerModal .btm-cell-rest {
  background: linear-gradient(135deg, #6C757D, #495057);
  color: #fff;
  cursor: not-allowed;
  font-weight: 600;
  border-color: #495057;
}

/* 选中状态悬停效果 */
#bulkTimeManagerModal .btm-cell-selected:hover {
  opacity: 0.9;
  transform: translateY(-1px);
  box-shadow: 0 3px 10px rgba(0, 122, 255, 0.25);
}

/* 休息状态悬停效果（无变化） */
#bulkTimeManagerModal .btm-cell-rest:hover {
  transform: none;
  box-shadow: none;
  opacity: 0.8;
}

/* 活跃状态（点击时的反馈） */
#bulkTimeManagerModal .btm-cell:active:not(.btm-cell-rest) {
  transform: translateY(0);
  transition: all 0.1s ease;
}

#bulkTimeManagerModal .btm-wed-subwrap{
  display:flex;
  flex-direction:column;
  gap:2px;
}

/* 统一周三子单元格样式 - 与其他列完全一致 */
#bulkTimeManagerModal .btm-wed-sub{
  flex:1;
  padding:4px 2px;
  border:1px solid #eef1f5; /* 与其他单元格边框颜色一致 */
  border-radius:4px;
  transition: all 0.25s ease;
  cursor: pointer;
  font-weight: 500;
  background: #fff; /* 确保默认背景为白色 */
  color: #2f4150; /* 确保默认文字颜色一致 */
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 20px;
}

/* 统一周三子单元格悬停效果 - 与其他列完全一致 */
#bulkTimeManagerModal .btm-wed-sub:hover:not(.rest):not(.selected) {
  background: #e6f1ff;
  border-color: #b1d3ff;
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
}

/* 统一周三子单元格选中状态 - 与其他列完全一致 */
#bulkTimeManagerModal .btm-wed-sub.selected {
  background: linear-gradient(135deg, #007AFF, #5856D6);
  color: #fff;
  font-weight: 700;
  border-color: #3366cc;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15) inset;
}

/* 统一周三子单元格休息状态 - 与其他列完全一致 */
#bulkTimeManagerModal .btm-wed-sub.rest {
  background: linear-gradient(135deg, #6C757D, #495057);
  color: #fff;
  cursor: not-allowed;
  font-weight: 600;
  border-color: #495057;
}

/* 周三子单元格选中状态悬停效果 - 与其他列完全一致 */
#bulkTimeManagerModal .btm-wed-sub.selected:hover {
  opacity: 0.9;
  transform: translateY(-1px);
  box-shadow: 0 3px 10px rgba(0, 122, 255, 0.25);
}

/* 周三子单元格休息状态悬停效果 - 与其他列完全一致 */
#bulkTimeManagerModal .btm-wed-sub.rest:hover {
  transform: none;
  box-shadow: none;
  opacity: 0.8;
}

/* 周三子单元格活跃状态 - 与其他列完全一致 */
#bulkTimeManagerModal .btm-wed-sub:active:not(.rest) {
  transform: translateY(0);
  transition: all 0.1s ease;
}

#bulkTimeManagerModal .btm-right .btm-summary-title{
  font-size:15px;
  font-weight:700;
  color:#2c3e50;
}
#bulkTimeManagerModal .btm-selected-list{
  flex:1;
  overflow:auto;
  background:#fff;
  border:1px solid #e0e4ea;
  border-radius:10px;
  padding:10px;
  font-size:12px;
  line-height:1.5;
  display:flex;
  flex-direction:column;
  gap:6px;
}
#bulkTimeManagerModal .btm-chip{
  display:inline-block;
  background:#007aff22;
  border:1px solid #007aff88;
  color:#007AFF;
  padding:3px 8px;
  border-radius:14px;
  font-size:11px;
  margin:2px;
  font-weight:600;
  cursor:default;
}
#bulkTimeManagerModal .btm-chip.wed{background:#5856d622;border-color:#5856d6aa;color:#4b49c8;}
#bulkTimeManagerModal .btm-note{
  font-size:11px;
  line-height:1.6;
  background:#fff9e6;
  border:1px solid #ffe3a3;
  padding:10px 12px;
  border-radius:8px;
  color:#8a6113;
}
@media (max-width:1200px){
  #bulkTimeManagerModal .btm-right{width:280px;}
}
@media (max-width:960px){
  #bulkTimeManagerModal .btm-wrapper{width:96%;height:94%;}
  #bulkTimeManagerModal .btm-right{display:none;}
  #bulkTimeManagerModal .btm-left{padding:10px;}
}
/* ===== BTM 筛选功能新增样式 BEGIN ===== */
.btm-filter-bar{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  margin:4px 0 14px;
  background:#f2f5f9;
  padding:10px 12px;
  border:1px solid #e0e4ea;
  border-radius:10px;
}
.btm-filter-bar input,
.btm-filter-bar select{
  padding:8px 10px;
  border:2px solid #d6dae2;
  border-radius:8px;
  font-size:13px;
  outline:none;
  min-width:140px;
  background:#fff;
  transition:.25s;
}
.btm-filter-bar input:focus,
.btm-filter-bar select:focus{
  border-color:#007AFF;
  box-shadow:0 0 0 3px rgba(0,122,255,.15);
}
#btmFilterResetBtn{
  background:#4e5d78;
  color:#fff;
  padding:8px 16px;
  border:none;
  border-radius:8px;
  font-weight:600;
  cursor:pointer;
  transition:.25s;
}
#btmFilterResetBtn:hover{
  background:#3d4a63;
  transform:translateY(-2px);
}
.btm-filter-empty{
  font-size:13px;
  color:#999;
  padding:12px 4px 4px;
  font-style:italic;
}
/* 自适应 */
@media (max-width:680px){
  .btm-filter-bar{
    flex-direction:column;
    align-items:stretch;
  }
  .btm-filter-bar input,
  .btm-filter-bar select{
    width:100%;
    min-width:unset;
  }
  #btmFilterResetBtn{
    width:100%;
  }
}
/* ===== BTM 筛选功能新增样式 END ===== */
/* === 楼层快速切换条（新增） === */
.floor-switch-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin: 0 0 14px;
}

.floor-switch-btn {
    background: #ecf0f1;
    color: #34495e;
    border: none;
    padding: 6px 14px;
    border-radius: 22px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    line-height: 1;
    transition: .25s;
}

.floor-switch-btn:hover {
    background: var(--hover-color);
    color: #fff;
}

.floor-switch-btn.active {
    background: var(--primary-color);
    color: #fff;
    font-weight: 600;
    box-shadow: 0 2px 6px rgba(0,0,0,.15);
    cursor: default;
}

</style>
</head>
<body>
<!-- ===== 缓存显示 ===== -->
<div id="cacheInfo" class="cache-info" style="display:none;">
  <div class="cache-size" id="cacheSize">计算中...</div>
  <div class="cache-percentage" id="cachePercentage">0%</div>
  <div class="cache-details" id="cacheDetails">详情</div>
</div>

<div id="systemContent" style="display:none;">
  <h1>耶胡迪梅纽因学校琴房管理系统</h1>
  <div id="currentTime" style="text-align:center;font-size:20px;font-weight:600;"></div>
  <div id="autoResetInfo" class="auto-reset-info" style="text-align:center;font-size:.9em;color:#7f8c8d;margin-top:10px;margin-bottom:20px;">


    系统将在每天晚上21:45自动重置所有琴房状态
  </div>

  <!-- 搜索功能 -->
  <div class="search-section">
    <div class="search-container">
      <input type="text" id="globalSearch" placeholder="搜索学生或琴房...">
      <button onclick="clearSearch()" id="clearSearchBtn" class="clear-btn" style="display:none;">关闭</button>
    </div>
    <div id="searchResults" class="search-results" style="display:none;"></div>
  </div>

  <!-- 时间轴控制 -->
  <div class="timeline-control-container">
    <button class="timeline-control-btn" id="timelineMainControlBtn" onclick="toggleTimeline()">
      <span class="timeline-control-icon">⏰</span>
      <span class="timeline-control-text">显示琴房状态预测</span>
    </button>
  </div>

<!-- 状态聚焦：15分钟内释放 + 超时 -->
<div class="timeline-section" id="timelineSection">
  <div class="focus-header" style="display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px;">
    <h3 style="margin:0;display:flex;align-items:center;gap:8px;color:#e67e22;">⏰ 即将释放与超时监控</h3>
    <div class="focus-tools" style="display:flex;gap:8px;flex-wrap:wrap;">
      <select id="focusTypeFilter" onchange="filterFocusCards()" style="padding:6px 8px;border:1px solid var(--border-color);border-radius:6px;font-size:12px;">
        <option value="">所有类型</option>
        <option value="三角钢琴">三角钢琴</option>
        <option value="立式钢琴">立式钢琴</option>
        <option value="无钢琴">无钢琴</option>
      </select>
    </div>
  </div>

  <div class="focus-groups">
    <!-- 15 分钟内释放 -->
    <div class="focus-group soon" data-group="soon">
      <div class="focus-group-header">
        <div class="focus-group-title">🕒 15 分钟内释放 <span id="focusSoonCount">0</span></div>
        <div class="focus-group-sub">剩余 ≤ 15 分钟的正在使用琴房</div>
      </div>
      <div class="focus-group-body" id="focusSoonBody">
        <div class="focus-empty">暂无 15 分钟内将释放的琴房</div>
      </div>
    </div>

    <!-- 超时 -->
    <div class="focus-group overtime" data-group="overtime">
      <div class="focus-group-header">
        <div class="focus-group-title">⛔ 超时使用 <span id="focusOverCount">0</span></div>
        <div class="focus-group-sub">已超过基础练琴时长</div>
      </div>
      <div class="focus-group-body" id="focusOverBody">
        <div class="focus-empty">暂无超时琴房</div>
      </div>
    </div>
  </div>

  <div class="focus-foot-note">
    说明：准备阶段 1 分钟后开始计时；仅在准备结束后且剩余 ≤ 15 分钟时列入“15 分钟内释放”；超过基础练琴时长列入“超时”。
  </div>
</div>
  <!-- 快速需求 -->
  <div class="panel secondary">
    <h3 style="margin-top:0;color:var(--secondary-color);">快速需求</h3>
    <p class="text-muted" style="font-size:15px;line-height:1.4;margin-top:4px;">
  根据琴房类型快速查找可用琴房或加入排队<br>
      <span style="color:#e67e22; font-size:13px;">注意：有人排队时需先排队（先到先得）</span><br>
    </p>
    <div class="demand-buttons">
      <button class="demand-btn grand-piano" onclick="handleDemandRequest('grand')">
        <div>🎹 三角琴房</div>
        <div id="grandStatus" style="font-size:.75em;margin-top:6px;">检查中...</div>
      </button>
      <button class="demand-btn upright-piano" onclick="handleDemandRequest('upright')">
        <div>🎹 立式琴房</div>
        <div id="uprightStatus" style="font-size:.75em;margin-top:6px;">检查中...</div>
      </button>
      <button class="demand-btn no-piano" onclick="handleDemandRequest('none')">
        <div>🎵 普通琴房</div>
        <div id="noneStatus" style="font-size:.75em;margin-top:6px;">检查中...</div>
      </button>
    </div>
  </div>

  <!-- 排队系统 -->
  <div class="panel queue">
    <div class="queue-header">
      <h3 class="queue-title">排队系统</h3>
    </div>

    <div class="queue-subsection" id="grandQueueSection">
      <div class="queue-subheader">
        <h4 style="margin:0;">三角琴房排队</h4>
      </div>
      <div class="queue-list" id="grandQueueList">
        <div class="empty-queue">暂无排队学生</div>
      </div>
    </div>

    <div class="queue-subsection" id="uprightQueueSection">
      <div class="queue-subheader">
        <h4 style="margin:0;">立式琴房排队</h4>
      </div>
      <div class="queue-list" id="uprightQueueList">
        <div class="empty-queue">暂无排队学生</div>
      </div>
    </div>

    <div class="queue-subsection" id="noneQueueSection">
      <div class="queue-subheader">
        <h4 style="margin:0;">普通琴房排队</h4>
      </div>
      <div class="queue-list" id="noneQueueList">
        <div class="empty-queue">暂无排队学生</div>
      </div>
    </div>
  </div>
  <!-- 琴房显示容器 -->
  <div id="rooms" class="fade-in"></div>
  <div id="utilizationRate" style="text-align:center;font-size:1.05em;color:var(--primary-color);margin:15px 0;"></div>

  <!-- 管理操作 -->
  <div class="admin-controls" style="text-align:center;display:flex;flex-wrap:wrap;gap:10px;justify-content:center;">
    <button onclick="manualReset()">手动重置系统</button>
    <button onclick="lockSystem()">锁定系统</button>
    <button onclick="exportPracticeLogs()">导出练琴日志</button>
    <button onclick="backupSystemData()">备份系统数据</button>
    <button onclick="restoreSystemData()">恢复系统数据</button>
    <button onclick="viewOperationLogs()">查看操作日志</button>
    <button onclick="clearLocalStorage()">清理缓存</button>
    <button onclick="manageStudentDatabase()">管理学生库</button>
    <button onclick="manageRoomDatabase()">管理琴房库</button>
    <button onclick="openSettingsModal()">系统设置</button>
    <button onclick="openAttendanceModal()" style="background:#e67e22;">考勤检查</button>
    <button class="overtime-manage-btn" onclick="openOvertimeModal()" style="background:var(--danger-color);">超时管理</button>


  </div>
</div>

<!-- 公用提示 -->
<div id="toast" class="toast"></div>

<!-- 各模态 (保持原 ID) -->
<div id="studentListModal"><div class="modal-content mid">
  <span class="close" onclick="closeModal()">&times;</span>
  <h2>选择学生</h2>
  <input type="text" id="modalStudentSearch" placeholder="搜索或添加新学生 (支持↑↓键选择，回车确认)" oninput="searchStudentsModal(this.value)" style="width:100%;margin-bottom:12px;">
  <div id="modalStudentList" style="max-height:320px;overflow:auto;border:1px solid var(--border-color);border-radius:8px;padding:6px;"></div>
  <div id="addNewStudentSection" style="display:none;margin-top:10px;">
    <button onclick="addNewStudent()">添加新学生</button>
  </div>
</div></div>

<div id="queueStudentModal"><div class="modal-content mid">
  <span class="close" onclick="closeQueueStudentModal()">&times;</span>
  <h2>选择排队学生</h2>
  <input type="text" id="queueStudentSearch" placeholder="搜索或添加新学生 (支持↑↓键选择，回车确认)" oninput="searchQueueStudents(this.value)" style="width:100%;margin-bottom:12px;">
  <div id="queueStudentList" style="max-height:320px;overflow:auto;border:1px solid var(--border-color);border-radius:8px;padding:6px;"></div>
  <div id="addNewQueueStudentSection" style="display:none;margin-top:10px;">
    <button onclick="addNewQueueStudent()">添加新学生到排队</button>
  </div>
</div></div>

<div id="queueModal"><div class="modal-content">
  <span class="close" onclick="closeQueueModal()">&times;</span>
  <h2 id="queueModalTitle">选择排队学生</h2>
  <div id="queueModalList" style="max-height:320px;overflow:auto;"></div>
</div></div>

<div id="availableRoomsModal"><div class="modal-content mid">
  <span class="close" onclick="closeAvailableRoomsModal()">&times;</span>
  <h2 id="availableRoomsTitle">选择琴房</h2>
  <div id="availableRoomsInfo" style="margin-bottom:10px;"></div>
  <div id="availableRoomsList"></div>
</div></div>

<div id="replaceableRoomsModal"><div class="modal-content mid">
  <span class="close" onclick="closeReplaceableRoomsModal()">&times;</span>
  <h2 id="replaceableRoomsTitle">选择要替换的琴房</h2>
  <div id="replaceableRoomsInfo" style="margin-bottom:10px;"></div>
  <div id="replaceableRoomsList"></div>
</div></div>

<div id="studentDatabaseModal"><div class="modal-content wide">
  <span class="close" onclick="closeStudentDatabaseModal()">&times;</span>
  <h2>学生库管理</h2>
<div class="student-db-controls" style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:15px;align-items:center;">
    <input type="text" id="studentDbSearch" placeholder="搜索学生姓名..."style="flex:1;min-width:200px;">
    <select id="majorFilter" onchange="filterByMajor()"><option value="">所有专业</option></select>
    <select id="gradeFilter" onchange="filterByGrade()"><option value="">所有年级</option></select>
    <button onclick="addNewStudentToDatabase()">添加新学生</button>
    <button onclick="exportStudentDatabase()" style="background:var(--success-color);">导出学生库</button>
    <input type="file" id="importStudentFile" accept=".json,.csv" style="display:none;" onchange="importStudentDatabase(event)">
    <button onclick="document.getElementById('importStudentFile').click()" style="background:var(--warning-color);" title="支持JSON和CSV格式，支持年级G1-G12格式">导入学生库</button>
    <button onclick="openBulkTimeManager()" style="background:#007AFF;">批量管理时间段</button>
</div>
  <div id="studentDatabaseList" style="max-height:400px;overflow:auto;border:1px solid var(--border-color);border-radius:8px;margin-bottom:10px;"></div>
  <div id="studentDbStats" class="student-db-stats"></div>
</div></div>

<div id="editStudentModal"><div class="modal-content">
  <span class="close" onclick="closeEditStudentModal()">&times;</span>
  <h2>编辑学生信息</h2>
  <div class="form-group" style="margin-bottom:12px;">
    <label for="editStudentName" style="display:inline-block;width:80px;font-weight:600;">姓名：</label>
    <input type="text" id="editStudentName" placeholder="请输入学生姓名" style="width:calc(100% - 90px);">
  </div>
  <div class="form-group" style="margin-bottom:12px;">
    <label for="editStudentMajor" style="display:inline-block;width:80px;font-weight:600;">专业：</label>
    <select id="editStudentMajor" style="width:calc(100% - 90px);"></select>
  </div>
  <div class="form-group" style="margin-bottom:12px;">
    <label for="editStudentGrade" style="display:inline-block;width:80px;font-weight:600;">年级：</label>
    <input type="text" id="editStudentGrade" placeholder="如：G1, G12, 1年级等" style="width:calc(100% - 90px);" title="支持格式：G1-G12, 1-12, 1年级-12年级">
  </div>
  <div style="display:flex;justify-content:flex-end;gap:10px;margin-top:10px;">
    <button onclick="saveStudentChanges()">保存修改</button>
    <button onclick="closeEditStudentModal()" class="clear-btn">取消</button>
  </div>
</div></div>

<div id="majorSelectionModal"><div class="modal-content" style="max-width:420px;">
  <span class="close" onclick="closeMajorSelectionModal()">&times;</span>
  <h2>选择或创建专业</h2>
  <div id="existingMajors" style="margin-bottom:15px;">
    <h4 style="margin:0 0 10px;color:var(--primary-color);text-align:left;">现有专业：</h4>
    <div id="majorButtonsList" style="display:flex;flex-wrap:wrap;gap:10px;"></div>
  </div>
  <div style="border-top:1px solid var(--border-color);padding-top:15px;">
    <h4 style="margin:0 0 10px;color:var(--secondary-color);text-align:left;">创建新专业：</h4>
    <input type="text" id="newMajorInput" placeholder="输入新专业名称" style="width:100%;margin-bottom:10px;">
    <button onclick="createNewMajor()" style="width:100%;">创建新专业</button>
  </div>
</div></div>

<div id="roomDatabaseModal"><div class="modal-content wide">
  <span class="close" onclick="closeRoomDatabaseModal()">&times;</span>
  <h2>琴房库管理</h2>
  <div class="room-db-controls">
<div id="roomQuickAdd" style="display:flex;flex-wrap:wrap;gap:8px;margin:10px 0 12px;">
  <input type="text" id="newRoomNameInput" placeholder="名称" style="flex:0 0 120px;">
  <input type="text" id="newRoomLocationInput" placeholder="位置(可选)" style="flex:0 0 120px;">
  <select id="newRoomTypeSelect" style="flex:0 0 110px;">
    <option value="三角钢琴">三角钢琴</option>
    <option value="立式钢琴">立式钢琴</option>
    <option value="无钢琴">无钢琴</option>
  </select>
  <input type="text" id="newRoomRemarkInput" placeholder="备注(可选)" style="flex:1;min-width:140px;">
  <button style="flex:0 0 90px;" onclick="roomDbAddRoom()">新增</button>
</div>
    <input type="text" id="roomSearchInput" placeholder="按名称/备注搜索..." oninput="displayRoomDatabase()">
    <select id="roomLocationFilter" onchange="displayRoomDatabase()"><option value="">所有位置</option></select>
    <select id="roomTypeFilter" onchange="displayRoomDatabase()">
      <option value="">所有类型</option>
      <option value="三角钢琴">三角钢琴</option>
      <option value="立式钢琴">立式钢琴</option>
      <option value="无钢琴">无钢琴</option>
    </select>
    <button class="import-room-btn" onclick="importRoomDatabase()">导入琴房库</button>
    <button class="export-btn" onclick="exportRoomDatabase()">导出琴房库</button>
  </div>
  <div class="small-tip" style="font-size:11px;color:#888;margin:4px 0 10px;">提示：修改类型会即时影响分类；已占用琴房名称不支持更名（统一保留）</div>
  <div id="roomDatabaseList" style="border:1px solid var(--border-color);border-radius:8px;max-height:480px;overflow:auto;"></div>
  <div class="room-db-stats" id="roomDbStats"></div>
</div></div>

<div id="timeSlotModal"><div class="modal-content time-slot-modal-content">
  <span class="close" onclick="closeTimeSlotModal()">&times;</span>
  <h2 id="timeSlotModalTitle">管理练琴时间段</h2>
  <div class="weekday-selector" style="margin-bottom:15px;padding:15px;background:#f8f9fa;border-radius:8px;border:1px solid var(--border-color);">
    <h4 style="margin:0 0 10px;color:var(--primary-color);">选择星期：</h4>
    <div class="weekday-buttons">
      <button class="weekday-btn active" data-day="monday" onclick="selectWeekday('monday')">周一</button>
      <button class="weekday-btn" data-day="tuesday" onclick="selectWeekday('tuesday')">周二</button>
      <button class="weekday-btn" data-day="wednesday" onclick="selectWeekday('wednesday')">周三</button>
      <button class="weekday-btn" data-day="thursday" onclick="selectWeekday('thursday')">周四</button>
      <button class="weekday-btn" data-day="friday" onclick="selectWeekday('friday')">周五</button>
    </div>
  </div>
  <div class="time-input-group" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:10px;">
    <label style="font-weight:600;">开始时间:</label>
    <select id="startHour"></select><span>:</span><select id="startMinute"></select>
  </div>
  <div class="time-input-group" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:15px;">
    <label style="font-weight:600;">结束时间:</label>
    <select id="endHour"></select><span>:</span><select id="endMinute"></select>
  </div>
  <div style="text-align:center;margin-bottom:18px;">
    <button onclick="addTimeSlot()" style="background:var(--secondary-color);">添加时间段</button>
  </div>
  <div class="weekly-summary">
    <h4 style="margin:0 0 10px;color:var(--primary-color);">本周时间段汇总：</h4>
    <div id="weeklySummaryDisplay"></div>
    <div style="text-align:center;margin-top:15px;">
      <button onclick="clearAllTimeSlots()" style="background:var(--danger-color);">清空全部时间段</button>
    </div>
  </div>
  <div class="current-time-slots" style="background:#f8f9fa;padding:15px;border-radius:8px;">
    <h4 id="currentDayTitle" style="margin:0 0 10px;">周一时间段：</h4>
    <div id="currentTimeSlotsList"></div>
  </div>
</div></div>
<div id="bulkTimeManagerModal" style="display:none;">
  <div class="btm-wrapper">
    <div class="btm-header">
      <div class="btm-title">批量练琴时间段管理</div>
      <div class="btm-actions">
        <button class="btm-btn btm-secondary" onclick="BTM.clearAllSelections()">清空全部选择</button>
        <button class="btm-btn btm-primary" onclick="BTM.applyAndSave()">保存并同步</button>
        <button class="btm-btn btm-danger" onclick="closeBulkTimeManager()">关闭</button>
      </div>
    </div>
    <div class="btm-body">
      <div class="btm-left">
        <div class="btm-student-bar">
            <select id="btmStudentSelect" onchange="BTM.selectStudent()" class="btm-select"></select>
            <div class="btm-stu-nav">
              <button onclick="BTM.prevStudent()">←</button>
              <button onclick="BTM.nextStudent()">→</button>
            </div>
          </div>

          <!-- 筛选工具条（新增） -->
          <div class="btm-filter-bar">
            <input type="text" id="btmSearchInput" placeholder="搜索学生姓名 (支持拼音首字母)" />
            <select id="btmMajorFilter"></select>
            <select id="btmGradeFilter"></select>
            <button id="btmFilterResetBtn" onclick="BTM.resetFilters()">重置</button>
          </div>

        <div class="btm-stu-info" id="btmStudentInfo"></div>
        <div class="btm-legend">
          <span><b style="background:#007aff33;border:1px solid #007aff66;width:16px;height:16px;display:inline-block;border-radius:4px;margin-right:4px;"></b>可选</span>
          <span><b style="background:#007AFF;color:#fff;border:1px solid #0060c8;width:16px;height:16px;display:inline-block;border-radius:4px;margin-right:4px;"></b>已选</span>
          <span><b style="background:#555;color:#fff;border:1px solid #333;width:16px;height:16px;display:inline-block;border-radius:4px;margin-right:4px;"></b>休息/午餐</span>
        </div>
        <div class="btm-table-wrap">
          <table class="btm-table" id="btmTable">
            <thead>
              <tr>
                <th class="btm-time-col">时间段</th>
                <th>周一</th>
                <th>周二</th>
                <th>周三</th>
                <th>周四</th>
                <th>周五</th>
              </tr>
            </thead>
            <tbody id="btmTbody"></tbody>
          </table>
        </div>
      </div>
      <div class="btm-right">
        <div class="btm-summary-title">当前学生已选时间段</div>
        <div id="btmSelectedList" class="btm-selected-list"></div>
        <div class="btm-note">
          说明：<br>
          1) 此界面基于固定节次（适合标准快速标记）；<br>
          2) 保存后会覆盖该学生对应节次的原有时间段（仅对应到能匹配的固定时段，不会删除不在表里的自定义 10 分钟节次）；<br>
          3) 周三含拆分节次（午间/下午多个子段）；<br>
          4) 保存并同步会触发本地持久化与（在线时）云同步。<br>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="settingsModal"><div class="modal-content settings-modal-content">
  <span class="close" onclick="closeSettingsModal()">&times;</span>
  <h2>系统设置</h2>
  
  <!-- 练琴时长设置 -->
  <div class="settings-section">
    <h3>⏰ 练琴时长设置</h3>
    <div class="setting-item">
      <div class="setting-info">
        <div class="setting-label">基础练琴时长</div>
        <div class="setting-description">超过该时长将被标记为超时使用（建议范围：60-180分钟）</div>
        <div class="setting-preview" id="durationPreview">当前设置：120分钟</div>
      </div>
      <div class="setting-control">
        <div class="input-group">
          <input type="number" id="baseDurationInput" class="setting-input" min="1" max="240" value="120" onchange="updateDurationPreview()">
          <span class="input-unit">分钟</span>
        </div>
        <div class="setting-range">
          <small>范围：1-240分钟</small>
        </div>
      </div>
    </div>
  </div>

  <!-- 自动重置设置 -->
  <div class="settings-section">
    <h3>🔄 自动重置设置</h3>
    <div class="setting-item">
      <div class="setting-info">
        <div class="setting-label">每日重置时间</div>
        <div class="setting-description">系统将在指定时间自动清空所有琴房占用状态和排队信息</div>
        <div class="setting-preview" id="resetTimePreview">当前设置：21:45</div>
      </div>
      <div class="setting-control">
        <div class="time-input-group">
          <div class="time-input">
            <input type="number" id="resetHourInput" class="setting-input time-input-field" min="0" max="23" value="21" onchange="updateResetTimePreview()">
            <label>时</label>
          </div>
          <div class="time-separator">:</div>
          <div class="time-input">
            <input type="number" id="resetMinuteInput" class="setting-input time-input-field" min="0" max="59" value="45" onchange="updateResetTimePreview()">
            <label>分</label>
          </div>
        </div>
      </div>
    </div>
    
    <div class="setting-item">
      <div class="setting-info">
        <div class="setting-label">异常检查开始时间</div>
        <div class="setting-description">每天几点开始进行练琴异常提醒检查</div>
        <div class="setting-preview" id="startAnomalyPreview">当前设置：08:00开始</div>
      </div>
      <div class="setting-control">
        <div class="time-input-group">
          <div class="time-input">
            <input type="number" id="startAnomalyHourInput" class="setting-input time-input-field" min="0" max="23" value="8" onchange="updateStartAnomalyPreview()">
            <label>时</label>
          </div>
          <div class="time-separator">:</div>
          <div class="time-input">
            <input type="number" id="startAnomalyMinuteInput" class="setting-input time-input-field" min="0" max="59" value="0" onchange="updateStartAnomalyPreview()">
            <label>分</label>
          </div>
        </div>
      </div>
    </div>
    
    <div class="setting-item">
      <div class="setting-info">
        <div class="setting-label">异常检查停止时间</div>
        <div class="setting-description">每天超过指定时间后停止练琴异常提醒检查，避免深夜误报</div>
        <div class="setting-preview" id="stopAnomalyPreview">当前设置：19:00后停止</div>
      </div>
      <div class="setting-control">
        <div class="time-input-group">
          <div class="time-input">
            <input type="number" id="stopAnomalyHourInput" class="setting-input time-input-field" min="0" max="23" value="19" onchange="updateStopAnomalyPreview()">
            <label>时</label>
          </div>
          <div class="time-separator">:</div>
          <div class="time-input">
            <input type="number" id="stopAnomalyMinuteInput" class="setting-input time-input-field" min="0" max="59" value="0" onchange="updateStopAnomalyPreview()">
            <label>分</label>
          </div>
        </div>
      </div>
    </div>

  </div>
  <!-- 自动锁定设置 -->
  <div class="settings-section">
    <h3>🔒 自动锁定设置</h3>
    <div class="setting-item">
      <div class="setting-info">
        <div class="setting-label">自动锁定时间</div>
        <div class="setting-description">系统在指定时间无操作后自动锁定（建议范围：5-60分钟）</div>
        <div class="setting-preview" id="autoLockPreview">当前设置：10分钟</div>
      </div>
      <div class="setting-control">
        <div class="input-group">
          <input type="number" id="autoLockTimeInput" class="setting-input" min="1" max="120" value="10" onchange="updateAutoLockPreview()">
          <span class="input-unit">分钟</span>
        </div>
        <div class="setting-range">
          <small>范围：1-120分钟</small>
        </div>
      </div>
    </div>
    
    <div class="setting-item">
      <div class="setting-info">
        <div class="setting-label">启用自动锁定</div>
        <div class="setting-description">关闭此选项将完全禁用自动锁定功能</div>
      </div>
      <div class="setting-control">
        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
          <input type="checkbox" id="autoLockEnabledInput" checked onchange="updateAutoLockPreview()">
          <span>启用自动锁定</span>
        </label>
      </div>
    </div>
  </div>

  <!-- 安全设置 -->
  <div class="settings-section security-section">
    <h3>🔐 安全设置</h3>
    <div class="security-notice">
      <div class="notice-icon">⚠️</div>
      <div class="notice-text">
        <strong>重要提醒：</strong>修改登录密码时必须提供管理员密码进行验证
      </div>
    </div>
    
    <div class="setting-item">
      <div class="setting-info">
        <div class="setting-label">修改登录密码</div>
        <div class="setting-description">用于系统解锁的密码，留空则不修改当前密码</div>
      </div>
      <div class="setting-control">
        <div class="password-input-group">
          <input type="password" id="loginPasswordInput" class="setting-input password-field" placeholder="输入新密码（可选）">
          <button type="button" class="password-toggle" onclick="togglePasswordVisibility('loginPasswordInput')" title="显示/隐藏密码">
            👁️
          </button>
        </div>
      </div>
    </div>
    
    <div class="setting-item">
      <div class="setting-info">
        <div class="setting-label">管理员密码验证</div>
        <div class="setting-description admin-required">修改登录密码时必须填写此项进行身份验证</div>
      </div>
      <div class="setting-control">
        <div class="password-input-group">
          <input type="password" id="adminPasswordInput" class="setting-input password-field" placeholder="输入管理员密码">
          <button type="button" class="password-toggle" onclick="togglePasswordVisibility('adminPasswordInput')" title="显示/隐藏密码">
            👁️
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- 操作按钮 -->
  <div class="settings-actions">
    <button class="settings-save-btn" onclick="saveSettings()">
      <span class="btn-icon">💾</span>
      <span>保存设置</span>
    </button>
    <button class="settings-cancel-btn" onclick="closeSettingsModal()">
      <span class="btn-icon">❌</span>
      <span>取消</span>
    </button>
  </div>
</div></div>

<div id="attendanceModal"><div class="modal-content large">
  <span class="close" onclick="closeAttendanceModal()">&times;</span>
  <div class="attendance-header" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;margin-bottom:10px;padding-right:50px;">
    <h2 class="attendance-title" style="margin:0;display:flex;align-items:center;gap:10px;color:#e67e22;">📋 学生考勤检查
      <span id="attendanceBadge" class="overtime-badge" style="display:none;"></span>
    </h2>
    <div class="attendance-controls" style="display:flex;gap:8px;flex-wrap:wrap;">
      <select id="attendanceMajorFilter" class="attendance-filter" onchange="renderAttendanceList()" style="padding:6px 8px;border:1px solid var(--border-color);border-radius:4px;font-size:12px;">
        <option value="">所有专业</option>
      </select>
      <select id="attendanceStatusFilter" class="attendance-filter" onchange="renderAttendanceList()" style="padding:6px 8px;border:1px solid var(--border-color);border-radius:4px;font-size:12px;">
        <option value="">所有状态</option>
        <option value="absent">缺勤</option>
        <option value="present">正常出勤</option>
        <option value="low_efficiency">低效出勤</option>
        <option value="under_review">待观察</option>
        <option value="excused">已请假</option>
        <option value="queuing">排队中</option>
        <option value="practicing">练琴中</option>
        <option value="preparing">准备中</option>
        <option value="overtime">超时练琴</option>
      </select>
      <button class="btn-mini-primary" onclick="exportAttendanceReport()">导出报告</button>
      <!-- 🔥 新增云端导出按钮 -->
          <button class="btn-mini-primary" onclick="exportCloudAttendanceReport()" style="background:#e67e22;">☁️ 云端导出</button>
    </div>
  </div>
  <div id="attendanceContent"></div>
  <div id="attendanceSummary" class="attendance-summary" style="margin-top:10px;"></div>
</div></div>

<div id="overtimeModal"><div class="modal-content wide">
  <span class="close" onclick="closeOvertimeModal()">&times;</span>
  <div class="overtime-header" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;margin-bottom:10px;padding-right:50px;">
    <h2 style="margin:0;">超时练琴管理 <span id="overtimeCountBadge" class="overtime-badge" style="display:none;"></span></h2>
    <div class="overtime-filter-group" style="display:flex;flex-wrap:wrap;gap:8px;">
      <input type="text" id="overtimeSearch" placeholder="搜索学生/琴房" oninput="renderOvertimeList()" style="padding:6px 8px;border:1px solid var(--border-color);border-radius:4px;font-size:12px;">
      <button class="btn-mini-primary" onclick="renderOvertimeList(true)">刷新</button>
      <button class="btn-mini-danger" onclick="clearAllOvertimeRooms()">全部清空</button>
    </div>
  </div>
  <div class="overtime-tools" style="font-size:12px;color:#666;margin-bottom:10px;">显示所有超时练琴记录，按类型分类并按超时时长排序</div>
  <div id="overtimeContent"></div>
  <div id="overtimeStats" class="overtime-stat" style="font-size:12px;color:#555;margin-top:8px;"></div>
</div></div>
<!-- 练琴状态检查提醒面板 -->
<div id="overrunReminderPanel" class="overrun-panel collapsed" style="display:none;">
  <div class="overrun-panel-header" onclick="toggleOverrunPanel()">
    <div>
      <h4>⚠️ 异常提醒 <span id="overrunCountBadge" class="overrun-count-badge" style="display:none;">0</span></h4>
      <div class="header-subtitle">练琴超出练琴时间段监控</div>
    </div>
    <div style="display:flex;align-items:center;gap:12px;">
      <button onclick="clearAllOverrunReminders();event.stopPropagation();" style="background:#e74c3c;color:#fff;border:none;padding:6px 12px;border-radius:6px;font-size:11px;cursor:pointer;transition:all 0.2s;" onmouseover="this.style.background='#c0392b'" onmouseout="this.style.background='#e74c3c'">
        🗑️ 一键清空
      </button>
      <div style="font-size:12px;opacity:.9;">点击关闭</div>
    </div>
    <div class="overrun-panel-toggle-tip" onclick="toggleOverrunPanel();event.stopPropagation();">异常</div>
  </div>
  <div class="overrun-panel-body" id="overrunPanelBody">
    <div class="overrun-empty">🎉 暂无异常练琴<br><small>系统运行正常</small></div>
  </div>
  <div class="overrun-panel-footer">
    <strong>监控规则：</strong>学生在预定练琴时间段结束后仍持续占用 ≥ 15 分钟<br>
    <small>💡 "忽略"不计入考勤；"记录"将写入考勤报告</small>
  </div>
</div>



<!-- ===== JS 主脚本（重构后） ===== -->
<script>
/* =========================================================
 *  耶胡迪梅纽因学校琴房管理系统（重构版）
 *  分层结构：
 *   1. 常量与工具
 *   2. 数据模型与持久化
 *   3. UI 通用（模态、Toast、解锁）
 *   4. 房间与琴房库
 *   5. 学生库与时间段
 *   6. 排队系统
 *   7. 快速需求（可用/替换）
 *   8. 时间轴预测
 *   9. 超时管理
 *  10. 考勤系统
 *  10-1. 练琴状态异常提醒
 *  11. 系统设置 / 备份恢复 / 日志
 *  12. 全局搜索
 *  13. 缓存监控
 *  14. 初始化与事件绑定
 *  15. 兼容暴露（旧函数名映射）
 * =======================================================*/

/* =============== 1. 常量与工具 =============== */
const KEYS = {
  ROOMS:'rooms',
  ROOM_DB:'roomDatabase',
  STUD_DB:'studentDatabase',
  STUD_SLOTS:'studentTimeSlots',
  PRACTICE_LOG:'practiceLogs',
  QUEUE:'queueList',
  OPS:'operationLogs',
  SETTINGS:'systemSettings',
  AUTO_RESET:'autoResetSettings',
  TIMELINE_VISIBLE:'timelineVisible',
  OVERRUN_REMINDERS:'practiceOverrunReminders',
  OVERRUN_IGNORED:'practiceOverrunIgnored',
  OVERRUN_STATS:'practiceOverrunStats'
};

const SLOT_HISTORY_KEY = 'studentSlotHistory';

const DEFAULT_SETTINGS = {
  basePracticeDuration:120,
  loginPassword:'password',
  adminPassword:'ymsq2022',
  autoResetHour:21,
  autoResetMinute:45,
  stopAnomalyCheckHour:19,  // 新增：每天几点后停止异常检查（默认19点）
  stopAnomalyCheckMinute:0,
  startAnomalyCheckHour:8,  // 🔥 新增：异常检查开始时间（小时）
  startAnomalyCheckMinute:0,
  dataProtectionMode: true, // 🔥 新增：数据保护模式
  autoLockEnabled: true,        // 🔥 新增：是否启用自动锁定
  autoLockTimeMinutes: 10    
};

const WEEK_MAP = {1:'monday',2:'tuesday',3:'wednesday',4:'thursday',5:'friday'};
const WEEK_CN  = {monday:'周一',tuesday:'周二',wednesday:'周三',thursday:'周四',friday:'周五'};

// 🔥 添加 Firebase 配置
const firebaseConfig = {
  apiKey: "AIzaSyBVo2SAW85dT1e0oaxJor4idPKnfZ21Bww",
  authDomain: "menuhin-backup.firebaseapp.com",
  databaseURL: "https://menuhin-backup-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "menuhin-backup",
  storageBucket: "menuhin-backup.firebasestorage.app",
  messagingSenderId: "573338040341",
  appId: "1:573338040341:web:01a627216b050c2abef61c",
  measurementId: "G-EKF09W8PVP"
};

/* =============== Firebase 实时同步功能 =============== */
let firebaseApp = null;
let database = null;
let isOnline = false;
let syncEnabled = true;
let lastSyncTime = 0;
let deviceId = null;

const FIREBASE_PATHS = {
    ROOMS: 'rooms',
    ROOM_DB: 'roomDatabase', 
    STUDENT_DB: 'studentDatabase',
    STUDENT_SLOTS: 'studentTimeSlots',
    QUEUE: 'queueList',
    LAST_UPDATE: 'lastUpdate',
    DEVICE_STATUS: 'deviceStatus',
    SYSTEM_SETTINGS: 'systemSettings',
    ATTENDANCE_DATA: 'attendanceData',
    OVERRUN_REMINDERS: 'practiceOverrunReminders',
    OVERRUN_STATS: 'overrunStats',
    OVERRUN_IGNORED: 'overrunIgnored',
    EXCUSE_DATA: 'excuseData' , // 新增：专门存储请假数据
    OVERRUN_DATA: 'overrunData',
    PRACTICE_RECORDS: 'practiceRecords', // 🔥 新增：练习时长记录
    PRACTICE_SESSIONS: 'practiceSessions' // 🔥 新增：练习会话数据
};

// 🔥 新增：清理对象中的 undefined 值
function cleanDataForFirebase(obj) {
    if (obj === null || obj === undefined) {
        return null;
    }
    
    if (Array.isArray(obj)) {
        return obj.map(item => cleanDataForFirebase(item));
    }
    
    if (typeof obj === 'object') {
        const cleaned = {};
        for (const [key, value] of Object.entries(obj)) {
            if (value !== undefined) {
                // 🔥 特殊处理房间数据
                if (key === 'student' || key === 'registerTime') {
                    cleaned[key] = value === null ? null : value;
                } else {
                    cleaned[key] = cleanDataForFirebase(value);
                }
            }
        }
        return cleaned;
    }
    
    return obj;
}


// 初始化 Firebase
function initFirebase() {
    try {
        console.log('🔥 开始初始化 Firebase...');

        // ===== 自适应连接策略：多次断线后降级为长轮询 =====
        (function(){
          if(!window.__fbTransportState){
            window.__fbTransportState={
              disconnectCount:0,
              lastDisconnectAt:0,
              forcedLongPolling:false
            };
          }
          // 若 10 分钟内累计断线 ≥3 次且尚未降级，则启用长轮询
          if(window.__fbTransportState.disconnectCount>=3 && !window.__fbTransportState.forcedLongPolling){
            console.warn('[net] 多次断线，启用长轮询降级模式');
            window.firebase && window.firebase.database && window.firebase.database.INTERNAL && (window.firebase.database.INTERNAL.forceLongPolling=true);
            window.__fbTransportState.forcedLongPolling=true;
          }
        })();
        
        firebaseApp = firebase.initializeApp(firebaseConfig);
        database = firebase.database();
        deviceId = getDeviceId();
        
        console.log('✅ Firebase 应用初始化成功');
        
        // 🔥 替换原有的连接状态监听器
        database.ref('.info/connected').on('value', (snapshot) => {
            const connected = snapshot.val() === true;
            const wasOnline = isOnline;
            isOnline = connected;
            updateConnectionStatus();
            
            if (connected && !wasOnline) {
                // 重新连接的情况
                console.log('🟢 Firebase 重新连接成功');
                showToast('🟢 已重新连接到云端服务器', 2000);
                
                // 🔥 关键修改：连接后立即检查是否需要同步
                setTimeout(() => {
                    const deviceStatus = detectDeviceStatus();
                    if (deviceStatus.isNewDevice || deviceStatus.totalScore === 0) {
                        console.log('🔄 检测到无数据设备，立即同步...');
                        performInitialSync();
                    } else {
                        console.log('🔄 正常设备重连，执行常规同步...');
                        performInitialSync();
                    }
                    // 触发状态更新
                    triggerRealTimePracticeStatusUpdate();
                }, 500);
                
            } else if (connected && wasOnline === undefined) {
                // 首次连接的情况
                console.log('🟢 Firebase 首次连接成功');
                showToast('🟢 已连接到云端服务器', 2000);
                
                // 🔥 首次连接时立即同步
                setTimeout(() => {
                    const deviceStatus = detectDeviceStatus();
                    console.log('📱 首次连接设备状态:', deviceStatus);
                    
                    // 🔥 关键：根据设备状态决定同步策略
                    if (deviceStatus.isNewDevice || deviceStatus.totalScore === 0) {
                        console.log('📥 新设备或无数据，优先拉取云端数据...');
                    }
                    
                    performInitialSync();
                    setupPeriodicSync();
                    // 启用同步健康监控
                    setTimeout(monitorSyncHealth, 30000);
                    // 首次连接时立即同步实时状态
                    triggerRealTimePracticeStatusUpdate();
                }, 1000);
                
            } else if (!connected) {
                console.log('🔴 Firebase 连接已断开');
                // 记录断线次数并可能触发降级
                const st=window.__fbTransportState; if(st){
                  const now=Date.now();
                  if(now - st.lastDisconnectAt > 10*60*1000){ st.disconnectCount=0; }
                  st.lastDisconnectAt=now; st.disconnectCount++;
                  if(st.disconnectCount===3 && !st.forcedLongPolling){
                    console.warn('[net] 触发降级: forceLongPolling');
                    try{ window.firebase.database.INTERNAL.forceLongPolling=true; st.forcedLongPolling=true; }catch(e){console.warn('降级失败',e);} }
                }
                showToast('🔴 与云端服务器断开连接，使用本地模式', 3000);
                // 连接断开时保存当前状态
                persistAllData();
                flushPendingOperations(); // 尝试落盘待处理操作
            }
        }, (error) => {
            console.error('连接状态监听错误:', error);
            isOnline = false;
            updateConnectionStatus();
            showToast('⚠️ 连接监听出错，请检查网络', 3000);
        });
        
        createConnectionIndicator();
        setupDataListeners();
        registerDevice();

        // 启动网络诊断 (简化版：测量 fetch gstatic HEAD 耗时) & 输出结果
        runLightweightNetworkDiagnostics();
        // 周期 2 分钟重测一次（仅在未强制降级时）
        setInterval(()=>{ if(!window.__fbTransportState.forcedLongPolling) runLightweightNetworkDiagnostics(); }, 120000);
        
    } catch (error) {
        console.error('❌ Firebase 初始化失败:', error);
        showToast('❌ 云端同步不可用，使用本地模式', 5000);
        isOnline = false;
        updateConnectionStatus();
    }
}

// ===== 轻量网络诊断 =====
function runLightweightNetworkDiagnostics(){
  const target='https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js';
  const start=performance.now();
  fetch(target,{method:'HEAD',cache:'no-cache',mode:'no-cors'}).catch(()=>{}).finally(()=>{
    const dur=Math.round(performance.now()-start);
    let quality = dur<150?'good': dur<600?'moderate':'poor';
    console.log(`[net] 诊断 gstatic HEAD=${dur}ms quality=${quality}`);
    window.__lastNetDiag={dur,quality,ts:Date.now()};
  });
}

// ===== 离线登记操作队列 =====
const pendingOps=[]; // {type:'register'|'clear', roomName, student, ts, payload}
function enqueueOperation(op){
  op.ts=Date.now();
  pendingOps.push(op);
  try{ localStorage.setItem('pendingOps', JSON.stringify(pendingOps.slice(-200))); }catch(e){}
  console.warn('[offline-queue] 已缓存操作', op.type, op.roomName || op.student, '队列长度=', pendingOps.length);
}
function restorePendingOps(){
  try{ const raw=localStorage.getItem('pendingOps'); if(raw){ const arr=JSON.parse(raw); if(Array.isArray(arr)) {pendingOps.length=0; arr.forEach(o=>pendingOps.push(o)); if(arr.length) console.log('[offline-queue] 恢复待处理操作', arr.length);} } }catch(e){}
}
restorePendingOps();
function flushPendingOperations(){
  if(!isOnline || !database) return;
  if(!pendingOps.length) return;
  console.log('[offline-queue] 尝试回放操作 数量=', pendingOps.length);
  const copy=pendingOps.slice();
  pendingOps.length=0; // 乐观清空
  let success=0,failed=0; const remain=[];
  const doOne=(op)=>{
    if(op.type==='register'){
      return performRegisterRoom(op.roomName, op.student, {queued:true});
    }else if(op.type==='clear'){
      return performClearRoom(op.roomName,{queued:true});
    }
    return Promise.resolve();
  };
  (async()=>{
    for(const op of copy){
      try{ await doOne(op); success++; }catch(e){ failed++; remain.push(op); console.warn('[offline-queue] 回放失败将重试', op, e); }
    }
    if(remain.length){ pendingOps.push(...remain); }
    try{ localStorage.setItem('pendingOps', JSON.stringify(pendingOps.slice(-200))); }catch(e){}
    console.log(`[offline-queue] 回放完成 success=${success} failed=${failed} 剩余=${pendingOps.length}`);
  })();
}

// 在任何登记/清空入口处（示例函数占位，若已有则补充调用 enqueueOperation）
function performRegisterRoom(roomName, student, opts={}){
  // ...existing code... （此处假设原本有真正写入 Firebase 的逻辑）
  if(!isOnline){ enqueueOperation({type:'register',roomName,student}); return Promise.resolve('queued'); }
  // 真实写入逻辑待接入现有实现
  // placeholder: 返回 Promise
  return new Promise((res)=>{ res('ok'); });
}
function performClearRoom(roomName, opts={}){
  // ...existing code...
  if(!isOnline){ enqueueOperation({type:'clear',roomName}); return Promise.resolve('queued'); }
  return new Promise((res)=>{ res('ok'); });
}


// 🔥 新增：设备数据状态检测
let isNewDevice = false;
let hasValidLocalData = false;

function detectDeviceStatus() {
    // 检查是否有有效的本地数据
    const roomCount = Object.keys(roomDatabase).length;
    const studentCount = Object.values(studentDatabase).reduce((a,b)=>a+b.length,0);
    const hasRooms = rooms && rooms.length > 0;
    const hasTimeSlots = Object.keys(studentTimeSlots).length > 0;
    const hasLogs = practiceLogs && practiceLogs.length > 0;
    const hasQueues = queueList && (queueList.grand.length + queueList.upright.length + queueList.none.length) > 0;
    
    // 🔥 关键修改：更宽松的有效数据判断
    const coreDataScore = roomCount * 3 + studentCount * 2;
    const extendedDataScore = (hasTimeSlots ? 5 : 0) + (hasLogs ? 2 : 0) + (hasQueues ? 1 : 0);
    const totalScore = coreDataScore + extendedDataScore;
    
    // 🔥 关键修改：降低阈值，更容易触发云端拉取
    hasValidLocalData = totalScore > 0; // 从2降低到0，任何数据都算有效
    isNewDevice = totalScore === 0; // 完全没有数据才算新设备
    
    console.log('📱 设备状态检测:', {
        isNewDevice,
        hasValidLocalData,
        totalScore,
        roomCount,
        studentCount
    });
    
    return { isNewDevice, hasValidLocalData, totalScore };
}


// 设置连接监听
function setupConnectionMonitoring() {
    const connectedRef = database.ref('.info/connected');
    connectedRef.on('value', (snapshot) => {
        const connected = snapshot.val() === true;
        
        if (connected !== isOnline) {
            isOnline = connected;
            updateConnectionStatus();
            
            if (connected) {
                console.log('🟢 Firebase 连接已建立');
                showToast('🟢 已连接到云端服务器', 2000);
                
                // 重新连接后延迟同步
                setTimeout(() => {
                    performInitialSync();
                }, 1000);
            } else {
                console.log('🔴 Firebase 连接已断开');
                showToast('🔴 与云端服务器断开连接', 3000);
            }
        }
    });
}

// 🔥 新增：数据保护检查
function validateDataBeforeSync(data) {
    const checks = {
        hasRooms: data.rooms && Array.isArray(data.rooms) && data.rooms.length > 0,
        hasRoomDb: data.roomDatabase && Object.keys(data.roomDatabase).length > 0,
        hasStudents: data.studentDatabase && Object.keys(data.studentDatabase).length > 0,
        isValid: false
    };
    
    // 至少要有房间数据库或学生数据库
    checks.isValid = checks.hasRoomDb || checks.hasStudents;
    
    console.log('🔍 数据验证结果:', checks);
    return checks;
}

// 🔥 新增：危险操作确认
function confirmDataOverwrite() {
    return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:flex;align-items:center;justify-content:center;z-index:10001;';
        modal.innerHTML = `
            <div style="background:#fff;padding:30px;border-radius:16px;max-width:500px;width:90%;text-align:center;">
                <h3 style="color:#e74c3c;margin-bottom:20px;">⚠️ 数据同步确认</h3>
                <p style="margin-bottom:20px;line-height:1.5;">
                    检测到您的设备数据较少，云端可能有更完整的数据。<br>
                    是否要从云端获取最新数据？
                </p>
                <div style="display:flex;gap:15px;justify-content:center;">
                    <button onclick="resolveConfirm(true)" style="background:#27ae60;color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;">
                        从云端获取
                    </button>
                    <button onclick="resolveConfirm(false)" style="background:#95a5a6;color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;">
                        使用本地数据
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        window.resolveConfirm = (result) => {
            document.body.removeChild(modal);
            delete window.resolveConfirm;
            resolve(result);
        };
    });
}

// 执行初始同步
function performInitialSync() {
    if (!database || !isOnline) return;
    
    const deviceStatus = detectDeviceStatus();
    console.log('🔄 执行初始同步...', deviceStatus);
    
    // 🔥 关键修改：新设备或无数据设备立即拉取
    if (deviceStatus.isNewDevice || deviceStatus.totalScore === 0) {
        console.log('📥 新设备或无数据，立即拉取云端数据...');
        pullDataFromCloud().then(() => {
            console.log('✅ 云端数据拉取完成');
            // 🔥 新增：更新本地占用快照
            lastLocalSnapshotOccupancy = rooms.filter(r=>r.student).length;
            // 拉取完成后检查是否需要推送本地补充数据
            setTimeout(() => {
                const updatedStatus = detectDeviceStatus();
                if (updatedStatus.totalScore > 0) {
                    console.log('📤 推送本地数据到云端...');
                    pushDataToCloud();
                }
                // 🔥 新增：首帧完成标记
                initialSyncCompleted = true;
                initialSyncInProgress = false;
                console.log('🎯 初始同步完成 - 新设备分支');
            }, 2000);
        });
    } else {
        // 有数据的设备，先拉取再推送
        console.log('📥 现有设备，先拉取后推送...');
        setTimeout(() => {
            pullDataFromCloud().then(() => {
                // 🔥 新增：更新本地占用快照
                lastLocalSnapshotOccupancy = rooms.filter(r=>r.student).length;
                setTimeout(() => {
                    console.log('📤 推送最新状态到云端...');
                    pushDataToCloud();
                    // 🔥 新增：首帧完成标记
                    initialSyncCompleted = true;
                    initialSyncInProgress = false;
                    console.log('🎯 初始同步完成 - 现有设备分支');
                }, 1000);
            });
        }, 1000);
    }
}



// 🔥 修改：增强云端数据拉取逻辑
function pullDataFromCloud() {
    console.log('📥 开始从云端拉取数据...');
    
    // 🔥 新增：数据保护检查
    if (systemSettings.dataProtectionMode) {
        const localOccupancy = rooms.filter(r => r.student && r.registerTime);
        const recentWakeup = Date.now() - lastWakeupTime < 60000; // 1分钟内唤醒
        
        if (localOccupancy.length > 0 && recentWakeup) {
            console.log('🛡️ 数据保护模式：拒绝覆盖本地占用状态（刚唤醒）');
            console.log('本地占用:', localOccupancy.map(r => `${r.name}:${r.student}`));
            
            // 推送本地数据而不是拉取
            setTimeout(() => {
                pushDataToCloud();
            }, 1000);
            return Promise.resolve();
        }
    }
    return database.ref().once('value')
        .then((snapshot) => {
            const cloudData = snapshot.val();
            
            if (!cloudData) {
                console.log('☁️ 云端无数据，保持本地状态');
                return;
            }
            
            console.log('📥 收到云端数据:', Object.keys(cloudData));
            
            // 🔥 关键修改：新设备无条件接受云端数据
            const deviceStatus = detectDeviceStatus();
            const cloudTimestamp = cloudData[FIREBASE_PATHS.LAST_UPDATE]?.timestamp || 0;
            const localTimestamp = lastSyncTime || 0;
            
            const shouldApplyCloudData = deviceStatus.isNewDevice || 
                                       cloudTimestamp > localTimestamp || 
                                       !deviceStatus.hasValidLocalData;
            
            if (shouldApplyCloudData) {
                console.log('📥 应用云端数据，设备状态:', deviceStatus, '云端时间戳:', new Date(cloudTimestamp).toLocaleString());
                applyCloudDataSafely(cloudData);
                
                // 🔥 新增：应用完成后立即通知其他设备
                setTimeout(() => {
                    notifyOtherDevicesOfSync();
                }, 1000);
            } else {
                console.log('📥 本地数据较新或设备状态不适合应用云端数据');
            }
            
            // 🔥 新增：记录远端占用数
            if(cloudData && Array.isArray(cloudData[FIREBASE_PATHS.ROOMS])){
                const occ = cloudData[FIREBASE_PATHS.ROOMS].filter(r=>r && r.student).length;
                lastRemoteSnapshotOccupancy = occ;
                console.log('☁️ 云端占用数缓存为', occ);
            }
            
        })
        .catch((error) => {
            console.error('❌ 拉取云端数据失败:', error);
            showToast('❌ 无法获取云端数据，使用本地模式', 3000);
        });
}


function safePushAllRooms(reason='manual'){
    if(!canSyncNow('bulk_push',{reason})) return;
    pushDataToCloud();
}


// 🔥 新增：安全应用云端数据
function applyCloudDataSafely(cloudData) {
    // 🔥 新增：本地数据为空时的特殊处理
    const localDataScore = Object.keys(roomDatabase).length + 
                          Object.values(studentDatabase).reduce((a,b)=>a+b.length,0);
    
    if (localDataScore === 0) {
        console.log('📥 本地数据为空，直接应用云端数据...');
        // 本地数据为空时，直接应用云端数据，跳过复杂的保护逻辑
        applyCloudDataDirectly(cloudData);
        return;
    }
    
    // 🔥 新增：数据保护检查（原有逻辑保持不变）
    const localOccupiedRooms = rooms.filter(r => r.student && r.registerTime);
    const cloudRooms = cloudData[FIREBASE_PATHS.ROOMS] || [];
    const cloudOccupiedRooms = cloudRooms.filter(r => r && r.student && r.registerTime);
    
    // 如果启用数据保护模式且本地有占用状态而云端没有，拒绝应用
    if (systemSettings.dataProtectionMode && localOccupiedRooms.length > 0 && cloudOccupiedRooms.length === 0) {
        console.warn('🛡️ 数据保护模式：拒绝应用空的云端数据，本地有占用状态需要保护');
        console.log('本地占用房间:', localOccupiedRooms.map(r => `${r.name}:${r.student}`));
        
        // 反向推送本地数据到云端
        setTimeout(() => {
            console.log('🔄 推送本地占用状态到云端...');
            pushDataToCloud();
        }, 1000);
        
        showToast('🛡️ 数据保护：已保护本地占用状态', 3000);
        return;
    }
    
    // 🔥 新增：时间有效性检查
    const now = Date.now();
    const maxAge = 10 * 60 * 1000; // 10分钟
    
    if (cloudOccupiedRooms.length > 0) {
        const hasValidData = cloudOccupiedRooms.some(r => {
            const age = now - (r.registerTime || 0);
            return age >= 0 && age <= maxAge;
        });
        
        if (!hasValidData) {
            console.warn('🛡️ 云端数据时效性检查失败，保护本地状态');
            return;
        }
    }
    
    // 应用云端数据的原有逻辑...
    applyCloudDataDirectly(cloudData);
}
function forceCloudSync() {
    if (!database || !isOnline) {
        showToast('❌ 未连接到云端服务器', 3000);
        return;
    }
    
    if (!confirm('确定要强制从云端同步数据吗？这将覆盖本地数据。')) {
        return;
    }
    
    console.log('🔄 强制从云端同步数据...');
    
    // 临时禁用数据保护
    const originalProtectionMode = systemSettings.dataProtectionMode;
    systemSettings.dataProtectionMode = false;
    
    pullDataFromCloud().then(() => {
        // 恢复数据保护设置
        systemSettings.dataProtectionMode = originalProtectionMode;
        showToast('✅ 强制同步完成', 3000);
    }).catch(error => {
        systemSettings.dataProtectionMode = originalProtectionMode;
        showToast('❌ 强制同步失败: ' + error.message, 5000);
    });
}

// 添加到管理按钮中
window.forceCloudSync = forceCloudSync;

// 🔥 新增：直接应用云端数据（用于本地数据为空的情况）
function applyCloudDataDirectly(cloudData) {
    let hasUpdates = false;
    
    try {
        // 禁用同步避免循环
        syncEnabled = false;
        
        // 应用琴房数据库
        if (cloudData[FIREBASE_PATHS.ROOM_DB]) {
            roomDatabase = { ...cloudData[FIREBASE_PATHS.ROOM_DB] };
            rebuildRoomsFromDb();
            hasUpdates = true;
            console.log('✅ 应用云端琴房数据库');
        }
        
        // 应用学生数据库
        if (cloudData[FIREBASE_PATHS.STUDENT_DB]) {
            studentDatabase = { ...cloudData[FIREBASE_PATHS.STUDENT_DB] };
            hasUpdates = true;
            console.log('✅ 应用云端学生数据库');
        }
        
        // 应用学生时间段
        if (cloudData[FIREBASE_PATHS.STUDENT_SLOTS]) {
            studentTimeSlots = { ...cloudData[FIREBASE_PATHS.STUDENT_SLOTS] };
            hasUpdates = true;
            console.log('✅ 应用云端学生时间段');
        }
        
        // 应用房间状态（按名称匹配，禁止使用数组下标）
        if (cloudData[FIREBASE_PATHS.ROOMS] && Array.isArray(cloudData[FIREBASE_PATHS.ROOMS])) {
            const now = Date.now();
            const PROTECT_MS = 30000; // 登记后30秒内避免被远端"空写"覆盖

            // 先做一张 name -> remoteRoom 的索引表
            const remoteMap = new Map();
            cloudData[FIREBASE_PATHS.ROOMS]
                .filter(r => r && r.name)
                .forEach(r => remoteMap.set(r.name, r));

            let changedRooms = [];
            
            rooms.forEach(localRoom => {
                const remote = remoteMap.get(localRoom.name);
                if(!remote) return; // 云端没有该房间记录，忽略
                
        // 若本地刚清空且处于保护期内，且远端仍有旧学生 → 拒绝回填
        const CLEAR_PROTECT_MS = 30000;
        if(localRoom.student==null && localRoom.clearTime){
          const sinceClear = now - localRoom.clearTime;
          if(remote.student && sinceClear < CLEAR_PROTECT_MS){
            console.warn('[房间保护-清空] 拒绝远端回填', localRoom.name, 'sinceClear(ms)=', sinceClear);
            return;
          }
        }

        // 远端有学生
                if(remote.student){
                    // 如果本地没有学生 → 直接套用
                    if(!localRoom.student){
                        localRoom.student = remote.student;
                        localRoom.registerTime = remote.registerTime || null;
                        changedRooms.push({room: localRoom.name, action: 'apply_remote_student'});
                        return;
                    }
                    
                    // 如果本地也有学生但不同 → 用时间戳决胜
                    const localTime = localRoom.registerTime || 0;
                    const remoteTime = remote.registerTime || 0;
                    if(remote.student !== localRoom.student){
                        if(remoteTime > localTime){
                            changedRooms.push({room: localRoom.name, action:'replace_local_with_remote', from: localRoom.student, to: remote.student});
                            localRoom.student = remote.student;
                            localRoom.registerTime = remoteTime;
                        }else{
                            // 本地更新更新 → 保留本地，忽略远端
                            // 可在此写日志
                        }
                    }else{
                        // 同一个学生 → 如果远端时间更新、更大则同步 registerTime
                        if(remoteTime > (localRoom.registerTime || 0)){
                            localRoom.registerTime = remoteTime;
                        }
                    }
                }else{
                    // 远端为空，本地有学生 → 保护期判断
                    if(localRoom.student){
                        const age = now - (localRoom.registerTime || 0);
                        if(age < PROTECT_MS){
                            // 保护期内拒绝远端清空
                            console.warn('[房间保护] 拒绝远端清空(保护期内)', localRoom.name, localRoom.student, 'age(ms)=', age);
                            return;
                        }
                        // 否则接受清空
                        changedRooms.push({room: localRoom.name, action:'remote_clear', student: localRoom.student});
                        localRoom.student = null;
                        localRoom.registerTime = null;
                    }
                }
            });

            if(changedRooms.length){
                console.log('✅ 按名称安全应用云端房间状态，变更列表: ', changedRooms);
                hasUpdates = true;
            }else{
                console.log('ℹ️ 云端房间状态无实质变化（名称匹配检查）');
            }
        }

        
        // 应用排队信息
        if (cloudData[FIREBASE_PATHS.QUEUE]) {
            queueList = {
                grand: cloudData[FIREBASE_PATHS.QUEUE].grand || [],
                upright: cloudData[FIREBASE_PATHS.QUEUE].upright || [],
                none: cloudData[FIREBASE_PATHS.QUEUE].none || []
            };
            hasUpdates = true;
            console.log('✅ 应用云端排队信息');
        }
        
        // 应用系统设置
        if (cloudData[FIREBASE_PATHS.SYSTEM_SETTINGS]) {
            systemSettings = { 
                ...DEFAULT_SETTINGS, 
                ...cloudData[FIREBASE_PATHS.SYSTEM_SETTINGS] 
            };
            hasUpdates = true;
            console.log('✅ 应用云端系统设置');
        }
        
        // 应用异常提醒数据
        if (cloudData[FIREBASE_PATHS.OVERRUN_DATA]) {
            handleRemoteOverrunDataUpdate(cloudData[FIREBASE_PATHS.OVERRUN_DATA]);
            hasUpdates = true;
            console.log('✅ 应用云端异常提醒数据');
        }
        
        if (hasUpdates) {
            // 持久化到本地
            persistAllData();
            
            // 刷新UI
            needsFullUpdate = true;
            updateRooms();
            updateQueueDisplay();
            updateDemandButtonsStatus();
            
            showToast('✅ 已从云端同步最新数据', 3000);
            console.log('🎉 云端数据同步完成');
        }
        
    } catch (error) {
        console.error('❌ 应用云端数据失败:', error);
        showToast('❌ 数据同步异常，请刷新页面', 5000);
    } finally {
        // 重新启用同步
        setTimeout(() => {
            syncEnabled = true;
        }, 2000);
    }
}

// 🔥 新增：通知其他设备同步完成
function notifyOtherDevicesOfSync() {
    if (!database || !isOnline) return;
    
    const notification = {
        deviceId: deviceId,
        action: 'sync_completed',
        timestamp: Date.now(),
        message: '设备同步完成'
    };
    
    database.ref('sync_notifications').push(notification)
        .then(() => {
            console.log('📢 已通知其他设备同步完成');
        })
        .catch(error => {
            console.warn('⚠️ 通知发送失败:', error);
        });
}

// 🔥 新增：监听其他设备的同步通知
function listenForSyncNotifications() {
    if (!database) return;
    
    database.ref('sync_notifications').limitToLast(10).on('child_added', (snapshot) => {
        const notification = snapshot.val();
        
        // 忽略自己的通知
        if (notification.deviceId === deviceId) return;
        
        // 如果是其他设备的同步完成通知，延迟拉取最新数据
        if (notification.action === 'sync_completed') {
            console.log('📢 收到其他设备同步通知:', notification);
            
            setTimeout(() => {
                console.log('🔄 响应其他设备同步，拉取最新数据...');
                pullDataFromCloud();
            }, 2000);
        }
    });
}


// 🔥 新增：谨慎应用房间状态
function applyRoomStatesCarefully(cloudRooms) {
    const now = Date.now();
    const maxAge = 10 * 60 * 1000; // 10分钟
    
    cloudRooms.forEach((cloudRoom, index) => {
        const localRoom = rooms.find(r => r.name === cloudRoom.name);
        if (!localRoom) return;
        
        // 🔥 关键：检查数据时效性
        if (cloudRoom.student && cloudRoom.registerTime) {
            const age = now - cloudRoom.registerTime;
            
            if (age > maxAge) {
                console.warn(`⚠️ 跳过过期的房间状态: ${cloudRoom.name}, 年龄: ${Math.round(age/60000)}分钟`);
                return;
            }
            
            // 检查合理性
            if (age < 0) {
                console.warn(`⚠️ 跳过未来时间的房间状态: ${cloudRoom.name}`);
                return;
            }
        }
        
        // 应用状态
        localRoom.student = cloudRoom.student || null;
        localRoom.registerTime = cloudRoom.registerTime || null;
    });
}

// 🔥 新增：推送本地数据到云端
function pushDataToCloud() {
    if(!canSyncNow('direct_push',{})) return;
    const now = Date.now();
    lastOverrunVersion = now;
    
    const updates = {};
    
    // 按名称稳定排序，避免不同设备写入顺序不同导致潜在重放风险
    const sortedRooms = [...rooms]
        .sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN',{numeric:true}))
        .map(r => ({
            ...r,
            lastModified: Date.now()  // 简单的统一时间戳；后续可改为逐房间变动时间
        }));
    updates[FIREBASE_PATHS.ROOMS] = cleanDataForFirebase(sortedRooms);
    
    updates[FIREBASE_PATHS.ROOM_DB] = cleanDataForFirebase(roomDatabase);
    updates[FIREBASE_PATHS.STUDENT_DB] = cleanDataForFirebase(studentDatabase);
    updates[FIREBASE_PATHS.STUDENT_SLOTS] = cleanDataForFirebase(studentTimeSlots);
    updates[FIREBASE_PATHS.QUEUE] = cleanDataForFirebase(queueList);
    updates[FIREBASE_PATHS.SYSTEM_SETTINGS] = cleanDataForFirebase(systemSettings);
    
    // 异常提醒数据
    updates[FIREBASE_PATHS.OVERRUN_DATA] = {
        version: now,
        reminders: cleanDataForFirebase(practiceOverrunReminders),
        ignored: [...overrunIgnoredKeys],
        stats: cleanDataForFirebase(overrunStats),
        updatedAt: now,
        action: 'push_local_data'
    };
    
    updates[FIREBASE_PATHS.LAST_UPDATE] = {
        timestamp: now,
        deviceId,
        action: 'push_local_data'
    };
    
    database.ref().update(updates)
        .then(() => {
            console.log('✅ 本地数据推送完成');
            lastSyncTime = Date.now();
            showToast('✅ 本地数据已同步到云端', 2000);
        })
        .catch(err => {
            console.error('❌ 推送本地数据失败:', err);
            showToast('❌ 数据同步失败', 3000);
        });
}


// 🔥 修改：移除定期同步，改为实时监听
function setupPeriodicSync() {
    console.log('✅ 使用实时监听模式，无需定期同步');
    // 不再设置定期检查，完全依赖 Firebase 实时监听
}



// 🔥 修复：统一的 syncToFirebase 函数（防抖版）
function syncToFirebase(action = 'update', metadata = {}) {
    if (!database || !isOnline || !syncEnabled) {
        console.log('⏸️ 跳过同步：', { database: !!database, isOnline, syncEnabled });
        return;
    }
    
    // 🔥 数据保护检查
    const dataCheck = validateDataBeforeSync({
        rooms,
        roomDatabase,
        studentDatabase
    });
    
    if (!dataCheck.isValid && action !== 'force_sync') {
        console.warn('⚠️ 数据不完整，跳过同步:', dataCheck);
        return;
    }
    
    // 🔥 防抖处理：短时间内多次调用只执行最后一次
    if (syncDebounceTimeout) {
        clearTimeout(syncDebounceTimeout);
    }
    
    syncDebounceTimeout = setTimeout(() => {
        performActualSync(action, metadata);
        syncDebounceTimeout = null;
    }, SYNC_DEBOUNCE_MS);
}
// ==== 新增：全局安全前置检查 BEGIN ====
function canSyncNow(action, metadata){
    // 1. 初始同步期间禁止
    if(initialSyncInProgress){
        console.log('⏸️ 同步被阻止：initialSyncInProgress=true');
        return false;
    }
    // 2. 尚未完成首帧拉取也禁止（兜底）
    if(!initialSyncCompleted){
        console.log('⏸️ 同步被阻止：initialSyncCompleted=false');
        return false;
    }
    // 3. 空集覆盖保护：本地无占用 + 云端之前记录有占用
  const localOcc = rooms.filter(r=>r.student).length;
  if(action!=='single_clear' && localOcc===0 && lastRemoteSnapshotOccupancy>0){
    console.warn('🛡️ 阻止空集合覆盖：本地0占用，云端记录', lastRemoteSnapshotOccupancy);
    return false;
  }
    // 4. 大幅下降保护：一次性减少 >80% 且无用户近期操作
    const drop = lastLocalSnapshotOccupancy>0 ? (lastLocalSnapshotOccupancy - localOcc)/lastLocalSnapshotOccupancy : 0;
  if(action!=='single_clear' && drop > 0.8){
        const now = Date.now();
        if(now - lastUserDestructiveActionTs > DESTRUCTIVE_ACTION_WINDOW){
            console.warn('🛡️ 阻止疑似异常清空：下降比例', (drop*100).toFixed(1),'%');
            return false;
        }
    }
    return true;
}
// ==== 新增：全局安全前置检查 END ====

// 🔥 新增：执行实际同步的函数
function performActualSync(action, metadata) {
    if(!canSyncNow(action, metadata)) return;
    const now = Date.now();
    
    // 🔥 关键改进：计算数据指纹，检测实际变化
    const cleanRooms = cleanDataForFirebase(rooms).map(room => ({
        ...room,
        student: room.student || null,
  registerTime: room.registerTime || null,
  clearTime: room.clearTime || null
    }));
    
    const cleanQueue = cleanDataForFirebase({
        grand: queueList.grand || [],
        upright: queueList.upright || [],
        none: queueList.none || []
    });
    
    // 生成数据指纹（排除时间戳）
    const currentFingerprint = JSON.stringify({
        rooms: cleanRooms,
        queue: cleanQueue
    });
    
    // 🔥 核心：如果数据没有变化，跳过同步
    if (lastDataFingerprint === currentFingerprint) {
        console.log('⏸️ 跳过同步：数据无变化');
        return;
    }
    
    console.log('🔄 检测到数据变化，同步到 Firebase...', action);
    
    const updates = {};
    updates[FIREBASE_PATHS.ROOMS] = cleanRooms;
    updates[FIREBASE_PATHS.QUEUE] = cleanQueue;
    updates[FIREBASE_PATHS.LAST_UPDATE] = {
        timestamp: now,
        deviceId: deviceId,
        action: action,
        metadata: metadata,
        changeHash: generateChangeHash(currentFingerprint) // 🔥 新增：变化哈希
    };
    
    database.ref().update(updates)
        .then(() => {
            console.log('✅ 数据同步成功 -', action);
            lastSyncTime = now;
            // 🔥 更新指纹缓存
            lastDataFingerprint = currentFingerprint;
        })
        .catch((error) => {
            console.error('❌ 数据同步失败:', error);
            // 🔥 同步失败时不更新指纹，确保下次重试
        });
}

// 🔥 新增：生成变化哈希（用于更精确的变化检测）
function generateChangeHash(fingerprint) {
    // 简单哈希函数
    let hash = 0;
    for (let i = 0; i < fingerprint.length; i++) {
        const char = fingerprint.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // 转换为32位整数
    }
    return hash.toString(36);
}


function handleRemoteRoomsUpdate(remoteRooms) {
    if (!Array.isArray(remoteRooms) || !syncEnabled) return;
  // 自愈增强：若有操作锁，进入排队队列而不是无限递归延迟
  if(operationLocks.size > 0){
    window.__pendingRemoteRooms = remoteRooms; // 只保留最新快照
    window.__pendingRemoteRoomsFirstTs = window.__pendingRemoteRoomsFirstTs || Date.now();
    const waited = Date.now() - window.__pendingRemoteRoomsFirstTs;
    const attempts = (window.__pendingRemoteRoomsAttempts = (window.__pendingRemoteRoomsAttempts||0)+1);
    if(waited > 10000 || attempts > 8){
      console.warn('[remoteQueue] 超过等待阈值，强制应用远程更新 (waited='+waited+'ms attempts='+attempts+')');
    } else {
      if(!window.__remoteQueueNoticeShown){
        console.log('⚠️ 有正在进行的操作，排队远程更新 (attempt '+attempts+')');
        window.__remoteQueueNoticeShown = true;
      }
      // 等待锁释放时由锁释放逻辑主动再调用
      return;
    }
  } else {
    // 清理排队状态
    window.__pendingRemoteRooms = null; window.__pendingRemoteRoomsAttempts=0; window.__pendingRemoteRoomsFirstTs=null; window.__remoteQueueNoticeShown=false;
  }
    
    // 🔥 新增：检测远程重置操作
    const remoteOccupiedCount = remoteRooms.filter(r => r && r.student).length;
    const localOccupiedCount = rooms.filter(r => r.student).length;
    
    // 如果远程数据全部为空且本地有占用，可能是远程重置
    if (remoteOccupiedCount === 0 && localOccupiedCount > 0) {
        // 检查是否在保护期内（刚登记的房间不被远程清空覆盖）
        const now = Date.now();
        const recentRegistrations = rooms.filter(r => 
            r.student && r.registerTime && (now - r.registerTime) < 30000 // 30秒内
        );
        
        if (recentRegistrations.length > 0) {
            console.log('🛡️ 检测到远程重置，但本地有近期登记，保护本地状态');
            // 推送本地状态到云端而不是接受远程清空
            setTimeout(() => {
                pushDataToCloud();
            }, 1000);
            return;
        } else {
            console.log('🔄 检测到远程重置操作，同步本地状态');
            // 接受远程重置
            rooms.forEach(r => {
                if (r.student) {
                    addPracticeLog(r.student, r.name, r.registerTime, now, '远程重置同步');
                    r.student = null;
                    r.registerTime = null;
                }
            });
            
            persistRooms();
            needsFullUpdate = true;
            updateRooms();
            showToast('🔄 已同步远程重置操作', 3000);
            return;
        }
    }
    
    // 🔥 新增：数据完整性检查
    if (isNewDevice && remoteRooms.length === 0) {
        console.log('⚠️ 新设备收到空房间数据，忽略更新');
        return;
    }
    
    // 🔥 新增：检查是否有正在进行的操作
    if (operationLocks.size > 0) {
        console.log('⚠️ 有正在进行的操作，延迟处理远程更新');
        setTimeout(() => handleRemoteRoomsUpdate(remoteRooms), 1000);
        return;
    }
    
    console.log('📥 收到远程房间数据更新');
    
    let hasChanges = false;
    const changes = [];
    const now = Date.now();
    const conflicts = [];
    
    remoteRooms.forEach((remoteRoom, index) => {
        const localRoom = rooms.find(r => r.name === remoteRoom.name);
        if (!localRoom) return;
        
        const oldStudent = localRoom.student;
        const newStudent = remoteRoom.student;
        const oldTime = localRoom.registerTime;
        const newTime = remoteRoom.registerTime;
        
        // 🔥 新增：保护最近的双击清空操作，防止被远程更新覆盖
        const recentClearTime = window.lastClearOperations?.get(remoteRoom.name);
        if (recentClearTime && (now - recentClearTime) < 2000) { // 2秒内的清空操作保护
            if (newStudent && !oldStudent) {
                console.log(`🛡️ 保护最近清空操作：忽略 ${remoteRoom.name} 的远程学生登记 (${newStudent})`);
                return; // 跳过这个房间的更新
            }
        }
        
        // 🔥 新增：清理过期的清空操作记录（避免内存泄漏）
        if (window.lastClearOperations) {
            for (const [roomName, clearTime] of window.lastClearOperations.entries()) {
                if (now - clearTime > 5000) { // 5秒后清理
                    window.lastClearOperations.delete(roomName);
                }
            }
        }
        
        // 🔥 增强冲突检测逻辑
        if (oldStudent && newStudent && oldStudent !== newStudent) {
            const timeDiff = Math.abs((newTime || 0) - (oldTime || 0));
            
            // 🔥 关键：如果时间差很小，说明是同时操作冲突
            if (timeDiff < 3000) { // 3秒内的操作认为是冲突
                conflicts.push({
                    room: remoteRoom.name,
                    local: { student: oldStudent, time: oldTime },
                    remote: { student: newStudent, time: newTime },
                    timeDiff: timeDiff
                });
                
                // 🔥 冲突解决：使用时间戳较新的
                if ((newTime || 0) > (oldTime || 0)) {
                    changes.push(`🔄 冲突解决：${remoteRoom.name} 由 ${oldStudent} 改为 ${newStudent}`);
                    localRoom.student = newStudent;
                    localRoom.registerTime = newTime;
                    hasChanges = true;
                    
                    // 记录冲突解决日志
                    addPracticeLog(oldStudent, remoteRoom.name, oldTime, now, `冲突解决被替换(远程优先,时差${timeDiff}ms)`);
                } else {
                    console.log(`⚠️ 忽略较旧的远程更新: ${remoteRoom.name}, 时差: ${timeDiff}ms`);
                    return;
                }
            } else {
                // 时间差较大，正常处理
                if ((newTime || 0) > (oldTime || 0)) {
                    changes.push(`🔄 正常更新：${remoteRoom.name} 由 ${oldStudent} 改为 ${newStudent}`);
                    localRoom.student = newStudent;
                    localRoom.registerTime = newTime;
                    hasChanges = true;
                    addPracticeLog(oldStudent, remoteRoom.name, oldTime, now, '远程更新替换');
                }
            }
        } else {
            // 正常的变化检测
            const studentChanged = oldStudent !== newStudent;
            const timeChanged = oldTime !== newTime;
            
            if (studentChanged || timeChanged) {
                const timeIsValid = !newTime || (newTime > 0 && newTime <= now + 60000);
                
                if (!timeIsValid && newStudent) {
                    console.warn('⚠️ 检测到无效时间戳，跳过此次更新:', {
                        room: remoteRoom.name,
                        student: newStudent,
                        time: newTime
                    });
                    return;
                }
                
                localRoom.student = newStudent;
                localRoom.registerTime = newTime;
                hasChanges = true;
                
                if (newStudent && !oldStudent) {
                    changes.push(`${newStudent} 登记了 ${remoteRoom.name}`);
                } else if (!newStudent && oldStudent) {
                    changes.push(`${oldStudent} 离开了 ${remoteRoom.name}`);
                } else if (newStudent && oldStudent && newStudent !== oldStudent) {
                    changes.push(`${remoteRoom.name}: ${oldStudent} → ${newStudent}`);
                }
            }
        }
    });
    
    if (hasChanges) {
        console.log('🔄 应用远程房间变化:', changes);
        
        if (conflicts.length > 0) {
            console.warn('⚠️ 检测到分配冲突:', conflicts);
            showToast(`⚠️ 检测到 ${conflicts.length} 个分配冲突，已自动解决`, 4000);
        }
        
        // 🔥 增强：使用防抖更新，避免频繁刷新
        clearTimeout(window.remoteUpdateTimeout);
        window.remoteUpdateTimeout = setTimeout(() => {
            syncEnabled = false;
            
            persistRooms();
            needsFullUpdate = true;
            updateRooms();
            
            // 刷新相关界面
            const overtimeModal = document.getElementById('overtimeModal');
            if (overtimeModal && overtimeModal.style.display === 'block') {
                renderOvertimeList(true);
            }
            
            if (changes.length > 0) {
                showToast('🔄 ' + changes.slice(0, 3).join('; ') + (changes.length > 3 ? '...' : ''), 4000);
            }
            
            setTimeout(() => {
                syncEnabled = true;
            }, 1500); // 增加禁用时间
        }, 200); // 200ms 防抖
    }
}


// 处理远程排队数据更新
function handleRemoteQueueUpdate(remoteQueue) {
    if (!remoteQueue || typeof remoteQueue !== 'object' || !syncEnabled) return;
    
    console.log('📥 收到远程排队数据更新');
    
    let hasChanges = false;
    const changes = [];
    
    ['grand', 'upright', 'none'].forEach(type => {
        const remoteList = remoteQueue[type] || [];
        const localList = queueList[type] || [];
        
        if (JSON.stringify(remoteList) !== JSON.stringify(localList)) {
            const typeName = type === 'grand' ? '三角' : type === 'upright' ? '立式' : '普通';
            changes.push(`${typeName}排队: ${localList.length} → ${remoteList.length}人`);
            
            queueList[type] = [...remoteList];
            hasChanges = true;
        }
    });
    
    if (hasChanges) {
        console.log('🔄 应用远程排队变化:', changes);
        
        syncEnabled = false;
        persistQueues();
        updateQueueDisplay();
        
        if (changes.length > 0) {
            showToast('🔄 排队更新: ' + changes.join('; '), 3000);
        }
        
        setTimeout(() => {
            syncEnabled = true;
        }, 1000);
    }
}

// 处理远程学生数据库更新
function handleRemoteStudentDbUpdate(remoteStudentDb) {
    if (!remoteStudentDb || typeof remoteStudentDb !== 'object' || !syncEnabled) return;
    
    if (JSON.stringify(studentDatabase) !== JSON.stringify(remoteStudentDb)) {
        console.log('📥 收到远程学生数据库更新');
        
        syncEnabled = false;
        studentDatabase = { ...remoteStudentDb };
        persistStudents();
        
        // 刷新相关UI
        if ($('studentDatabaseModal').style.display === 'block') {
            renderStudentDatabaseList();
        }
        
        showToast('🔄 学生数据库已同步', 2000);
        
        setTimeout(() => {
            syncEnabled = true;
        }, 1000);
    }
}
// 🔥 新增：处理远程请假数据更新
function handleRemoteExcuseUpdate(excuseData, action) {
    if (!excuseData || typeof excuseData !== 'object' || !syncEnabled) return;
    
    console.log('📥 收到远程请假数据更新:', excuseData);
    
    const studentName = excuseData.studentName;
    const isCancel = excuseData.action === 'cancel_excuse';
    const isAutoRecover = excuseData.action === 'auto_recover_expired_excuses';
    
    // 🔥 新增：处理自动恢复记录
    if (isAutoRecover) {
        // 触发本地的过期检查
        checkExpiredExcuses();
        return;
    }
    
    // 查找对应的考勤记录
    const targets = [...(attendanceData.students || []), ...(attendanceData.endedSlots || [])]
        .filter(s => s.name === studentName);
    
    if (!targets.length) {
        console.log('⚠️ 未找到对应的考勤记录:', studentName);
        return;
    }
    
    let hasChanges = false;
    
    targets.forEach(stu => {
        if (isCancel) {
            // 取消请假：重新计算状态
            if (stu.finalAttendanceStatus === 'excused') {
                const practicedSec = getStudentPracticeTimeInSlot(stu.name, stu);
                const realtimeStatus = getStudentAttendanceStatus(stu.name);
                const calc = calculateAttendanceStatus(stu.name, stu, realtimeStatus, practicedSec);
                Object.assign(stu, calc, {
                    practicedSec,
                    practicedText: fmtPracticeSec(practicedSec),
                    excuseEndDate: null // 🔥 清除请假结束日期
                });
                hasChanges = true;
            }
        } else {
            // 设置请假
            if (stu.finalAttendanceStatus !== 'excused') {
                // 🔥 新增：处理请假有效期
                const statusText = excuseData.endDate 
                    ? `已请假：${excuseData.reason}（${excuseData.durationText || '有期限'}）`
                    : `已请假：${excuseData.reason}（仅本次）`;
                
                stu.finalAttendanceStatus = 'excused';
                stu.finalStatusText = statusText;
                stu.excuseEndDate = excuseData.endDate; // 🔥 新增：保存请假结束日期
                hasChanges = true;
            }
        }
    });
    
    if (hasChanges) {
        syncEnabled = false;
        
        // 刷新UI
        if (isAttendanceModalOpen) {
            renderAttendanceList(false);
        }
        updateAttendanceBadge();
        
        const action = isCancel ? '取消请假' : '请假';
        showToast(`🔄 ${studentName} ${action}状态已同步`, 2000);
        
        setTimeout(() => {
            syncEnabled = true;
        }, 1000);
    }
}

// 修改现有的 handleRemoteRoomDbUpdate 函数
function handleRemoteRoomDbUpdate(remoteRoomDb) {
    if (!remoteRoomDb || typeof remoteRoomDb !== 'object' || !syncEnabled) return;
    
    // 🔥 关键修复：检查是否有房间被删除
    const localRoomNames = new Set(Object.keys(roomDatabase));
    const remoteRoomNames = new Set(Object.keys(remoteRoomDb));
    
    // 找出被删除的房间
    const deletedRooms = [];
    localRoomNames.forEach(name => {
        if (!remoteRoomNames.has(name)) {
            deletedRooms.push(name);
        }
    });
    
    // 找出新增或更新的房间
    const hasChanges = JSON.stringify(roomDatabase) !== JSON.stringify(remoteRoomDb);
    
    if (hasChanges || deletedRooms.length > 0) {
        console.log('📥 收到远程房间数据库更新');
        
        if (deletedRooms.length > 0) {
            console.log('🗑️ 检测到远程删除的房间:', deletedRooms);
            
            // 处理被删除房间的占用状态
            deletedRooms.forEach(roomName => {
                const room = rooms.find(r => r.name === roomName);
                if (room && room.student) {
                    console.log(`📝 记录被删除房间的占用日志: ${roomName} - ${room.student}`);
                    addPracticeLog(
                        room.student,
                        room.name,
                        room.registerTime,
                        Date.now(),
                        '房间被远程删除'
                    );
                }
            });
        }
        
        syncEnabled = false;
        roomDatabase = { ...remoteRoomDb };
        persistRoomDb();
        
        // 🔥 关键：使用修复后的同步函数，会正确处理删除
        roomDbSyncRoomsFromDatabase();
        
        // 刷新房间数据库界面（如果打开）
        if ($('roomDatabaseModal').style.display === 'block') {
            roomDbRenderList();
        }
        
        const changeMsg = deletedRooms.length > 0 
            ? `房间数据库已同步（删除${deletedRooms.length}间）`
            : '房间数据库已同步';
            
        showToast('🔄 ' + changeMsg, 2000);
        
        setTimeout(() => {
            syncEnabled = true;
        }, 1000);
    }
}
// 🔥 新增：专门处理房间删除的同步函数
function syncRoomDeletion(roomName, wasOccupied = false) {
    if (!syncEnabled || !isOnline || !database) return;
    
    console.log(`🔄 同步房间删除到云端: ${roomName}`);
    
    const updates = {};
    
    // 更新房间数据库
    updates[FIREBASE_PATHS.ROOM_DB] = roomDatabase;
    
    // 更新运行时房间数组
    const cleanRooms = rooms.map(r => ({
        ...r,
        student: r.student || null,
        registerTime: r.registerTime || null
    }));
    updates[FIREBASE_PATHS.ROOMS] = cleanRooms;
    
    // 添加删除操作记录
    updates[FIREBASE_PATHS.LAST_UPDATE] = {
        timestamp: Date.now(),
        deviceId: deviceId,
        action: 'room_delete',
        roomName: roomName,
        wasOccupied: wasOccupied
    };
    
    database.ref().update(updates)
        .then(() => {
            console.log('✅ 房间删除同步成功');
            showToast('✅ 房间删除已同步到所有设备', 2000);
        })
        .catch(error => {
            console.error('❌ 房间删除同步失败:', error);
            showToast('❌ 房间删除同步失败', 3000);
        });
}

// 🔥 新增：处理远程学生时间段更新
function handleRemoteStudentSlotsUpdate(remoteSlots) {
    if (!remoteSlots || typeof remoteSlots !== 'object' || !syncEnabled) return;
    
    if (JSON.stringify(studentTimeSlots) !== JSON.stringify(remoteSlots)) {
        console.log('📥 收到远程学生时间段更新');
        
        syncEnabled = false;
        studentTimeSlots = { ...remoteSlots };
        persistStudentSlots();
        
        // 刷新相关UI
        if ($('timeSlotModal').style.display === 'block') {
            displayCurrentTimeSlots();
            displayWeeklySummary();
        }
        if ($('studentDatabaseModal').style.display === 'block') {
            renderStudentDatabaseList();
        }
        if ($('attendanceModal').style.display === 'block') {
            renderAttendanceList(true);
        }
        
        showToast('🔄 学生时间段已同步', 2000);
        
        setTimeout(() => {
            syncEnabled = true;
        }, 1000);
    }
}

// 🔥 新增：处理远程系统设置更新
function handleRemoteSystemSettingsUpdate(remoteSettings) {
    if (!remoteSettings || typeof remoteSettings !== 'object' || !syncEnabled) return;
    
    if (JSON.stringify(systemSettings) !== JSON.stringify(remoteSettings)) {
        console.log('📥 收到远程系统设置更新');
        
        syncEnabled = false;
        const oldDuration = systemSettings.basePracticeDuration;
        systemSettings = { ...DEFAULT_SETTINGS, ...remoteSettings };
        persistSettings();
        
        // 如果基础时长变化，需要刷新所有状态
        if (oldDuration !== systemSettings.basePracticeDuration) {
            applyAfterBaseDurationChange();
        }
        
        // 刷新相关UI
        if ($('settingsModal').style.display === 'block') {
            $('baseDurationInput').value = systemSettings.basePracticeDuration;
            $('resetHourInput').value = systemSettings.autoResetHour;
            $('resetMinuteInput').value = systemSettings.autoResetMinute;
            $('stopAnomalyHourInput').value = systemSettings.stopAnomalyCheckHour;
            $('stopAnomalyMinuteInput').value = systemSettings.stopAnomalyCheckMinute || 0;
            updateDurationPreview();
            updateResetTimePreview();
            updateStopAnomalyPreview();
        }
        
        showToast('🔄 系统设置已同步', 2000);
        
        setTimeout(() => {
            syncEnabled = true;
        }, 1000);
    }
}



// 注册设备
function registerDevice() {
    if (!database || !isOnline) return;
    
    const deviceRef = database.ref(FIREBASE_PATHS.DEVICE_STATUS + '/' + deviceId);
    deviceRef.set({
        lastSeen: Date.now(),
        userAgent: navigator.userAgent,
        online: true
    });
    
    // 设置离线时的状态
    deviceRef.onDisconnect().update({
        online: false,
        lastSeen: Date.now()
    });
}

// 获取设备ID
function getDeviceId() {
    let id = localStorage.getItem('deviceId');
    if (!id) {
        id = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('deviceId', id);
    }
    return id;
}

// 创建连接状态指示器
function createConnectionIndicator() {
    const indicator = document.createElement('div');
    indicator.id = 'connectionStatus';
    indicator.style.cssText = `
        position: fixed;
        top: 50px;
        left: 10px;
        padding: 8px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        z-index: 1000;
        transition: all 0.3s ease;
        cursor: pointer;
        user-select: none;
    `;
    
    indicator.addEventListener('click', showSyncStatus);
    document.body.appendChild(indicator);
    
    updateConnectionStatus();
}

// 更新连接状态显示
function updateConnectionStatus() {
    const indicator = document.getElementById('connectionStatus');
    if (!indicator) return;
    
    if (isOnline) {
        indicator.className = 'connection-online';
        indicator.textContent = '🟢 云端已连接';
        indicator.title = '点击查看同步状态详情';
        indicator.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
        indicator.style.color = 'white';
        indicator.style.boxShadow = '0 2px 8px rgba(39, 174, 96, 0.3)';
    } else {
        indicator.className = 'connection-offline';
        indicator.textContent = '🔴 云端断开';
        indicator.title = '与云端服务器断开连接';
        indicator.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
        indicator.style.color = 'white';
        indicator.style.boxShadow = '0 2px 8px rgba(231, 76, 60, 0.3)';
    }
}

// 显示同步状态详情
function showSyncStatus() {
    const roomCount = Object.keys(roomDatabase).length;
    const studentCount = Object.values(studentDatabase).reduce((a,b)=>a+b.length,0);
    const slotCount = Object.keys(studentTimeSlots).length;
    const reminderCount = practiceOverrunReminders.length;
    
    const status = `
Firebase 同步状态详情：

• 连接状态: ${isOnline ? '✅ 已连接' : '❌ 已断开'}
• 同步功能: ${syncEnabled ? '✅ 已启用' : '❌ 已禁用'}
• 设备ID: ${deviceId}
• 项目ID: ${firebaseConfig.projectId}
• 数据库: ${firebaseConfig.databaseURL}
• 上次同步: ${lastSyncTime ? new Date(lastSyncTime).toLocaleString() : '未同步'}

同步数据概览：
• 琴房库: ${roomCount} 间
• 学生库: ${studentCount} 人
• 时间段: ${slotCount} 人已设置
• 异常提醒: ${reminderCount} 条
• 考勤数据: ${attendanceData.students?.length || 0} 条记录

测试说明：
1. 在另一台设备打开同样的系统
2. 在任一设备进行操作（登记、排队、设置等）
3. 另一台设备应立即显示更新
    `.trim();
    
    alert(status);
}

/// 修改现有的持久化函数，添加 Firebase 同步
const originalPersistRooms = persistRooms;
persistRooms = function() {
    originalPersistRooms();
    if (syncEnabled && isOnline) {
        syncToFirebase('room_update');
    }
};

const originalPersistQueues = persistQueues;
persistQueues = function() {
    originalPersistQueues();
    if (syncEnabled && isOnline) {
        syncToFirebase('queue_update');
    }
};

const originalPersistStudents = persistStudents;
persistStudents = function() {
    originalPersistStudents();
    if (syncEnabled && isOnline && database) {
        database.ref(FIREBASE_PATHS.STUDENT_DB).set(studentDatabase);
    }
};

const originalPersistRoomDb = persistRoomDb;
persistRoomDb = function() {
    originalPersistRoomDb();
    if (syncEnabled && isOnline && database) {
        database.ref(FIREBASE_PATHS.ROOM_DB).set(roomDatabase);
    }
};

// 🔥 新增：学生时间段同步
const originalPersistStudentSlots = persistStudentSlots;
persistStudentSlots = function() {
    originalPersistStudentSlots();
    if (syncEnabled && isOnline && database) {
        database.ref(FIREBASE_PATHS.STUDENT_SLOTS).set(studentTimeSlots);
    }
};

// 🔥 新增：系统设置同步
const originalPersistSettings = persistSettings;
persistSettings = function() {
    originalPersistSettings();
    if (syncEnabled && isOnline && database) {
        database.ref(FIREBASE_PATHS.SYSTEM_SETTINGS).set(systemSettings);
    }
};



// ========== 处理远端 overrunData 全量包 ==========
function handleRemoteOverrunDataUpdate(remote) {
  if (!remote || typeof remote !== 'object') return;

  // 版本判断：若远端版本 <= 本地版本，则忽略（避免回退）
  if (remote.version && lastOverrunVersion && remote.version <= lastOverrunVersion) {
    console.log('⏸️ 跳过较旧的远程异常提醒数据:', remote.version, '<=', lastOverrunVersion);
    return;
  }

  console.log('📥 收到远程异常提醒数据更新:', remote);

  // 不再用 syncEnabled 阻挡"读"，只限制"写"
  const { reminders = [], ignored = [], stats = {}, version = Date.now() } = remote;

  // 🔥 关键修复：正确处理忽略集合
  let ignoredArray = [];
  if (Array.isArray(ignored)) {
    ignoredArray = ignored;
  } else if (ignored && typeof ignored === 'object') {
    // 处理可能的对象格式
    ignoredArray = Object.values(ignored).filter(v => typeof v === 'string');
  }

  // 应用远程数据
  practiceOverrunReminders = Array.isArray(reminders) ? reminders : [];
  overrunIgnoredKeys = new Set(ignoredArray);
  overrunStats = stats || {};
  lastOverrunVersion = version;

  // 只本地缓存，不再回写云端，避免镜像写
  lsSet(KEYS.OVERRUN_REMINDERS, practiceOverrunReminders);
  lsSet(KEYS.OVERRUN_IGNORED, [...overrunIgnoredKeys]);
  lsSet(KEYS.OVERRUN_STATS, overrunStats);
  
  updateOverrunPanel();

  // 若考勤面板打开，可刷新
  const attModal = $('attendanceModal');
  if (attModal && attModal.style.display === 'block') {
    renderAttendanceList(false);
  }

  console.log('✅ 远程异常提醒数据已应用:', {
    reminders: practiceOverrunReminders.length,
    ignored: overrunIgnoredKeys.size,
    statsKeys: Object.keys(overrunStats).length
  });
}
// 🔥 新增：处理远程练习记录更新
function handleRemotePracticeRecordUpdate(dateKey, remoteData) {
    if (!remoteData || typeof remoteData !== 'object' || !syncEnabled) return;
    
    console.log('📥 收到远程练习记录更新:', dateKey);
    
    if (!dailyPracticeRecords[dateKey]) {
        dailyPracticeRecords[dateKey] = {};
    }
    
    Object.keys(remoteData).forEach(studentName => {
        const remoteRecord = remoteData[studentName];
        const localRecord = dailyPracticeRecords[dateKey][studentName];
        
        // 如果远程记录更新时间更新，则应用远程数据
        if (!localRecord || remoteRecord.lastUpdated > localRecord.lastUpdated) {
            dailyPracticeRecords[dateKey][studentName] = {
                inSlot: remoteRecord.inSlotSeconds || 0,
                outSlot: remoteRecord.outSlotSeconds || 0,
                totalSessions: remoteRecord.totalSessions || 0,
                sessions: [], // 详细会话信息不从远程同步
                lastUpdated: remoteRecord.lastUpdated || Date.now()
            };
        }
    });
    
    persistPracticeRecords();
    console.log('✅ 远程练习记录已应用');
}


function setupDataListeners() {
    console.log('👂 设置数据监听器...');
    
    // 🔥 关键修复：确保database已正确初始化
    if (!database) {
        console.error('Database not initialized');
        return;
    }
    
    try {
        // 🔥 新增：监听同步通知
        listenForSyncNotifications();
        
        // 监听房间数据变化
        database.ref(FIREBASE_PATHS.ROOMS).on('value', (snapshot) => {
            if (snapshot.exists()) {
                handleRemoteRoomsUpdate(snapshot.val());
            }
        }, (error) => {
            console.error('房间数据监听错误:', error);
        });
        
        // 监听排队数据变化
        database.ref(FIREBASE_PATHS.QUEUE).on('value', (snapshot) => {
            if (snapshot.exists()) {
                handleRemoteQueueUpdate(snapshot.val());
            }
        }, (error) => {
            console.error('排队数据监听错误:', error);
        });
        
        // 监听学生数据库变化
        database.ref(FIREBASE_PATHS.STUDENT_DB).on('value', (snapshot) => {
            if (snapshot.exists()) {
                handleRemoteStudentDbUpdate(snapshot.val());
            }
        }, (error) => {
            console.error('学生数据库监听错误:', error);
        });
        
        // 🔥 删除：实时练琴状态监听（已合并到房间状态）
        
        // 监听琴房数据库变化
        database.ref(FIREBASE_PATHS.ROOM_DB).on('value', (snapshot) => {
            if (snapshot.exists()) {
                handleRemoteRoomDbUpdate(snapshot.val());
            }
        }, (error) => {
            console.error('琴房数据库监听错误:', error);
        });
        
        // 🔥 新增：监听练习记录变化
        database.ref(FIREBASE_PATHS.PRACTICE_RECORDS).on('child_changed', (snapshot) => {
            if (snapshot.exists()) {
                handleRemotePracticeRecordUpdate(snapshot.key, snapshot.val());
            }
        }, (error) => {
            console.error('练习记录监听错误:', error);
        });

        // 🔥 新增：监听学生时间段变化
        database.ref(FIREBASE_PATHS.STUDENT_SLOTS).on('value', (snapshot) => {
            if (snapshot.exists()) {
                handleRemoteStudentSlotsUpdate(snapshot.val());
            }
        }, (error) => {
            console.error('学生时间段监听错误:', error);
        });
        
        // 🔥 新增：监听系统设置变化
        database.ref(FIREBASE_PATHS.SYSTEM_SETTINGS).on('value', (snapshot) => {
            if (snapshot.exists()) {
                handleRemoteSystemSettingsUpdate(snapshot.val());
            }
        }, (error) => {
            console.error('系统设置监听错误:', error);
        });
        
        // 🔥 修复：统一监听异常提醒 overrunData
        database.ref(FIREBASE_PATHS.OVERRUN_DATA).on('value', snapshot => {
          if (snapshot.exists()) {
            const data = snapshot.val();
            console.log('📥 收到远程 overrunData 更新:', data);
            handleRemoteOverrunDataUpdate(data);
          }
        }, err => {
          console.error('异常提醒 overrunData 监听错误:', err);
        });      

        // 🔥 新增：监听请假数据变化
        database.ref(FIREBASE_PATHS.EXCUSE_DATA).on('child_added', (snapshot) => {
            if (snapshot.exists()) {
                handleRemoteExcuseUpdate(snapshot.val(), 'added');
            }
        }, (error) => {
            console.error('请假数据监听错误:', error);
        });
        
        // 🔥 新增：监听请假数据修改
        database.ref(FIREBASE_PATHS.EXCUSE_DATA).on('child_changed', (snapshot) => {
            if (snapshot.exists()) {
                handleRemoteExcuseUpdate(snapshot.val(), 'changed');
            }
        }, (error) => {
            console.error('请假数据修改监听错误:', error);
        });
        
    } catch (error) {
        console.error('设置监听器失败:', error);
    }
    
    console.log('✅ 数据监听器设置完成');
}


function pad2(n){return n.toString().padStart(2,'0');}

// 标准化时间格式，将 "8:00" 转换为 "08:00"
function normalizeTimeFormat(timeStr) {
  if (!timeStr || typeof timeStr !== 'string') return timeStr;
  const parts = timeStr.trim().split(':');
  if (parts.length !== 2) return timeStr;
  const hours = parts[0].padStart(2, '0');
  const minutes = parts[1].padStart(2, '0');
  return `${hours}:${minutes}`;
}
function todayKey(){
  const d=new Date();
  return d.getFullYear()+'-'+pad2(d.getMonth()+1)+'-'+pad2(d.getDate());
}
function toDateKey(dateLike){
  if(!dateLike) return null;
  // 已是 yyyy-mm-dd
  if(/^\d{4}-\d{2}-\d{2}$/.test(dateLike)) return dateLike;
  const d=new Date(dateLike);
  if(isNaN(d.getTime())) return null;
  return d.getFullYear()+'-'+pad2(d.getMonth()+1)+'-'+pad2(d.getDate());
}

function formatHMS(sec){
  const h=Math.floor(sec/3600),m=Math.floor((sec%3600)/60),s=sec%60;
  return `${pad2(h)}:${pad2(m)}:${pad2(s)}`;
}
function minutesToTime(m){return `${pad2(Math.floor(m/60))}:${pad2(m%60)}`;}
function timeToMinutes(t){const [H,M]=t.split(':').map(Number);return H*60+M;}
function formatDurationHuman(seconds){
  if(seconds<=0) return '0秒';
  const h=Math.floor(seconds/3600),m=Math.floor((seconds%3600)/60),s=seconds%60;
  if(h) return `${h}小时${m?m+'分':''}${s? s+'秒':''}`;
  if(m) return `${m}分${s? s+'秒':''}`;
  return `${s}秒`;
}
function formatWait(ms){
  if(ms<=0) return '出现可用琴房！(点击查看)';
  return formatDurationHuman(Math.ceil(ms/1000));
}
function escapeCSV(v){
  if(v==null) return '';
  const s=String(v);
  return /[",\n]/.test(s)?`"${s.replace(/"/g,'""')}"`:s;
}

/* 拼音映射（保留） */
const pinyinMap={'靳':'jin','蓝':'lan','熙':'xi','邓':'deng','涵':'han','周':'zhou','静':'jing','远':'yuan','冯':'feng','瑞':'rui','夕':'xi','吕':'lv','金':'jin','昂':'ang','徐':'xu','涬':'shuang','宸':'chen','窦':'dou','璟':'jing','华':'hua','林':'lin','晏':'yan','熹':'xi','段':'duan','鉴':'jian','叶':'ye','蔚':'wei','刘':'liu','泽':'ze','文':'wen','潘':'pan','瑾':'jin','熠':'yi','李':'li','博':'bo','恩':'en','王':'wang','奕':'yi','然':'ran','韩':'han','昀':'yun','桦':'hua','孔':'kong','璇':'xuan','臧':'zang','昱':'yu','棋':'qi','蔺':'lin','轩':'xuan','宋':'song','梓':'zi','暄':'xuan','田':'tian','子':'zi','萱':'xuan','张':'zhang','依':'yi','陈':'chen','思':'si','彤':'tong','杨':'yang','雨':'yu','桐':'tong','赵':'zhao','欣':'xin','怡':'yi','马':'ma','晨':'chen','曦':'xi','高':'gao','梦':'meng','琪':'qi','郑':'zheng','诗':'shi','吴':'wu','佳':'jia','何':'he','朱':'zhu','心':'xin','语':'yu','胡':'hu','若':'ruo','汐':'xi','许':'xu','瑶':'yao','罗':'luo','雅':'ya','钟':'zhong','嫣':'yan','谢':'xie','苏':'su','琳':'lin','江':'jiang','孙':'sun','袁':'yuan','汪':'wang','曹':'cao','姚':'yao','沈':'shen','卢':'lu','韦':'wei','董':'dong','傅':'fu','程':'cheng','丁':'ding','石':'shi','任':'ren','邹':'zou','龙':'long','史':'shi','方':'fang','夏':'xia','侯':'hou','邱':'qiu','尹':'yin','黎':'li','汤':'tang','易':'yi','常':'chang','武':'wu','乔':'qiao','贺':'he','赖':'lai','龚':'gong','庞':'pang','樊':'fan','兰':'lan','殷':'yin','施':'shi','陶':'tao','翁':'weng','安':'an','倪':'ni','严':'yan','牛':'niu','温':'wen','芦':'lu','季':'ji','俞':'yu','章':'zhang','鲁':'lu','葛':'ge','伍':'wu','申':'shen','尤':'you','毕':'bi','聂':'nie','丛':'cong','焦':'jiao','向':'xiang','柯':'ke','岳':'yue','湘':'xiang','悦':'yue','玮':'wei','管':'guan','哲':'zhe','婷':'ting','释':'shi','言':'yan','祝':'zhu','宝':'bao','彭':'peng','美':'mei','淇':'qi','康':'kang','群':'qun','耿':'geng','幄':'wo','千':'qian','瑜':'yu','又':'you','雯':'wen','俊':'jun','杰':'jie','劲':'jin','豪':'hao','笙':'sheng','权':'quan','薛':'xue','宜':'yi','陆':'lu','曜':'yao','嶙':'lin','馨':'xin','裕':'yu','昕':'xin','沐':'mu','唐':'tang','君':'jun','盛':'sheng','硕':'shuo','晗':'han','如':'ru','牧':'mu','风':'feng','晞':'xi','伊':'yi','清':'qing','妃':'fei','月':'yue','祺':'qi','蒲':'pu','柏':'bai','羽':'yu','冠':'guan','成':'cheng','颜':'yan','亦':'yi','沅':'yuan','承':'cheng','秦':'qin','铂':'bo','筵':'yan','慧':'hui','作':'zuo','翰':'han','上':'shang','之':'zhi','路':'lu','瓒':'zan','著':'zhu','睿':'rui','籽':'zi','丞':'cheng','妍':'yan','栩':'xu','乐':'le','逸':'yi','诚':'cheng','钰':'yu','洁':'jie','媛':'yuan','鋆':'yun','谨':'jin','畅':'chang','茹':'ru','沂':'yi','婉':'wan','荷':'he','洋':'yang','明':'ming','多':'duo','郗':'xi','传':'chuan','平':'ping','世':'shi','元':'yuan','汇':'hui','沙':'sha','皓':'hao','家':'jia','楠':'nan','官':'guan','柘':'zhe','希':'xi','溥':'pu','尚':'shang','凌':'ling','翾':'xuan','姜':'jiang','煊':'xuan','琬':'wan','迪':'di','昍':'xuan','沁':'qin','祎':'yi','珈':'jia','政':'zheng','阳':'yang','以':'yi','骞':'qian','乙':'yi','铮':'zheng','商':'shang','天':'tian','赐':'ci','晟':'sheng','峰':'feng','邵':'shao','颢':'hao','浩':'hao','余':'yu','浡':'bo','瀚':'han','峻':'jun','于':'yu','钲':'zheng','埼':'qi','苏':'su','彦':'yan','炳':'bing','岐':'qi','璠':'fan','白':'bai','咏':'yong','玎':'ding','庄':'zhuang','笛':'di','薪':'xin','米':'mi','琪':'qi','存':'cun','和':'he','笑':'xiao','欧':'ou','翰':'han','喆':'zhe','庭':'ting','彰':'zhang','邰':'tai','蔡':'cai','屹':'yi','潆':'ying','潞':'lu','修':'xiu','冉':'ran','光':'guang','翼':'yi','珺':'jun','闻':'wen','治':'zhi','玥':'yue','婧':'jing','婍':'qi','植':'zhi','寅':'yin','井':'jing','溪':'xi','紫':'zi','航':'hang','显':'xian','翔':'xiang','景':'jing','园':'yuan','羿':'yi','达':'da','正':'zheng','潼':'tong','嘉':'jia','崚':'ling','汉':'han','冼':'xian','昊':'hao','敬':'jing','尔':'er','卓':'zhuo','帅':'shuai','志':'zhi','可':'ke','钧':'jun','鉴':'jian','笙':'sheng','权':'quan','显':'xian','翔':'xiang','晏':'yan','熹':'xi','释':'shi','言':'yan','森':'sen','贤':'xian','柳':'liu','恩':'en','奕':'yi','潼':'tong','嘉':'jia','怡':'yi','金':'jin','昂':'ang','瑾':'jin','熠':'yi','美':'mei','淇':'qi','千':'qian','瑜':'yu','子':'zi','轩':'xuan','志':'zhi','昊':'hao','萱':'xuan','申':'shen','崚':'ling','梓':'zi','康':'kang','岳':'yue','汉':'han','昊':'hao','熹':'xi','又':'you','安':'an','涬':'shuang','宸':'chen','宜':'yi','艺':'yi','卓':'zhuo','然':'ran','蔚':'wei','蓝':'lan','敬':'jing','轩':'xuan','昱':'yu','棋':'qi','尔':'er','涵':'han','雯':'wen','婷':'ting','卓':'zhuo','群':'qun','子':'zi','帅':'shuai','子':'zi','依':'yi','博':'bo','玮':'wei','欣':'xin','怡':'yi','静':'jing','远':'yuan','宝':'bao','怡':'yi','常':'chang','欣':'xin','洋':'yang','婉':'wan','茹':'ru','明':'ming','多':'duo','杰':'jie','欣':'xin','荷':'he','千':'qian','皓':'hao','汇':'hui','泽':'ze','传':'chuan','平':'ping','世':'shi','元':'yuan','冠':'guan','源':'yuan','米':'mi','琪':'qi','单':'dan','若':'ruo','溪':'xi','恩':'en','和':'he','金':'jin','黄':'huang','可':'ke','欣':'xin','孔':'kong','梓':'zi','语':'yu','存':'cun','浩':'hao','嘉':'jia','荷':'he','雨':'yu','笛':'di','子':'zi','轩':'xuan','薪':'xin','瑜':'yu','梓':'zi','宸':'chen','承':'cheng','熹':'xi','子':'zi','墨':'mo','塘':'tang','欣':'xin','妍':'yan','笑':'xiao','欧':'ou','祎':'yi','玥':'yue','婧':'jing','婍':'qi','植':'zhi','元':'yuan','浩':'hao','元':'yuan','梓':'zi','寅':'yin','依':'yi','诺':'nuo','钧':'jun','屹':'yi','博':'bo','闻':'wen','庭':'ting','彰':'zhang','潆':'ying','潞':'lu','熠':'yi','宸':'chen','天':'tian','翼':'yi','治':'zhi','钧':'jun','林':'lin','熠':'yi','梓':'zi','峰':'feng','修':'xiu','冉':'ran','珺':'jun','翰':'han','喆':'zhe','米':'mi','阳':'yang','光':'guang','栩':'xu','乐':'le','安':'an','慧':'hui','冠':'guan','华':'hua','若':'ruo','昕':'xin','雨':'yu','熙':'xi','金':'jin','沂':'yi','以':'yi','诺':'nuo','钰':'yu','沐':'mu','曦':'xi','牧':'mu','风':'feng','欣':'xin','妍':'yan','沅':'yuan','承':'cheng','籽':'zi','丞':'cheng','谨':'jin','畅':'chang','作':'zuo','翰':'han','文':'wen','盛':'sheng','路':'lu','雨':'yu','瓒':'zan','亦':'yi','宸':'chen','逸':'yi','诚':'cheng','子':'zi','清':'qing','柏':'bai','羽':'yu','铂':'bo','筵':'yan','曜':'yao','嶙':'lin','轩':'xuan','子':'zi','茹':'ru','嘉':'jia','君':'jun','洁':'jie','媛':'yuan','月':'yue','祺':'qi','淇':'qi','晗':'han','如':'ru','上':'shang','恩':'en','雅':'ya','晞':'xi','一':'yi','妃':'fei','怡':'yi','文':'wen','魏':'wei','伊':'yi','萱':'xuan','易':'yi','成':'cheng','晟':'sheng','嘉':'jia','家':'jia','硕':'shuo','佳':'jia','馨':'xin','语':'yu','著':'zhu','睿':'rui','诗':'shi','悦':'yue','依':'yi','宸':'chen','子':'zi','鋆':'yun','涵':'han','之':'zhi','裕':'yu','达':'da'
};
function matchPinyin(name, searchTerm) {
  if (!searchTerm) return true;
  const searchLower = searchTerm.toLowerCase().trim();
  const nameLower = name.toLowerCase();
  
  // 直接匹配中文
  if (nameLower.includes(searchLower)) return true;
  
  // 🔥 新增：处理空格分隔的多关键词搜索
  const keywords = searchLower.split(/\s+/).filter(k => k.length > 0);
  if (keywords.length > 1) {
    return matchMultipleKeywords(name, keywords);
  }
  
  // 单关键词的原有逻辑
  const nameChars = name.split('');
  const firstLetters = nameChars.map(char => {
    const py = pinyinMap[char];
    return py ? py.charAt(0) : char.toLowerCase();
  });
  
  // 如果搜索词只有一个字母，只匹配第一个字的首字母
  if (searchLower.length === 1) {
    return firstLetters[0] === searchLower;
  }
  
  // 多字母搜索时的连续首字母匹配
  const firstLettersStr = firstLetters.join('');
  
  // 1. 完整的首字母匹配（如 "彭美岐" -> "pmq"）
  if (firstLettersStr === searchLower) return true;
  
  // 2. 从开头开始的部分匹配（如 "彭美岐" -> "pm"）
  if (firstLettersStr.startsWith(searchLower)) return true;
  
  // 3. 连续子串匹配（如 "彭美岐" -> "mq" 匹配 "美岐"）
  if (searchLower.length >= 2 && firstLettersStr.includes(searchLower)) return true;
  
  // 4. 全拼音匹配（如果有 toPinyin 函数）
  if (typeof toPinyin === 'function') {
    const pinyin = toPinyin(name).toLowerCase();
    if (pinyin.includes(searchLower)) return true;
  }
  
  return false;
}

// 🔥 更新：多关键词匹配函数（完整版）
function matchMultipleKeywords(name, keywords) {
  const nameLower = name.toLowerCase();
  const nameChars = name.split('');
  const firstLetters = nameChars.map(char => {
    const py = pinyinMap[char];
    return py ? py.charAt(0) : char.toLowerCase();
  });
  const firstLettersStr = firstLetters.join('');
  
  // 方案1：每个关键词都必须单独匹配（AND 逻辑）
  const allMatch = keywords.every(keyword => {
    // 1. 直接中文匹配
    if (nameLower.includes(keyword)) return true;
    
    // 2. 单字母首字母匹配
    if (keyword.length === 1) {
      return firstLetters.includes(keyword);
    }
    
    // 3. 多字母连续匹配
    if (keyword.length >= 2) {
      return firstLettersStr.includes(keyword);
    }
    
    return false;
  });
  
  if (allMatch) return true;
  
  // 方案2：智能首字母组合匹配
  // 例如：["p", "m"] 匹配 "彭美岐" 的连续首字母 "pm"
  const isAllSingleLetters = keywords.every(k => k.length === 1);
  if (isAllSingleLetters) {
    return matchSmartKeywords(name, keywords);
  }
  
  // 方案3：组合关键词匹配
  // 例如：["p", "mei"] 匹配 "彭美岐" 的 "p" + "美"
  return matchCombinedKeywords(name, keywords, firstLetters, nameLower);
}

// 🔥 新增：组合关键词匹配
function matchCombinedKeywords(name, keywords, firstLetters, nameLower) {
  // 尝试不同的匹配组合
  for (let i = 0; i < keywords.length; i++) {
    const keyword = keywords[i];
    let matched = false;
    
    // 检查当前关键词是否能匹配
    if (keyword.length === 1) {
      // 单字母：检查首字母
      matched = firstLetters.includes(keyword);
    } else {
      // 多字母：检查中文或拼音
      matched = nameLower.includes(keyword) || 
                firstLetters.join('').includes(keyword);
    }
    
    if (!matched) return false;
  }
  
  return true;
}


// 🔥 新增：智能关键词匹配（支持首字母组合）
function matchSmartKeywords(name, keywords) {
  const nameChars = name.split('');
  const firstLetters = nameChars.map(char => {
    const py = pinyinMap[char];
    return py ? py.charAt(0) : char.toLowerCase();
  });
  
  // 尝试将关键词组合匹配到连续的首字母
  // 例如：["p", "m"] 匹配 "彭美岐" 的 "p" 和 "m"
  if (keywords.length <= nameChars.length) {
    // 检查是否存在连续的首字母匹配
    for (let i = 0; i <= firstLetters.length - keywords.length; i++) {
      let match = true;
      for (let j = 0; j < keywords.length; j++) {
        if (firstLetters[i + j] !== keywords[j]) {
          match = false;
          break;
        }
      }
      if (match) return true;
    }
    
    // 🔥 关键改进：支持非连续但按顺序的首字母匹配
    // 例如：["p", "q"] 可以匹配 "彭美岐" 的 "p"(彭) 和 "q"(岐)
    let keywordIndex = 0;
    for (let i = 0; i < firstLetters.length && keywordIndex < keywords.length; i++) {
      if (firstLetters[i] === keywords[keywordIndex]) {
        keywordIndex++;
      }
    }
    if (keywordIndex === keywords.length) return true;
  }
  
  return false;
}




/* =============== 2. 数据模型与变量 =============== */
let rooms=[];
let roomDatabase={};
let studentDatabase={};
let studentTimeSlots={};
let practiceLogs=[];
let queueList={grand:[],upright:[],none:[]};
let operationLogs=[];
let systemSettings={...DEFAULT_SETTINGS};
let lastResetDate=null;
let currentRoom=null;
let isLocked=true;
let roomViewMode='overview';
let currentFloor=null;
let needsFullUpdate=true;
let timelineVisible=false;
let attendanceData={};


let lastAttendanceCheck=null;
let timelineCats = ['grand','upright','other'];
let currentTimelineCatIndex = 0;
/* === 练琴异常提醒新增全局变量 BEGIN === */
let practiceOverrunReminders = [];
let overrunIgnoredKeys = new Set();
let lastOverrunCheck = 0;  // 节流检测
/* === 练琴异常提醒新增全局变量 END === */
/* === 超时段统计 === */
let overrunStats = {};  // { dateKey: { studentName:{count:number} } }
/* === 练习时长记录系统 === */
let dailyPracticeRecords = {}; // { dateKey: { studentName: { inSlot: seconds, outSlot: seconds, totalSlots: [], details: [] } } }
let practiceSessionTracker = new Map(); // 当前练琴会话跟踪器
let lastPracticeSync = 0; // 上次同步时间

let studentSlotHistory = new Set();
// 在全局变量区域添加
let operationLocks = new Set(); // 操作锁集合
let operationLockTimestamps = new Map(); // 操作锁时间戳，用于超时清理
let pendingOperations = new Map(); // 待处理操作队列

// 操作锁超时时间（5分钟）
// 锁超时：由原 5 分钟降为 90 秒，减少遗留锁影响 (D)
const OPERATION_LOCK_TIMEOUT = 90 * 1000;

// ========== 异常提醒同步版本控制 ==========
let lastOverrunVersion = 0; 
// 🔥 新增：智能同步相关变量
let lastDataFingerprint = null;
let syncDebounceTimeout = null;
const SYNC_DEBOUNCE_MS = 500;
           // 本地已应用的版本号
let lastOverrunSyncTime = 0;           // 节流写入

const OVERRUN_SYNC_DEBOUNCE = 800;     // 毫秒，避免短时间重复写
// 🔥 新增：请假状态检查间隔（每分钟检查一次过期状态）
let excuseCheckInterval = null;

// 🔥 新增：请假操作历史记录
let excuseOperationHistory = [];
let anomalyCheckInterval = null; // 异常检查定时器
let isAnomalyCheckActive = false; // 异常检查是否激活
// 🔥 新增：数据保护相关变量
let deviceSleepTime = null;
let dataProtectionMode = true; // 启用数据保护模式
let lastWakeupTime = 0;

// 🔥 新增：自动锁定功能变量
let autoLockTimer = null;
let autoLockWarningTimer = null;
let lastActivityTime = Date.now();
let autoLockWarningShown = false;
// ==== 新增：同步防护控制变量 BEGIN ====
let initialSyncInProgress = true;        // 首次云端数据拉取期间不允许 push
let initialSyncCompleted = false;        // 完成第一轮安全 pull
let lastRemoteSnapshotOccupancy = 0;     // 缓存云端上一次占用数量
let lastLocalSnapshotOccupancy = 0;      // 本地最近一次已成功上报的占用数量
let lastUserDestructiveActionTs = 0;     // 记录最近一次“用户主动清空”操作时间
const DESTRUCTIVE_ACTION_WINDOW = 10000; // 10 秒内允许一次大幅下降（例如手动重置）
// ==== 新增：同步防护控制变量 END ====

const AUTO_LOCK_WARNING_TIME = 30 * 1000; // 提前30秒警告

// 🔥 新增：获取自动锁定超时时间的函数
function getAutoLockTimeout() {
  return systemSettings.autoLockTimeMinutes * 60 * 1000;
}
/* =============== 3. 存取封装 =============== */
function lsGet(k,def){try{return JSON.parse(localStorage.getItem(k))??def;}catch{return def;}}
function lsSet(k,v){localStorage.setItem(k,JSON.stringify(v));}
function updateAutoLockPreview(){
  const enabled = $('autoLockEnabledInput').checked;
  const minutes = parseInt($('autoLockTimeInput').value) || 10;
  
  if (!enabled) {
    $('autoLockPreview').textContent = '当前设置：已禁用';
    $('autoLockPreview').style.color = '#95a5a6';
  } else {
    $('autoLockPreview').textContent = `当前设置：${minutes}分钟`;
    $('autoLockPreview').style.color = '#e67e22';
  }
}

function loadAll(){
  roomDatabase=lsGet(KEYS.ROOM_DB,{});
  rooms=lsGet(KEYS.ROOMS,[]);
  if(!rooms.length) rebuildRoomsFromDb();
  studentDatabase=lsGet(KEYS.STUD_DB,{});
  
  // 🔥 新增：升级学生数据库结构以支持年级
  upgradeStudentDatabaseStructure();
  
  studentTimeSlots=lsGet(KEYS.STUD_SLOTS,{});
  practiceLogs=lsGet(KEYS.PRACTICE_LOG,[]);
  queueList=lsGet(KEYS.QUEUE,{grand:[],upright:[],none:[]});
  operationLogs=lsGet(KEYS.OPS,[]);
  systemSettings={...DEFAULT_SETTINGS,...lsGet(KEYS.SETTINGS,{})};
  // 🔥 新增：加载请假操作历史
  excuseOperationHistory=lsGet('excuseOperationHistory',[]);
  // 确保新字段存在默认值
  if(systemSettings.stopAnomalyCheckMinute === undefined) {
    systemSettings.stopAnomalyCheckMinute = 0;
  }
  // 🔥 新增：确保开始时间字段存在默认值
  if(systemSettings.startAnomalyCheckHour === undefined) {
    systemSettings.startAnomalyCheckHour = 8;
  }
  if(systemSettings.startAnomalyCheckMinute === undefined) {
    systemSettings.startAnomalyCheckMinute = 0;
  }
  lastResetDate=lsGet(KEYS.AUTO_RESET,{lastResetDate:null}).lastResetDate;
  // 旧格式迁移（英语 toDateString -> yyyy-mm-dd）
  if(lastResetDate){
    const migrated = toDateKey(lastResetDate);
    if(migrated && migrated !== lastResetDate){
      lastResetDate = migrated;
      persistReset();
    }
  }

  timelineVisible=localStorage.getItem(KEYS.TIMELINE_VISIBLE)==='true';
  /* === 加载练琴异常提醒数据 BEGIN === */
  practiceOverrunReminders = lsGet(KEYS.OVERRUN_REMINDERS,[]);
  const ignoredArr = lsGet(KEYS.OVERRUN_IGNORED,[]);
  overrunIgnoredKeys = new Set(ignoredArr);
  /* === 加载练琴异常提醒数据 END === */
  /* === 加载超时段统计 === */
  overrunStats = lsGet(KEYS.OVERRUN_STATS, {});
  /* === 加载练习时长记录 === */
  dailyPracticeRecords = lsGet('dailyPracticeRecords', {});
  // 清理过期数据（保留最近30天）
  cleanupOldPracticeRecords();

  // 🔥 新增：加载实时练琴状态
  realTimePracticeStatus = lsGet('realTimePracticeStatus', {});
}


function persistRooms(){lsSet(KEYS.ROOMS,rooms);}
function persistRoomDb(){lsSet(KEYS.ROOM_DB,roomDatabase);}
function persistStudents(){lsSet(KEYS.STUD_DB,studentDatabase);}
function persistStudentSlots(){lsSet(KEYS.STUD_SLOTS,studentTimeSlots);}
function persistLogs(){lsSet(KEYS.PRACTICE_LOG,practiceLogs);}
function persistQueues(){lsSet(KEYS.QUEUE,queueList);}
function persistOps(){lsSet(KEYS.OPS,operationLogs);}
function persistSettings(){lsSet(KEYS.SETTINGS,systemSettings);}
function persistReset(){lsSet(KEYS.AUTO_RESET,{lastResetDate});}
function persistOverrunsLocal() {
  lsSet(KEYS.OVERRUN_REMINDERS, practiceOverrunReminders);
  lsSet(KEYS.OVERRUN_IGNORED, [...overrunIgnoredKeys]);
  lsSet(KEYS.OVERRUN_STATS, overrunStats);
}
/**
 * 完整持久化（本地 + 可选云端同步）
 * @param {boolean} triggerSync - 是否触发云端同步
 * @param {string} action - 同步动作类型
 * @param {object} meta - 元数据
 */

function logOperation(type,detail){operationLogs.push({time:new Date().toISOString(),type,detail});persistOps();}
// ========== 云端同步函数 ==========
function syncOverrunData(action = 'update', meta = {}) {
  if (!isOnline || !syncEnabled || !database) {
    console.log('⏸️ 跳过云端同步：', { isOnline, syncEnabled, hasDatabase: !!database });
    return;
  }
  
  const now = Date.now();
  
  // 频率控制：普通更新限制，重要操作不限制
  if (now - lastOverrunSyncTime < OVERRUN_SYNC_DEBOUNCE && action === 'update') {
    console.log('⏸️ 跳过云端同步：频率限制');
    return;
  }
  
  lastOverrunVersion = now;
  lastOverrunSyncTime = now;

  const payload = {
    version: lastOverrunVersion,
    reminders: practiceOverrunReminders,
    ignored: [...overrunIgnoredKeys], // 🔥 确保 Set 转数组
    stats: overrunStats,
    updatedAt: now,
    action,
    meta
  };

  console.log('🔄 同步异常提醒数据到云端:', action, {
    reminders: payload.reminders.length,
    ignored: payload.ignored.length,
    statsKeys: Object.keys(payload.stats).length
  });

  database
    .ref(FIREBASE_PATHS.OVERRUN_DATA)
    .set(payload)
    .then(() => {
      console.log('✅ 异常提醒数据同步成功:', action);
    })
    .catch(err => {
      console.error('❌ 异常提醒数据同步失败:', err);
    });
}

// ========== 统一对外调用的 persistOverruns（兼容旧调用点） ==========
function persistOverruns(triggerSync = true, action = 'update', meta = {}) {
  // 1. 先执行本地持久化
  persistOverrunsLocal();
  
  // 2. 可选的云端同步
  if (triggerSync && isOnline && syncEnabled) {
    syncOverrunData(action, meta);
  }
}
/* =============== 4. UI 基础：Toast / 模态 / 时间显示 =============== */
function showToast(msg, ms=3000){
  const t = document.getElementById('toast');
  if (t._lastMsg === msg && Date.now() - (t._lastTime||0) < 800) {
    // 800ms 内同样内容不再重复刷新，防止短时间 spam
    return;
  }
  t._lastMsg = msg;
  t._lastTime = Date.now();
  t.textContent = msg;
  t.style.display='block';
  clearTimeout(t._to);
  t._to = setTimeout(()=>{ t.style.display='none'; }, ms);
}
function $(id){return document.getElementById(id);}
function updateClock(){ $('currentTime').textContent=new Date().toLocaleString(); }

/* =============== 5. 房间与琴房库 =============== */
function rebuildRoomsFromDb(){
  rooms=Object.values(roomDatabase).map(r=>({
    name:r.name,
    type:r.pianoType==='三角钢琴'?'grand':'other',
    pianoKind:r.pianoType,
    location:r.location,
    remark:r.remark,
    student:null,
    registerTime:null,
  }));
  
  // 🔥 新增：按名称自然排序
  rooms.sort((a, b) => {
    return a.name.localeCompare(b.name, 'zh-Hans-CN', {
      numeric: true,
      sensitivity: 'base'
    });
  });
  
  persistRooms();
}

function isGrand(room){return room.pianoKind==='三角钢琴';}

function getFloorKey(room){
  const loc=room.location||'';
  if(loc.includes('负一')) return '-1';
  if(loc.includes('一楼')) return '1';
  if(loc.includes('二楼')) return '2';
  if(loc.includes('三楼')) return '3';
  if(loc.includes('四楼')) return '4';
  return '其他';
}
function floorStats(){
  const f={};
  // 预定义楼层初始化
  ['-1','1','2','3','4','temp'].forEach(key => {
    f[key] = {total:0,occ:0};
  });
  
  rooms.forEach(r=>{
    const k=getFloorKey(r);
    if(!f[k]) f[k]={total:0,occ:0}; // 动态创建新楼层统计
    f[k].total++; 
    if(r.student) f[k].occ++;
  });
  return f;
}
function renderRoomsLayout() {
    const container = $('rooms');
    if (roomViewMode === 'overview') {
        const fs = floorStats();
        let html = '<h2>琴房状态</h2><div class="floor-buttons">';
        Object.entries(fs).forEach(([k, v]) => {
            if (!v.total) return;
            const name = 
                k === '-1' ? '负1楼' : 
                k === 'temp' ? '临时新增' : 
                k === '其他' ? '其他位置' :
                /^\d+$/.test(k) ? k + '楼' : k; // 纯数字加"楼"，否则直接显示
            const rate = (v.occ / v.total * 100).toFixed(0);
            html += `<button class="floor-btn" onclick="showFloorDetails('${k}')">
                <div>${name}</div>
                <div class="floor-info">${v.occ}/${v.total} 使用中 (${rate}%)</div>
            </button>`;
        });
        html += '</div>';
        container.innerHTML = html;
    } else {
        // 当前楼层数据
        const currentList = rooms.filter(r => getFloorKey(r) === currentFloor);
        const floorName =
            currentFloor === '-1' ? '负1楼' :
            currentFloor === 'temp' ? '临时新增琴房' :
            currentFloor === '其他' ? '其他位置' :
            /^\d+$/.test(currentFloor) ? currentFloor + '楼' : currentFloor;

        // 重新获取所有楼层统计用于生成切换条
        const fs = floorStats();
        // 按显示顺序排序（手动定义顺序，然后添加其他楼层）
        const predefinedOrder = ['-1', '1', '2', '3', '4', 'temp'];
        const predefinedFloors = predefinedOrder.filter(f => fs[f] && fs[f].total > 0);
        // 添加未预定义但有房间的楼层
        const otherFloors = Object.keys(fs).filter(f => fs[f] && fs[f].total > 0 && !predefinedOrder.includes(f)).sort();
        const orderedFloors = [...predefinedFloors, ...otherFloors];

        // 生成快速切换按钮
        const switchBar = `
            <div class="floor-switch-bar">
                ${orderedFloors.map(f => {
                    const name =
                        f === '-1' ? '负1楼' :
                        f === 'temp' ? '临时新增' :
                        f === '其他' ? '其他位置' :
                        /^\d+$/.test(f) ? f + '楼' : f; // 纯数字加"楼"，否则直接显示
                    const stat = fs[f];
                    const occText = `${stat.occ}/${stat.total}`;
                    const active = f === currentFloor ? 'active' : '';
                    return `<button class="floor-switch-btn ${active}" ${f === currentFloor ? 'disabled' : ''} onclick="showFloorDetails('${f}')">${name}<span style="margin-left:4px;font-size:11px;opacity:.8;">${occText}</span></button>`;
                }).join('')}
            </div>
        `;

        // 分组
        const group = { grand: [], upright: [], other: [] };
        currentList.forEach(r => {
            if (r.pianoKind === '三角钢琴') group.grand.push(r);
            else if (r.pianoKind === '立式钢琴') group.upright.push(r);
            else group.other.push(r);
        });

        const renderGroup = (title, list) => {
            if (!list.length) return '';
            return `<h4 style="margin:16px 0 6px;">${title}</h4>
                    <div class="room-container">${list.map(renderRoomCard).join('')}</div>`;
        };

        let html = `<h2>琴房状态</h2>
            <div class="floor-header" style="display:flex;align-items:center;gap:12px;margin-bottom:12px;">
                <button class="floor-back-btn" style="background:var(--secondary-color);" onclick="showFloorOverview()">← 返回概览</button>
                <h3 style="margin:0;">${floorName}</h3>
            </div>
            ${switchBar}
            ${renderGroup('三角钢琴琴房', group.grand)}
            ${renderGroup('立式钢琴琴房', group.upright)}
            ${renderGroup('其他琴房', group.other)}
        `;
        container.innerHTML = html;
    }
}


function updateRoomCardContents(){
  if(roomViewMode === 'overview') return;

  const roomCards = document.querySelectorAll('.room[data-room-name]');
  const now = Date.now();

  roomCards.forEach(cardEl => {
    const roomName = cardEl.dataset.roomName;
    const room = rooms.find(r => r.name === roomName);
    if(!room) return;

    const oldClasses = ['available','preparing','in-use','expired'];
    oldClasses.forEach(c=>cardEl.classList.remove(c));

    let newStatusClass = '';
    let statusChipHTML = '';
    let showBottomRow = false;

    if(room.student){
      const prepEnd = room.registerTime + 60000;
      showBottomRow = true;
      if(now < prepEnd){
        const remainSec = Math.ceil((prepEnd - now)/1000);
        newStatusClass = 'preparing';
        statusChipHTML = `<span class="room-status-chip preparing">准备中 ${remainSec}s</span>`;
      }else{
        const used = Math.floor((now - prepEnd)/1000);
        const limit = systemSettings.basePracticeDuration * 60;
        if(used <= limit){
          newStatusClass = 'in-use';
          statusChipHTML = `<span class="room-status-chip in-use">${formatHMS(used)}</span>`;
        }else{
          newStatusClass = 'expired';
          const overtime = used - limit;
          statusChipHTML = `<span class="room-status-chip expired">超时 ${formatDurationHuman(overtime)}</span>`;
        }
      }
    }else{
      newStatusClass = 'available';
      statusChipHTML = `<span class="room-status-chip available">空闲</span>`;
      showBottomRow = false;
    }

    if(newStatusClass) cardEl.classList.add(newStatusClass);
    cardEl.dataset.hasStudent = room.student ? '1':'0';

    // 备注行如果不存在且有备注，补一次（避免完全重绘）
    if(room.remark && !cardEl.querySelector('.room-remark')){
      const nameEl = cardEl.querySelector('.room-name');
      if(nameEl){
        nameEl.insertAdjacentHTML('afterend',
          `<div class="room-remark" title="${room.remark.replace(/"/g,'&quot;')}">${room.remark}</div>`);
      }
    }

    const chipEl = cardEl.querySelector('.room-status-chip');
    if(chipEl){
      if(chipEl.outerHTML !== statusChipHTML){
        chipEl.outerHTML = statusChipHTML;
      }
    }else{
      // 不存在则在底部行里追加（极少数动态插入）
      const bottom = cardEl.querySelector('.room-bottom-row');
      if(bottom){
        bottom.insertAdjacentHTML('afterbegin', statusChipHTML);
      }
    }

    const bottomRow = cardEl.querySelector('.room-bottom-row');
    if(bottomRow){
      bottomRow.style.display = showBottomRow ? 'flex' : 'none';
    }

    // 清空按钮
    const actionsEl = cardEl.querySelector('.room-actions');
    if(room.student){
      if(actionsEl){
        // 续琴房按钮检查
        if(!actionsEl.querySelector('.room-renew-btn')){
          actionsEl.insertAdjacentHTML('beforeend',
            `<button class="room-renew-btn" onclick="event.stopPropagation();renewRoom('${roomName}')">
               <span>⟳</span><span>续</span>
             </button>`);
        }
      }
    }else{
      if(actionsEl){
        const renewBtn = actionsEl.querySelector('.room-renew-btn');
        if(renewBtn) renewBtn.remove();
      }
    }
  });
}


function updateRoomStatuses(){
  if(roomViewMode==='overview'){
    // 概览模式不需要更新单个卡片状态
    return;
  }
  
  // 详细模式：只更新动态内容，不重新渲染整个布局
  updateRoomCardContents();
}


function renderRoomCard(room){
  const now = Date.now();
  let statusClass = '', studentInfo = '', statusChip = '';

  const typeClass =
    room.pianoKind === '三角钢琴' ? 'type-grand' :
    room.pianoKind === '立式钢琴' ? 'type-upright' : 'type-none';

  if(room.student){
    const prepEnd = room.registerTime + 60000;
    studentInfo = `
      <div class="room-student-info">
        <span class="room-student-dot"></span>
        <span>${room.student}</span>
      </div>`;
    if(now < prepEnd){
      const remainSec = Math.ceil((prepEnd - now)/1000);
      statusClass = 'preparing';
      statusChip = `<span class="room-status-chip preparing">准备中 ${remainSec}s</span>`;
    }else{
      const used = Math.floor((now - prepEnd)/1000);
      const limit = systemSettings.basePracticeDuration * 60;
      if(used <= limit){
        statusClass = 'in-use';
        statusChip = `<span class="room-status-chip in-use">${formatHMS(used)}</span>`;
      }else{
        statusClass = 'expired';
        const overtime = used - limit;
        statusChip = `<span class="room-status-chip expired">超时 ${formatDurationHuman(overtime)}</span>`;
      }
    }
  }else{
    statusClass = 'available';
    statusChip = `<span class="room-status-chip available">空闲</span>`;
  }

  const metaTitle = `名称:${room.name}
位置:${room.location||'未知'}
类型:${room.pianoKind||''}
备注:${room.remark||'无'}`.replace(/"/g,'"');

  const remarkLine = room.remark
    ? `<div class="room-remark" title="${room.remark.replace(/"/g,'&quot;')}">${room.remark}</div>`
    : '';

  return `
    <div class="room ${typeClass} ${statusClass}"
         title="${metaTitle}"
         data-room-name="${room.name}"
         data-has-student="${room.student?1:0}"
         onclick="roomCardClick(event,'${room.name}')"
         ondblclick="roomCardDoubleClick(event,'${room.name}')">
      <div class="room-name">${room.name}</div>
      ${remarkLine}
      <div class="room-status">
        ${studentInfo}
        <div class="room-bottom-row">
          ${statusChip}
          ${room.student ? `
          <div class="room-actions">
            <button class="room-clear-btn" onclick="event.stopPropagation();clearRoomWithConfirm('${room.name}')">
              <span>✕</span><span>清空</span>
            </button>
            <button class="room-renew-btn" onclick="event.stopPropagation();renewRoom('${room.name}')">
              <span>⟳</span><span>续</span>
            </button>
          </div>` : ''}
        </div>
      </div>
    </div>`;
}
/* ==== 双击清空 & 续琴房 功能新增 BEGIN ==== */
function roomCardClick(event, roomName){
  const card = event.currentTarget;
  // 防止双击第二次 click 触发已排队的逻辑（双击会出现两次单击 + 一次 dblclick）
  if(card._clickTimer){
    return;
  }
  card._clickTimer = setTimeout(()=>{
    card._clickTimer = null;
    handleRoomClick(roomName);
  },180);
}

function roomCardDoubleClick(event, roomName){
  event.stopPropagation();
  event.preventDefault();
  const card = event.currentTarget;
  if(card._clickTimer){
    clearTimeout(card._clickTimer);
    card._clickTimer = null;
  }
  handleRoomDoubleClick(roomName);
}

function handleRoomDoubleClick(name){
    if(isLocked){
        alert('系统已锁定');return;
    }
    const r = rooms.find(x=>x.name===name);
    if(!r){
        showToast('未找到琴房');return;
    }
    if(!r.student){
        showToast('该琴房当前为空');return;
    }
    
    // 🔥 新增：操作锁保护，防止并发冲突
    const lockKey = `double_clear_${name}`;
    if(operationLocks.has(lockKey)){
        showToast('正在处理中，请稍后...');
        return;
    }
    operationLocks.add(lockKey);
    
    const studentName = r.student;
    const now = Date.now();

    // 🔥 新增：标记最近清空操作时间戳，用于远程更新保护
    window.lastClearOperations = window.lastClearOperations || new Map();
    window.lastClearOperations.set(name, now);

    try {
        // 写练琴日志
        addPracticeLog(studentName, r.name, r.registerTime, now, '双击清空');

        // 本地清空
        r.student = null;
        r.registerTime = null;
        r.clearTime = now; // 🔥 新增：记录清空时间

        // 统一状态处理
        handleRoomStatusChange('room_double_clear',{
            roomName:name,
            clearedStudent:studentName
        });

        // 持久化 & UI
        persistRooms();
        needsFullUpdate = true;
        updateRooms();
        showToast(`${studentName} 已从 ${name} 清空 (双击)`);
        refreshSearchResults();

        // 🔥 增强：使用事务式清空确保原子性
        if(database && isOnline){
            attemptAtomicClear(name, studentName, now, lockKey);
        } else {
            // 离线模式下的立即推送
            forcePushRoomsImmediately('room_double_clear_offline');
            setTimeout(() => operationLocks.delete(lockKey), 500);
        }
        
    } catch(error) {
        console.error('双击清空失败:', error);
        operationLocks.delete(lockKey);
        showToast('清空失败，请重试');
    }
}

// 🔥 新增：原子清空函数，防止竞态条件
function attemptAtomicClear(roomName, expectedStudent, clearTime, lockKey) {
    const roomPath = `${FIREBASE_PATHS.ROOMS}`;
    
    database.ref(roomPath).transaction((currentRooms) => {
        if (!Array.isArray(currentRooms)) {
            console.warn('原子清空失败：云端房间数据格式错误');
            return currentRooms;
        }
        
        const targetRoom = currentRooms.find(r => r && r.name === roomName);
        if (!targetRoom) {
            console.warn(`原子清空失败：云端未找到房间 ${roomName}`);
            return currentRooms;
        }
        
        // 检查是否还是预期的学生（防止被其他操作替换）
        if (targetRoom.student !== expectedStudent) {
            console.warn(`原子清空失败：房间 ${roomName} 学生已变更 (期望:${expectedStudent}, 实际:${targetRoom.student})`);
            return; // 取消事务
        }
        
        // 执行原子清空
        targetRoom.student = null;
        targetRoom.registerTime = null;
        targetRoom.clearTime = clearTime;
        targetRoom.lastModified = Date.now();
        
        console.log(`✅ 原子清空成功：${roomName} (${expectedStudent})`);
        return currentRooms;
        
    }).then((result) => {
        if (result.committed) {
            console.log(`🔄 原子清空已提交到云端：${roomName}`);
        } else {
            console.warn(`⚠️ 原子清空被取消：${roomName}，可能已被其他设备修改`);
            showToast(`${roomName} 可能已被其他设备修改，请检查状态`);
        }
        setTimeout(() => operationLocks.delete(lockKey), 500);
    // 锁释放后若有排队的远程更新尝试处理
    if(operationLocks.size===0 && window.__pendingRemoteRooms){
      const queued = window.__pendingRemoteRooms; // 取当前最新
      // 立即清空标记避免递归冲突
      window.__pendingRemoteRooms = null; window.__pendingRemoteRoomsAttempts=0; window.__pendingRemoteRoomsFirstTs=null; window.__remoteQueueNoticeShown=false;
      setTimeout(()=>{ try{ handleRemoteRoomsUpdate(queued);}catch(e){console.warn('处理排队远程更新失败',e);} }, 50);
    }
    }).catch((error) => {
        console.error(`❌ 原子清空失败：${roomName}`, error);
        showToast('清空操作失败，请重试');
        // 回退：再次尝试强制推送
        forcePushRoomsImmediately('atomic_clear_fallback');
        setTimeout(() => operationLocks.delete(lockKey), 1000);
    if(operationLocks.size===0 && window.__pendingRemoteRooms){
      const queued = window.__pendingRemoteRooms;
      window.__pendingRemoteRooms = null; window.__pendingRemoteRoomsAttempts=0; window.__pendingRemoteRoomsFirstTs=null; window.__remoteQueueNoticeShown=false;
      setTimeout(()=>{ try{ handleRemoteRoomsUpdate(queued);}catch(e){console.warn('处理排队远程更新失败',e);} }, 100);
    }
    });
}


function renewRoom(name){
    if(isLocked){
        alert('系统已锁定');return;
    }
    const r = rooms.find(x=>x.name===name);
    if(!r || !r.student){
        showToast('无法续：琴房为空');return;
    }

    // ====== 新增：先检查是否有排队（同类型） ======
    // 类型映射
    const queueType =
        r.pianoKind === '三角钢琴' ? 'grand' :
        r.pianoKind === '立式钢琴' ? 'upright' : 'none';

    const qArr = queueList[queueType] || [];
    if(qArr.length > 0){
        const first = qArr[0];

        // 如果队首不是当前使用者 => 按规则应该先给排队
        if(first !== r.student){
            const keep = confirm(
                `当前有 ${qArr.length} 人在排队（第1位：${first}）。\n`+
                `按规则需优先分配给排队学生。\n\n`+
                `【确定】= 仍然强制为 ${r.student} 续时（覆盖排队优先）\n`+
                `【取消】= 打开排队分配窗口处理分配`
            );
            if(!keep){
                // 打开队列分配弹窗，优先处理排队
                showQueueModal(name, queueType);
                return;
            }else{
                // 记录一次覆盖队列的操作，方便审计
                logOperation('renew_override_queue', {
                    room: name,
                    currentStudent: r.student,
                    queueFirst: first,
                    queueLength: qArr.length,
                    timestamp: Date.now()
                });
            }
        }
    }
    // ====== 队列处理结束 ======

    if(!confirm(`续琴房：${name}\n当前学生：${r.student}\n此操作将重新计时，保留同一学生。`)){
        return;
    }

    const now = Date.now();
    // 记录上一段
    addPracticeLog(r.student, r.name, r.registerTime, now, '续琴房');
    // 重设开始时间
    r.registerTime = now;

    handleRoomStatusChange('room_renew',{
        roomName:name,
        student:r.student
    });

    persistRooms();
    needsFullUpdate = true;
    updateRooms();
    showToast(`${r.student} 已在 ${name} 续时成功`);
    refreshSearchResults();

    // 云端同步：立即推送
    if(syncEnabled && isOnline){
        try{
            syncToFirebase('room_renew',{
                roomName:name,
                student:r.student,
                newRegisterTime:now,
                timestamp:now
            });
        }catch(e){
            console.warn('room_renew 同步失败(稍后自动重试):',e);
        }
    }
}

/* ==== 双击清空 & 续琴房 功能新增 END ==== */


function updateRooms(){
  // 🔥 新增：验证房间数据一致性
  const dbRoomNames = new Set(Object.keys(roomDatabase));
  const invalidRooms = rooms.filter(r => r && r.name && !dbRoomNames.has(r.name));
  
  if(invalidRooms.length > 0) {
    console.warn('🔧 发现无效房间，自动清理:', invalidRooms.map(r => r.name));
    rooms = rooms.filter(r => !r || !r.name || dbRoomNames.has(r.name));
    persistRooms();
    needsFullUpdate = true;
  }
  
  if(needsFullUpdate){
    renderRoomsLayout();
    needsFullUpdate=false;
  } else {
    updateRoomStatuses();
  }
  
  updateUtilization();
  updateDemandButtonsStatus();
  if(timelineVisible) updateTimeline();
}



function updateUtilization(){
  const total=rooms.length;
  const occ=rooms.filter(r=>r.student).length;
  $('utilizationRate').textContent=`琴房使用率: ${(occ/Math.max(total,1)*100).toFixed(2)}%`;
}
function showFloorDetails(f){roomViewMode='detailed';currentFloor=f;needsFullUpdate=true;updateRooms();}
function showFloorOverview(){roomViewMode='overview';currentFloor=null;needsFullUpdate=true;updateRooms();}

/* 房间操作 */

function deleteRoom(name){
  if(isLocked){alert('系统已锁定');return;}
  if(!confirm('确定删除琴房 '+name+' ?'))return;
  const idx=rooms.findIndex(r=>r.name===name);
  if(idx>-1){
    const r=rooms[idx];
    if(r.student){addPracticeLog(r.student,r.name,r.registerTime,Date.now(),'删除时清除');}
    rooms.splice(idx,1);
  }
  delete roomDatabase[name];
  persistRoomDb();persistRooms();
  needsFullUpdate=true;updateRooms();
  showToast('已删除琴房');
}
function clearRoomWithConfirm(name){
    if(isLocked){alert('系统已锁定');return;}
    const r=rooms.find(x=>x.name===name);
    if(!r||!r.student)return;
    if(!confirm(`确定清除 ${name} 中的学生 ${r.student} ?`))return;
    
    const studentName = r.student;  // 保存学生名称
    
    addPracticeLog(r.student,r.name,r.registerTime,Date.now(),'手动清除');
    // 🔥 新增：结束练习时长记录
    const sessionId = `${studentName}_${name}_${r.registerTime}`;
    endPracticeSession(sessionId, Date.now(), '手动清除');

    
    // 🔥 确保设置为 null 而不是 undefined
  r.student = null;
  r.registerTime = null;
  r.clearTime = Date.now(); // 记录清空时间用于保护
    
    // 🔥 使用统一的房间状态变化处理
    handleRoomStatusChange('room_clear', {
        roomName: name,
        clearedStudent: studentName,
        source: 'manual_clear'
    });
    
    needsFullUpdate=true;
    updateRooms();
    
    showToast('已清除');
    
  // 🔥 新增：刷新搜索结果
  refreshSearchResults();
  // 🔥 立即推送单房间清空（跳过批量防抖）
  try{ performActualSync('single_clear',{room:name}); }catch(e){ console.warn('single_clear sync failed',e); }
}

function clearOvertimeRoom(name){
  if(isLocked){alert('系统已锁定');return;}
  const r=rooms.find(x=>x.name===name);
  if(!r||!r.student)return;
  if(!confirm(`确定清除 ${name} 中的学生 ${r.student} ?`))return;
  
  const studentName = r.student;  // 保存学生名称
  const operationTime = Date.now();
  
  addPracticeLog(r.student,r.name,r.registerTime,operationTime,'超时管理清除');
  
  // 🔥 确保设置为 null 而不是 undefined
  r.student = null;
  r.registerTime = null;
  r.clearTime = Date.now();
  
  // 🔥 使用统一的房间状态变化处理
  handleRoomStatusChange('overtime_clear', {
      roomName: name,
      clearedStudent: studentName,
      source: 'overtime_management'
  });
  
  // 刷新UI
  needsFullUpdate=true;
  updateRooms();
  
  // 若超时管理面板当前可见则立即重渲染
  const modal = $('overtimeModal');
  if(modal && modal.style.display === 'block'){
    renderOvertimeList(true);
  }
  
  showToast('已清除');
  
  // 🔥 新增：刷新搜索结果
  refreshSearchResults();
  // 🔥 立即推送单房间清空
  try{ performActualSync('single_clear',{room:name}); }catch(e){ console.warn('single_clear sync failed',e); }
}

window.clearOvertimeRoom = clearOvertimeRoom; // 供内联 onclick 使用

/* 练琴日志 */
function addPracticeLog(student,room,start,end,reason='正常结束'){
  const prepare=60000;
  const actualStart=start+prepare;
  const dur=Math.max(0,end-actualStart);
  practiceLogs.push({
    student,room,startTime:start,endTime:end,
    duration:dur,actualStartTime:actualStart,
    date:new Date(start).toDateString(),endReason:reason
  });
  persistLogs();
}

/* =============== 6. 学生库与时间段（核心精简） =============== */
// 🔥 修复：改进 getStudentMajor 函数，增加年级识别
function getStudentMajor(studentName) {
    // 🔥 添加调试日志
    console.log('🔍 查找学生专业:', studentName);
    
    for (const [major, students] of Object.entries(studentDatabase)) {
        if (Array.isArray(students)) {
            const studentRecord = students.find(s => {
                if (typeof s === 'string') {
                    return s === studentName;
                } else if (typeof s === 'object' && s.name) {
                    return s.name === studentName;
                }
                return false;
            });
            
            if (studentRecord) {
                console.log('✅ 找到专业:', studentName, '->', major);
                return major;
            }
        }
    }
    
    console.warn('⚠️ 未找到学生专业，使用默认:', studentName, '-> 其他');
    return '其他';
}

// 🔥 新增：获取学生年级信息
function getStudentGrade(studentName) {
    for (const [major, students] of Object.entries(studentDatabase)) {
        if (Array.isArray(students)) {
            const studentRecord = students.find(s => {
                if (typeof s === 'string') {
                    return s === studentName;
                } else if (typeof s === 'object' && s.name) {
                    return s.name === studentName;
                }
                return false;
            });
            
            if (studentRecord && typeof studentRecord === 'object') {
                return studentRecord.grade || '';
            }
        }
    }
    return '';
}

// 🔥 新增：解析年级格式（支持G1-G12格式）
function parseGradeInput(input) {
    if (!input || typeof input !== 'string') return '';
    
    const cleaned = input.trim().toUpperCase();
    
    // 匹配 G1-G12 格式
    const gradeMatch = cleaned.match(/^G(\d{1,2})$/);
    if (gradeMatch) {
        const gradeNum = parseInt(gradeMatch[1]);
        if (gradeNum >= 1 && gradeNum <= 12) {
            return `G${gradeNum}`;
        }
    }
    
    // 匹配中文年级格式
    const chineseMatch = cleaned.match(/^(\d{1,2})[年级]?$/);
    if (chineseMatch) {
        const gradeNum = parseInt(chineseMatch[1]);
        if (gradeNum >= 1 && gradeNum <= 12) {
            return `G${gradeNum}`;
        }
    }
    
    // 直接数字格式
    const numMatch = cleaned.match(/^\d{1,2}$/);
    if (numMatch) {
        const gradeNum = parseInt(cleaned);
        if (gradeNum >= 1 && gradeNum <= 12) {
            return `G${gradeNum}`;
        }
    }
    
    return input; // 保持原输入，让用户自由填写
}

// 🔥 新增：格式化年级显示
function formatGradeDisplay(grade) {
    if (!grade) return '';
    
    const gradeMatch = grade.match(/^G(\d{1,2})$/);
    if (gradeMatch) {
        const num = parseInt(gradeMatch[1]);
        return `${num}年级`;
    }
    
    return grade;
}
// 🔥 修改：升级学生数据库结构以支持年级
function upgradeStudentDatabaseStructure() {
    let hasChanges = false;
    
    Object.keys(studentDatabase).forEach(major => {
        const students = studentDatabase[major];
        if (Array.isArray(students)) {
            const upgradedStudents = students.map(student => {
                if (typeof student === 'string') {
                    // 将字符串格式升级为对象格式
                    hasChanges = true;
                    return {
                        name: student,
                        grade: '' // 默认空年级，等待用户填写
                    };
                } else if (typeof student === 'object' && student.name) {
                    // 确保对象格式有年级字段
                    if (!student.hasOwnProperty('grade')) {
                        hasChanges = true;
                        student.grade = '';
                    }
                    return student;
                }
                return student;
            });
            studentDatabase[major] = upgradedStudents;
        }
    });
    
    if (hasChanges) {
        persistStudents();
        console.log('✅ 学生数据库结构已升级，支持年级信息');
    }
}


// 🔥 修改：获取学生姓名（兼容新旧格式）
/**
 * 🔥 修复：安全获取学生姓名（兼容所有格式）
 */
function getStudentName(studentRecord) {
    if (!studentRecord) {
        console.warn('⚠️ getStudentName: 学生记录为空');
        return '';
    }
    
    // 如果是字符串，直接返回
    if (typeof studentRecord === 'string') {
        return safeTrim(studentRecord);
    }
    
    // 如果是对象，尝试获取 name 字段
    if (typeof studentRecord === 'object' && studentRecord !== null) {
        if (studentRecord.name) {
            return safeTrim(studentRecord.name);
        }
        
        // 兼容其他可能的字段名
        if (studentRecord.studentName) {
            return safeTrim(studentRecord.studentName);
        }
        
        // 如果对象没有 name 字段，尝试转换为字符串
        console.warn('⚠️ 学生对象缺少 name 字段:', studentRecord);
        return safeTrim(JSON.stringify(studentRecord));
    }
    
    // 其他类型，转换为字符串
    console.warn('⚠️ 未知的学生数据类型:', typeof studentRecord, studentRecord);
    return safeTrim(studentRecord);
}


// 🔥 修改：获取学生完整信息
function getStudentInfo(studentName) {
    for (const [major, students] of Object.entries(studentDatabase)) {
        if (Array.isArray(students)) {
            const studentRecord = students.find(s => getStudentName(s) === studentName);
            if (studentRecord) {
                return {
                    name: getStudentName(studentRecord),
                    major: major,
                    grade: typeof studentRecord === 'object' ? (studentRecord.grade || '') : ''
                };
            }
        }
    }
    return { name: studentName, major: '其他', grade: '' };
}
/**
 * 🔥 修复：数据库清理和验证函数
 */
function validateAndCleanStudentDatabase() {
    console.log('🔧 开始验证和清理学生数据库...');
    
    let cleanedCount = 0;
    let errorCount = 0;
    
    Object.keys(studentDatabase).forEach(major => {
        if (!Array.isArray(studentDatabase[major])) {
            console.warn(`⚠️ 专业 ${major} 的数据不是数组，尝试修复...`);
            
            // 尝试修复非数组数据
            if (typeof studentDatabase[major] === 'object' && studentDatabase[major] !== null) {
                studentDatabase[major] = Object.values(studentDatabase[major]).filter(v => v);
            } else {
                studentDatabase[major] = [];
            }
            cleanedCount++;
        }
        
        // 清理数组中的无效数据
        const originalLength = studentDatabase[major].length;
        studentDatabase[major] = studentDatabase[major].filter(student => {
            try {
                const name = getStudentName(student);
                if (!name || name.length === 0) {
                    console.warn(`⚠️ 发现空姓名学生记录:`, student);
                    errorCount++;
                    return false;
                }
                return true;
            } catch (error) {
                console.error(`❌ 处理学生记录时出错:`, student, error);
                errorCount++;
                return false;
            }
        });
        
        if (studentDatabase[major].length !== originalLength) {
            cleanedCount++;
            console.log(`🔧 专业 ${major}: 清理了 ${originalLength - studentDatabase[major].length} 个无效记录`);
        }
        
        // 确保所有学生记录都是正确的格式
        studentDatabase[major] = studentDatabase[major].map(student => {
            if (typeof student === 'string') {
                return {
                    name: student,
                    grade: ''
                };
            } else if (typeof student === 'object' && student !== null) {
                return {
                    name: getStudentName(student),
                    grade: student.grade || ''
                };
            } else {
                return {
                    name: String(student),
                    grade: ''
                };
            }
        });
    });
    
    // 移除空专业
    Object.keys(studentDatabase).forEach(major => {
        if (!studentDatabase[major] || studentDatabase[major].length === 0) {
            delete studentDatabase[major];
            cleanedCount++;
        }
    });
    
    if (cleanedCount > 0 || errorCount > 0) {
        persistStudents();
        console.log(`✅ 数据库清理完成: 清理了 ${cleanedCount} 个问题，移除了 ${errorCount} 个无效记录`);
        showToast(`🔧 数据库已清理: 修复 ${cleanedCount} 个问题`, 3000);
    } else {
        console.log('✅ 学生数据库验证通过，无需清理');
    }
    
    return { cleanedCount, errorCount };
}

function handleRoomClick(name){
  if(isLocked){alert('系统已锁定');return;}
  const room = rooms.find(r=>r.name===name);
  if(!room) return;

  const type = room.pianoKind==='三角钢琴' ? 'grand' :
               room.pianoKind==='立式钢琴' ? 'upright' : 'none';

  // 若该类型有排队 -> 打开快速分配/替换弹窗
  if(queueList[type] && queueList[type].length){
    showQueueModal(name,type);
    return;
  }

  // 没有排队
  if(room.student){
    alert('该琴房正在使用中，无排队不能直接替换。');
    return;
  }
  currentRoom = name;
  openStudentSelectModal(room);
}

function openStudentSelectModal(room){
  $('modalStudentSearch').value='';
  $('studentListModal').style.display='block';
  
  // 初始化输入处理器（如果还没有）
  setTimeout(() => {
    if (!inputHandlers.has('modalStudentSearch')) {
      const handler = new SmartInputHandler('modalStudentSearch', searchStudentsModal);
      inputHandlers.set('modalStudentSearch', handler);
    }
    
    // 聚焦到搜索框
    const searchInput = $('modalStudentSearch');
    if (searchInput) {
      searchInput.focus();
    }
  }, 50);
  
  if(room.pianoKind==='三角钢琴') renderPianoStudents();
  else renderMajorButtons();
}

function renderPianoStudents(){
  const list=$('modalStudentList');
  const arr=studentDatabase['钢琴教研室']||[];
  const studentNames = arr.map(s => getStudentName(s)); // 🔥 修复：正确获取学生姓名
  list.innerHTML='<div class="category-title" style="margin-bottom:6px;">钢琴教研室</div>' +
    (studentNames.length ? studentNames.map(name=>renderStudentSelectable(name)).join('') : '<div style="text-align:center;color:#999;padding:15px;">暂无学生</div>');
  $('addNewStudentSection').style.display='block';
}

function renderMajorButtons(){
  const list=$('modalStudentList');
  const majors=Object.keys(studentDatabase);
  list.innerHTML='<div class="major-buttons" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:10px;">'+
    majors.map(m=>`<button class="major-btn" style="background:var(--primary-color);" onclick="showMajorStudents('${m}')">${m} (${studentDatabase[m].length})</button>`).join('')+
    '</div>';
  $('addNewStudentSection').style.display='none';
}
function showMajorStudents(m){
  const list=$('modalStudentList');
  const arr=studentDatabase[m]||[];
  const studentNames = arr.map(s => getStudentName(s)); // 🔥 修复：正确获取学生姓名
  let html=`<div class="major-header" style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
      <button class="back-btn" style="background:var(--secondary-color);" onclick="renderMajorButtons()">← 返回</button>
      <div class="category-title">${m} (${studentNames.length})</div>
    </div>`;
  html+=studentNames.map(name=>renderStudentSelectable(name)).join('');
  list.innerHTML=html;
  $('addNewStudentSection').style.display='block';
}

function renderStudentSelectable(name) {
    const statusInfo = getStudentStatusForModal(name);
    const occupiedRoom = rooms.find(r => r.student === name);
    const canForceReplace = statusInfo.isDisabled && occupiedRoom && currentRoom && occupiedRoom.name !== currentRoom;
    
    // 根据是否可以强制替换来决定点击行为
    let clickAction;
    if (statusInfo.isDisabled) {
        if (canForceReplace) {
            clickAction = `onclick="showStudentStatusHint('${name}','${statusInfo.reason||''}')"`;
        } else {
            clickAction = `onclick="showStudentStatusHint('${name}','${statusInfo.reason||''}')"`;
        }
    } else {
        clickAction = `onclick="selectStudent('${name}')"`;
    }
    
    // 添加特殊样式类
    let itemClass = 'student-item';
    if (statusInfo.isDisabled) {
        itemClass += ' disabled-student';
        if (canForceReplace) {
            itemClass += ' force-replaceable';
        }
    }
    
    return `<div class="${itemClass}" ${clickAction}>
        <span class="student-name-text">${name}</span>
        ${statusInfo.statusBadge || ''}
        ${canForceReplace ? '<span class="force-replace-hint" title="点击可强制替换">⚡</span>' : ''}
    </div>`;
}
function closeModal(){ 
  const modal = $('studentListModal');
  modal.style.display='none'; 
  currentRoom=null; 
  
  // 🔥 新增：触发模态框关闭事件
  modal.dispatchEvent(new CustomEvent('modalClosed'));
}

function searchStudentsModal(q){
  if(!currentRoom){
    console.warn('currentRoom is null in searchStudentsModal');
    return;
  }
  const room=rooms.find(r=>r.name===currentRoom);
  if(!room){
    console.warn('Room not found:', currentRoom);
    return;
  }
  
  const isGrand=room && room.pianoKind==='三角钢琴';
  const list=$('modalStudentList');
  q=q.trim();
  
  if(!q){
    if(isGrand) renderPianoStudents(); 
    else renderMajorButtons();
    return;
  }
  
  let out=[];
  if(isGrand){
    (studentDatabase['钢琴教研室']||[])
      .filter(s=>{
        const studentName = getStudentName(s); // 🔥 修复：正确获取学生姓名
        return matchPinyin(studentName, q);
      })
      .forEach(s=>out.push(renderStudentSelectable(getStudentName(s)))); // 🔥 修复：传递姓名字符串
  }else{
    for(const [m,arr] of Object.entries(studentDatabase)){
      const filtered=arr.filter(s=>{
        const studentName = getStudentName(s); // 🔥 修复：正确获取学生姓名
        return matchPinyin(studentName, q);
      });
      if(filtered.length){
        out.push(`<div class="category-title" style="margin-top:10px;">${m}</div>`);
        filtered.forEach(s=>out.push(renderStudentSelectable(getStudentName(s)))); // 🔥 修复：传递姓名字符串
      }
    }
  }
  
  if(!out.length){
    list.innerHTML=`<div style="text-align:center;color:#999;padding:20px;">未找到匹配学生</div>`;
    $('addNewStudentSection').style.display='block';
  }else{
    list.innerHTML=out.join('');
    $('addNewStudentSection').style.display='none';
  }
}

function addNewStudent(){
  const name=$('modalStudentSearch').value.trim();
  if(!name){alert('请输入姓名');return;}
  // 检查重复
  if(Object.values(studentDatabase).some(a=>a.includes(name))){
    alert('学生已存在');return;
  }
  const room=rooms.find(r=>r.name===currentRoom);
  let major='其他';
  if(room && room.pianoKind==='三角钢琴') major='钢琴教研室';
  else major=prompt('请输入学生专业(默认 其他)：','其他') || '其他';
  if(!studentDatabase[major]) studentDatabase[major]=[];
  studentDatabase[major].push(name);
  persistStudents();
  showToast('已添加 '+name);
  selectStudent(name);
}

function getStudentStatusForModal(student){
  // 占用
  const occ=rooms.find(r=>r.student===student);
  const inG=queueList.grand.includes(student);
  const inU=queueList.upright.includes(student);
  const inN=queueList.none.includes(student);
  let badge='',dis=false,cls='',reason='';
  if(occ){
    const now=Date.now();
    const prepEnd=occ.registerTime+60000;
    if(now<prepEnd){badge=`<span class="student-status-badge preparing">准备中:${occ.name}</span>`;reason='准备中';}
    else{
      const used=Math.floor((now-prepEnd)/1000);
      const limit=systemSettings.basePracticeDuration*60;
      if(used<=limit){badge=`<span class="student-status-badge practicing">练琴:${occ.name}</span>`;reason='练琴中';}
      else{badge=`<span class="student-status-badge overtime">超时:${occ.name}</span>`;reason='超时中';}
    }
    dis=true;cls='disabled-student';
  }else if(inG||inU||inN){
    let type=inG?'三角':inU?'立式':'普通';
    const pos=(inG?queueList.grand:inU?queueList.upright:queueList.none).indexOf(student)+1;
    badge=`<span class="student-status-badge queuing">${type}排队第${pos}位</span>`;
    reason='已在排队';
    dis=true;cls='disabled-student';
  }
  return {
    statusBadge:badge,
    isDisabled:dis,
    disabledClass:cls,
    reason
  };
}

// 修改 showStudentStatusHint 函数，添加强制替换选项
function showStudentStatusHint(name, reason) {
    // 获取学生当前状态详情
    const studentStatus = getStudentStatusForModal(name);
    const occupiedRoom = rooms.find(r => r.student === name);
    
    // 构建详细信息
    let detailInfo = `学生 ${name} 当前不可选择\n原因：${reason}`;
    
    if (occupiedRoom) {
        const now = Date.now();
        const prepEnd = occupiedRoom.registerTime + 60000;
        let timeInfo = '';
        
        if (now < prepEnd) {
            const remainSec = Math.ceil((prepEnd - now) / 1000);
            timeInfo = `正在 ${occupiedRoom.name} 准备中（剩余 ${remainSec} 秒）`;
        } else {
            const used = Math.floor((now - prepEnd) / 1000);
            const limit = systemSettings.basePracticeDuration * 60;
            if (used <= limit) {
                timeInfo = `正在 ${occupiedRoom.name} 练琴（已用 ${formatHMS(used)}）`;
            } else {
                const overtime = used - limit;
                timeInfo = `正在 ${occupiedRoom.name} 超时练琴（超时 ${formatDurationHuman(overtime)}）`;
            }
        }
        detailInfo += `\n当前状态：${timeInfo}`;
    }
    
    // 检查是否可以强制替换
    const canForceReplace = occupiedRoom && currentRoom && occupiedRoom.name !== currentRoom;
    
    if (canForceReplace) {
        detailInfo += `\n\n是否要将 ${name} 从 ${occupiedRoom.name} 转移到 ${currentRoom}？`;
        detailInfo += `\n⚠️ 注意：这将结束其在原琴房的练琴并记录到日志中。`;
        
        if (confirm(detailInfo)) {
            // 用户确认强制替换
            forceReplaceStudent(name, occupiedRoom.name, currentRoom);
        }
    } else {
        // 不能强制替换的情况，只显示信息
        alert(detailInfo);
    }
}

// 新增：强制替换学生函数
function forceReplaceStudent(studentName, fromRoom, toRoom) {
    if (isLocked) {
        alert('系统已锁定');
        return;
    }
    
    const fromRoomObj = rooms.find(r => r.name === fromRoom);
    const toRoomObj = rooms.find(r => r.name === toRoom);
    
    if (!fromRoomObj || !toRoomObj) {
        alert('琴房信息错误');
        return;
    }
    
    const now = Date.now();
    
    // 记录原琴房的练琴日志
    addPracticeLog(
        studentName,
        fromRoom,
        fromRoomObj.registerTime,
        now,
        `强制转移到 ${toRoom}`
    );
    
    // 如果目标琴房有其他学生，也要记录日志
    if (toRoomObj.student && toRoomObj.student !== studentName) {
        addPracticeLog(
            toRoomObj.student,
            toRoom,
            toRoomObj.registerTime,
            now,
            `被 ${studentName} 强制替换`
        );
    }
    
    // 清空原琴房
    fromRoomObj.student = null;
    fromRoomObj.registerTime = null;
    
    // 分配到新琴房
    toRoomObj.student = studentName;
    toRoomObj.registerTime = now;
    
    // 持久化和更新UI
    persistRooms();
    
    // 🔥 改进：带操作标识的同步
    if (syncEnabled && isOnline) {
        syncToFirebase('force_replace', {
            studentName,
            fromRoom,
            toRoom,
            timestamp: now,
            source: 'force_selection'
        });
    }
    
    needsFullUpdate = true;
    updateRooms();
    
    // 关闭学生选择模态框
    closeModal();
    
    // 刷新搜索结果
    refreshSearchResults();
    
    showToast(`${studentName} 已强制转移到 ${toRoom}`);
    
    // 记录操作日志
    logOperation('force_replace_student', {
        student: studentName,
        fromRoom,
        toRoom,
        timestamp: now
    });
}

async function selectStudent(student) {
    // 防连点：若已有正在进行的选择，直接忽略
    if (window.__selectingInProgress) {
        console.log('[selectStudent] 忽略重复点击:', student);
        return;
    }
    window.__selectingInProgress = true;
  window.__selectingStartTs = Date.now();
    // UI 禁用（按钮/可点击项）
    try{
      const modal = document.getElementById('studentSelectModal') || document;
      const clickable = modal.querySelectorAll('button, [data-student-name], .student-item, .student-row');
      clickable.forEach(el=>{ el.__oldPointerEvents = el.style.pointerEvents; el.style.pointerEvents='none'; el.classList.add('selecting-disabled'); });
    }catch(_){ }
    if (!currentRoom) {
        console.error('currentRoom is null when selecting student:', student);
        showToast('错误：未选择琴房');
        closeModal();
        return;
    }
    
    const room = rooms.find(r => r.name === currentRoom);
    if (!room) {
        console.error('Room not found:', currentRoom);
        showToast('错误：琴房不存在');
        closeModal();
        return;
    }
    
    // 🔥 新增：检查操作锁
    const lockKey = `assign_${student}`;
    if (operationLocks.has(lockKey)) {
        // 检查锁是否超时
        const lockTime = operationLockTimestamps.get(lockKey);
        if (lockTime && (Date.now() - lockTime > OPERATION_LOCK_TIMEOUT)) {
            // 超时锁，自动清理
            operationLocks.delete(lockKey);
            operationLockTimestamps.delete(lockKey);
            console.log('🔓 操作锁超时清理:', lockKey);
        } else {
            showToast('该学生正在被其他操作处理中，请稍后重试');
            return;
        }
    }
    
    // 🔥 新增：添加操作锁
    operationLocks.add(lockKey);
    operationLockTimestamps.set(lockKey, Date.now());
    console.log('🔒 设置操作锁:', lockKey, '当前锁数量:', operationLocks.size);
    
    try {
        // 🔥 新增：使用 Firebase 事务确保原子性
        const success = await assignStudentWithTransaction(student, room);
        if (success) {
            showToast(`${student} 已登记到 ${room.name}`);
            closeModal();
            // 🔥 新增：刷新搜索结果
            refreshSearchResults();
        } else {
            showToast('分配失败：学生可能已被其他设备分配');
        }
    } catch (error) {
        console.error('分配学生时发生错误:', error);
        showToast('操作失败，请重试');
    } finally {
        // 🔥 移除操作锁
        operationLocks.delete(lockKey);
        operationLockTimestamps.delete(lockKey);
        console.log('🔓 移除操作锁:', lockKey, '剩余锁数量:', operationLocks.size);
        // 解除 UI 禁用
        try{
          const modal = document.getElementById('studentSelectModal') || document;
          const clickable = modal.querySelectorAll('button, [data-student-name], .student-item, .student-row');
          clickable.forEach(el=>{ el.style.pointerEvents = el.__oldPointerEvents || ''; el.classList.remove('selecting-disabled'); });
        }catch(_){ }
        window.__selectingInProgress = false;
    window.__selectingStartTs = null;
    if(operationLocks.size===0 && window.__pendingRemoteRooms){
      const queued = window.__pendingRemoteRooms;
      window.__pendingRemoteRooms = null; window.__pendingRemoteRoomsAttempts=0; window.__pendingRemoteRoomsFirstTs=null; window.__remoteQueueNoticeShown=false;
      setTimeout(()=>{ try{ handleRemoteRoomsUpdate(queued);}catch(e){console.warn('处理排队远程更新失败',e);} }, 30);
    }
    }
}

// ✅ 修复版：使用旧式 / compat transaction 写法
async function assignStudentWithTransaction(student, targetRoom) {
    if (!database || !isOnline) {
        return assignStudentLocal(student, targetRoom);
    }

    const roomsRef = database.ref('rooms');
  let abortReason = null; // 标记事务放弃原因（区分最近占用 vs 其它）

    // 记录本地快照用于后续日志对比（避免在事务函数里做副作用）
    const localBefore = Array.isArray(rooms) ? rooms.map(r => r ? {
        name: r.name,
        student: r.student,
        registerTime: r.registerTime
    } : r) : [];

    // 用于在 updateFunction 内暂存变化（只存数据，不写日志，不做外部调用）
    let changeSummary = null;

    const result = await new Promise((resolve, reject) => {
        roomsRef.transaction(function(currentRooms){
            if (!Array.isArray(currentRooms)) {
                // 云端还不是数组或为空 → 不做写入，等待初始化逻辑
                return currentRooms;
            }

            const idx = currentRooms.findIndex(r => r && r.name === targetRoom.name);
            if (idx === -1) {
                console.warn('事务中止：找不到房间', targetRoom.name);
                return; // undefined → abort，不提交
            }

            // 克隆
            const next = currentRooms.slice();

            const now = Date.now();

            // 学生是否在其它房间
            const otherIndex = next.findIndex((r,i)=> r && r.student === student && i !== idx);

            // 目标房间当前占用者
            const originalStudent = next[idx].student || null;
            const originalRegister = next[idx].registerTime || null;

            // 如果同一个学生已经在目标房间，无需改动（返回原数组，事务会判断无变化）
            if (originalStudent === student) {
                return currentRooms; // 不做变化
            }

      // “刚刚被别人占用”防抖：窗口从 5000ms 减为 1500ms (A)
      if (originalStudent && originalStudent !== student) {
        const existingTime = next[idx].registerTime || 0;
        if (now - existingTime < 1500) {
          console.log('🚫 拒绝覆盖：房间刚被', originalStudent, '占用 <1.5s');
          abortReason = 'recent_occupy';
          return; // abort (committed=false)
        }
      }

            // 先清理该学生在其它房间的占用
            let clearedRoom = null;
            if (otherIndex !== -1) {
                clearedRoom = {
                    name: next[otherIndex].name,
                    fromRegisterTime: next[otherIndex].registerTime
                };
                next[otherIndex] = {
                    ...next[otherIndex],
                    student: null,
                    registerTime: null
                };
            }

            // 写入目标房间
            next[idx] = {
                ...next[idx],
                student: student,
                registerTime: now
            };

            // 记录变化概要（不会写到数据库，只在 JS 里，用于提交成功后生成日志）
            changeSummary = {
                targetRoom: next[idx].name,
                newStudent: student,
                previousStudent: originalStudent,
                previousRegisterTime: originalRegister,
                clearedRoom: clearedRoom
            };

            return next;
        }, function(error, committed, snapshot){
            if (error) return reject(error);
            resolve({ committed, snapshot });
        }, false); // 第三个参数是 applyLocally（可 true/false；false = 不做乐观本地更新）
    });

  if (!result.committed) {
    if (abortReason === 'recent_occupy') {
      console.warn('⚠️ 事务未提交：房间刚被占用(1.5s 防抖)');
      showToast('房间刚被占用，请 1~2 秒后再试');
    } else {
      console.warn('⚠️ 事务未提交（条件不满足或被并发覆盖）');
    }
    return false;
  }

    const serverRooms = result.snapshot.val();
    if (!Array.isArray(serverRooms)) {
        console.warn('⚠️ 事务后云端 rooms 非数组，忽略');
        return false;
    }

    // 更新本地（建议整体替换，保持与云端一致）
    syncEnabled = false;
    rooms = serverRooms.map(r => r ? { ...r } : r);
    persistRooms();
    needsFullUpdate = true;
    updateRooms();
    triggerRealTimePracticeStatusUpdate();
    setTimeout(()=>{ syncEnabled = true; }, 500);

    // 现在再写日志（不会重复）
    if (changeSummary) {
        const now = Date.now();
        if (changeSummary.previousStudent && changeSummary.previousStudent !== student) {
            addPracticeLog(
                changeSummary.previousStudent,
                changeSummary.targetRoom,
                changeSummary.previousRegisterTime,
                now,
                `被 ${student} 替换(事务)`
            );
        }
        if (changeSummary.clearedRoom) {
            addPracticeLog(
                student,
                changeSummary.clearedRoom.name,
                changeSummary.clearedRoom.fromRegisterTime,
                now,
                '转移(事务)'
            );
        }
    }

    return true;
}

// 🔥 新增：清理超时的操作锁
function cleanupExpiredOperationLocks() {
    const now = Date.now();
    let cleaned = 0;
    
    for (const [lockKey, timestamp] of operationLockTimestamps.entries()) {
        if (now - timestamp > OPERATION_LOCK_TIMEOUT) {
            operationLocks.delete(lockKey);
            operationLockTimestamps.delete(lockKey);
            cleaned++;
            console.log('🔓 操作锁超时清理:', lockKey, '持续时间:', Math.round((now - timestamp) / 1000), '秒');
        }
    }
    
    if (cleaned > 0) {
        console.log(`🧹 已清理 ${cleaned} 个超时操作锁`);
    }
}

// 周期性清理遗留操作锁 (D) - 每 30 秒
if(!window.__opLockCleaner){
  window.__opLockCleaner = setInterval(()=>{
    try{ cleanupExpiredOperationLocks(); }catch(e){ console.warn('cleanupExpiredOperationLocks error', e); }
    // 锁看门狗：检测长时间未释放的锁 (>20s) 主动释放
    try{
      const now = Date.now();
      for(const [k,ts] of operationLockTimestamps.entries()){
        if(now - ts > 20000){
          console.warn('[lock-watchdog] 强制释放长时间锁', k, '存活(ms)=', now-ts);
          operationLocks.delete(k); operationLockTimestamps.delete(k);
        }
      }
      if(operationLocks.size===0 && window.__pendingRemoteRooms){
        const queued = window.__pendingRemoteRooms;
        window.__pendingRemoteRooms = null; window.__pendingRemoteRoomsAttempts=0; window.__pendingRemoteRoomsFirstTs=null; window.__remoteQueueNoticeShown=false;
        setTimeout(()=>{ try{ handleRemoteRoomsUpdate(queued);}catch(e){console.warn('处理排队远程更新失败',e);} }, 10);
      }
    }catch(e){ console.warn('lock watchdog error', e); }
    // selectingInProgress 超时自愈 (>8s)
    try{
      if(window.__selectingInProgress && window.__selectingStartTs && (Date.now() - window.__selectingStartTs > 8000)){
        console.warn('[selecting-watchdog] 释放卡住的选择流程');
        window.__selectingInProgress=false; window.__selectingStartTs=null;
        const modal = document.getElementById('studentSelectModal') || document;
        const clickable = modal.querySelectorAll('button, [data-student-name], .student-item, .student-row');
        clickable.forEach(el=>{ el.style.pointerEvents = el.__oldPointerEvents || ''; el.classList.remove('selecting-disabled'); });
      }
    }catch(e){ console.warn('selecting watchdog error', e); }
  }, 30000);
}

// 🔥 新增：手动清理所有操作锁（调试用）
function clearAllOperationLocks() {
    const count = operationLocks.size;
    operationLocks.clear();
    operationLockTimestamps.clear();
    console.log(`🧹 已手动清理 ${count} 个操作锁`);
    showToast(`已清理 ${count} 个操作锁`);
}


// 🔥 新增：本地分配函数（离线模式或事务失败时使用）
function assignStudentLocal(student, room) {
    // 🔥 增强：本地冲突检测
    const occupiedRooms = rooms.filter(r => r.student === student);
    const otherRooms = occupiedRooms.filter(r => r.name !== room.name);
    
    if (otherRooms.length > 0) {
        const confirmMsg = `学生 ${student} 正在 ${otherRooms.map(r => r.name).join('、')} 练琴，是否转移到 ${room.name}?`;
        if (!confirm(confirmMsg)) {
            return false;
        }
        
        // 清空其他房间
        const now = Date.now();
        otherRooms.forEach(or => {
            addPracticeLog(or.student, or.name, or.registerTime, now, '转移(本地冲突解决)');
            or.student = null;
            or.registerTime = null;
        });
    }
    
    // 🔥 增强：检查目标房间状态
    if (room.student && room.student !== student) {
        const confirmReplace = confirm(`${room.name} 正被 ${room.student} 使用，确定要替换吗？`);
        if (!confirmReplace) {
            return false;
        }
    }
    
    // 分配到目标房间
    assignStudentToRoom(student, room, Date.now());
    return true;
}


function assignStudentToRoom(student, room, time) {
    // 🔥 增强：记录被替换学生的详细日志
    if (room.student && room.student !== student) {
        addPracticeLog(room.student, room.name, room.registerTime, time, `被 ${student} 替换`);
        console.log(`📝 记录被替换: ${room.student} 在 ${room.name} 被 ${student} 替换`);
    }
    
    // 🔥 确保数据一致性
    room.student = student;
    // 🔥 新增：开始练习时长记录
    startPracticeSession(student, room.name, time);

    room.registerTime = time;
    
    // 🔥 使用统一的房间状态变化处理
    handleRoomStatusChange('student_assign', {
        roomName: room.name,
        studentName: student,
        source: 'student_selection'
    });
    
    needsFullUpdate = true;
    updateRooms();
    
    // 🔥 记录操作日志
    logOperation('student_assign', {
        student: student,
        room: room.name,
        timestamp: time,
        method: 'assignStudentToRoom'
    });
}


function refreshAllDerivedAfterSlotChange(affectedStudents){
  // 1. 立即重算考勤
  checkAttendance();
  // 2. 清理相关异常提醒
  if (Array.isArray(affectedStudents)) {
    const before = practiceOverrunReminders.length;
    practiceOverrunReminders = practiceOverrunReminders.filter(r=> !affectedStudents.includes(r.student));
    if (practiceOverrunReminders.length !== before) {
      persistOverruns(true,'slot_change_cleanup',{removed:before-practiceOverrunReminders.length});
      updateOverrunPanel();
    }
  }
  // 3. 正在进行的会话更新 currentSlot
  practiceSessionTracker.forEach(sess=>{
     if(affectedStudents && affectedStudents.includes(sess.studentName)){
        sess.currentSlot = findCurrentTimeSlot(getStudentTodaySlots(sess.studentName), Date.now());
     }
  });
}


function addTimeSlot(){
  if(!currentEditingStudent||!currentEditingWeekday) return;
  const sh=$('startHour').value, sm=$('startMinute').value, eh=$('endHour').value, em=$('endMinute').value;
  const start=`${sh}:${sm}`, end=`${eh}:${em}`;
  if(!validateTimeSlot(start,end)) return;
  
  // 确保学生时间段结构存在
  initStudentSlotStructure(currentEditingStudent);
  
  // 添加安全检查，确保 dayArr 存在
  const dayArr = studentTimeSlots[currentEditingStudent][currentEditingWeekday];
  if(!dayArr) {
    // 如果仍然不存在，重新初始化
    studentTimeSlots[currentEditingStudent][currentEditingWeekday] = [];
  }
  
  const finalDayArr = studentTimeSlots[currentEditingStudent][currentEditingWeekday];
  
  if(hasTimeConflict(finalDayArr,{start,end})){
    alert('时间冲突');return;
  }
  
  finalDayArr.push({start,end,duration:calcDurationText(start,end)});
  finalDayArr.sort((a,b)=>a.start.localeCompare(b.start));
  persistStudentSlots();
  displayCurrentTimeSlots();
  
  // 🔥 修复：只在学生数据库模态框确实打开且当前不在时间段管理中时才刷新学生列表
  if($('studentDatabaseModal').style.display === 'block' && $('timeSlotModal').style.display !== 'block'){
    renderStudentDatabaseList();
  }
  refreshAllDerivedAfterSlotChange([currentEditingStudent]);
  showToast('已添加时间段');
}

function initStudentSlotStructure(name){
  if(!studentTimeSlots[name]){
    studentTimeSlots[name]={monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]};
  }
  // 额外检查：确保每个星期的数组都存在
  ['monday','tuesday','wednesday','thursday','friday'].forEach(day => {
    if(!studentTimeSlots[name][day]) {
      studentTimeSlots[name][day] = [];
    }
  });
}

function validateTimeSlot(start,end){
  const s=timeToMinutes(start), e=timeToMinutes(end);
  if(isNaN(s)||isNaN(e)){alert('时间格式无效');return false;}
  if(e<=s){alert('结束时间必须晚于开始时间');return false;}
  // 允许 00:00 - 23:59 之间任意分钟
  if(s<0 || e>24*60){alert('时间需在 00:00 - 23:59 范围内');return false;}
  return true;
}

function hasTimeConflict(list,slot){
  const ns=timeToMinutes(slot.start), ne=timeToMinutes(slot.end);
  return list.some(s=>{
    const es=timeToMinutes(s.start), ee=timeToMinutes(s.end);
    return ns<ee && ne>es;
  });
}
function calcDurationText(start,end){
  const m=timeToMinutes(end)-timeToMinutes(start);
  const h=Math.floor(m/60),mm=m%60;
  if(h && mm) return `${h}小时${mm}分钟`;
  if(h) return `${h}小时`;
  return `${mm}分钟`;
}

/* 时间段管理（仅保留调用需要的核心 UI 函数变量） */
let currentEditingStudent=null;
let currentEditingWeekday='monday';
let currentEditingMajor=null;

function manageStudentTimeSlots(student,major){
  currentEditingStudent=student;
  currentEditingMajor=major;
  currentEditingWeekday='monday';
  $('timeSlotModalTitle').textContent=`管理 ${student} 的练琴时间段`;
  initTimeSelectors();
  selectWeekday('monday');
  displayWeeklySummary();
  $('timeSlotModal').style.display='block';
}
function initTimeSelectors(){
  const sh=$('startHour'), eh=$('endHour'), sm=$('startMinute'), em=$('endMinute');
  sh.innerHTML=''; eh.innerHTML=''; sm.innerHTML=''; em.innerHTML='';
  
  // 小时 0-23
  for(let h=0; h<=23; h++){
    const opt=`<option>${pad2(h)}</option>`;
    sh.innerHTML+=opt;
    eh.innerHTML+=opt;
  }
  
  // 🔥 修改：分钟只能选择 10 的倍数
  for(let m=0;m<60;m++){
    const opt=`<option>${pad2(m)}</option>`;
    sm.innerHTML+=opt;
    em.innerHTML+=opt;
  }

  
  // 默认：08:00 - 09:00
  sh.value='08'; sm.value='00';
  eh.value='09'; em.value='00';
}

function selectWeekday(d){
  currentEditingWeekday=d;
  document.querySelectorAll('.weekday-btn').forEach(b=>b.classList.toggle('active',b.dataset.day===d));
  $('currentDayTitle').textContent=WEEK_CN[d]+'时间段：';
  displayCurrentTimeSlots();
}
function displayCurrentTimeSlots(){
  const c=$('currentTimeSlotsList');
  const slots=studentTimeSlots[currentEditingStudent]?.[currentEditingWeekday]||[];
  if(!slots.length){c.innerHTML='<div style="text-align:center;color:#999;padding:20px;">当前星期暂无时间段</div>';displayWeeklySummary();return;}
  c.innerHTML=slots.map((s,i)=>`
    <div class="time-slot-item">
      <div class="time-slot-info">
        <div class="time-slot-time">${s.start} - ${s.end}</div>
        <div class="time-slot-duration">时长：${s.duration}</div>
      </div>
      <button class="delete-time-slot" onclick="deleteTimeSlot(${i})">删除</button>
    </div>`).join('');
  displayWeeklySummary();
}
function deleteTimeSlot(i){
  if(!currentEditingStudent) return;
  const arr=studentTimeSlots[currentEditingStudent][currentEditingWeekday];
  if(!arr||!arr[i])return;
  if(!confirm(`删除时间段 ${arr[i].start}-${arr[i].end}?`))return;
  
  // 删除指定的时间段
  arr.splice(i,1);
  
  // 检查是否所有时间段都被清空
  const hasAnySlots = Object.values(studentTimeSlots[currentEditingStudent]).some(a=>a.length);
  if(!hasAnySlots) {
    // 如果所有时间段都被清空，删除该学生的时间段记录
    delete studentTimeSlots[currentEditingStudent];
  }
  
  // 持久化数据
  persistStudentSlots();
  
  // 🔥 修复：只刷新当前时间段管理界面，不触发外部界面刷新
  displayCurrentTimeSlots();
  
  // 🔥 修复：只在学生数据库模态框确实打开且当前不在时间段管理中时才刷新学生列表
  if($('studentDatabaseModal').style.display === 'block' && $('timeSlotModal').style.display !== 'block'){
    renderStudentDatabaseList();
  }
  
  // 刷新相关的派生数据（考勤、异常提醒等）
  refreshAllDerivedAfterSlotChange([currentEditingStudent]);
  
  showToast('已删除时间段');
}

function displayWeeklySummary(){
  const box=$('weeklySummaryDisplay');
  const data=studentTimeSlots[currentEditingStudent];
  if(!data){box.innerHTML='<div class="weekly-summary-empty">暂无时间段设置</div>';return;}
  let html='';let total=0;
  Object.keys(WEEK_CN).forEach(k=>{
    const arr=data[k]||[];
    if(arr.length){
      total+=arr.length;
      html+=`<div class="weekly-summary-day">
        <div class="weekly-summary-day-title">${WEEK_CN[k]} (${arr.length}段)</div>
        <div>${arr.map(s=>`<span class="weekly-summary-slot">${s.start}-${s.end}</span>`).join('')}</div>
      </div>`;
    }
  });
  if(!html) html='<div class="weekly-summary-empty">暂无时间段设置</div>';
  box.innerHTML=html;
}
function clearAllTimeSlots(){
  if(!currentEditingStudent) return;
  const d=studentTimeSlots[currentEditingStudent];
  if(!d){showToast('无时间段');return;}
  let total=Object.values(d).reduce((a,b)=>a+b.length,0);
  if(!total){showToast('无时间段');return;}
  if(!confirm(`确定清空 ${currentEditingStudent} 的全部 ${total} 个时间段?`))return;
  delete studentTimeSlots[currentEditingStudent];
  persistStudentSlots();
  displayCurrentTimeSlots();
  // 🔥 修复：只在学生数据库模态框确实打开且当前不在时间段管理中时才刷新学生列表
  if($('studentDatabaseModal').style.display === 'block' && $('timeSlotModal').style.display !== 'block'){
    renderStudentDatabaseList();
  }
  refreshAllDerivedAfterSlotChange([currentEditingStudent]);
  showToast('已清空');
}

function closeTimeSlotModal(){
  $('timeSlotModal').style.display='none';
  currentEditingStudent=null;
  currentEditingMajor=null;
  currentEditingWeekday='monday';
  
  // 🔥 新增：关闭时间段管理后，如果学生数据库模态框是打开的，刷新学生列表
  if($('studentDatabaseModal').style.display === 'block'){
    renderStudentDatabaseList();
  }
}


function searchStudentDatabase(){
  // 只需要重新渲染即可（renderStudentDatabaseList 会读取输入框值）
  renderStudentDatabaseList();
}
function refreshAllMajorSelectors(){
  populateMajorFilter();           // 学生库筛选
  populateGradeFilter();           // 🔥 新增年级筛选
  populateAttendanceMajorFilter(); // 考勤筛选（下面新增）
}
function populateAttendanceMajorFilter(){
  const sel = $('attendanceMajorFilter');
  if(!sel) return;
  const current = sel.value;
  const majors = Object.keys(studentDatabase).sort((a,b)=>a.localeCompare(b,'zh-Hans-CN'));
  sel.innerHTML = '<option value="">所有专业</option>' +
    majors.map(m=>`<option value="${m}">${m}</option>`).join('');
  // 尽量保留用户当前选择
  if([...sel.options].some(o=>o.value===current)) sel.value=current;
}
function cleanupEmptyMajors(){
  let removed = 0;
  Object.keys(studentDatabase).forEach(m=>{
    if(!Array.isArray(studentDatabase[m]) || studentDatabase[m].length===0){
      delete studentDatabase[m];
      removed++;
    }
  });
  if(removed){
    persistStudents();
    refreshAllMajorSelectors();
  }
}
function injectStudentDbHint(){
  if(document.querySelector('.usage-tip')) return;
  const modal=$('studentDatabaseModal').querySelector('.modal-content');
  const tip=document.createElement('div');
  tip.className='usage-tip';
  tip.style.cssText='background:#e8f5e8;border:1px solid #27ae60;border-radius:6px;padding:10px;font-size:12px;color:#27ae60;margin:10px 0;cursor:pointer;';
  tip.innerHTML='<div style="font-weight:700;">💡 使用提示 (点击展开)</div><div style="display:none;line-height:1.5;margin-top:6px;">' +
    '• 只有工作日考勤；时间段分钟为10的倍数；支持 CSV 智能增量导入；请假功能在考勤面板。' +
    '</div>';
  tip.addEventListener('click',()=>{
    const c=tip.querySelector('div:nth-child(2)');
    const show=c.style.display!=='none';
    c.style.display=show?'none':'block';
  });
  modal.insertBefore(tip,modal.children[2]);
}
function populateMajorFilter(){
  const sel=$('majorFilter');
  const majors=Object.keys(studentDatabase).sort((a,b)=>a.localeCompare(b,'zh-Hans-CN'));
  sel.innerHTML='<option value="">所有专业</option>'+majors.map(m=>`<option value="${m}">${m}</option>`).join('');
}
function renderStudentDatabaseList(){
  const box = $('studentDatabaseList');
  if(!box) return;
  const q = $('studentDbSearch') ? $('studentDbSearch').value.trim() : '';
  const filter = $('majorFilter') ? $('majorFilter').value : '';
  const gradeFilter = $('gradeFilter') ? $('gradeFilter').value : ''; // 🔥 新增年级筛选

  // 保底格式化
  Object.keys(studentDatabase).forEach(m=>{
    if(!Array.isArray(studentDatabase[m])){
      studentDatabase[m] = (studentDatabase[m] && typeof studentDatabase[m]==='object')
        ? Object.values(studentDatabase[m]).filter(v=>typeof v==='string')
        : [];
    }
  });

  const majors = Object.keys(studentDatabase)
    .sort((a,b)=>a.localeCompare(b,'zh-Hans-CN'));

  let html='';
  let shownStudents = 0;

  majors.forEach(m=>{
    if(filter && filter!==m) return;
    const students = studentDatabase[m]
      .filter(s=>{
        const name = getStudentName(s);
        const grade = typeof s === 'object' ? (s.grade || '') : '';
        
        // 🔥 新增：年级筛选
        if(gradeFilter) {
          if(gradeFilter === 'no_grade' && grade) return false;
          if(gradeFilter !== 'no_grade' && grade !== gradeFilter) return false;
        }
        
        return matchPinyin(name, q);
      })
      .sort((a,b)=>{
        const nameA = getStudentName(a);
        const nameB = getStudentName(b);
        return nameA.localeCompare(nameB,'zh-Hans-CN');
      });

    if(!students.length) return;

    shownStudents += students.length;

    html += `
      <div class="student-major-block" data-major="${m}">
        <div class="student-major-header" style="
          display:flex;justify-content:space-between;align-items:center;
          background:#f0f6fb;border:1px solid #d5e4f1;
          padding:8px 12px;border-radius:8px;margin-top:14px;cursor:pointer;
        " onclick="toggleMajorCollapse('${m}')">
          <div style="font-weight:700;color:#2c3e50;">${m} 
            <span style="font-size:12px;color:#666;font-weight:500;">(${students.length})</span>
          </div>
          <div style="font-size:12px;color:#3498db;" id="majorCollapseIcon_${m}">收起 ▲</div>
        </div>
        <div class="student-major-body" id="majorBody_${m}" style="border:1px solid #e0e6eb;border-top:none;border-radius:0 0 8px 8px;padding:6px 6px 2px 6px;">
          ${students.map(s=>{
            const name = getStudentName(s);
            const grade = typeof s === 'object' ? (s.grade || '') : '';
            const hasSlots = studentTimeSlots[name] && Object.values(studentTimeSlots[name]).some(daySlots => daySlots.length > 0);
            const slotCount = hasSlots ? Object.values(studentTimeSlots[name]).reduce((total, daySlots) => total + daySlots.length, 0) : 0;
            
            return `<div class="student-db-item" style="border:none;border-bottom:1px solid #eef3f6;">
              <div class="student-info">
                <span class="student-name">${name}</span>
                <span class="major-badge">${m}</span>
                ${grade ? `<span class="grade-badge" style="background:#e67e22;color:#fff;font-size:10px;padding:2px 6px;border-radius:10px;margin-left:4px;">${formatGradeDisplay(grade)}</span>` : ''}
                ${hasSlots ? `<span class="slot-count-badge" style="background:#27ae60;color:#fff;font-size:10px;padding:2px 6px;border-radius:10px;margin-left:4px;">${slotCount}段</span>` : ''}
                <div class="time-slots-display" style="margin-top:6px;">
                  ${getStudentTimeSlotsDisplay(name)}
                </div>
              </div>
              <div class="student-actions">
                <button class="student-action-btn ${hasSlots?'edit-btn':'add-time-btn'}" onclick="manageStudentTimeSlots('${name}','${m}')" style="background:${hasSlots?'#3498db':'#27ae60'};">
                  ${hasSlots?'⏰ 管理时间段':'➕ 添加时间段'}
                </button>
                <button class="student-action-btn edit-btn" onclick="editStudent('${name}','${m}')">编辑</button>
                <button class="student-action-btn delete-btn" onclick="deleteStudent('${name}','${m}')">删除</button>
              </div>
            </div>`;
          }).join('')}
        </div>
      </div>`;
  });

  if(!html){
    if(q){
      html=`<div class="empty-database">未找到匹配结果：${q}</div>`;
    }else{
      html='<div class="empty-database">暂无学生</div>';
    }
  }

  box.innerHTML = html;
  
  // 🔥 增强统计信息，包含年级统计
  const totalSlots = Object.values(studentTimeSlots).reduce((total, studentSlots) => {
    return total + Object.values(studentSlots).reduce((dayTotal, daySlots) => dayTotal + daySlots.length, 0);
  }, 0);
  
  // 统计年级分布
  const gradeStats = {};
  let studentsWithGrade = 0;
  Object.values(studentDatabase).forEach(students => {
    students.forEach(s => {
      const grade = typeof s === 'object' ? (s.grade || '') : '';
      if (grade) {
        studentsWithGrade++;
        gradeStats[grade] = (gradeStats[grade] || 0) + 1;
      }
    });
  });
  
  const gradeStatsText = Object.keys(gradeStats).length > 0 
    ? `；年级分布：${Object.entries(gradeStats).map(([grade, count]) => `${formatGradeDisplay(grade)}(${count})`).join('，')}`
    : '';
  
  $('studentDbStats').innerHTML = `共有专业 ${majors.length} 个；总学生 ${Object.values(studentDatabase).reduce((a,b)=>a+b.length,0)} 人；当前显示 ${shownStudents} 人；已设置时间段 ${totalSlots} 个；已设置年级 ${studentsWithGrade} 人${gradeStatsText}。`;
}


// 折叠/展开函数
function toggleMajorCollapse(major){
  const body = $('majorBody_'+major);
  const icon = $('majorCollapseIcon_'+major);
  if(!body) return;
  const collapsed = body.style.display === 'none';
  body.style.display = collapsed ? 'block' : 'none';
  if(icon){
    icon.textContent = collapsed ? '收起 ▲' : '展开 ▼';
  }
}

function filterByMajor(){
  // 只是包装一下，后续若要做额外逻辑可加这里
  renderStudentDatabaseList();
}

function getStudentTimeSlotsDisplay(name){
  const d = studentTimeSlots[name];
  if(!d) return '<span style="color:#e74c3c;font-size:12px;font-weight:700;">⚠️ 未设置练琴时间</span>';
  
  let totalSlots = 0;
  let displaySlots = [];
  const weekDays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
  
  // 🔥 按星期顺序收集所有时间段
  weekDays.forEach(day => {
    const daySlots = d[day] || [];
    daySlots.forEach(slot => {
      totalSlots++;
      if(displaySlots.length < 3) { // 显示前3个
        displaySlots.push({
          day: WEEK_CN[day],
          slot: slot
        });
      }
    });
  });
  
  if(!totalSlots) return '<span style="color:#e74c3c;font-size:12px;font-weight:700;">⚠️ 未设置练琴时间</span>';
  
  // 🔥 生成显示内容
  let html = displaySlots.map(item => 
    `<span class="time-slot-badge" title="${item.day} ${item.slot.start}-${item.slot.end} (${item.slot.duration})">${item.day} ${item.slot.start}-${item.slot.end}</span>`
  ).join('');
  
  if(totalSlots > 3) {
    html += `<span class="time-slot-badge more-slots" style="background:#3498db;color:#fff;cursor:pointer;" title="点击查看全部${totalSlots}个时间段" onclick="showStudentSlotsPreview('${name}')">+${totalSlots-3}个</span>`;
  }
  
  // 🔥 添加统计信息
  html += `<div style="font-size:11px;color:#666;margin-top:4px;">共${totalSlots}个时间段，覆盖${Object.keys(d).filter(day => d[day] && d[day].length > 0).length}天</div>`;
  
  return html;
}


/* ==== 学生库导出 / 导入（时间段 CSV / JSON 智能处理） ==== */

/**
 * 导出学生库
 * 提示选择格式：1=CSV 2=JSON (默认 CSV)
 */
function exportStudentDatabase(){
  if(!Object.keys(studentDatabase).length){
    alert('学生库为空，无法导出');return;
  }
  const choice = prompt("选择导出格式:\n1 CSV (默认)\n2 JSON","1") || "1";
  if(choice==="2"){
    exportStudentDatabaseJSON();
  }else{
    exportStudentDatabaseCSV();
  }
  logOperation('export_student_db',{format:choice==="2"?'json':'csv'});
}

/* CSV: 姓名,专业,年级,周一,周二,周三,周四,周五 */
function exportStudentDatabaseCSV(){
  const header = ['姓名','专业','年级','周一','周二','周三','周四','周五']; // 🔥 新增年级列
  const lines=[header.join(',')];
  const majors = Object.keys(studentDatabase).sort((a,b)=>a.localeCompare(b,'zh-Hans-CN'));
  majors.forEach(major=>{
    studentDatabase[major].sort((a,b)=>getStudentName(a).localeCompare(getStudentName(b),'zh-Hans-CN')).forEach(studentRecord=>{
      const name = getStudentName(studentRecord);
      const grade = typeof studentRecord === 'object' ? (studentRecord.grade || '') : ''; // 🔥 新增
      const slotObj = studentTimeSlots[name] || {};
      const dayCells = ['monday','tuesday','wednesday','thursday','friday'].map(day=>{
        const arr = slotObj[day]||[];
        return arr.map(s=>`${s.start}-${s.end}`).join(';');
      });
      lines.push([escapeCSV(name),escapeCSV(major),escapeCSV(grade),...dayCells.map(escapeCSV)].join(',')); // 🔥 新增年级
    });
  });
  const csv = '\uFEFF'+lines.join('\n'); // 加 BOM 方便 Excel
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='学生库_'+new Date().toISOString().slice(0,10)+'.csv';
  a.click();
  showToast('学生库 CSV 已导出');
}

function exportStudentDatabaseJSON(){
  const payload = {
    version:'student-db-v1',
    exportedAt:new Date().toISOString(),
    students:buildStudentExportJSON()
  };
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json;charset=utf-8;'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='学生库_'+new Date().toISOString().replace(/[:T]/g,'-').split('.')[0]+'.json';
  a.click();
  showToast('学生库 JSON 已导出');
}

function buildStudentExportJSON(){
  const out=[];
  Object.keys(studentDatabase).forEach(major=>{
    studentDatabase[major].forEach(studentRecord=>{
      const name = getStudentName(studentRecord);
      const grade = typeof studentRecord === 'object' ? (studentRecord.grade || '') : ''; // 🔥 新增
      out.push({
        name,
        major,
        grade, // 🔥 新增年级字段
        slots: studentTimeSlots[name] || {monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]}
      });
    });
  });
  return out;
}

/**
 * 导入入口
 */
function importStudentDatabase(evt){
  const file = evt.target.files[0];
  if(!file){return;}
  const name=file.name.toLowerCase();
  const isCSV = name.endsWith('.csv');
  const reader=new FileReader();
  reader.onload = e=>{
    let text=e.target.result;
    try{
      if(isCSV){
        handleStudentCSVImport(text);
      }else{
        handleStudentJSONImport(text);
      }
    }catch(err){
      console.error(err);
      alert('导入失败: '+err.message);
    }finally{
      // 重置 input 以便重复导入同一文件
      evt.target.value='';
    }
  };
  reader.readAsText(file,'utf-8');
}

/* === JSON 导入 === */
function handleStudentJSONImport(text){
  let data=JSON.parse(text);
  if(Array.isArray(data.students)){
    data = data.students;
  }else if(Array.isArray(data)){
    // ok
  }else if(data.version && data.students){
    data = data.students;
  }else{
    throw new Error('JSON 结构不符合: 期待 {students:[...]} 或数组');
  }
  const normalized = data.map(s=>({
    name: s.name?.trim(),
    major: (s.major && s.major.trim()) ? s.major.trim() : null,
    grade: parseGradeInput(s.grade || ''), // 🔥 新增年级处理
    slots: normalizeStudentSlotsObject(s.slots||{})
  }));
  proceedStudentImport(normalized,'json');
}


function detectDelimiter(line){
  // 统计候选分隔符出现次数
  const candidates = [',',';','\t','，','|'];
  let best = ',', bestCount = -1;
  candidates.forEach(d=>{
    const c = line.split(d).length - 1;
    if(c > bestCount){ best = d; bestCount = c; }
  });
  return best;
}

function cleanHeaderCell(h){
  return h
    .replace(/\uFEFF/g,'')                 // BOM
    .replace(/[\u0000-\u001F]/g,'')        // 控制字符(含 \u0000)
    .replace(/[\u200B-\u200F\u202A-\u202E\u2060\u2061]/g,'') // 零宽/方向控制
    .replace(/\u00A0/g,' ')                // 不间断空格
    .replace(/\u3000/g,'')                 // 全角空格
    .trim()
    .toLowerCase();
}

/* === CSV 导入 === */
function handleStudentCSVImport(csvText){
  // 先移除整体 BOM
  if(csvText.charCodeAt(0)===0xFEFF){
    csvText = csvText.slice(1);
  }
  // 兼容 UTF-16 被错误按 UTF-8 读入出现大量 \u0000：去掉全部 \u0000
  csvText = csvText.replace(/\u0000/g,'');
  // 统一换行
  csvText = csvText.replace(/\r/g,'');
  const rawLines = csvText.split('\n');
  // 不用简单 trim 过滤所有行，先保留以便调试
  // 找到第一条"非纯空白且含非控制字符"作为 header
  let headerIndex = -1;
  for(let i=0;i<rawLines.length;i++){
    const temp = rawLines[i].replace(/[\u0000-\u001F]/g,'').trim();
    if(temp){ headerIndex = i; break; }
  }
  if(headerIndex === -1) throw new Error('CSV 空内容');
  const headerLine = rawLines[headerIndex];
  const delimiter = detectDelimiter(headerLine);
  const headers = headerLine.split(delimiter);
  const map = mapCSVHeaders(headers);

  if(map.name == null){
    // Debug 输出
    console.warn('[CSV 导入调试] Headers 原始：', headers);
    console.warn('[CSV 导入调试] Headers CharCodes：', headers.map(h=>[...h].map(c=>c.charCodeAt(0).toString(16))));
    // 最终仍无 -> 强制设为 0，避免报错（最后的兜底）
    map.name = 0;
  }

  const records = [];
  for(let i=headerIndex+1;i<rawLines.length;i++){
    const raw = rawLines[i];
    if(!raw) continue;
    const cols = raw.split(delimiter);
    if(cols.length===1 && !cols[0].trim()) continue;

    let rawName = (cols[map.name]||'')
        .replace(/\uFEFF/g,'')
        .replace(/[\u0000-\u001F]/g,'')
        .replace(/[\u200B-\u200F\u202A-\u202E\u2060]/g,'')
        .trim();
    if(!rawName) continue;
    const name = rawName.replace(/\s{2,}/g,' ');

    // 专业
    let majorCandidate = null;
    if(map.major != null){
      const mraw = (cols[map.major]||'').replace(/[\u0000-\u001F]/g,'').trim();
      if(mraw && !/^(未设置|null|none)$/i.test(mraw)) majorCandidate = mraw;
    }

    // 🔥 新增：年级处理
    let gradeCandidate = '';
    if(map.grade != null){
      const graw = (cols[map.grade]||'').replace(/[\u0000-\u001F]/g,'').trim();
      if(graw && !/^(未设置|null|none)$/i.test(graw)) {
        gradeCandidate = parseGradeInput(graw);
      }
    }

    const slotObj={monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]};

    const weekdayColsPresent = ['monday','tuesday','wednesday','thursday','friday'].some(d=>map[d]!=null);
    if(weekdayColsPresent){
      ['monday','tuesday','wednesday','thursday','friday'].forEach(day=>{
        const idx=map[day];
        if(idx==null) return;
        const cell=(cols[idx]||'').trim();
        if(!cell || /未设置/i.test(cell)) return;
        parseSimpleDayCellToSlots(cell, slotObj[day]);
      });
    }
    if(map.aggregate != null){
      const aggCell = (cols[map.aggregate]||'').trim();
      if(aggCell && !/未设置/i.test(aggCell)){
        parseAggregateSlotsCell(aggCell, slotObj);
      }
    }
    Object.keys(slotObj).forEach(d=>{
      slotObj[d] = sanitizeSlotList(slotObj[d]);
    });

    records.push({name,major:majorCandidate,grade:gradeCandidate,slots:slotObj}); // 🔥 新增年级
  }

  proceedStudentImport(records,'csv');
}
function parseSimpleDayCellToSlots(cell, targetArr){
  if(!cell || !cell.trim()) return;
  
  // 🔥 支持多种分隔符：分号、逗号、斜杠、换行等
  const parts = cell.split(/[\s;，,\/|、\n\r]+/).filter(Boolean);
  
  parts.forEach(seg=>{
    // 🔥 增强正则：支持单位数小时和更多格式
    // 支持格式：8:00-8:45, 08:00-08:45, 8:00-8:45, 8-9等
    const timeMatch = seg.match(/^(\d{1,2}):?(\d{0,2})\s*[-~至到]\s*(\d{1,2}):?(\d{0,2})$/);
    
    if(timeMatch){
      let [, startH, startM, endH, endM] = timeMatch;
      
      // 处理省略分钟的情况（如 8-9）
      startM = startM || '00';
      endM = endM || '00';
      
      // 补零
      const start = `${startH.padStart(2,'0')}:${startM.padStart(2,'0')}`;
      const end = `${endH.padStart(2,'0')}:${endM.padStart(2,'0')}`;
      
      if(isValidSlotFormat(start, end, true)){
        targetArr.push({
          start: start,
          end: end,
          duration: calcDurationText(start, end)
        });
      }
    } else {
      // 🔥 尝试其他格式解析
      const altMatch = seg.match(/^(\d{1,2})[:：](\d{2})\s*[-~至到]\s*(\d{1,2})[:：](\d{2})$/);
      if(altMatch){
        const [, startH, startM, endH, endM] = altMatch;
        const start = `${startH.padStart(2,'0')}:${startM}`;
        const end = `${endH.padStart(2,'0')}:${endM}`;
        
        if(isValidSlotFormat(start, end, true)){
          targetArr.push({
            start: start,
            end: end,
            duration: calcDurationText(start, end)
          });
        }
      }
    }
  });
}




// 解析类似： 周一:08:00-10:00;周一:13:00-15:00;周二:09:00-10:00 ...
function parseAggregateSlotsCell(cell, slotObj){
  if(!cell || !cell.trim()) return;
  
  // 统一分隔符处理
  const pieces = cell.split(/[\s;，,\/|、\n\r]+/).filter(Boolean);
  
  pieces.forEach(p=>{
    // 🔥 支持更多格式：
    // "周一:08:00-09:00", "星期一:08:00-09:00", "周一 08:00-09:00"
    // "Monday:08:00-09:00", "周一08:00-09:00"
    const dayTimeMatch = p.match(/^(周|星期)?(一|二|三|四|五|Monday|Tuesday|Wednesday|Thursday|Friday|Mon|Tue|Wed|Thu|Fri)\s*[:：]?\s*(\d{1,2}):?(\d{0,2})\s*[-~至到]\s*(\d{1,2}):?(\d{0,2})$/i);
    
    if(dayTimeMatch){
      let [, prefix, dayPart, startH, startM, endH, endM] = dayTimeMatch;
      
      // 处理英文星期
      const dayMap = {
        '一': 'monday', '二': 'tuesday', '三': 'wednesday', '四': 'thursday', '五': 'friday',
        'monday': 'monday', 'tuesday': 'tuesday', 'wednesday': 'wednesday', 'thursday': 'thursday', 'friday': 'friday',
        'mon': 'monday', 'tue': 'tuesday', 'wed': 'wednesday', 'thu': 'thursday', 'fri': 'friday'
      };
      
      const dayKey = dayMap[dayPart.toLowerCase()];
      if(!dayKey) return;
      
      // 处理省略分钟
      startM = startM || '00';
      endM = endM || '00';
      
      const start = `${startH.padStart(2,'0')}:${startM.padStart(2,'0')}`;
      const end = `${endH.padStart(2,'0')}:${endM.padStart(2,'0')}`;
      
      if(isValidSlotFormat(start, end, true)){
        slotObj[dayKey].push({
          start: start,
          end: end,
          duration: calcDurationText(start, end)
        });
      }
    }
  });
}


/* === 头部映射：兼容多语言/别名 === */
function mapCSVHeaders(headers){
  const map = {};
  headers.forEach((raw,i)=>{
    const key = cleanHeaderCell(raw);
    
    // 基础字段映射
    if(/^(姓名|学生|name|student)$/.test(key)) map.name = i;
    else if(/^(专业|major|department)$/.test(key)) map.major = i;
    else if(/^(年级|grade|level|class)$/.test(key)) map.grade = i; // 🔥 新增年级映射
    
    // 🔥 增强星期映射 - 支持更多格式
    else if(/^(周一|星期一|monday|mon|week1|w1)$/.test(key)) map.monday = i;
    else if(/^(周二|星期二|tuesday|tue|week2|w2)$/.test(key)) map.tuesday = i;
    else if(/^(周三|星期三|wednesday|wed|week3|w3)$/.test(key)) map.wednesday = i;
    else if(/^(周四|星期四|thursday|thu|week4|w4)$/.test(key)) map.thursday = i;
    else if(/^(周五|星期五|friday|fri|week5|w5)$/.test(key)) map.friday = i;
    
    // 🔥 聚合时间段列映射
    else if(/^(练琴时间段|时间段|时间安排|schedule|slots|timetable|全部时间|所有时间)$/.test(key)) map.aggregate = i;
    
    // 🔥 其他可能的时间相关列
    else if(/时间|time|slot/.test(key) && !/^(周|星期|monday|tuesday|wednesday|thursday|friday)/.test(key)) {
      map.aggregate = i; // 作为聚合列处理
    }
  });
  
  // 🔥 Fallback逻辑增强
  if(map.name == null){
    // 尝试基于内容和位置判断
    const first = headers[0] || '';
    const cleanedFirst = cleanHeaderCell(first);
    if(/姓|名|student/.test(cleanedFirst) || /^[a-z]*name$/.test(cleanedFirst) || /^[\u4e00-\u9fa5]{1,6}$/.test(cleanedFirst)){
      map.name = 0;
    }
  }
  
  return map;
}


/* 拆 CSV 行（简单逗号拆分 + 处理引号） */
function splitCSVRow(line, expectedLen){
  const out=[];
  let current='',inQuotes=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i];
    if(ch==='"'){
      if(inQuotes && line[i+1]==='"'){ // 双引号转义
        current+='"'; i++;
      }else{
        inQuotes=!inQuotes;
      }
    }else if(ch===',' && !inQuotes){
      out.push(current); current='';
    }else{
      current+=ch;
    }
  }
  out.push(current);
  // 长度不足补空
  while(out.length<expectedLen) out.push('');
  return out;
}

function isValidSlotFormat(start,end,isImporting=false){
  try{
    if(!/^\d{1,2}:\d{2}$/.test(start) || !/^\d{1,2}:\d{2}$/.test(end)) return false;
    const s=timeToMinutes(start), e=timeToMinutes(end);
    if(isNaN(s)||isNaN(e)) return false;
    if(s<0 || e>1440) return false;
    if(e<=s) return false;
    
    // 🔥 修复：检查分钟是否为10的倍数（仅在手动添加时限制）
    // 导入时允许任何分钟值
    if (!isImporting) {
      const startParts = start.split(':');
      const endParts = end.split(':');
      const startMin = parseInt(startParts[1]);
      const endMin = parseInt(endParts[1]);
      
      if (startMin % 10 !== 0 || endMin % 10 !== 0) {
        return false; // 手动添加时必须是10的倍数
      }
    }
    
    return true;
  }catch{return false;}
}



/* 清理重叠与排序 */
function sanitizeSlotList(list){
  if(!list.length) return [];
  // 先规范对象
  list=list.map(s=>({start:s.start,end:s.end,duration:calcDurationText(s.start,s.end)}));
  list.sort((a,b)=>a.start.localeCompare(b.start));
  const result=[];
  list.forEach(s=>{
    if(!result.length){
      result.push(s);return;
    }
    const last=result[result.length-1];
    const ls=timeToMinutes(last.start), le=timeToMinutes(last.end);
    const cs=timeToMinutes(s.start),   ce=timeToMinutes(s.end);
    if(cs<le){ 
      // 重叠：跳过（可扩展为合并：取 max 结束）
      // 若需合并把 le 调成 max(le,ce) 并更新 last.end / duration
      // 这里维持"跳过"策略
      return;
    }
    result.push(s);
  });
  return result;
}

/* 标准化 JSON slots 对象 */
function normalizeStudentSlotsObject(slots){
  const out={monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]};
  Object.keys(out).forEach(day=>{
    const arr=Array.isArray(slots[day])?slots[day]:[];
    out[day]=sanitizeSlotList(arr.filter(s=>s.start && s.end && isValidSlotFormat(s.start,s.end,true))); // 🔥 修改：导入时允许任意分钟
  });
  return out;
}


/**
 * 统一导入处理
 * records: [{name,major,grade,slots:{monday:[],...}}]
 * source: 'csv'|'json'
 */
function proceedStudentImport(records,source){
  if(!records.length){
    alert('无有效数据');return;
  }
  const strategy = prompt("选择导入策略:\n1 合并追加(默认)\n2 覆盖同名学生时间段\n3 仅新增学生\n4 全量重置(清空后导入)","1") || "1";
  if(!/^[1-4]$/.test(strategy)){alert('取消导入');return;}

  const summary={
    source,
    strategy,
    totalInput:records.length,
    newStudents:0,
    updatedStudents:0,
    skippedExisting:0,
    newMajors:0,
    newSlots:0,
    gradesUpdated:0, // 🔥 新增年级更新统计
    majorUpdated:0   // 🔥 新增专业更新统计
  };

  if(strategy==="4"){
    // 完全清空（保留系统其他数据）
    studentDatabase={};
    studentTimeSlots={};
    // 🔥 立即持久化清空操作
    persistStudents();
    persistStudentSlots();
  }
  const existingMajors = new Set(Object.keys(studentDatabase));

  records.forEach(rec=>{
    const {name,major,grade,slots}=rec; // 🔥 新增grade解构
    if(!name) return;

    // 🔥 关键修改：改进学生查找逻辑，同时记录学生所在的专业
    let hasStudent = false;
    let existingMajorOfStudent = null;
    let existingStudentRecord = null;
    let studentIndex = -1;
    
    for(const [m,arr] of Object.entries(studentDatabase)){
      const foundIndex = arr.findIndex(s=>getStudentName(s)===name);
      if(foundIndex !== -1){ 
        hasStudent=true; 
        existingMajorOfStudent=m; 
        existingStudentRecord=arr[foundIndex];
        studentIndex = foundIndex;
        break; 
      }
    }

    // 决定 targetMajor：
    // 1) 如果导入有明确 major（非 null），就用导入的
    // 2) 否则如果学生已存在，用其原专业
    // 3) 否则用 '其他'
    let targetMajor;
    if(major){ 
      targetMajor = major;
    }else if(hasStudent){
      targetMajor = existingMajorOfStudent;
    }else{
      targetMajor = '其他';
    }

    // 如果该专业不存在则创建
    if(!studentDatabase[targetMajor]){
      studentDatabase[targetMajor]=[];
      // 如果是"沿用旧专业"则不会走到创建；只有真正新建才计数
      if(!existingMajors.has(targetMajor)) {
        summary.newMajors++;
      }
    }

    if(!hasStudent){
      // 新学生 - 🔥 使用对象格式支持年级
      studentDatabase[targetMajor].push({
        name: name,
        grade: grade || ''
      });
      summary.newStudents++;
      studentTimeSlots[name]=slots;
      summary.newSlots += countSlots(slots);
      if(grade) summary.gradesUpdated++; // 🔥 新增
    }else{
      // 已存在学生
      if(strategy==="3"){ // 仅新增
        summary.skippedExisting++;
        return;
      }
      
      // 🔥 关键修改：处理专业变更
      let needsMajorUpdate = false;
      if(major && targetMajor !== existingMajorOfStudent) {
        // 需要将学生从原专业移动到新专业
        needsMajorUpdate = true;
        
        // 从原专业中移除
        studentDatabase[existingMajorOfStudent].splice(studentIndex, 1);
        
        // 如果原专业变空，删除它
        if(studentDatabase[existingMajorOfStudent].length === 0) {
          delete studentDatabase[existingMajorOfStudent];
        }
        
        // 添加到新专业（使用现有的学生记录结构）
        const updatedRecord = typeof existingStudentRecord === 'string' 
          ? { name: name, grade: grade || '' }
          : { ...existingStudentRecord, grade: grade || existingStudentRecord.grade || '' };
        
        studentDatabase[targetMajor].push(updatedRecord);
        summary.majorUpdated++;
        
        // 更新引用
        existingStudentRecord = updatedRecord;
      }
      
      // 🔥 处理年级更新（无论是否更换专业）
      if(grade) {
        if(typeof existingStudentRecord === 'string') {
          // 如果没有更换专业，需要升级字符串格式为对象格式
          if(!needsMajorUpdate) {
            const index = studentDatabase[existingMajorOfStudent].indexOf(existingStudentRecord);
            studentDatabase[existingMajorOfStudent][index] = {
              name: name,
              grade: grade
            };
          }
          summary.gradesUpdated++;
        } else if(typeof existingStudentRecord === 'object') {
          // 更新年级
          if(existingStudentRecord.grade !== grade) {
            existingStudentRecord.grade = grade;
            summary.gradesUpdated++;
          }
        }
      }
      
      // 🔥 处理时间段更新
      if(strategy==="2"){ // 覆盖时间段
        studentTimeSlots[name]=slots;
        summary.updatedStudents++;
        summary.newSlots += countSlots(slots);
      }else if(strategy==="1"){ // 合并
        initStudentSlotStructure(name);
        const before=countSlots(studentTimeSlots[name]);
        mergeSlots(studentTimeSlots[name],slots);
        const after=countSlots(studentTimeSlots[name]);
        if(after>before || needsMajorUpdate){
          summary.updatedStudents++;
          summary.newSlots += (after-before);
        }else if(!needsMajorUpdate){
          summary.skippedExisting++;
        }
      } else {
        // 即使不更新时间段，如果更新了专业或年级，也算作更新
        if(needsMajorUpdate || (grade && summary.gradesUpdated > 0)) {
          summary.updatedStudents++;
        } else {
          summary.skippedExisting++;
        }
      }
    }
  });

  persistStudents();
  persistStudentSlots();

  // 刷新 UI
  populateMajorFilter();
  populateGradeFilter(); // 🔥 新增
  renderStudentDatabaseList();
  cleanupEmptyMajors();
  refreshAllMajorSelectors();

  showStudentImportSummary(summary);
  logOperation('import_student_db',summary);
}


function countSlots(slotObj){
  return Object.values(slotObj).reduce((a,b)=>a+b.length,0);
}

/* 合并追加：仅追加不与现有冲突的时间段 */
function mergeSlots(baseSlots, newSlots){
  Object.keys(baseSlots).forEach(day=>{
    const existing = baseSlots[day];
    const incoming = newSlots[day]||[];
    if(!incoming.length) return;
    incoming.forEach(ns=>{
      // 判断与 existing 冲突
      const nsStart=timeToMinutes(ns.start), nsEnd=timeToMinutes(ns.end);
      const conflict = existing.some(es=>{
        const esStart=timeToMinutes(es.start), esEnd=timeToMinutes(es.end);
        return nsStart<esEnd && nsEnd>esStart;
      });
      if(!conflict){
        existing.push({...ns});
      }
    });
    existing.sort((a,b)=>a.start.localeCompare(b.start));
  });
}

/* 导入结果展示 */
/* 导入结果展示 */
function showStudentImportSummary(sum){
  const details = [];
  
  if(sum.newStudents > 0) details.push(`✅ 新增学生: ${sum.newStudents}人`);
  if(sum.updatedStudents > 0) details.push(`🔄 更新学生: ${sum.updatedStudents}人`);
  if(sum.skippedExisting > 0) details.push(`⏭️ 跳过重复: ${sum.skippedExisting}人`);
  if(sum.newMajors > 0) details.push(`🆕 新建专业: ${sum.newMajors}个`);
  if(sum.majorUpdated > 0) details.push(`🔄 更新专业: ${sum.majorUpdated}人`); // 🔥 新增
  if(sum.newSlots > 0) details.push(`⏰ 新增时间段: ${sum.newSlots}个`);
  if(sum.gradesUpdated > 0) details.push(`🎓 更新年级: ${sum.gradesUpdated}人`); // 🔥 新增
  
  const msg = [
    '📊 导入完成统计',
    '',
    `📁 来源格式: ${sum.source.toUpperCase()}`,
    `🔧 导入策略: ${({'1':'合并追加','2':'覆盖时间段','3':'仅新增','4':'全量重置'})[sum.strategy]}`,
    `📝 输入记录: ${sum.totalInput}条`,
    '',
    ...details,
    '',
    '🎉 所有数据已成功导入并保存！'
  ].join('\n');
  
  alert(msg);
  showToast('✅ 学生库导入完成', 3000);
}


function addNewStudentToDatabase(){
  const name=prompt('学生姓名：').trim();
  if(!name) return;
  if(Object.values(studentDatabase).some(a=>a.includes(name))){alert('已存在');return;}
  window.pendingStudentName=name;
  $('majorSelectionModal').style.display='block';
  renderMajorSelectionButtons();
}
function renderMajorSelectionButtons(){
  const box=$('majorButtonsList');
  const majors=Object.keys(studentDatabase).sort((a,b)=>a.localeCompare(b,'zh-Hans-CN'));
  box.innerHTML=majors.map(m=>`<button class="major-btn" style="background:var(--primary-color);" onclick="selectExistingMajor('${m}')">${m} (${studentDatabase[m].length})</button>`).join('')||
    '<div style="color:#999;font-style:italic;">暂无专业</div>';
}
function selectExistingMajor(m){ finalizeAddStudent(m); }
function createNewMajor(){
  const m=$('newMajorInput').value.trim(); if(!m){alert('请输入');return;}
  if(studentDatabase[m]){alert('已存在');return;}
  finalizeAddStudent(m);
}
function finalizeAddStudent(major){
  const name=window.pendingStudentName;
  if(!studentDatabase[major]) studentDatabase[major]=[];
  
  // 🔥 修改：使用对象格式添加学生，支持年级
  studentDatabase[major].push({
    name: name,
    grade: '' // 默认空年级，用户可后续编辑
  });
  
  persistStudents();
  showToast(`已添加 ${name} 到 ${major}`);
  $('majorSelectionModal').style.display='none';
  window.pendingStudentName=null;
  renderStudentDatabaseList();
  refreshAllMajorSelectors();
  populateGradeFilter(); // 🔥 新增
  cleanupEmptyMajors();
  
  // 让新学生一定可见：如果当前搜索框有值且不匹配，清空搜索后再刷新
  const q = $('studentDbSearch').value.trim();
  if(q && !matchPinyin(name, q)){
    $('studentDbSearch').value='';
    renderStudentDatabaseList();
  }
}


function closeMajorSelectionModal(){
  $('majorSelectionModal').style.display='none';
  window.pendingStudentName=null;
}
// 🔥 新增：年级筛选函数
function filterByGrade(){
  renderStudentDatabaseList();
}
let editingStudent=null;
function editStudent(name,major){
  editingStudent={oldName:name,oldMajor:major};
  $('editStudentName').value=name;
  
  // 填充专业选择器
  const sel=$('editStudentMajor');
  const existingMajors = Object.keys(studentDatabase).sort((a,b)=>a.localeCompare(b,'zh-Hans-CN'));
  
  // 🔥 关键修改：添加"添加新专业"选项
  let optionsHTML = existingMajors.map(m=>`<option value="${m}" ${m===major?'selected':''}>${m}</option>`).join('');
  optionsHTML += '<option value="__ADD_NEW__">+ 添加新专业</option>';
  sel.innerHTML = optionsHTML;
  
  // 🔥 新增：监听专业选择变化
  sel.addEventListener('change', handleMajorSelectionChange);
  
  // 🔥 新增：填充年级信息
  const studentInfo = getStudentInfo(name);
  $('editStudentGrade').value = studentInfo.grade || '';
  
  $('editStudentModal').style.display='block';
}
function handleMajorSelectionChange(event) {
  const selectedValue = event.target.value;
  
  if (selectedValue === '__ADD_NEW__') {
    const newMajor = prompt('请输入新专业名称：');
    
    if (newMajor && newMajor.trim()) {
      const majorName = newMajor.trim();
      
      // 检查专业是否已存在
      if (studentDatabase[majorName]) {
        alert('该专业已存在');
        // 重新选择已存在的专业
        event.target.value = majorName;
        return;
      }
      
      // 创建新专业
      studentDatabase[majorName] = [];
      persistStudents();
      
      // 重新填充选择器并选中新专业
      const sel = event.target;
      const existingMajors = Object.keys(studentDatabase).sort((a,b)=>a.localeCompare(b,'zh-Hans-CN'));
      let optionsHTML = existingMajors.map(m=>`<option value="${m}" ${m===majorName?'selected':''}>${m}</option>`).join('');
      optionsHTML += '<option value="__ADD_NEW__">+ 添加新专业</option>';
      sel.innerHTML = optionsHTML;
      sel.value = majorName;
      
      showToast(`新专业"${majorName}"已创建`);
      
      // 刷新相关UI
      refreshAllMajorSelectors();
      
    } else {
      // 用户取消或输入为空，恢复到原来的选择
      const editingStudent = window.editingStudent;
      if (editingStudent) {
        event.target.value = editingStudent.oldMajor;
      } else {
        // 回退到第一个选项
        event.target.selectedIndex = 0;
      }
    }
  }
}

function closeEditStudentModal(){ 
  $('editStudentModal').style.display='none'; 
  
  // 🔥 新增：清理事件监听器
  const sel = $('editStudentMajor');
  if (sel) {
    sel.removeEventListener('change', handleMajorSelectionChange);
  }
  
  editingStudent=null; 
}

function saveStudentChanges(){
  if(!editingStudent) return;
  const newName=$('editStudentName').value.trim();
  const newMajor=$('editStudentMajor').value;
  const newGrade=parseGradeInput($('editStudentGrade').value.trim()); // 🔥 新增
  
  if(!newName){alert('姓名必填');return;}
  if(newName!==editingStudent.oldName && Object.values(studentDatabase).some(a=>a.some(s=>getStudentName(s)===newName))){
    alert('该姓名已存在');return;
  }
  
  // 🔥 关键修复：先保存时间段数据，再进行迁移
  const oldTimeSlots = studentTimeSlots[editingStudent.oldName];
  
  // 移除旧记录
  const arr=studentDatabase[editingStudent.oldMajor];
  const idx=arr.findIndex(s=>getStudentName(s)===editingStudent.oldName);
  if(idx>-1) arr.splice(idx,1);
  if(!arr.length) delete studentDatabase[editingStudent.oldMajor];
  
  // 添加新记录（使用对象格式支持年级）
  if(!studentDatabase[newMajor]) studentDatabase[newMajor]=[];
  const existingIndex = studentDatabase[newMajor].findIndex(s=>getStudentName(s)===newName);
  if(existingIndex === -1) {
    studentDatabase[newMajor].push({
      name: newName,
      grade: newGrade
    });
  } else {
    // 更新现有记录
    if (typeof studentDatabase[newMajor][existingIndex] === 'string') {
      studentDatabase[newMajor][existingIndex] = {
        name: newName,
        grade: newGrade
      };
    } else {
      studentDatabase[newMajor][existingIndex].grade = newGrade;
    }
  }
  
  // 🔥 关键修复：正确迁移时间段数据
  if(oldTimeSlots && editingStudent.oldName !== newName){
    // 如果学生姓名发生变化，迁移时间段数据
    studentTimeSlots[newName] = oldTimeSlots;
    delete studentTimeSlots[editingStudent.oldName];
  }
  
  persistStudents();persistStudentSlots();
  editingStudent=null;
  closeEditStudentModal();
  renderStudentDatabaseList();
  cleanupEmptyMajors();
  refreshAllMajorSelectors();
  populateMajorFilter();
  populateGradeFilter(); // 🔥 新增
  showToast('已保存');
}
function deleteStudent(name,major){
  if(!confirm(`删除学生 ${name}?`))return;
  studentDatabase[major]=studentDatabase[major].filter(s=>getStudentName(s)!==name);
  if(!studentDatabase[major].length) delete studentDatabase[major];
  if(studentTimeSlots[name]) delete studentTimeSlots[name];
  rooms.forEach(r=>{
    if(r.student===name){
      addPracticeLog(name,r.name,r.registerTime,Date.now(),'学生删除');
      r.student=null;r.registerTime=null;
    }
  });
  ['grand','upright','none'].forEach(t=>queueList[t]=queueList[t].filter(s=>s!==name));
  persistStudents();persistStudentSlots();persistQueues();persistRooms();
  renderStudentDatabaseList();
  updateRooms();
  showToast('学生已删除');
  cleanupEmptyMajors();
  refreshAllMajorSelectors();
  populateGradeFilter(); // 🔥 新增
}
function closeStudentDatabaseModal(){ $('studentDatabaseModal').style.display='none'; }

/* =============== 7. 排队系统 =============== */
function validateQueueAdd(student,type){
  if(queueList[type].includes(student)) return {ok:false,reason:'已在该队列'};
  for(const t of ['grand','upright','none']) if(t!==type && queueList[t].includes(student)) return {ok:false,reason:'已在其他队列'};
  if(rooms.some(r=>r.student===student)) return {ok:false,reason:'正在练琴'};
  return {ok:true};
}
function showQueueStudentModal(type){
  currentQueueType=type;
  $('queueStudentSearch').value='';
  searchQueueStudents('');
  $('queueStudentModal').style.display='block';
  
  // 初始化输入处理器并聚焦
  setTimeout(() => {
    if (!inputHandlers.has('queueStudentSearch')) {
      const handler = new SmartInputHandler('queueStudentSearch', searchQueueStudents);
      inputHandlers.set('queueStudentSearch', handler);
    }
    
    const searchInput = $('queueStudentSearch');
    if (searchInput) {
      searchInput.focus();
    }
  }, 50);
}

function manageStudentDatabase(){
  if(isLocked){alert('系统已锁定');return;}
  
  const searchInput = $('studentDbSearch');
  const majorSel = $('majorFilter');
  const gradeSel = $('gradeFilter'); // 🔥 新增年级筛选器
  if(searchInput) searchInput.value = '';
  if(majorSel) majorSel.value = '';
  if(gradeSel) gradeSel.value = ''; // 🔥 新增

  populateMajorFilter();
  populateGradeFilter(); // 🔥 新增
  if(majorSel && ![...majorSel.options].some(o=>o.value===majorSel.value)){
    majorSel.value = '';
  }
  renderStudentDatabaseList();
  $('studentDatabaseModal').style.display='block';
  injectStudentDbHint();
  
  // 初始化输入处理器
  setTimeout(() => {
    if (!inputHandlers.has('studentDbSearch')) {
      const handler = new SmartInputHandler('studentDbSearch', searchStudentDatabase);
      inputHandlers.set('studentDbSearch', handler);
    }
  }, 50);
}

// 🔥 新增：填充年级筛选器
function populateGradeFilter(){
  const sel = $('gradeFilter');
  if (!sel) return;
  
  const grades = new Set();
  Object.values(studentDatabase).forEach(students => {
    students.forEach(s => {
      const grade = typeof s === 'object' ? (s.grade || '') : '';
      if (grade) {
        grades.add(grade);
      }
    });
  });
  
  const sortedGrades = Array.from(grades).sort((a, b) => {
    // 优先按G1-G12排序
    const aMatch = a.match(/^G(\d+)$/);
    const bMatch = b.match(/^G(\d+)$/);
    
    if (aMatch && bMatch) {
      return parseInt(aMatch[1]) - parseInt(bMatch[1]);
    } else if (aMatch) {
      return -1;
    } else if (bMatch) {
      return 1;
    } else {
      return a.localeCompare(b, 'zh-Hans-CN');
    }
  });
  
  sel.innerHTML = '<option value="">所有年级</option>' +
    '<option value="no_grade">未设置年级</option>' +
    sortedGrades.map(g => `<option value="${g}">${formatGradeDisplay(g)}</option>`).join('');
}


function closeQueueStudentModal(){ $('queueStudentModal').style.display='none'; currentQueueType=null; }
let currentQueueType=null;
function searchQueueStudents(q){
  const list=$('queueStudentList'); q=q.trim();
  const type=currentQueueType;
  if(!type){list.innerHTML='<div style="text-align:center;color:#999;padding:20px;">无类型</div>';return;}
  let html='';
  if(!q){
    // 显示主要分类按钮
    if(type==='grand'){
      const arr=studentDatabase['钢琴教研室']||[];
      const studentNames = arr.map(s => getStudentName(s)); // 🔥 修复：正确获取学生姓名
      html='<div class="category-title">钢琴教研室</div>'+
        studentNames.map(name=>renderQueueSelectable(name,type)).join('')||'<div style="text-align:center;color:#999;padding:15px;">暂无学生</div>';
    }else{
      for(const [m,arr] of Object.entries(studentDatabase)){
        const studentNames = arr.map(s => getStudentName(s)); // 🔥 修复：正确获取学生姓名
        html+=`<div class="category-title">${m}</div>`+
          studentNames.map(name=>renderQueueSelectable(name,type)).join('');
      }
    }
  }else{
    for(const [m,arr] of Object.entries(studentDatabase)){
      const f=arr.filter(s=>{
        const studentName = getStudentName(s); // 🔥 修复：正确获取学生姓名
        return matchPinyin(studentName, q);
      }).map(s => getStudentName(s)); // 🔥 修复：转换为姓名字符串
      if(f.length){
        html+=`<div class="category-title">${m}</div>`+f.map(name=>renderQueueSelectable(name,type)).join('');
      }
    }
  }
  if(!html) html='<div style="text-align:center;color:#999;padding:20px;">未找到匹配学生</div>';
  list.innerHTML=html;
  $('addNewQueueStudentSection').style.display='block';
}

function renderQueueSelectable(name,type){
  const v=validateQueueAdd(name,type);
  const status = getStudentStatusForModal(name);
  const cls = 'student-item'+(v.ok?'': ' disabled-student');
  const click = v.ok? `onclick="attemptQueueAdd('${name}')"`:`onclick="showStudentStatusHint('${name}','${status.reason||'不可加入'}')"`;
  return `<div class="${cls}" ${click}>
    <span class="student-name-text">${name}</span>${status.statusBadge||''}
  </div>`;
}
function attemptQueueAdd(name){
  if(!currentQueueType) return;
  const v=validateQueueAdd(name,currentQueueType);
  if(!v.ok){showToast(v.reason);return;}
  queueList[currentQueueType].push(name);
  persistQueues();
  updateQueueDisplay();
  closeQueueStudentModal();
  showToast(`${name} 已加入排队`);
}
function addNewQueueStudent(){
  if(!currentQueueType){showToast('无类型');return;}
  const name=$('queueStudentSearch').value.trim();
  if(!name){alert('请输入姓名');return;}
  if(Object.values(studentDatabase).some(a=>a.includes(name))){
    // 已存在 -> 直接验证加入
    const v=validateQueueAdd(name,currentQueueType);
    if(!v.ok){alert(v.reason);return;}
  }else{
    let major=currentQueueType==='grand'?'钢琴教研室':'其他';
    if(!studentDatabase[major]) studentDatabase[major]=[];
    studentDatabase[major].push(name);
    persistStudents();
  }
  queueList[currentQueueType].push(name);
  persistQueues();
  updateQueueDisplay();
  closeQueueStudentModal();
  showToast('已添加并排队');
}
function updateQueueDisplay(){
  ['grand','upright','none'].forEach(type=>{
    const box = $(type + 'QueueList');
    const arr = queueList[type];
    if(!box) return;

    if(!arr.length){
      box.innerHTML = '<div class="empty-queue">暂无排队学生</div>';
    }else{
      const waits = computeQueueWaits(type);
      const html = arr.map((student,i)=>{
        const waitMs = waits[i];
        const ready = waitMs <= 0;
        const waitText = formatWait(waitMs);
        return `
          <div class="queue-item${ready?' has-available-rooms':''}" 
               data-type="${type}" 
               data-index="${i}" 
               data-student="${student}" 
               ${ready?`data-ready="1"`:''}>
            <div class="queue-number">${i+1}</div>
            <div class="queue-student-info">
              <div class="queue-student-name">${student}</div>
              <div class="queue-wait">${waitText}</div>
            </div>
            <div class="queue-actions">
              <button class="queue-btn up" ${i===0?'disabled':''} data-action="up">↑</button>
              <button class="queue-btn down" ${i===arr.length-1?'disabled':''} data-action="down">↓</button>
              <button class="queue-btn remove" data-action="remove">✕</button>
            </div>
          </div>`;
      }).join('');
      box.innerHTML = html;
    }

    // 新增：根据是否为空隐藏对应 section
    const sectionIdMap = {grand:'grandQueueSection',upright:'uprightQueueSection',none:'noneQueueSection'};
    const section = $(sectionIdMap[type]);
    if(section){
      section.style.display = queueList[type].length ? 'block' : 'none';
    }
  });

  bindQueueListEventsOnce();

  // 面板总体显示条件：任一非空
  const visible = queueList.grand.length || queueList.upright.length || queueList.none.length;
  document.querySelector('.panel.queue').style.display = visible ? 'block':'none';
}

let queueEventsBound = false;
function bindQueueListEventsOnce(){
  if(queueEventsBound) return;
  const panel = document.querySelector('.panel.queue');
  if(!panel) return;
  panel.addEventListener('click', e=>{
    const item = e.target.closest('.queue-item');
    const btn  = e.target.closest('.queue-btn');
    if(btn && item){
      const type = item.dataset.type;
      const index = parseInt(item.dataset.index);
      const action = btn.dataset.action;
      if(action==='up'){ moveQueueItem(type,index,-1); }
      else if(action==='down'){ moveQueueItem(type,index,1); }
      else if(action==='remove'){ removeFromQueue(type,index); }
      return;
    }
    if(item && item.dataset.ready==='1'){
      // 只有 ready 时才允许点击整体进入选择
      const type = item.dataset.type;
      const student = item.dataset.student;
      showReplaceableRoomsModal(student,type);
    }
  });
  queueEventsBound = true;
}

/* 覆盖 move / remove 后直接调用 updateQueueDisplay (不再单独 refreshAllQueueWaits) */
function moveQueueItem(type,i,dir){
  const arr=queueList[type];
  const ni=i+dir;
  if(ni<0||ni>=arr.length) return;
  [arr[i],arr[ni]]=[arr[ni],arr[i]];
  persistQueues();
  updateQueueDisplay();
}
function removeFromQueue(type,i){
  const arr=queueList[type];
  const stu=arr[i];
  if(!confirm(`将 ${stu} 移出${type==='grand'?'三角':type==='upright'?'立式':'普通'}队列?`))return;
  arr.splice(i,1);
  persistQueues();
  updateQueueDisplay();
  showToast('已移除');
}

function clearQueue(type){
  if(!queueList[type].length){showToast('队列为空');return;}
  if(!confirm(`清空${type==='grand'?'三角':type==='upright'?'立式':'普通'}琴房排队?`))return;
  queueList[type]=[];
  persistQueues();updateQueueDisplay();
}
function clearAllQueues(){
  if(!queueList.grand.length && !queueList.upright.length && !queueList.none.length){
    showToast('无任何排队');
    return;
  }
  if(!confirm('确定清空所有排队?'))return;
  queueList={grand:[],upright:[],none:[]};
  persistQueues();updateQueueDisplay();
  showToast('已清空全部排队');
}

/* 等待时间估算 */
function computeQueueWaits(type){
  const now=Date.now();
  const prep=60000;
  const max=systemSettings.basePracticeDuration*60*1000;
  const candidates=rooms.filter(r=>{
    if(type==='grand') return r.pianoKind==='三角钢琴';
    if(type==='upright') return r.pianoKind==='立式钢琴';
    return r.pianoKind==='无钢琴';
  });
  if(!candidates.length) return queueList[type].map(()=>0);
  const finishTimes=candidates.map(r=>{
    if(!r.student) return now;
    const prepEnd=r.registerTime+prep;
    if(now<prepEnd) return r.registerTime+prep+max;
    const used=now-prepEnd;
    if(used>max) return now;
    return r.registerTime+prep+max;
  });
  const servers=[...finishTimes];
  const waits=[];
  queueList[type].forEach(()=>{
    let mi=0;
    for(let j=1;j<servers.length;j++) if(servers[j]<servers[mi]) mi=j;
    const wait=Math.max(0,servers[mi]-now);
    waits.push(wait);
    servers[mi]+=prep+max;
  });
  return waits;
}
function refreshAllQueueWaits(){
  ['grand','upright','none'].forEach(type=>{
    const arr=queueList[type];
    if(!arr.length) return;
    const waits=computeQueueWaits(type);
    waits.forEach((w,i)=>{
      const el=$(`queue-wait-${type}-${i}`);
      if(el) el.textContent=formatWait(w);
      const item=el?el.closest('.queue-item'):null;
      if(item){
        if(w<=0){
          item.classList.add('has-available-rooms');
          item.onclick=()=>showReplaceableRoomsModal(arr[i],type);
        }else{
          item.classList.remove('has-available-rooms');
          item.onclick=null;
        }
      }
    });
  });
}
/* ========= 队列快速分配 / 替换弹窗 ========= */
function showQueueModal(roomName,type){
  const modal = $('queueModal');
  const listBox = $('queueModalList');
  const room = rooms.find(r=>r.name===roomName);
  if(!modal || !room) return;

  $('queueModalTitle').textContent = `为 ${roomName} 分配（${type==='grand'?'三角':type==='upright'?'立式':'普通'}队列）`;

  const qArr = queueList[type];
  if(!qArr.length){
    listBox.innerHTML = '<div style="padding:20px;text-align:center;color:#999;">当前无排队</div>';
    modal.style.display='block';
    return;
  }

  const roomStatusLine = room.student
    ? `<div style="margin-bottom:10px;font-size:13px;color:#c0392b;">
         当前占用：${room.student}（${getRoomOccupyRuntime(room)}）
       </div>`
    : `<div style="margin-bottom:10px;font-size:13px;color:#27ae60;">
         当前为空闲，可直接分配
       </div>`;

  // 构造队列列表
  const rows = qArr.map((stu,idx)=>{
    const isFirst = idx===0;
    return `<div style="display:flex;align-items:center;justify-content:space-between;
                        padding:8px 10px;border:1px solid #e0e0e0;border-radius:8px;
                        margin-bottom:8px;background:${isFirst?'#fffbe6':'#fff'};">
        <div style="flex:1;min-width:0;">
          <div style="font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${idx+1}. ${stu}</div>
          ${isFirst?'<div style="font-size:11px;color:#b37400;">推荐优先</div>':''}
        </div>
        <button style="background:#3498db;color:#fff;border:none;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:12px;"
          onclick="assignQueueStudentToRoom('${stu}','${roomName}','${type}')">
          分配
        </button>
      </div>`;
  }).join('');

  listBox.innerHTML = roomStatusLine + rows +
    `<div style="margin-top:6px;font-size:11px;line-height:1.4;color:#777;">
       分配逻辑：点击“分配”后该学生将进入此琴房，并自动从队列中移除；
       ${room.student?'原学生将被提前结束并记录日志。':''}
     </div>`;

  modal.style.display='block';
}

function getRoomOccupyRuntime(room){
  if(!room.student) return '';
  const now=Date.now();
  const prepEnd = room.registerTime+60000;
  if(now<prepEnd){
    return '准备中';
  }
  const used = Math.floor((now-prepEnd)/1000);
  const limit = systemSettings.basePracticeDuration*60;
  if(used<=limit) return '已用 '+formatHMS(used);
  return '超时 '+formatHMS(used);
}

function assignQueueStudentToRoom(student,roomName,type){
  const room = rooms.find(r=>r.name===roomName);
  if(!room) return;
  const now = Date.now();

  // 若学生已在其它房间，先清空其它房间
  const otherRooms = rooms.filter(r=>r.student===student && r.name!==roomName);
  otherRooms.forEach(or=>{
    addPracticeLog(or.student,or.name,or.registerTime,now,'转移(队列分配)');
    or.student=null;or.registerTime=null;
  });

  // 如果房间已有学生 -> 日志 & 覆盖
  if(room.student){
    if(!confirm(`确认将 ${student} 分配到 ${roomName} 并结束当前 ${room.student} 的使用？`)){
      return;
    }
    addPracticeLog(room.student,room.name,room.registerTime,now,`被 ${student} 队列替换`);
  }

  room.student = student;
  room.registerTime = now;

  // 从队列移除
  const arr = queueList[type];
  const idx = arr.indexOf(student);
  if(idx>-1) arr.splice(idx,1);

  persistRooms();
  persistQueues();
  updateQueueDisplay();
  needsFullUpdate=true;
  updateRooms();
  closeQueueModal();
  showToast(`${student} 已进入 ${roomName}`);
  // 🔥 立即触发实时状态更新
  triggerRealTimePracticeStatusUpdate();
}


function closeQueueModal(){
  const m=$('queueModal');
  if(m) m.style.display='none';
}

/* =============== 8. 快速需求（可用/替换） =============== */
let currentDemandType=null;
let currentDemandRooms=[];
function handleDemandRequest(type){
  if(isLocked){alert('系统已锁定');return;}
  currentDemandType=type;
  if(queueList[type] && queueList[type].length){
    if(confirm('当前有排队，需先加入队列，是否打开排队选择？')){
      showQueueStudentModal(type);
    }
    return;
  }
  const res=analyzeDemandAvailability(type);
  if(res.available.length){
    showAvailableRoomsModal(res.available,type,'available');
  }else if(res.overtime.length){
    showAvailableRoomsModal(res.overtime,type,'overtime');
  }else{
    if(confirm('无可用/超时琴房，是否加入排队？')){
      showQueueStudentModal(type);
    }
  }
}
function analyzeDemandAvailability(type){
  const now=Date.now();
  const available=[], overtime=[];
  rooms.forEach(r=>{
    const match = (type==='grand' && r.pianoKind==='三角钢琴')
               || (type==='upright' && r.pianoKind==='立式钢琴')
               || (type==='none' && r.pianoKind==='无钢琴');
    if(!match) return;
    if(!r.student) available.push(r);
    else{
      const prepEnd=r.registerTime+60000;
      if(now>prepEnd){
        const used=Math.floor((now-prepEnd)/1000);
        const limit=systemSettings.basePracticeDuration*60;
        if(used>limit){
          overtime.push({...r,overtimeSeconds:used-limit,elapsedTime:used+60});
        }
      }
    }
  });
  overtime.sort((a,b)=>b.overtimeSeconds-a.overtimeSeconds);
  return {available,overtime};
}
function showAvailableRoomsModal(list,type,mode){
  currentDemandRooms=list;
  $('availableRoomsTitle').textContent= mode==='available'
    ?`选择${type==='grand'?'三角':'upright'===type?'立式':'普通'}琴房`
    :'选择超时琴房（将替换当前学生）';
  
  const info=$('availableRoomsInfo');
  info.innerHTML= mode==='available'
    ? `<div style="color:var(--success-color);margin-bottom:12px;">找到 ${list.length} 间空闲琴房</div>`
    : `<div class="overtime-info" style="margin-bottom:12px;">无空闲琴房，以下为可替换的超时琴房</div>`;
  
  // 添加搜索框
  const searchBox = `
    <div style="margin-bottom:15px;">
      <input type="text" id="roomSelectSearch" placeholder="搜索琴房名称、位置..." 
             style="width:100%;padding:8px 12px;border:1px solid var(--border-color);border-radius:6px;font-size:14px;"
             oninput="filterRoomSelection(this.value)">
    </div>`;
  
  // 网格布局显示琴房
  const roomCards = list.map((r,idx)=>{
    let statusInfo = '';
    let cardClass = 'room-select-card available';
    
    if(mode==='overtime'){
      statusInfo = `
        <div class="room-overtime-info">
          <span style="color:var(--danger-color);font-weight:600;">超时 ${formatDurationHuman(r.overtimeSeconds)}</span>
          <div style="font-size:11px;color:#666;margin-top:2px;">当前：${r.student}</div>
        </div>`;
      cardClass = 'room-select-card overtime';
    } else if(r.remark) {
      statusInfo = `<div class="room-remark" style="font-size:11px;color:#666;margin-top:4px;">${r.remark}</div>`;
    }
    
    const typeIcon = r.pianoKind==='三角钢琴' ? '🎹' : r.pianoKind==='立式钢琴' ? '🎹' : '🎵';
    
    return `
      <div class="${cardClass}" 
           data-name="${r.name.toLowerCase()}" 
           data-location="${(r.location||'').toLowerCase()}"
           onclick="selectDemandRoom('${r.name}','${mode}')">
        <div class="room-card-header">
          <span class="room-type-icon">${typeIcon}</span>
          <span class="room-card-name">${r.name}</span>
        </div>
        <div class="room-card-location">${r.location||'未知位置'}</div>
        ${statusInfo}
        <div class="room-select-arrow">→</div>
      </div>`;
  }).join('');

  $('availableRoomsList').innerHTML = searchBox + 
    `<div class="room-select-grid">${roomCards}</div>` + 
    (list.length === 0 ? '<div style="text-align:center;color:#999;padding:25px;">暂无琴房</div>' : '');
  
  $('availableRoomsModal').style.display='block';
  
  // 聚焦搜索框
  setTimeout(()=>{
    const searchInput = $('roomSelectSearch');
    if(searchInput) searchInput.focus();
  }, 100);
}
function filterRoomSelection(query) {
  const cards = document.querySelectorAll('.room-select-card');
  const q = query.toLowerCase().trim();
  
  let visibleCount = 0;
  cards.forEach(card => {
    const name = card.dataset.name || '';
    const location = card.dataset.location || '';
    const shouldShow = !q || name.includes(q) || location.includes(q);
    
    card.style.display = shouldShow ? 'block' : 'none';
    if(shouldShow) visibleCount++;
  });
  
  // 显示过滤结果提示
  let resultHint = document.querySelector('.filter-result-hint');
  if(q && visibleCount === 0) {
    if(!resultHint) {
      resultHint = document.createElement('div');
      resultHint.className = 'filter-result-hint';
      resultHint.style.cssText = 'text-align:center;color:#999;padding:20px;font-style:italic;';
      document.querySelector('.room-select-grid').appendChild(resultHint);
    }
    resultHint.textContent = '未找到匹配的琴房';
    resultHint.style.display = 'block';
  } else if(resultHint) {
    resultHint.style.display = 'none';
  }
}

function selectDemandRoom(name,mode){
  currentRoom=name;
  $('availableRoomsModal').style.display='none';
  // 打开学生选择
  const room=rooms.find(r=>r.name===name);
  openStudentSelectModal(room);
}
function closeAvailableRoomsModal(){
  $('availableRoomsModal').style.display='none';
  currentDemandType=null;currentDemandRooms=[];
  currentRoom=null;
}

/* 替换超时（来自排队闪烁点击） */
function showReplaceableRoomsModal(student,type){
  const {available, overtime}=analyzeDemandAvailability(type);
  if(!available.length && !overtime.length){
    alert('当前无可用或可替换琴房');return;
  }
  
  $('replaceableRoomsTitle').textContent=`为 ${student} 选择琴房`;
  const info=$('replaceableRoomsInfo');
  info.innerHTML=`<div style="margin-bottom:12px;">空闲: <span style="color:var(--success-color);font-weight:600;">${available.length}</span> 间 · 超时: <span style="color:var(--danger-color);font-weight:600;">${overtime.length}</span> 间</div>`;
  
  // 添加搜索框
  const searchBox = `
    <div style="margin-bottom:15px;">
      <input type="text" id="replaceRoomSearch" placeholder="搜索琴房名称、位置..." 
             style="width:100%;padding:8px 12px;border:1px solid var(--border-color);border-radius:6px;font-size:14px;"
             oninput="filterReplaceRoomSelection(this.value)">
    </div>`;
  
  const allRooms = [...available, ...overtime];
  const roomCards = allRooms.map(r=>{
    const isAvailable = available.includes(r);
    const cardClass = isAvailable ? 'room-select-card available' : 'room-select-card overtime';
    const statusIcon = isAvailable ? '🟢' : '🔴';
    const statusText = isAvailable ? '空闲' : '超时';
    const typeIcon = r.pianoKind==='三角钢琴' ? '🎹' : r.pianoKind==='立式钢琴' ? '🎹' : '🎵';
    
    let extraInfo = '';
    if(!isAvailable) {
      extraInfo = `<div style="font-size:11px;color:var(--danger-color);margin-top:2px;">当前：${r.student}</div>`;
    }
    
    const action = isAvailable ? 'available' : 'replace';
    
    return `
      <div class="${cardClass}" 
           data-name="${r.name.toLowerCase()}" 
           data-location="${(r.location||'').toLowerCase()}"
           onclick="replaceWithQueueStudent('${student}','${type}','${r.name}','${action}')">
        <div class="room-card-header">
          <span class="room-type-icon">${typeIcon}</span>
          <span class="room-card-name">${r.name}</span>
          <span style="font-size:12px;">${statusIcon}</span>
        </div>
        <div class="room-card-location">${r.location||'未知位置'}</div>
        <div style="font-size:11px;color:#666;font-weight:600;">${statusText}</div>
        ${extraInfo}
        <div class="room-select-arrow">→</div>
      </div>`;
  }).join('');
  
  $('replaceableRoomsList').innerHTML = searchBox + 
    `<div class="room-select-grid">${roomCards}</div>`;
  
  $('replaceableRoomsModal').style.display='block';
  
  // 聚焦搜索框
  setTimeout(()=>{
    const searchInput = $('replaceRoomSearch');
    if(searchInput) searchInput.focus();
  }, 100);
}

function filterReplaceRoomSelection(query) {
  const cards = document.querySelectorAll('#replaceableRoomsList .room-select-card');
  const q = query.toLowerCase().trim();
  
  let visibleCount = 0;
  cards.forEach(card => {
    const name = card.dataset.name || '';
    const location = card.dataset.location || '';
    const shouldShow = !q || name.includes(q) || location.includes(q);
    
    card.style.display = shouldShow ? 'block' : 'none';
    if(shouldShow) visibleCount++;
  });
}
function closeReplaceableRoomsModal(){ $('replaceableRoomsModal').style.display='none'; }
function replaceWithQueueStudent(student,type,roomName,mode){
  const room=rooms.find(r=>r.name===roomName);
  if(!room){alert('琴房不存在');return;}
  const idx=queueList[type].indexOf(student);
  if(idx<0){alert('学生已不在队列');closeReplaceableRoomsModal();return;}
  const now=Date.now();
  if(mode==='replace' && room.student){
    addPracticeLog(room.student,room.name,room.registerTime,now,`被 ${student} 替换`);
  }
  room.student=student;
  room.registerTime=now;
  queueList[type].splice(idx,1);
  persistRooms();persistQueues();
  updateQueueDisplay();
  needsFullUpdate=true;updateRooms();
  closeReplaceableRoomsModal();
  showToast(`${student} 已进入 ${roomName}`);
  // 🔥 立即触发实时状态更新
  triggerRealTimePracticeStatusUpdate();
  // 🔥 新增：刷新搜索结果
  refreshSearchResults();
}

/* =============== 9. 时间轴预测 =============== */
function toggleTimeline(){
  timelineVisible=!timelineVisible;
  localStorage.setItem(KEYS.TIMELINE_VISIBLE, timelineVisible.toString());
  const btn=$('timelineMainControlBtn');
  const section=$('timelineSection');
  if(timelineVisible){
    section.style.display='block';
    btn.classList.add('active');
    btn.querySelector('.timeline-control-text').textContent='隐藏琴房状态预测';
    btn.querySelector('.timeline-control-icon').textContent='👁️';
    updateTimeline();
  }else{
    section.style.display='none';
    btn.classList.remove('active');
    btn.querySelector('.timeline-control-text').textContent='显示琴房状态预测';
    btn.querySelector('.timeline-control-icon').textContent='⏰';
  }
}
function updateTimeline(){
  if(!timelineVisible) return;

  const now = Date.now();
  const baseMs = systemSettings.basePracticeDuration * 60000;
  const prepMs = 60000;

  const soonList = [];      // 剩余 <= 15 分钟
  const overtimeList = [];  // 已超时

  // 确保 rooms 数组存在且有效
  if(!rooms || !Array.isArray(rooms)) {
    rooms = [];
  }

  rooms.forEach(r=>{
    if(!r.student) return;

    const card = {
      name: r.name,
      pianoType: r.pianoKind || '无钢琴',
      location: r.location || '',
      remark: r.remark || '',
      student: r.student,
      remainMs: null,
      overtimeMs: null,
      isPreparing: false,
      usedSeconds: 0
    };

    const prepEnd = r.registerTime + prepMs;
    const endLimit = prepEnd + baseMs;

    if(now < prepEnd){
      // 准备阶段
      card.isPreparing = true;
      return;
    }

    const used = now - prepEnd;
    card.usedSeconds = Math.floor(used/1000);

    if(used > baseMs){
      card.overtimeMs = used - baseMs;
      overtimeList.push(card);
    }else{
      const remain = endLimit - now;
      card.remainMs = remain;
      if(remain <= 15*60000){
        soonList.push(card);
      }
    }
  });

  // 排序：soon 按剩余升序 / 名称；overtime 按超时降序 / 名称
  soonList.sort((a,b)=>{
    if(a.remainMs !== b.remainMs) return a.remainMs - b.remainMs;
    return a.name.localeCompare(b.name,'zh-Hans-CN');
  });
  overtimeList.sort((a,b)=>{
    if(a.overtimeMs !== b.overtimeMs) return b.overtimeMs - a.overtimeMs;
    return a.name.localeCompare(b.name,'zh-Hans-CN');
  });

  // 更新计数显示
  const soonCountEl = $('focusSoonCount');
  const overCountEl = $('focusOverCount');
  if(soonCountEl) soonCountEl.textContent = soonList.length;
  if(overCountEl) overCountEl.textContent = overtimeList.length;

  // 🔥 关键改进：增量更新而非重建整个容器
  updateTimelineContainer('focusSoonBody', soonList, 'soon');
  updateTimelineContainer('focusOverBody', overtimeList, 'overtime');

  // 应用过滤器
  filterFocusCards();
}

// 🔥 新增：增量更新容器函数
function updateTimelineContainer(containerId, dataList, type) {
  const container = $(containerId);
  if(!container) return;

  // 如果没有数据，显示空状态
  if(!dataList.length) {
    const emptyMsg = type === 'soon' 
      ? '暂无 15 分钟内将释放的琴房' 
      : '暂无超时琴房';
    
    if(container.children.length !== 1 || !container.querySelector('.focus-empty')) {
      container.innerHTML = `<div class="focus-empty">${emptyMsg}</div>`;
    }
    return;
  }

  // 移除空状态提示
  const emptyEl = container.querySelector('.focus-empty');
  if(emptyEl) emptyEl.remove();

  // 获取现有卡片
  const existingCards = Array.from(container.querySelectorAll('.focus-card'));
  const existingNames = existingCards.map(card => card.dataset.name);
  const newNames = dataList.map(item => item.name);

  // 1. 移除不再存在的卡片
  existingCards.forEach(card => {
    if(!newNames.includes(card.dataset.name)) {
      card.remove();
    }
  });

  // 2. 更新或添加卡片
  dataList.forEach((item, index) => {
    let card = container.querySelector(`[data-name="${item.name}"]`);
    
    if(!card) {
      // 创建新卡片
      card = document.createElement('div');
      card.className = `focus-card ${type}`;
      card.dataset.name = item.name;
      card.dataset.type = item.pianoType;
      card.dataset.location = item.location;
      card.dataset.student = item.student;
      
      // 插入到正确位置
      if(index === 0) {
        container.insertBefore(card, container.firstChild);
      } else {
        const prevCard = container.querySelector(`[data-name="${dataList[index-1].name}"]`);
        if(prevCard && prevCard.nextSibling) {
          container.insertBefore(card, prevCard.nextSibling);
        } else {
          container.appendChild(card);
        }
      }
    }

    // 更新卡片内容（只更新动态部分）
    updateCardContent(card, item, type);
    
    // 确保卡片在正确位置
    const currentIndex = Array.from(container.children).indexOf(card);
    if(currentIndex !== index) {
      if(index === 0) {
        container.insertBefore(card, container.firstChild);
      } else {
        const targetPrev = container.children[index - 1];
        if(targetPrev) {
          container.insertBefore(card, targetPrev.nextSibling);
        }
      }
    }
  });
}

// 🔥 修复：更新单个卡片的动态内容
function updateCardContent(cardElement, data, type) {
  // 工具函数
  function typeTag(t){
    if(t==='三角钢琴') return '<span class="fc-tag grand">三角</span>';
    if(t==='立式钢琴') return '<span class="fc-tag upright">立式</span>';
    return '<span class="fc-tag none">普通</span>';
  }
  
  function fmt(ms){
    if(ms==null) return '';
    let s = Math.ceil(ms/1000);
    if(s<60) return s+'秒';
    let m = Math.ceil(s/60);
    if(m<60) return m+'分';
    const h = Math.floor(m/60), mm = m%60;
    return h+'小时'+(mm?mm+'分':'');
  }

  // 更新或创建基础结构 - 修改为与琴房卡片一致的结构
  if(!cardElement.querySelector('.fc-room')) {
    cardElement.innerHTML = `
      <div class="fc-room"></div>
      <div class="fc-stu">
        <span class="dot"></span><span class="fc-stu-name"></span>
      </div>
      <div class="fc-status">
        <div class="fc-bottom-row">
          <div class="fc-status-chip"></div>
        </div>
      </div>
    `;
  }

  // 更新房间名称（相对静态）
  const roomEl = cardElement.querySelector('.fc-room');
  const expectedRoomContent = `${data.name}${typeTag(data.pianoType)}`;
  if(roomEl.innerHTML !== expectedRoomContent) {
    roomEl.innerHTML = expectedRoomContent;
    roomEl.title = data.name;
  }

  // 更新学生名称（相对静态）
  const stuNameEl = cardElement.querySelector('.fc-stu-name');
  if(stuNameEl.textContent !== data.student) {
    stuNameEl.textContent = data.student;
    cardElement.querySelector('.fc-stu').title = data.student;
  }

  // 更新状态芯片 - 🔥 关键修复：让位置和备注与状态芯片在同一行显示
  const chipEl = cardElement.querySelector('.fc-status-chip');

  if(type === 'soon') {
    // 15分钟内释放 - 只显示剩余时间 + 位置
    const chips = [];
    chips.push(`<span class="fc-chip remain">剩 ${fmt(data.remainMs)}</span>`);
    
    // 只添加位置信息 - 🔥 添加左边距
    if(data.location && data.location.trim()) {
      chips.push(`<span class="fc-chip location" title="${data.location}" style="margin-left: 8px;">${data.location}</span>`);
    }
    
    chipEl.innerHTML = chips.join('');
    
  } else if(type === 'overtime') {
    // 超时 - 只显示超时时长 + 位置
    const chips = [];
    chips.push(`<span class="fc-chip overtime">超时 ${fmt(data.overtimeMs)}</span>`);
    
    // 只添加位置信息 - 🔥 添加左边距
    if(data.location && data.location.trim()) {
      chips.push(`<span class="fc-chip location" title="${data.location}" style="margin-left: 8px;">${data.location}</span>`);
    }
    
    chipEl.innerHTML = chips.join('');
  }
}

function filterFocusCards(){
  const kw = '';
  const typeF = $('focusTypeFilter')?.value || '';
  ['SoonBody','OverBody'].forEach(suffix=>{
    const box = $('focus'+suffix);
    if(!box) return;
    const cards = box.querySelectorAll('.focus-card');
    if(!cards.length) return;
    let visible = 0;
    cards.forEach(card=>{
      const name = card.dataset.name.toLowerCase();
      const loc  = (card.dataset.location||'').toLowerCase();
      const stu  = (card.dataset.student||'').toLowerCase();
      const type = card.dataset.type;
      let show = true;
      if(typeF && type !== typeF) show = false;
      if(kw && !(name.includes(kw)||loc.includes(kw)||stu.includes(kw))) show = false;
      card.style.display = show ? '' : 'none';
      if(show) visible++;
    });
    // 处理过滤空提示
    const old = box.querySelector('.focus-empty-filter');
    if(visible===0 && cards.length){
      if(!old){
        const div=document.createElement('div');
        div.className='focus-empty-filter';
        div.textContent='无匹配结果';
        box.appendChild(div);
      }
    }else if(old){
      box.removeChild(old);
    }
  });
}

/* =============== 10. 超时管理 =============== */
function getOvertimeRecords(){
  const now=Date.now();
  const rec={grand:[],upright:[],other:[]};
  rooms.forEach(r=>{
    if(!r.student) return;
    const prepEnd=r.registerTime+60000;
    if(now<=prepEnd) return;
    const used=Math.floor((now-prepEnd)/1000);
    const limit=systemSettings.basePracticeDuration*60;
    if(used>limit){
      const over=used-limit;
      const target = r.pianoKind==='三角钢琴'?'grand':r.pianoKind==='立式钢琴'?'upright':'other';
      rec[target].push({
        room:r.name,student:r.student,usedSeconds:used,overtimeSeconds:over,location:r.location,pianoKind:r.pianoKind
      });
    }
  });
  Object.values(rec).forEach(arr=>arr.sort((a,b)=>b.overtimeSeconds-a.overtimeSeconds));
  return rec;
}
function openOvertimeModal(){renderOvertimeList(true);$('overtimeModal').style.display='block';}
function closeOvertimeModal(){$('overtimeModal').style.display='none';}
function renderOvertimeList(force){
  const search=$('overtimeSearch').value.trim().toLowerCase();
  const rec=getOvertimeRecords();
  let total=0;
  const box=$('overtimeContent');
  const build=(title,arr)=>{
    if(!arr.length) return '';
    const fil=arr.filter(r=>!search||r.room.toLowerCase().includes(search)||r.student.toLowerCase().includes(search));
    if(!fil.length) return '';
    total+=fil.length;
    return `<div class="overtime-category">
      <div class="overtime-category-header"><span>${title}</span><span class="overtime-category-count">${fil.length} 间</span></div>
      <div class="overtime-list-header"><div>琴房</div><div>学生</div><div>位置</div><div>已用时</div><div>超时时长</div><div>操作</div></div>
      ${fil.map(r=>`<div class="overtime-item highlight-expired">
        <div>${r.room}</div><div>${r.student}</div><div>${r.location||''}</div>
        <div>${formatHMS(r.usedSeconds)}</div>
        <div style="color:var(--danger-color);font-weight:700;">${formatDurationHuman(r.overtimeSeconds)}</div>
        <div class="ot-actions">
          <button class="btn-mini-danger" onclick="clearOvertimeRoom('${r.room}')">清空</button>
        </div>
      </div>`).join('')}
    </div>`;
  };
  box.innerHTML=
    build('三角钢琴',rec.grand)+
    build('立式钢琴',rec.upright)+
    build('其他琴房',rec.other) ||
    '<div style="text-align:center;color:#999;padding:40px;">暂无超时记录</div>';
  $('overtimeStats').textContent=`共 ${rec.grand.length+rec.upright.length+rec.other.length} 条，当前显示 ${total} 条`;
  refreshOvertimeBadge();
}
function clearAllOvertimeRooms(){
  const rec=getOvertimeRecords();
  const list=[...rec.grand,...rec.upright,...rec.other];
  if(!list.length){showToast('无超时琴房');return;}
  if(!confirm(`确定清空所有 ${list.length} 间超时琴房?`))return;
  const now=Date.now();
  let cleared=[];
  list.forEach(r=>{
    const room=rooms.find(x=>x.name===r.room);
    if(room&&room.student){
      addPracticeLog(room.student,room.name,room.registerTime,now,'超时批量清空');
      cleared.push({room:room.name,student:room.student});
      room.student=null;room.registerTime=null;
    }
  });
  
  // 🔥 立即持久化和同步
  persistRooms();
  
  // 🔥 新增：标记为用户主动操作
  lastUserDestructiveActionTs = Date.now();
  
  // 🔥 改进：批量清空的Firebase同步
  if (syncEnabled && isOnline && cleared.length > 0) {
      syncToFirebase('overtime_batch_clear', {
          clearedRooms: cleared,
          timestamp: now,
          count: cleared.length,
          source: 'overtime_management'
      });
  }
  
  updateRooms();
  renderOvertimeList(true);
  showToast('已清空超时琴房');
  logOperation('clear_all_overtime',{count:cleared.length,details:cleared});
}


function refreshOvertimeBadge(){
  const badge = $('overtimeCountBadge');
  const btn = document.querySelector('.overtime-manage-btn');
  if(!badge || !btn) return;
  
  const rec = getOvertimeRecords();
  const total = rec.grand.length + rec.upright.length + rec.other.length;
  
  if(total > 0){
    badge.style.display = 'inline-block';
    badge.textContent = total;
  } else {
    badge.style.display = 'none';
  }
}
/* =============== 10.5. 练习时长记录系统 =============== */

/**
 * 清理过期的练习记录（保留最近30天）
 */
function cleanupOldPracticeRecords() {
    const now = new Date();
    const cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const cutoffKey = toDateKey(cutoffDate);
    
    let cleaned = 0;
    Object.keys(dailyPracticeRecords).forEach(dateKey => {
        if (dateKey < cutoffKey) {
            delete dailyPracticeRecords[dateKey];
            cleaned++;
        }
    });
    
    if (cleaned > 0) {
        console.log(`🧹 清理了 ${cleaned} 天的过期练习记录`);
        persistPracticeRecords();
    }
}

/**
 * 开始练琴会话记录
 */
function startPracticeSession(studentName, roomName, registerTime) {
    const sessionId = `${studentName}_${roomName}_${registerTime}`;
    const now = Date.now();
    
    // 检查学生的时间段设置
    const studentSlots = getStudentTodaySlots(studentName);
    const currentSlot = findCurrentTimeSlot(studentSlots, now);
    
    const session = {
        sessionId,
        studentName,
        roomName,
        startTime: registerTime,
        prepEndTime: registerTime + 60000, // 准备结束时间
        actualStartTime: null, // 实际开始练琴时间（准备结束后）
        endTime: null,
        inSlotTime: 0, // 时间段内练习时长（秒）
        outSlotTime: 0, // 时间段外练习时长（秒）
        currentSlot: currentSlot, // 当前所在时间段
        slotTransitions: [], // 时间段转换记录
        isActive: true
    };
    
    practiceSessionTracker.set(sessionId, session);
    console.log('🎹 开始练琴会话:', sessionId, currentSlot ? `在时间段 ${currentSlot.start}-${currentSlot.end}` : '不在时间段内');
    
    return session;
}

/**
 * 更新练琴会话（每分钟调用）
 */
function updatePracticeSessions() {
    const now = Date.now();
    
    practiceSessionTracker.forEach((session, sessionId) => {
        if (!session.isActive) return;
        
        // 检查房间状态是否仍然匹配
        const room = rooms.find(r => r.name === session.roomName && r.student === session.studentName);
        if (!room) {
            // 房间已被清空，结束会话
            endPracticeSession(sessionId, now, '房间状态变更');
            return;
        }
        
        // 如果还在准备阶段，不计算练习时长
        if (now < session.prepEndTime) {
            return;
        }
        
        // 设置实际开始时间
        if (!session.actualStartTime) {
            session.actualStartTime = session.prepEndTime;
        }
        
        // 获取当前时间段状态
        const studentSlots = getStudentTodaySlots(session.studentName);
        const currentSlot = findCurrentTimeSlot(studentSlots, now);
        
        // 检查时间段是否发生变化
        if (JSON.stringify(currentSlot) !== JSON.stringify(session.currentSlot)) {
            session.slotTransitions.push({
                time: now,
                fromSlot: session.currentSlot,
                toSlot: currentSlot
            });
            session.currentSlot = currentSlot;
            console.log(`🔄 ${session.studentName} 时间段变化:`, currentSlot ? `进入 ${currentSlot.start}-${currentSlot.end}` : '离开时间段');
        }
        
        // 计算自上次更新以来的时长增量（60秒）
        const increment = 60; // 每分钟更新一次
        
        if (currentSlot) {
            session.inSlotTime += increment;
        } else {
            session.outSlotTime += increment;
        }
        
        console.log(`⏱️ ${session.studentName} 练习时长更新: 段内${Math.floor(session.inSlotTime/60)}分 段外${Math.floor(session.outSlotTime/60)}分`);
    });
}

/**
 * 结束练琴会话
 */
function endPracticeSession(sessionId, endTime, reason = '正常结束') {
    const session = practiceSessionTracker.get(sessionId);
    if (!session || !session.isActive) return null;
    
    session.endTime = endTime;
    session.isActive = false;
    session.endReason = reason;
    
    // 计算最终时长
    const actualEndTime = endTime;
    const actualStartTime = session.actualStartTime || session.prepEndTime;
    
    if (actualEndTime > actualStartTime) {
        const totalPracticeTime = Math.floor((actualEndTime - actualStartTime) / 1000);
        
        // 重新精确计算时间段内外时长
        recalculateSessionTimes(session);
        
        // 记录到日常练习记录
        recordDailyPractice(session);
        
        console.log(`🏁 结束练琴会话: ${session.studentName} - ${reason}`);
        console.log(`   总时长: ${Math.floor(totalPracticeTime/60)}分${totalPracticeTime%60}秒`);
        console.log(`   段内: ${Math.floor(session.inSlotTime/60)}分${session.inSlotTime%60}秒`);
        console.log(`   段外: ${Math.floor(session.outSlotTime/60)}分${session.outSlotTime%60}秒`);
    }
    
    // 从跟踪器中移除
    practiceSessionTracker.delete(sessionId);
    
    return session;
}

/**
 * 重新精确计算会话的时间段内外时长
 */
function recalculateSessionTimes(session) {
    if (!session.actualStartTime || !session.endTime) return;
    
    const studentSlots = getStudentTodaySlots(session.studentName);
    let inSlotTime = 0;
    let outSlotTime = 0;
    
    // 按分钟精确计算
    const startMinute = Math.floor(session.actualStartTime / 60000) * 60000;
    const endMinute = Math.floor(session.endTime / 60000) * 60000;
    
    for (let time = startMinute; time < endMinute; time += 60000) {
        const slot = findCurrentTimeSlot(studentSlots, time);
        if (slot) {
            inSlotTime += 60;
        } else {
            outSlotTime += 60;
        }
    }
    
    // 处理最后不足一分钟的部分
    const remainingSeconds = Math.floor((session.endTime - session.actualStartTime) / 1000) % 60;
    const lastSlot = findCurrentTimeSlot(studentSlots, session.endTime);
    if (lastSlot) {
        inSlotTime += remainingSeconds;
    } else {
        outSlotTime += remainingSeconds;
    }
    
    session.inSlotTime = inSlotTime;
    session.outSlotTime = outSlotTime;
}

/**
 * 记录到日常练习记录
 */
function recordDailyPractice(session) {
    const dateKey = toDateKey(new Date(session.startTime));
    
    if (!dailyPracticeRecords[dateKey]) {
        dailyPracticeRecords[dateKey] = {};
    }
    
    if (!dailyPracticeRecords[dateKey][session.studentName]) {
        dailyPracticeRecords[dateKey][session.studentName] = {
            inSlot: 0,
            outSlot: 0,
            totalSessions: 0,
            sessions: [],
            lastUpdated: Date.now()
        };
    }
    
    const record = dailyPracticeRecords[dateKey][session.studentName];
    record.inSlot += session.inSlotTime;
    record.outSlot += session.outSlotTime;
    record.totalSessions++;
    record.lastUpdated = Date.now();
    
    // 记录会话详情
    record.sessions.push({
        sessionId: session.sessionId,
        roomName: session.roomName,
        startTime: session.startTime,
        endTime: session.endTime,
        inSlotTime: session.inSlotTime,
        outSlotTime: session.outSlotTime,
        endReason: session.endReason,
        slotTransitions: session.slotTransitions.length
    });
    
    // 持久化
    persistPracticeRecords();
    
    // 同步到Firebase
    syncPracticeRecordsToFirebase(dateKey, session.studentName);
    
    console.log(`📊 记录日常练习: ${session.studentName} ${dateKey}`);
    console.log(`   累计段内: ${Math.floor(record.inSlot/60)}分 段外: ${Math.floor(record.outSlot/60)}分`);
}

/**
 * 获取学生今日时间段
 */
function getStudentTodaySlots(studentName) {
    const now = new Date();
    const weekday = WEEK_MAP[now.getDay()];
    if (!weekday || !studentTimeSlots[studentName]) return [];
    
    return studentTimeSlots[studentName][weekday] || [];
}

/**
 * 查找当前时间所在的时间段
 */
function findCurrentTimeSlot(slots, timestamp) {
    const date = new Date(timestamp);
    const currentMinutes = date.getHours() * 60 + date.getMinutes();
    
    return slots.find(slot => {
        const startMin = timeToMinutes(slot.start);
        const endMin = timeToMinutes(slot.end);
        return currentMinutes >= startMin && currentMinutes < endMin;
    });
}

/**
 * 获取学生指定日期的练习记录
 */
function getStudentPracticeRecord(studentName, dateKey = null) {
    if (!dateKey) dateKey = todayKey();
    
    return dailyPracticeRecords[dateKey]?.[studentName] || {
        inSlot: 0,
        outSlot: 0,
        totalSessions: 0,
        sessions: [],
        lastUpdated: 0
    };
}

/**
 * 获取学生最近几天的练习统计
 */
function getStudentPracticeStats(studentName, days = 7) {
    const stats = {
        totalDays: 0,
        totalInSlot: 0,
        totalOutSlot: 0,
        totalSessions: 0,
        dailyDetails: []
    };
    
    const today = new Date();
    for (let i = 0; i < days; i++) {
        const date = new Date(today.getTime() - i * 24 * 60 * 60 * 1000);
        const dateKey = toDateKey(date);
        const record = getStudentPracticeRecord(studentName, dateKey);
        
        if (record.totalSessions > 0) {
            stats.totalDays++;
            stats.totalInSlot += record.inSlot;
            stats.totalOutSlot += record.outSlot;
            stats.totalSessions += record.totalSessions;
            
            stats.dailyDetails.push({
                date: dateKey,
                inSlot: record.inSlot,
                outSlot: record.outSlot,
                sessions: record.totalSessions
            });
        }
    }
    
    return stats;
}

/**
 * 持久化练习记录
 */
function persistPracticeRecords() {
    lsSet('dailyPracticeRecords', dailyPracticeRecords);
}

/**
 * 同步练习记录到Firebase
 */
function syncPracticeRecordsToFirebase(dateKey, studentName) {
    if (!isOnline || !syncEnabled || !database) return;
    
    const now = Date.now();
    if (now - lastPracticeSync < 5000) return;
    
    lastPracticeSync = now;
    
    const record = dailyPracticeRecords[dateKey]?.[studentName];
    if (!record) return;
    
    // 限制会话记录数量
    const MAX_SESSION_KEEP = 50;
    let sessions = record.sessions || [];
    
    if (sessions.length > MAX_SESSION_KEEP) {
        sessions = sessions.slice(-MAX_SESSION_KEEP);
        record.sessions = sessions;
    }
    
    // 🔥 保持原始数据结构，不做字段转换
    const syncData = {
        studentName,
        dateKey,
        inSlotSeconds: record.inSlot,
        outSlotSeconds: record.outSlot,
        totalSessions: record.totalSessions,
        lastUpdated: record.lastUpdated,
        syncTime: now,
        sessions: sessions,  // 🔥 保持原始的 start/end 字段
        // 🔥 如果需要，可以添加元数据说明准备期处理方式
        metadata: {
            preparationPeriodSec: 60,
            note: "sessions contain raw start/end times including preparation period"
        }
    };
    
    database.ref(`${FIREBASE_PATHS.PRACTICE_RECORDS}/${dateKey}/${studentName}`)
        .update(syncData)
        .then(() => {
            console.log(`✅ 练习记录已同步: ${studentName} ${dateKey}`);
        })
        .catch(error => {
            console.error('❌ 练习记录同步失败:', error);
        });
}


/**
 * 格式化练习时长显示
 */
function formatPracticeTime(seconds) {
    if (seconds <= 0) return '0分钟';
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    let result = '';
    if (hours > 0) result += `${hours}小时`;
    if (minutes > 0) result += `${minutes}分钟`;
    if (secs > 0 && hours === 0) result += `${secs}秒`;
    
    return result || '0分钟';
}

/**
 * 导出学生练习时长报告
 */
function exportStudentPracticeReport(studentName = null, days = 7) {
    const today = new Date();
    const students = studentName ? [studentName] : Object.keys(studentDatabase).flatMap(major => 
        studentDatabase[major].map(s => getStudentName(s))
    );
    
    let csvContent = '学生姓名,日期,时间段内练习(分钟),时间段外练习(分钟),总练习时长(分钟),练琴次数,专业\n';
    
    students.forEach(student => {
        const major = getStudentMajor(student);
        
        for (let i = 0; i < days; i++) {
            const date = new Date(today.getTime() - i * 24 * 60 * 60 * 1000);
            const dateKey = toDateKey(date);
            const record = getStudentPracticeRecord(student, dateKey);
            
            if (record.totalSessions > 0) {
                const inSlotMin = Math.floor(record.inSlot / 60);
                const outSlotMin = Math.floor(record.outSlot / 60);
                const totalMin = inSlotMin + outSlotMin;
                
                csvContent += `${escapeCSV(student)},${dateKey},${inSlotMin},${outSlotMin},${totalMin},${record.totalSessions},${escapeCSV(major)}\n`;
            }
        }
    });
    
    const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `学生练习时长报告_${todayKey()}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showToast('✅ 练习时长报告已导出', 3000);
}

/* =============== 11. 考勤系统（聚合版最终整合） =============== */
let attendanceRealTimeInterval = null;
let isAttendanceModalOpen = false;
/**
 * 🔥 修复：安全的字符串处理函数
 */
function safeString(value) {
    if (value === null || value === undefined) {
        return '';
    }
    return String(value);
}

/**
 * 🔥 修复：安全的 trim 函数
 */
function safeTrim(value) {
    return safeString(value).trim();
}
function initAttendanceCheck() {
    // 每5分钟刷新，页面加载后2秒首次计算
    setInterval(checkAttendance, 5 * 60 * 1000);
    setTimeout(checkAttendance, 2000);
}

/* ===== 可调常量 ===== */
const ATTEND_BUFFER_MIN = 5; // 聚合段首缓冲分钟

/* ===== 工具函数 ===== */
function fmtPracticeSec(sec) {
    if (sec <= 0) return '0分';
    const m = Math.floor(sec / 60), s = sec % 60;
    if (m && s) return `${m}分${s}秒`;
    if (m) return `${m}分`;
    return `${s}秒`;
}
function getCurrentOvertimeCount(){
  const now = Date.now();
  const limit = systemSettings.basePracticeDuration * 60 * 1000; // 转换为毫秒
  let count = 0;
  
  rooms.forEach(r => {
    if(!r.student) return;
    const prepEnd = r.registerTime + 60000;
    if(now <= prepEnd) return; // 还在准备阶段
    
    const usedMs = now - prepEnd;
    if(usedMs > limit) {
      count++; // 当前正在超时
    }
  });
  
  return count;
}
// 兼容：某些函数里调用了 getTodayDateString，这里补一个别名
function getTodayDateString() {
  return todayKey(); // todayKey 已经返回 YYYY-MM-DD
}

// =====================
// 计算某学生在一个时间段内的练琴情况
// 返回 { seconds, inPreparingSlot }
// seconds: 已计入（去掉准备期）的有效练琴秒数
// inPreparingSlot: 学生已在房间且当前时间位于 slot 内，但仍未过准备期（用于后续不判缺勤）
// =====================
function getStudentPracticeTimeInSlot(studentName, slot, dateStr, registerTimeMs) {
  if(!dateStr) dateStr = todayKey();
  try {
    if (!slot || !slot.start || !slot.end) {
      return { seconds: 0, inPreparingSlot: false };
    }

    // 当前时间（只用于当天；历史回放可根据需要传入一个固定时间）
    const now = Date.now();
    const todayStr = getTodayDateString();
    const isToday = (dateStr === todayStr);

    // 如果不是今天，我们用该日 slot 结束时间做“观察时间点”
    const observeNow = isToday ? now : new Date(dateStr + 'T' + slot.end + ':00').getTime();

    // 没有 registerTime（不在房间 / 没开始）
    if (!registerTimeMs || isNaN(registerTimeMs)) {
      return { seconds: 0, inPreparingSlot: false };
    }

    const prepEnd = registerTimeMs + 60000; // 1 分钟准备
    const slotStartMs = new Date(`${dateStr}T${slot.start}:00`).getTime();
    const slotEndMs = new Date(`${dateStr}T${slot.end}:00`).getTime();

    // 未进入该时间段
    if (observeNow <= slotStartMs) {
      return { seconds: 0, inPreparingSlot: false };
    }

    // 已经过了时间段
    if (observeNow >= slotEndMs && registerTimeMs >= slotEndMs) {
      // 入房比段结束还晚
      return { seconds: 0, inPreparingSlot: false };
    }

    // 情形一：进入段内但仍在准备期
    if (observeNow < prepEnd && observeNow > slotStartMs) {
      return { seconds: 0, inPreparingSlot: true };
    }

    // 计算有效开始时间（略过准备期 & 不早于 slotStart）
    const effectiveStart = Math.max(prepEnd, slotStartMs);

    // 观察点不应超过 slotEnd
    const effectiveObserve = Math.min(observeNow, slotEndMs);

    if (effectiveObserve <= effectiveStart) {
      // 可能是：准备期还没结束 或 slot 很短
      return {
        seconds: 0,
        inPreparingSlot: (observeNow > slotStartMs && observeNow <= prepEnd)
      };
    }

    const seconds = Math.max(0, Math.floor((effectiveObserve - effectiveStart) / 1000));
    return {
      seconds,
      inPreparingSlot: false
    };
  } catch (e) {
    console.error('getStudentPracticeTimeInSlot 错误', e);
    return { seconds: 0, inPreparingSlot: false };
  }
}


/* 实时状态 */
function getStudentAttendanceStatus(student) {
    const r = rooms.find(x => x.student === student);
    if (r) {
        const now = Date.now();
        const prepEnd = r.registerTime + 60000;
        if (now < prepEnd) return { presence: 'practicing', label: '准备中', room: r.name };
        const usedSec = Math.floor((now - prepEnd) / 1000);
        const limit = systemSettings.basePracticeDuration * 60;
        if (usedSec <= limit) return { presence: 'practicing', label: '练琴中', room: r.name };
        return { presence: 'practicing', label: '超时练琴', room: r.name };
    }
    if (queueList.grand.includes(student))
        return { presence: 'queuing', label: `三角排队第${queueList.grand.indexOf(student) + 1}位`, room: '排队' };
    if (queueList.upright.includes(student))
        return { presence: 'queuing', label: `立式排队第${queueList.upright.indexOf(student) + 1}位`, room: '排队' };
    if (queueList.none.includes(student))
        return { presence: 'queuing', label: `普通排队第${queueList.none.indexOf(student) + 1}位`, room: '排队' };
    return { presence: 'absent', label: '缺勤', room: '不在琴房' };
}

// 🔥 统一的考勤状态计算函数
function calculateAttendanceStatus(student, slot, realtimeStatus, practicedSec, opts = {}) {
  // ---- 数值防御 ----
  practicedSec = Number(practicedSec);
  if (isNaN(practicedSec) || practicedSec < 0) practicedSec = 0;

  // 可选配置
  const {
    lowEffImmediate = false,     // true: 进行中只要 >0 且 <60% 就立刻 low_efficiency
    lowEffReviewRatio = 0.3,     // false 情况下：先 under_review，超过该比例仍未到 60% 判低效
    dynamicThresholdEnabled = true // 是否启用动态阈值
  } = opts;

  // 🔥 统一的时间计算
  const now = Date.now();
  const slotStartMs = new Date(`${getTodayDateString()}T${slot.start}:00`).getTime();
  const slotEndMs = new Date(`${getTodayDateString()}T${slot.end}:00`).getTime();
  const slotDurationSec = Math.floor((slotEndMs - slotStartMs) / 1000);
  
  // 🔥 计算有效时长（优先使用 effectiveTotalSec）
  const effectiveTotalSec = (slot.effectiveTotalSec && slot.effectiveTotalSec > 0)
    ? slot.effectiveTotalSec
    : ((slot.totalPlannedMinutes || 0) * 60);
  
  const efficiencyThresholdSec = Math.floor(effectiveTotalSec * 0.6); // 60% 阈值
  
  // 🔥 计算练琴比例
  let practiceRatio = 0;
  if (effectiveTotalSec > 0) {
    practiceRatio = practicedSec / effectiveTotalSec;
    if (!isFinite(practiceRatio) || isNaN(practiceRatio) || practiceRatio < 0) {
      practiceRatio = 0;
    }
    // 限制最大为 100%
    if (practiceRatio > 1) practiceRatio = 1;
  }

  const practicedMin = Math.floor(practicedSec / 60);
  const isFinished = (now >= slotEndMs);
  const isNotStartedYet = (now < slotStartMs);
  const slotElapsedSec = isNotStartedYet ? 0 : Math.min(slotDurationSec, Math.floor((now - slotStartMs) / 1000));
  
  // 🔥 检查是否在准备期
  const inPreparingSlot = realtimeStatus.presence === 'practicing' && 
                         (realtimeStatus.label?.includes('准备中') || realtimeStatus.label?.includes('准备期'));

  const practicedText = practicedSec > 0
    ? `${practicedMin}分钟`
    : (inPreparingSlot ? '准备中' : '0分钟');

  // 🔥 未开始的时间段
  if (isNotStartedYet || slot.slotPhase === 'future') {
    return {
      finalAttendanceStatus: 'under_review',
      finalStatusText: '未开始',
      practiceRatio,
      practicedText,
      practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟` +
        (slot.segments && slot.segments.length > 1 ? ` (合并${slot.segments.length}段)` : '')
    };
  }

  // 🔥 缓冲期特殊处理
  if (slot.slotPhase === 'pre-buffer') {
    if (practicedSec <= 0) {
      // 缓冲期内无练琴记录
      if (realtimeStatus.presence === 'queuing') {
        return {
          finalAttendanceStatus: 'under_review',
          finalStatusText: '排队中(缓冲期)',
          practiceRatio,
          practicedText,
          practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
        };
      }
      return {
        finalAttendanceStatus: 'absent',
        finalStatusText: '缺勤(缓冲期)',
        practiceRatio,
        practicedText,
        practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
      };
    } else {
      return {
        finalAttendanceStatus: 'under_review',
        finalStatusText: '缓冲观察',
        practiceRatio,
        practicedText,
        practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
      };
    }
  }

  // 🔥 段内准备期
  if (inPreparingSlot && realtimeStatus.presence === 'practicing') {
    const statusText = slot.slotPhase === 'active' ? '准备中(正式时段)' : '准备中';
    return {
      finalAttendanceStatus: 'under_review',
      finalStatusText: statusText,
      practiceRatio,
      practicedText,
      practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
    };
  }

  // 🔥 排队状态的特殊处理
  if (realtimeStatus.presence === 'queuing' && !isFinished) {
    let queueStatusText = '排队中';
    if (practicedSec > 0) {
      queueStatusText = `排队中(已练${practicedMin}分)`;
    } else if (slot.slotPhase === 'active') {
      queueStatusText = '排队中(待观察)';
    }
    
    return {
      finalAttendanceStatus: 'under_review',
      finalStatusText: queueStatusText,
      practiceRatio,
      practicedText,
      practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
    };
  }

  // 🔥 进行中（未结束）
  if (!isFinished && slot.slotPhase === 'active') {
    // 人不在房间且无练琴记录
    if (realtimeStatus.presence !== 'practicing' && practicedSec === 0) {
      return {
        finalAttendanceStatus: 'absent',
        finalStatusText: '缺勤(未开始)',
        practiceRatio,
        practicedText,
        practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
      };
    }

    // 🔥 动态阈值计算
    let currentThreshold = efficiencyThresholdSec;
    if (dynamicThresholdEnabled) {
      currentThreshold = Math.min(
        efficiencyThresholdSec,
        Math.max(60, Math.floor(slotElapsedSec * 0.6)) // 早期别太严：至少 60 秒
      );
    }

    // 满足阈值：直接出勤
    if (practicedSec >= currentThreshold) {
      return {
        finalAttendanceStatus: 'present',
        finalStatusText: `出勤 ${(practiceRatio * 100).toFixed(1)}%`,
        practiceRatio,
        practicedText,
        practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
      };
    }

    // 未达到阈值但有练琴记录
    if (practicedSec > 0) {
      if (lowEffImmediate) {
        return {
          finalAttendanceStatus: 'low_efficiency',
          finalStatusText: `低效 ${(practiceRatio * 100).toFixed(1)}%`,
          practiceRatio,
          practicedText,
          practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
        };
      } else {
        // 等过了一定的已过时段比例再给低效，否则继续观察
        const elapsedRatio = slotDurationSec > 0 ? slotElapsedSec / slotDurationSec : 0;
        if (elapsedRatio >= lowEffReviewRatio) {
          return {
            finalAttendanceStatus: 'low_efficiency',
            finalStatusText: `低效 ${(practiceRatio * 100).toFixed(1)}%`,
            practiceRatio,
            practicedText,
            practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
          };
        }
        return {
          finalAttendanceStatus: 'under_review',
          finalStatusText: '进行中',
          practiceRatio,
          practicedText,
          practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
        };
      }
    }

    // 完全无练琴记录
    return {
      finalAttendanceStatus: 'under_review',
      finalStatusText: '进行中',
      practiceRatio,
      practicedText,
      practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
    };
  }

  // 🔥 已结束：最终判定
  if (isFinished || slot.slotPhase === 'ended') {
    if (practicedSec <= 0) {
      return {
        finalAttendanceStatus: 'absent',
        finalStatusText: '缺勤(已结束)',
        practiceRatio,
        practicedText,
        practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
      };
    }

    // 达到 60% 阈值
    if (practicedSec >= efficiencyThresholdSec) {
      return {
        finalAttendanceStatus: 'present',
        finalStatusText: `已完成 ${(practiceRatio * 100).toFixed(1)}%`,
        practiceRatio,
        practicedText,
        practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
      };
    }

    // 有练琴但未达到 60%
    return {
      finalAttendanceStatus: 'low_efficiency',
      finalStatusText: `低效 ${(practiceRatio * 100).toFixed(1)}%`,
      practiceRatio,
      practicedText,
      practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
    };
  }

  // 🔥 默认情况
  return {
    finalAttendanceStatus: 'under_review',
    finalStatusText: '待观察',
    practiceRatio,
    practicedText,
    practiceDetails: `${practicedMin}分钟 / ${slot.totalPlannedMinutes}分钟`
  };
}



/* 合并：去除被包含 + end==next.start 归并 */
function buildMergedDaySlots(originalDaySlots) {
    if (!Array.isArray(originalDaySlots)) return [];
    const sorted = [...originalDaySlots].sort((a, b) => a.start.localeCompare(b.start));
    const filtered = [];
    sorted.forEach(s => {
        if (!filtered.length) { filtered.push({ ...s }); return; }
        const last = filtered[filtered.length - 1];
        if (last.start <= s.start && last.end >= s.end) {
            // 被包含 -> 丢
        } else filtered.push({ ...s });
    });
    const merged = [];
    filtered.forEach(s => {
        if (!merged.length) {
            merged.push({ start: s.start, end: s.end, segments: [{ ...s }] });
            return;
        }
        const last = merged[merged.length - 1];
        if (last.end === s.start) {
            last.end = s.end;
            last.segments.push({ ...s });
        } else {
            merged.push({ start: s.start, end: s.end, segments: [{ ...s }] });
        }
    });
    return merged;
}

/* 主扫描（聚合版） */
// 🔥 修复：考勤检查函数 - 避免频繁同步
function checkAttendance() {
    if (isLocked) return;
    const now = new Date();
    const w = now.getDay();
    if (w === 0 || w === 6) return;
    const weekday = WEEK_MAP[w];
    const currentMinutes = now.getHours() * 60 + now.getMinutes();

    // 🔥 计算新的考勤数据
    const newAttendanceData = {
        checkTime: now.toISOString(),
        students: [],
        endedSlots: [],
        futureSlots: []
    };

    Object.keys(studentTimeSlots).forEach(student => {
        const weekly = studentTimeSlots[student];
        if (!weekly || !weekly[weekday] || !weekly[weekday].length) return;

        // 🔥 关键修复：在这里就获取并缓存专业信息
        const studentMajor = getStudentMajor(student);
        console.log('📊 考勤检查 - 学生专业:', student, '->', studentMajor);

        const mergedSlots = buildMergedDaySlots(weekly[weekday]);
        const r = rooms.find(r => r.student === student);
        const inRoomBefore = !!r;

        mergedSlots.forEach(slotBase => {
            const startMin = timeToMinutes(slotBase.start);
            const endMin = timeToMinutes(slotBase.end);
            const totalPlannedMinutes = endMin - startMin;
            if (totalPlannedMinutes <= 0) return;

            let bufferMinutes = ATTEND_BUFFER_MIN;
            if (inRoomBefore && r) {
                const reg = new Date(r.registerTime);
                const regMinutes = reg.getHours() * 60 + reg.getMinutes();
                if (regMinutes <= startMin) bufferMinutes = 0;
            }

            const bufferedStartMin = Math.min(endMin, startMin + bufferMinutes);
            let slotPhase = 'future';
            if (currentMinutes < startMin) slotPhase = 'future';
            else if (currentMinutes >= startMin && currentMinutes < bufferedStartMin) slotPhase = 'pre-buffer';
            else if (currentMinutes >= bufferedStartMin && currentMinutes <= endMin) slotPhase = 'active';
            else slotPhase = 'ended';

            const slotObj = {
                start: slotBase.start,
                end: slotBase.end,
                segments: slotBase.segments,
                bufferMinutes,
                bufferedStart: minutesToTime(bufferedStartMin),
                slotPhase,
                totalPlannedMinutes,
                effectiveTotalSec: Math.max(0, (endMin - (startMin + bufferMinutes)) * 60)
            };

            const practicedObj = getStudentPracticeTimeInSlot(student, slotObj);
            const practicedSec = practicedObj.seconds || 0;   // 只取秒数
            const realtimeStatus = getStudentAttendanceStatus(student);
            const calc = calculateAttendanceStatus(student, slotObj, realtimeStatus, practicedSec);
            const row = {
                name: student,
                major: studentMajor, // 🔥 使用预先获取的专业信息
                practicedSec,
                practicedText: fmtPracticeSec(practicedSec),
                presence: realtimeStatus.presence,
                presenceText: realtimeStatus.label,
                room: realtimeStatus.room,
                overrunCountToday: getTodayOverrunCount(student),
                ...slotObj,
                ...calc
            };

            if (slotPhase === 'active' || slotPhase === 'pre-buffer') newAttendanceData.students.push(row);
            else if (slotPhase === 'ended') newAttendanceData.endedSlots.push(row);
            else newAttendanceData.futureSlots.push(row);
        });
    });

    // 🔥 关键修复：保留现有的请假状态，并确保专业信息不丢失
    if (attendanceData && attendanceData.students) {
        const excusedStudents = new Map();
        
        // 收集现有的请假状态
        [...attendanceData.students, ...attendanceData.endedSlots].forEach(student => {
            if (student.finalAttendanceStatus === 'excused') {
                const key = `${student.name}_${student.start}_${student.end}`;
                excusedStudents.set(key, {
                    finalAttendanceStatus: student.finalAttendanceStatus,
                    finalStatusText: student.finalStatusText,
                    major: student.major || getStudentMajor(student.name) // 🔥 确保专业信息
                });
            }
        });
        
        // 应用到新数据中
        [...newAttendanceData.students, ...newAttendanceData.endedSlots].forEach(student => {
            const key = `${student.name}_${student.start}_${student.end}`;
            if (excusedStudents.has(key)) {
                const excusedState = excusedStudents.get(key);
                student.finalAttendanceStatus = excusedState.finalAttendanceStatus;
                student.finalStatusText = excusedState.finalStatusText;
                // 🔥 确保专业信息正确
                if (excusedState.major && excusedState.major !== '未知专业') {
                    student.major = excusedState.major;
                }
            }
        });
    }

    // 🔥 最终验证：确保所有学生都有正确的专业信息
    [...newAttendanceData.students, ...newAttendanceData.endedSlots, ...newAttendanceData.futureSlots].forEach(student => {
        if (!student.major || student.major === '未知专业') {
            student.major = getStudentMajor(student.name);
            console.log('🔧 修复学生专业信息:', student.name, '->', student.major);
        }
    });

    attendanceData = newAttendanceData;
    checkExpiredExcuses();
    updateAttendanceBadge();
    lastAttendanceCheck = now;
    
    if (isAttendanceModalOpen) {
        renderAttendanceList(false);
    }
}

/* 渲染 */
function renderAttendanceList(force) {
    if (force) {
        checkAttendance();
        setTimeout(() => renderAttendanceList(false), 30);
        return;
    }
    
    const majorF = $('attendanceMajorFilter').value;
    const statusF = $('attendanceStatusFilter').value;
    const container = $('attendanceContent');
    
    // 🔥 添加安全检查
    const listAll = attendanceData.students || [];

    if (!listAll.length) {
        container.innerHTML = '<div class="attendance-empty"><h3>当前时间段无学生需要练琴</h3><p style="color:#666;">缓冲或进行中的聚合时段才会显示。</p></div>';
        updateAttendanceSummary([], []);
        return;
    }

    const list = listAll.filter(s => {
        if (majorF && s.major !== majorF) return false;
        if (statusF) {
            if (['absent', 'present', 'low_efficiency', 'under_review', 'excused'].includes(statusF)) {
                if (s.finalAttendanceStatus !== statusF) return false;
            } else if (statusF === 'queuing' && s.presence !== 'queuing') return false;
            else if (statusF === 'practicing' && s.presence !== 'practicing') return false;
            else if (statusF === 'preparing' && s.presenceText !== '准备中') return false;
            else if (statusF === 'overtime' && !s.presenceText.includes('超时')) return false;
        }
        return true;
    });

    const byMajor = {};
    list.forEach(s => (byMajor[s.major] ||= []).push(s));

    let html = '';
    Object.keys(byMajor).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN')).forEach(m => {
        const arr = byMajor[m];
        const absent = arr.filter(s => s.finalAttendanceStatus === 'absent').length;
        const low = arr.filter(s => s.finalAttendanceStatus === 'low_efficiency').length;
        const exc = arr.filter(s => s.finalAttendanceStatus === 'excused').length;

        html += `<div class="attendance-category">
            <div class="attendance-category-header">
                <span>${m}</span>
                <span class="attendance-category-count">${arr.length}段(缺勤${absent} 低效${low} 请假${exc})</span>
            </div>
            <div class="attendance-list-header">
                <div>学生</div><div>阶段/状态</div><div>练琴时间段</div>
                <div>所在琴房</div><div>已练/应练</div><div>操作</div>
            </div>
            ${arr.sort((a, b) => {
                const phaseOrder = { active: 0, 'pre-buffer': 1, ended: 2, future: 3 };
                if (phaseOrder[a.slotPhase] !== phaseOrder[b.slotPhase]) return phaseOrder[a.slotPhase] - phaseOrder[b.slotPhase];
                const statusOrder = { present: 0, low_efficiency: 1, under_review: 2, absent: 3, excused: 4 };
                if (statusOrder[a.finalAttendanceStatus] !== statusOrder[b.finalAttendanceStatus]) return statusOrder[a.finalAttendanceStatus] - statusOrder[b.finalAttendanceStatus];
                return a.name.localeCompare(b.name, 'zh-Hans-CN');
            }).map(s => {
                const cls = `attendance-status status-${s.finalAttendanceStatus}`;
                const slotTxt = `${s.start}-${s.end}` +
                    (s.slotPhase === 'pre-buffer' ? `(缓冲${s.bufferMinutes}分)` :
                        s.slotPhase === 'active' ? '(进行中)' : '');
                const segmentsPreview = s.segments.map(seg => `${seg.start}-${seg.end}`).join('，');
                let act = '—';
                if (s.finalAttendanceStatus === 'absent') {
                    act = `<button class="attendance-action-btn btn-excuse" style="background:#3498db;color:#fff;padding:4px 8px;border:none;border-radius:4px;cursor:pointer;font-size:12px;" onclick="excuseStudent('${s.name}')">请假</button>`;
                } else if (s.finalAttendanceStatus === 'excused') {
                    act = `<button class="attendance-action-btn" style="background:#e67e22;color:#fff;padding:4px 8px;border:none;border-radius:4px;cursor:pointer;font-size:12px;" onclick="cancelExcuse('${s.name}')">取消请假</button>`;
                }
                return `<div class="attendance-item ${s.finalAttendanceStatus === 'absent' ? 'absent' : ''}">
                    <div>${s.name}</div>
                    <div><span class="${cls}">${s.finalStatusText}${s.slotPhase === 'pre-buffer' ? ' / 缓冲' : ''}</span></div>
                    <div title="子段: ${segmentsPreview}">${slotTxt}</div>
                    <div>${s.room}</div>
                    <div title="${s.practiceDetails}">${s.practiceDetails}</div>
                    <div>${act}</div>
                </div>`;
            }).join('')}
        </div>`;
    });

    container.innerHTML = html || '<div class="attendance-empty">没有符合条件的学生</div>';
    updateAttendanceSummary(listAll, list);
}

/* 汇总 */
function updateAttendanceSummary(allActive, _shown) {
    const box = $('attendanceSummary');
    // 🔥 添加安全检查
    allActive = allActive || [];
    const effective = allActive.filter(s => s.slotPhase === 'active' && s.finalAttendanceStatus !== 'excused');
    const total = effective.length;
    const present = effective.filter(s => s.finalAttendanceStatus === 'present').length;
    const low = effective.filter(s => s.finalAttendanceStatus === 'low_efficiency').length;
    const absent = effective.filter(s => s.finalAttendanceStatus === 'absent').length;
    const under = effective.filter(s => s.finalAttendanceStatus === 'under_review').length;
    const exc = allActive.filter(s => s.finalAttendanceStatus === 'excused').length;
    const rate = total ? ((present + low) / total * 100).toFixed(1) : '0.0';
    const overrunTotal = getCurrentOvertimeCount(); // 使用实时超时数量

    box.innerHTML = `
        <div class="attendance-summary-item"><div class="attendance-summary-number total-count">${total}</div><div class="attendance-summary-label">应到人数</div></div>
        <div class="attendance-summary-item"><div class="attendance-summary-number present-count">${present}</div><div class="attendance-summary-label">正常</div></div>
        <div class="attendance-summary-item"><div class="attendance-summary-number" style="color:#f39c12;">${low}</div><div class="attendance-summary-label">低效</div></div>
        <div class="attendance-summary-item"><div class="attendance-summary-number absent-count">${absent}</div><div class="attendance-summary-label">缺勤</div></div>
        <div class="attendance-summary-item"><div class="attendance-summary-number" style="color:#3498db;">${under}</div><div class="attendance-summary-label">待观察</div></div>
        <div class="attendance-summary-item"><div class="attendance-summary-number" style="color:#95a5a6;">${exc}</div><div class="attendance-summary-label">请假</div></div>
        <div class="attendance-summary-item"><div class="attendance-summary-number">${rate}%</div><div class="attendance-summary-label">出勤率</div></div>
        <div class="attendance-summary-item" style="cursor:pointer;" onclick="switchToOvertimeManagement()" title="点击查看超时管理"><div class="attendance-summary-number" style="color:#e74c3c;">${overrunTotal}</div><div class="attendance-summary-label">超时</div></div>

    `;
}

/* 徽章 */
function updateAttendanceBadge() {
    const badge = $('attendanceBadge');
    if (!badge) return;
    
    // 🔥 添加安全检查
    const students = attendanceData.students || [];
    const problem = students
        .filter(s => ['absent', 'low_efficiency'].includes(s.finalAttendanceStatus) && s.slotPhase === 'active').length;
    
    if (problem) {
        badge.style.display = 'inline-block';
        badge.textContent = problem;
    } else {
        badge.style.display = 'none';
    }
}


/* =============== 智能汇总考勤导出系统（修复版） =============== */

function exportAttendanceReport() {
    if (!attendanceData.students.length && !(attendanceData.endedSlots || []).length) {
        alert('暂无可导出的考勤数据');
        return;
    }
    
    showSmartExportModal();
}

function showSmartExportModal() {
    const modal = document.createElement('div');
    modal.id = 'smartExportModal';
    modal.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.6);z-index:3000;display:flex;align-items:center;justify-content:center;';
    
    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];
    const weekAgo = new Date(today.getTime() - 6 * 24 * 60 * 60 * 1000);
    const weekAgoStr = weekAgo.toISOString().split('T')[0];
    
    modal.innerHTML = `
        <div style="background:#fff;padding:30px;border-radius:16px;max-width:600px;width:95%;max-height:90vh;overflow-y:auto;">
            <h3 style="margin:0 0 20px;color:var(--primary-color);text-align:center;">📊 智能考勤汇总导出</h3>
            
            <!-- 日期范围选择 -->
            <div class="export-section" style="margin-bottom:20px;padding:15px;background:#f8f9fa;border-radius:8px;">
                <h4 style="margin:0 0 10px;color:#2c3e50;">📅 日期范围</h4>
                <div style="display:flex;flex-direction:column;gap:8px;">
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="radio" name="dateRange" value="today" checked>
                        <span>仅今天 (${todayStr})</span>
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="radio" name="dateRange" value="yesterday">
                        <span>昨天</span>
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="radio" name="dateRange" value="week">
                        <span>最近7天 (${weekAgoStr} 至 ${todayStr})</span>
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="radio" name="dateRange" value="custom">
                        <span>自定义日期范围</span>
                    </label>
                </div>
                
                <!-- 自定义日期输入 -->
                <div id="customDateInputs" style="display:none;margin-top:10px;padding:10px;background:#fff;border-radius:6px;border:1px solid #ddd;">
                    <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
                        <label>开始日期：<input type="date" id="startDate" value="${weekAgoStr}" style="margin-left:5px;"></label>
                        <label>结束日期：<input type="date" id="endDate" value="${todayStr}" style="margin-left:5px;"></label>
                    </div>
                </div>
            </div>
            
            <!-- 内容筛选 -->
            <div class="export-section" style="margin-bottom:20px;padding:15px;background:#f8f9fa;border-radius:8px;">
                <h4 style="margin:0 0 10px;color:#2c3e50;">🔍 内容筛选</h4>
                <div style="display:flex;flex-direction:column;gap:6px;">
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="checkbox" id="includeAllStudents" checked>
                        <span>包含所有学生汇总</span>
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="checkbox" id="highlightProblems" checked>
                        <span>突出显示问题学生（缺勤/低效）</span>
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="checkbox" id="includeExcused">
                        <span>包含请假学生详情</span>
                    </label>
                </div>
            </div>
            
            <!-- 报告格式 -->
            <div class="export-section" style="margin-bottom:20px;padding:15px;background:#f8f9fa;border-radius:8px;">
                <h4 style="margin:0 0 10px;color:#2c3e50;">📋 报告格式</h4>
                <div style="display:flex;flex-direction:column;gap:6px;">
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="checkbox" id="includeSummary" checked>
                        <span>包含整体统计汇总</span>
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="checkbox" id="includeAnalysis" checked>
                        <span>包含问题学生分析</span>
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                        <input type="checkbox" id="includePracticeDetails" checked>
                        <span>包含详细练琴时间</span>
                    </label>
                </div>
            </div>
            
            <!-- 专业筛选 -->
            <div class="export-section" style="margin-bottom:25px;padding:15px;background:#f8f9fa;border-radius:8px;">
                <h4 style="margin:0 0 10px;color:#2c3e50;">🎓 专业筛选</h4>
                <select id="majorFilterExport" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;">
                    <option value="">所有专业</option>
                    ${Object.keys(studentDatabase).sort().map(major => 
                        `<option value="${major}">${major}</option>`
                    ).join('')}
                </select>
            </div>
            
            <!-- 操作按钮 -->
            <div style="display:flex;justify-content:flex-end;gap:12px;">
                <button id="cancelExportBtn" style="padding:10px 20px;background:#95a5a6;color:#fff;border:none;border-radius:6px;cursor:pointer;">取消</button>
                <button id="generateReportBtn" style="padding:10px 20px;background:var(--primary-color);color:#fff;border:none;border-radius:6px;cursor:pointer;">📊 生成汇总报告</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // 事件绑定
    modal.addEventListener('change', (e) => {
        if (e.target.name === 'dateRange') {
            const customInputs = modal.querySelector('#customDateInputs');
            if (customInputs) {
                customInputs.style.display = e.target.value === 'custom' ? 'block' : 'none';
            }
        }
    });
    
    const cancelBtn = modal.querySelector('#cancelExportBtn');
    const generateBtn = modal.querySelector('#generateReportBtn');
    
    if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
            closeSmartExportModal();
        });
    }
    
    if (generateBtn) {
        generateBtn.addEventListener('click', () => {
            executeSmartExport();
        });
    }
    
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeSmartExportModal();
        }
    });
}

function closeSmartExportModal() {
    const modal = document.getElementById('smartExportModal');
    if (modal) document.body.removeChild(modal);
}

function executeSmartExport() {
    const modal = document.getElementById('smartExportModal');
    
    // 收集筛选条件
    const filters = {
        dateRange: modal.querySelector('input[name="dateRange"]:checked').value,
        startDate: modal.querySelector('#startDate').value,
        endDate: modal.querySelector('#endDate').value,
        includeAllStudents: modal.querySelector('#includeAllStudents').checked,
        highlightProblems: modal.querySelector('#highlightProblems').checked,
        includeExcused: modal.querySelector('#includeExcused').checked,
        includeSummary: modal.querySelector('#includeSummary').checked,
        includeAnalysis: modal.querySelector('#includeAnalysis').checked,
        includePracticeDetails: modal.querySelector('#includePracticeDetails').checked,
        majorFilter: modal.querySelector('#majorFilterExport').value
    };
    
    closeSmartExportModal();
    generateSmartAttendanceReport(filters);
}

function generateSmartAttendanceReport(filters) {
    // 确定日期范围
    const dateRange = getDateRange(filters);
    
    // 🔥 关键修改：收集汇总数据而非详细记录
    const reportData = collectAggregatedAttendanceData(dateRange, filters);
    
    // 生成CSV报告
    let csv = generateReportHeader(dateRange, filters);
    
    if (filters.includeSummary) {
        csv += generateSummarySection(reportData, dateRange);
    }
    
    // 🔥 关键修改：始终使用汇总模式
    csv += generateStudentAggregatedReport(reportData, filters, dateRange);
    
    if (filters.includeAnalysis) {
        csv += generateProblemAnalysis(reportData, dateRange);
    }
    
    // 导出文件
    exportCSVFile(csv, `考勤汇总报告_${dateRange.startStr}_${dateRange.endStr}.csv`);
    
    showToast('✅ 考勤汇总报告已导出', 3000);
}

// 🔥 新增：收集汇总考勤数据
function collectAggregatedAttendanceData(dateRange, filters) {
    const data = {
        studentSummaries: new Map(),
        dailyStats: {},
        problemStudents: {
            consecutive: [],
            lowEfficiency: [],
            frequent: []
        }
    };
    
    // 收集当前考勤数据
    const currentData = [...(attendanceData.students || []), ...(attendanceData.endedSlots || [])];
    
    // 🔥 调试：检查原始数据中的专业信息
    console.log('📊 原始考勤数据专业分布:');
    const majorCount = {};
    currentData.forEach(record => {
        const major = record.major || '未设置';
        majorCount[major] = (majorCount[major] || 0) + 1;
        if (!record.major || record.major === '未知专业') {
            console.warn('⚠️ 发现专业信息缺失:', record.name, record.major);
        }
    });
    console.log('专业统计:', majorCount);
    
    // 按专业筛选
    const filteredData = filters.majorFilter 
        ? currentData.filter(s => s.major === filters.majorFilter)
        : currentData;
    
    // 🔥 关键：按学生汇总数据
    filteredData.forEach(record => {
        const studentName = record.name;
        
        // 🔥 确保专业信息正确 - 多重验证
        let studentMajor = record.major;
        if (!studentMajor || studentMajor === '未知专业') {
            studentMajor = getStudentMajor(studentName);
            console.log('🔧 重新获取学生专业:', studentName, '->', studentMajor);
        }
        
        if (!data.studentSummaries.has(studentName)) {
            data.studentSummaries.set(studentName, {
                name: studentName,
                major: studentMajor, // 🔥 使用验证后的专业信息
                totalSlots: 0,
                presentSlots: 0,
                lowEfficiencySlots: 0,
                absentSlots: 0,
                excusedSlots: 0,
                underReviewSlots: 0,
                totalPracticeTime: 0,
                totalPlannedTime: 0,
                timeSlots: [],
                overrunCount: record.overrunCountToday || 0,
                finalStatus: 'unknown',
                attendanceRate: 0
            });
        }
        
        const summary = data.studentSummaries.get(studentName);
        
        // 🔥 确保专业信息一致且正确
        if (!summary.major || summary.major === '未知专业') {
            summary.major = studentMajor;
        }
        
        summary.totalSlots++;
        summary.totalPracticeTime += record.practicedSec || 0;
        summary.totalPlannedTime += (record.totalPlannedMinutes || 0) * 60;
        
        // 记录时间段详情
        summary.timeSlots.push({
            timeRange: `${record.start}-${record.end}`,
            status: record.finalAttendanceStatus,
            statusText: record.finalStatusText,
            practiceTime: record.practicedSec || 0,
            plannedTime: (record.totalPlannedMinutes || 0) * 60
        });
        
        // 统计各状态数量
        switch (record.finalAttendanceStatus) {
            case 'present':
                summary.presentSlots++;
                break;
            case 'low_efficiency':
                summary.lowEfficiencySlots++;
                break;
            case 'absent':
                summary.absentSlots++;
                break;
            case 'excused':
                summary.excusedSlots++;
                break;
            case 'under_review':
                summary.underReviewSlots++;
                break;
        }
    });
    
    // 🔥 最终验证和计算
    data.studentSummaries.forEach((summary, studentName) => {
        // 🔥 最后一次确保专业信息正确
        if (!summary.major || summary.major === '未知专业') {
            summary.major = getStudentMajor(studentName);
            console.log('🔧 最终修复专业信息:', studentName, '->', summary.major);
        }
        
        // 计算出勤率（排除请假）
        const effectiveSlots = summary.totalSlots - summary.excusedSlots;
        if (effectiveSlots > 0) {
            summary.attendanceRate = ((summary.presentSlots + summary.lowEfficiencySlots) / effectiveSlots * 100);
        }
        
        // 计算练琴完成率
        summary.practiceCompletionRate = summary.totalPlannedTime > 0 
            ? (summary.totalPracticeTime / summary.totalPlannedTime * 100) 
            : 0;
        
        // 综合评估最终状态
        if (summary.excusedSlots === summary.totalSlots) {
            summary.finalStatus = 'excused';
        } else if (summary.absentSlots >= summary.totalSlots * 0.5) {
            summary.finalStatus = 'mostly_absent';
        } else if (summary.attendanceRate >= 80) {
            summary.finalStatus = 'good';
        } else if (summary.attendanceRate >= 60) {
            summary.finalStatus = 'fair';
        } else {
            summary.finalStatus = 'poor';
        }
    });
    
    // 🔥 调试：输出最终的专业分布
    console.log('📊 最终汇总数据专业分布:');
    const finalMajorCount = {};
    data.studentSummaries.forEach(summary => {
        const major = summary.major || '未设置';
        finalMajorCount[major] = (finalMajorCount[major] || 0) + 1;
    });
    console.log('最终专业统计:', finalMajorCount);
    
    // 分析问题学生
    data.problemStudents = analyzeProblemStudentsFromSummaries(data.studentSummaries, dateRange);
    
    return data;
}
// 🔥 新增：生成学生汇总报告
function generateStudentAggregatedReport(reportData, filters, dateRange) {
    let report = `=== 学生考勤汇总报告 ===\n`;
    
    // 表头
    let headers = [
        '姓名', '专业', '总时间段数', '正常出勤', '低效出勤', '缺勤', '请假', '待观察',
        '有效出勤率', '总练琴时长', '总计划时长', '练琴完成率', '综合评估'
    ];
    
    if (filters.includePracticeDetails) {
        headers.push('未还卡次数', '时间段详情');
    }
    
    report += headers.join(',') + '\n';
    
    // 按专业和综合评估排序
    const sortedStudents = Array.from(reportData.studentSummaries.values()).sort((a, b) => {
        // 先按专业排序
        if (a.major !== b.major) return a.major.localeCompare(b.major, 'zh-Hans-CN');
        
        // 再按综合评估排序（问题学生优先）
        const statusOrder = { 'poor': 0, 'mostly_absent': 1, 'fair': 2, 'good': 3, 'excused': 4 };
        if (statusOrder[a.finalStatus] !== statusOrder[b.finalStatus]) {
            return statusOrder[a.finalStatus] - statusOrder[b.finalStatus];
        }
        
        // 最后按姓名排序
        return a.name.localeCompare(b.name, 'zh-Hans-CN');
    });
    
    sortedStudents.forEach(student => {
        const practiceHours = Math.floor(student.totalPracticeTime / 3600);
        const practiceMinutes = Math.floor((student.totalPracticeTime % 3600) / 60);
        const practiceTimeText = practiceHours > 0 
            ? `${practiceHours}小时${practiceMinutes}分` 
            : `${practiceMinutes}分钟`;
        
        const plannedHours = Math.floor(student.totalPlannedTime / 3600);
        const plannedMinutes = Math.floor((student.totalPlannedTime % 3600) / 60);
        const plannedTimeText = plannedHours > 0 
            ? `${plannedHours}小时${plannedMinutes}分` 
            : `${plannedMinutes}分钟`;
        
        // 综合评估文本
        const statusTexts = {
            'good': '良好',
            'fair': '一般',
            'poor': '较差',
            'mostly_absent': '多次缺勤',
            'excused': '已请假'
        };
        
        let row = [
            escapeCSV(student.name),
            escapeCSV(student.major),
            student.totalSlots,
            student.presentSlots,
            student.lowEfficiencySlots,
            student.absentSlots,
            student.excusedSlots,
            student.underReviewSlots,
            student.attendanceRate.toFixed(1) + '%',
            practiceTimeText,
            plannedTimeText,
            student.practiceCompletionRate.toFixed(1) + '%',
            statusTexts[student.finalStatus] || '未知'
        ];
        
        if (filters.includePracticeDetails) {
            row.push(student.overrunCount);
            
            // 时间段详情
            const slotDetails = student.timeSlots.map(slot => 
                `${slot.timeRange}(${getStatusShortName(slot.status)})`
            ).join(';');
            row.push(escapeCSV(slotDetails));
        }
        
        report += row.join(',') + '\n';
    });
    
    return report + '\n';
}

// 🔥 新增：状态简称映射
function getStatusShortName(status) {
    const mapping = {
        'present': '正常',
        'low_efficiency': '低效',
        'absent': '缺勤',
        'excused': '请假',
        'under_review': '观察'
    };
    return mapping[status] || status;
}

// 🔥 修改：汇总版的统计部分
function generateSummarySection(reportData, dateRange) {
    const summaries = Array.from(reportData.studentSummaries.values());
    const total = summaries.length;
    
    if (total === 0) {
        return `=== 整体统计汇总 ===\n暂无数据\n\n`;
    }
    
    // 🔥 修复：确保专业信息正确
    summaries.forEach(summary => {
        if (!summary.major || summary.major === 'undefined') {
            console.warn('⚠️ 修复空专业信息:', summary.name);
            summary.major = getStudentMajor(summary.name);
        }
    });
    
    // 按最终状态统计
    const statusCounts = {
        good: summaries.filter(s => s.finalStatus === 'good').length,
        fair: summaries.filter(s => s.finalStatus === 'fair').length,
        poor: summaries.filter(s => s.finalStatus === 'poor').length,
        mostly_absent: summaries.filter(s => s.finalStatus === 'mostly_absent').length,
        excused: summaries.filter(s => s.finalStatus === 'excused').length
    };
    
    // 计算平均出勤率
    const avgAttendanceRate = total > 0 
        ? summaries.reduce((sum, s) => sum + s.attendanceRate, 0) / total 
        : 0;
    
    // 计算平均练琴完成率
    const avgPracticeRate = total > 0 
        ? summaries.reduce((sum, s) => sum + s.practiceCompletionRate, 0) / total 
        : 0;
    
    let summary = `=== 整体统计汇总 ===
报告周期: ${dateRange.startStr} 至 ${dateRange.endStr}
统计学生总数: ${total}

综合评估分布:
• 良好: ${statusCounts.good} 人 (${total > 0 ? (statusCounts.good/total*100).toFixed(1) : '0.0'}%)
• 一般: ${statusCounts.fair} 人 (${total > 0 ? (statusCounts.fair/total*100).toFixed(1) : '0.0'}%)
• 较差: ${statusCounts.poor} 人 (${total > 0 ? (statusCounts.poor/total*100).toFixed(1) : '0.0'}%)
• 多次缺勤: ${statusCounts.mostly_absent} 人 (${total > 0 ? (statusCounts.mostly_absent/total*100).toFixed(1) : '0.0'}%)
• 已请假: ${statusCounts.excused} 人 (${total > 0 ? (statusCounts.excused/total*100).toFixed(1) : '0.0'}%)

平均出勤率: ${avgAttendanceRate.toFixed(1)}%
平均练琴完成率: ${avgPracticeRate.toFixed(1)}%

`;

    // 🔥 修复：按专业统计 - 添加调试和验证
    const byMajor = {};
    summaries.forEach(s => {
        const major = s.major || '未知专业';
        
        // 🔥 添加调试日志
        console.log('📊 专业统计:', s.name, '->', major);
        
        if (!byMajor[major]) {
            byMajor[major] = { 
                total: 0, good: 0, fair: 0, poor: 0, mostly_absent: 0, excused: 0,
                totalAttendanceRate: 0, totalPracticeRate: 0
            };
        }
        const stats = byMajor[major];
        stats.total++;
        stats[s.finalStatus]++;
        stats.totalAttendanceRate += s.attendanceRate;
        stats.totalPracticeRate += s.practiceCompletionRate;
    });
    
    // 🔥 添加专业统计调试信息
    console.log('📊 专业统计汇总:', byMajor);
    
    summary += `=== 各专业统计 ===
专业,总人数,良好,一般,较差,多次缺勤,已请假,平均出勤率,平均练琴完成率
`;
    
    Object.keys(byMajor).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN')).forEach(major => {
        const stats = byMajor[major];
        const avgAttendance = stats.total > 0 ? (stats.totalAttendanceRate / stats.total).toFixed(1) : '0.0';
        const avgPractice = stats.total > 0 ? (stats.totalPracticeRate / stats.total).toFixed(1) : '0.0';
        
        // 🔥 添加调试日志
        console.log('📊 输出专业统计:', major, stats);
        
        summary += `${escapeCSV(major)},${stats.total},${stats.good},${stats.fair},${stats.poor},${stats.mostly_absent},${stats.excused},${avgAttendance}%,${avgPractice}%\n`;
    });
    
    return summary + '\n';
}
// 🔥 新增：基于汇总数据分析问题学生
function analyzeProblemStudentsFromSummaries(studentSummaries, dateRange) {
    const problemStudents = {
        consecutive: [],
        lowEfficiency: [],
        frequent: []
    };
    
    studentSummaries.forEach((summary, studentName) => {
        // 多次缺勤学生
        if (summary.finalStatus === 'mostly_absent' || summary.absentSlots >= 2) {
            problemStudents.consecutive.push({
                name: studentName,
                major: summary.major,
                absentSlots: summary.absentSlots,
                totalSlots: summary.totalSlots,
                attendanceRate: summary.attendanceRate
            });
        }
        
        // 低效练琴学生
        if (summary.lowEfficiencySlots > 0 || summary.practiceCompletionRate < 60) {
            problemStudents.lowEfficiency.push({
                name: studentName,
                major: summary.major,
                lowEfficiencySlots: summary.lowEfficiencySlots,
                practiceCompletionRate: summary.practiceCompletionRate,
                attendanceRate: summary.attendanceRate
            });
        }
    });
    
    // 频繁请假学生分析（基于历史记录）
    const excuseStats = analyzeExcuseFrequency(dateRange);
    problemStudents.frequent = excuseStats.filter(stat => stat.count >= 2);
    
    return problemStudents;
}

// 🔥 修改：问题分析报告
function generateProblemAnalysis(reportData, dateRange) {
    let analysis = `=== 问题学生分析 ===\n`;
    
    // 多次缺勤学生
    analysis += `=== 缺勤问题学生 ===
姓名,专业,缺勤次数,总时间段,出勤率,建议措施\n`;
    
    reportData.problemStudents.consecutive.forEach(student => {
        const suggestion = student.absentSlots >= 3 ? '紧急联系' : 
                          student.absentSlots >= 2 ? '重点关注' : '一般提醒';
        
        analysis += `${escapeCSV(student.name)},${escapeCSV(student.major)},${student.absentSlots},${student.totalSlots},${student.attendanceRate.toFixed(1)}%,${suggestion}\n`;
    });
    
    analysis += `\n=== 练琴效率问题学生 ===
姓名,专业,低效次数,练琴完成率,出勤率,需要关注\n`;
    
    reportData.problemStudents.lowEfficiency.forEach(student => {
        const concern = student.practiceCompletionRate < 30 ? '高度关注' : 
                       student.practiceCompletionRate < 50 ? '中度关注' : '轻度关注';
        
        analysis += `${escapeCSV(student.name)},${escapeCSV(student.major)},${student.lowEfficiencySlots},${student.practiceCompletionRate.toFixed(1)}%,${student.attendanceRate.toFixed(1)}%,${concern}\n`;
    });
    
    analysis += `\n=== 频繁请假学生 ===
姓名,专业,请假次数,请假原因,最近请假日期\n`;
    
    reportData.problemStudents.frequent.forEach(stat => {
        analysis += `${escapeCSV(stat.studentName)},${escapeCSV(stat.major)},${stat.count}次,${escapeCSV(stat.reasons.join(';'))},${stat.lastExcuseDate}\n`;
    });
    
    return analysis;
}

// 保留原有的辅助函数
function getDateRange(filters) {
    const today = new Date();
    let startDate, endDate;
    
    switch (filters.dateRange) {
        case 'today':
            startDate = endDate = new Date(today);
            break;
        case 'yesterday':
            startDate = endDate = new Date(today.getTime() - 24 * 60 * 60 * 1000);
            break;
        case 'week':
            startDate = new Date(today.getTime() - 6 * 24 * 60 * 60 * 1000);
            endDate = new Date(today);
            break;
        case 'custom':
            startDate = new Date(filters.startDate);
            endDate = new Date(filters.endDate);
            break;
    }
    
    return {
        start: startDate,
        end: endDate,
        startStr: startDate.toISOString().split('T')[0],
        endStr: endDate.toISOString().split('T')[0],
        days: Math.ceil((endDate - startDate) / (24 * 60 * 60 * 1000)) + 1
    };
}

function generateReportHeader(dateRange, filters) {
    const rangeText = dateRange.days === 1 
        ? `${dateRange.startStr}` 
        : `${dateRange.startStr} 至 ${dateRange.endStr}`;
    
    return `智能考勤汇总报告
报告日期范围: ${rangeText}
生成时间: ${new Date().toLocaleString()}
筛选条件: ${filters.majorFilter || '所有专业'}
${filters.highlightProblems ? '✓ 突出问题学生' : ''}
${filters.includeExcused ? '✓ 包含请假详情' : ''}

`;
}

function analyzeConsecutiveAbsence(studentName) {
    const student = [...(attendanceData.students || []), ...(attendanceData.endedSlots || [])]
        .find(s => s.name === studentName && s.finalAttendanceStatus === 'absent');
    
    return student ? 1 : 0;
}

function getLastAttendanceDate(studentName) {
    const recentLogs = practiceLogs
        .filter(log => log.student === studentName)
        .sort((a, b) => b.startTime - a.startTime);
    
    return recentLogs.length > 0 
        ? new Date(recentLogs[0].startTime).toLocaleDateString('zh-CN')
        : '未知';
}

function analyzeExcuseFrequency(dateRange) {
    const stats = new Map();
    
    (excuseOperationHistory || []).forEach(op => {
        const opDate = new Date(op.timestamp);
        if (opDate >= dateRange.start && opDate <= dateRange.end) {
            if (!stats.has(op.studentName)) {
                stats.set(op.studentName, {
                    studentName: op.studentName,
                    major: getStudentMajor(op.studentName),
                    count: 0,
                    reasons: [],
                    lastExcuseDate: null
                });
            }
            
            const stat = stats.get(op.studentName);
            stat.count++;
            if (!stat.reasons.includes(op.reason)) {
                stat.reasons.push(op.reason);
            }
            if (!stat.lastExcuseDate || opDate > new Date(stat.lastExcuseDate)) {
                stat.lastExcuseDate = opDate.toLocaleDateString('zh-CN');
            }
        }
    });
    
    return Array.from(stats.values());
}

function exportCSVFile(csvContent, filename) {
    const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function getStudentMajor(studentName) {
    try {
        const safeName = safeTrim(studentName);
        if (!safeName) {
            console.warn('⚠️ getStudentMajor: 学生姓名为空');
            return '其他';
        }

        for (const [major, students] of Object.entries(studentDatabase)) {
            if (!Array.isArray(students)) {
                console.warn(`⚠️ 专业 ${major} 的数据不是数组:`, students);
                continue;
            }

            const studentRecord = students.find(s => {
                try {
                    const name = getStudentName(s);
                    return name === safeName;
                } catch (error) {
                    console.warn('⚠️ 比较学生姓名时出错:', s, error);
                    return false;
                }
            });
            
            if (studentRecord) {
                return major;
            }
        }
        
        console.warn('⚠️ 未找到学生专业:', safeName);
        return '其他';
        
    } catch (error) {
        console.error('❌ getStudentMajor 出错:', studentName, error);
        return '其他';
    }
}
/**
 * 🔥 新增：数据库健康检查和修复工具
 */
function performDatabaseHealthCheck() {
    console.log('🏥 开始数据库健康检查...');
    
    const report = {
        studentDatabase: validateAndCleanStudentDatabase(),
        roomDatabase: validateRoomDatabase(),
        timeSlots: validateTimeSlots()
    };
    
    console.log('🏥 健康检查完成:', report);
    return report;
}

function validateRoomDatabase() {
    let issues = 0;
    Object.keys(roomDatabase).forEach(name => {
        const room = roomDatabase[name];
        if (!room.name || !room.pianoType) {
            console.warn('⚠️ 房间数据不完整:', name, room);
            issues++;
        }
    });
    return { issues };
}

function validateTimeSlots() {
    let issues = 0;
    Object.keys(studentTimeSlots).forEach(studentName => {
        const slots = studentTimeSlots[studentName];
        if (!slots || typeof slots !== 'object') {
            console.warn('⚠️ 学生时间段数据异常:', studentName, slots);
            issues++;
        }
    });
    return { issues };
}
// 辅助函数：CSV转义
function escapeCSV(str) {
    if (typeof str !== 'string') return str;
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
}


// 更新全局函数映射
window.exportAttendanceReport = exportAttendanceReport;
window.closeSmartExportModal = closeSmartExportModal;
window.executeSmartExport = executeSmartExport;

/* 请假弹窗与逻辑（适配聚合结构） */
function excuseStudent(name) {
    const reasons = [
        { v: 'sick', t: '生病' }, { v: 'class_change', t: '调课' },
        { v: 'leave', t: '请假' }, { v: 'other', t: '其他（自定义）' }
    ];
    
    const wrap = document.createElement('div');
    wrap.id = 'excuseModal';
    wrap.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.45);z-index:3000;display:flex;align-items:center;justify-content:center;';
    wrap.innerHTML = `<div style="background:#fff;padding:25px 28px;border-radius:16px;max-width:480px;width:95%;box-shadow:0 6px 24px rgba(0,0,0,.3);">
        <h3 style="margin:0 0 18px;color:var(--primary-color);text-align:center;">为 ${name} 记录请假</h3>
        
        <!-- 请假原因 -->
        <div style="margin-bottom:15px;">
            <h4 style="margin:0 0 8px;color:#2c3e50;font-size:14px;">请假原因：</h4>
            <div id="excuseOptions" style="display:flex;flex-direction:column;gap:6px;">
                ${reasons.map((r, index) => `<label class="excuse-reason-option" style="display:flex;align-items:center;gap:8px;border:1px solid #ddd;border-radius:8px;padding:8px 12px;cursor:pointer;transition:all 0.2s;">
                    <input type="radio" name="excuseReason" value="${r.v}" ${index === 0 ? 'checked' : ''}>
                    <span>${r.t}</span>
                </label>`).join('')}
            </div>
        </div>

        <!-- 自定义原因输入框 -->
        <div id="customReasonBox" style="display:none;margin-bottom:15px;">
            <input type="text" id="customReasonInput" placeholder="请输入具体原因..." style="width:100%;padding:10px 12px;border:1px solid #ddd;border-radius:8px;box-sizing:border-box;">
        </div>
        
        <!-- 请假有效期选择 -->
        <div style="margin-bottom:18px;">
            <h4 style="margin:0 0 8px;color:#2c3e50;font-size:14px;">请假有效期：</h4>
            <div id="excuseDurationOptions" style="display:flex;flex-direction:column;gap:6px;">
                <label style="display:flex;align-items:center;gap:8px;border:1px solid #ddd;border-radius:8px;padding:8px 12px;cursor:pointer;transition:all 0.2s;">
                    <input type="radio" name="excuseDuration" value="once" checked>
                    <span>🕐 仅本次时间段</span>
                </label>
                <label style="display:flex;align-items:center;gap:8px;border:1px solid #ddd;border-radius:8px;padding:8px 12px;cursor:pointer;transition:all 0.2s;">
                    <input type="radio" name="excuseDuration" value="tomorrow">
                    <span>📅 到明天上午恢复</span>
                </label>
                <label style="display:flex;align-items:center;gap:8px;border:1px solid #ddd;border-radius:8px;padding:8px 12px;cursor:pointer;transition:all 0.2s;">
                    <input type="radio" name="excuseDuration" value="custom">
                    <span>📆 自定义截止日期</span>
                </label>
            </div>
        </div>
        
        <!-- 自定义日期选择 -->
        <div id="customDateBox" style="display:none;margin-bottom:15px;">
            <label style="display:block;margin-bottom:5px;font-weight:600;color:#2c3e50;font-size:13px;">请假截止日期：</label>
            <input type="date" id="customEndDate" style="width:100%;padding:10px 12px;border:1px solid #ddd;border-radius:8px;box-sizing:border-box;" min="${new Date().toISOString().split('T')[0]}">
            <small style="color:#666;font-size:12px;margin-top:4px;display:block;">将在所选日期的上午8:00自动恢复考勤</small>
        </div>
        
        <div style="display:flex;justify-content:flex-end;gap:12px;margin-top:20px;">
            <button class="clear-btn" onclick="closeExcuseModal()" style="padding:10px 20px;">取消</button>
            <button onclick="confirmExcuse('${name}')" style="padding:10px 20px;">确认请假</button>
        </div>
    </div>`;
    
    document.body.appendChild(wrap);
    
    // 🔥 修复：事件监听器
    wrap.addEventListener('change', e => {
        if (e.target.name === 'excuseReason') {
            // 清除所有选项的选中样式
            const allReasonOptions = wrap.querySelectorAll('.excuse-reason-option');
            allReasonOptions.forEach(option => {
                option.style.borderColor = '#ddd';
                option.style.backgroundColor = 'transparent';
            });
            
            // 设置当前选中项的样式
            const selectedOption = e.target.closest('.excuse-reason-option');
            if (selectedOption) {
                selectedOption.style.borderColor = '#3498db';
                selectedOption.style.backgroundColor = '#e3f2fd';
            }
            
            $('customReasonBox').style.display = (e.target.value === 'other') ? 'block' : 'none';
        }
        
        if (e.target.name === 'excuseDuration') {
            // 清除所有时长选项的选中样式
            const allDurationOptions = wrap.querySelectorAll('#excuseDurationOptions label');
            allDurationOptions.forEach(option => {
                option.style.borderColor = '#ddd';
                option.style.backgroundColor = 'transparent';
            });
            
            // 设置当前选中项的样式
            const selectedOption = e.target.closest('label');
            if (selectedOption) {
                selectedOption.style.borderColor = '#3498db';
                selectedOption.style.backgroundColor = '#e3f2fd';
            }
            
            $('customDateBox').style.display = (e.target.value === 'custom') ? 'block' : 'none';
            if (e.target.value === 'custom') {
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                $('customEndDate').value = tomorrow.toISOString().split('T')[0];
            }
        }
    });
    
    // 🔥 修复：hover 效果
    wrap.addEventListener('mouseover', e => {
        const label = e.target.closest('label');
        if (label && (label.classList.contains('excuse-reason-option') || label.closest('#excuseDurationOptions'))) {
            const radio = label.querySelector('input[type="radio"]');
            if (radio && !radio.checked) {
                label.style.borderColor = '#3498db';
                label.style.backgroundColor = '#f8f9fa';
            }
        }
    });

    wrap.addEventListener('mouseout', e => {
        const label = e.target.closest('label');
        if (label && (label.classList.contains('excuse-reason-option') || label.closest('#excuseDurationOptions'))) {
            const radio = label.querySelector('input[type="radio"]');
            if (radio && !radio.checked) {
                label.style.borderColor = '#ddd';
                label.style.backgroundColor = 'transparent';
            }
        }
    });

    // 🔥 新增：初始化选中状态
    setTimeout(() => {
        // 初始化请假原因的默认选中状态
        const firstReasonRadio = wrap.querySelector('input[name="excuseReason"]:checked');
        if (firstReasonRadio) {
            const firstOption = firstReasonRadio.closest('.excuse-reason-option');
            if (firstOption) {
                firstOption.style.borderColor = '#3498db';
                firstOption.style.backgroundColor = '#e3f2fd';
            }
        }
        
        // 初始化有效期的默认选中状态
        const defaultDurationRadio = wrap.querySelector('input[name="excuseDuration"]:checked');
        if (defaultDurationRadio) {
            const defaultOption = defaultDurationRadio.closest('label');
            if (defaultOption) {
                defaultOption.style.borderColor = '#3498db';
                defaultOption.style.backgroundColor = '#e3f2fd';
            }
        }
    }, 10);
}



function closeExcuseModal() {
    const m = $('excuseModal');
    if (m) document.body.removeChild(m);
}

// 🔥 修复：请假操作 - 移除自动同步，改为手动控制
// 🔥 修复：请假操作 - 只同步请假状态
// 🔥 修复：请假操作 - 添加操作ID和历史记录
function confirmExcuse(name) {
    const reasonRadio = [...document.querySelectorAll('#excuseOptions input[name=excuseReason]')].find(r => r.checked);
    const durationRadio = [...document.querySelectorAll('#excuseDurationOptions input[name=excuseDuration]')].find(r => r.checked);
    
    if (!reasonRadio) { alert('请选择请假原因'); return; }
    if (!durationRadio) { alert('请选择请假有效期'); return; }
    
    let reason = reasonRadio.value === 'other' ? $('customReasonInput').value.trim() : reasonRadio.value;
    if (reasonRadio.value === 'other' && !reason) { alert('请输入具体原因'); return; }
    
    // 🔥 新增：处理有效期
    const duration = durationRadio.value;
    let endDate = null;
    let durationText = '';
    
    if (duration === 'once') {
        endDate = null;
        durationText = '仅本次';
    } else if (duration === 'tomorrow') {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(8, 0, 0, 0);
        endDate = tomorrow.toISOString();
        durationText = '到明天上午';
    } else if (duration === 'custom') {
        const customDate = $('customEndDate').value;
        if (!customDate) { alert('请选择截止日期'); return; }
        
        const endDateTime = new Date(customDate);
        endDateTime.setHours(8, 0, 0, 0);
        
        if (endDateTime <= new Date()) {
            alert('截止日期不能是过去的时间');
            return;
        }
        
        endDate = endDateTime.toISOString();
        durationText = `到${customDate}上午`;
    }

    const target = [...attendanceData.students, ...attendanceData.endedSlots].filter(s => s.name === name);
    
    // 🔥 关键修改：生成唯一操作ID
    const operationId = `excuse_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // 🔥 修改：增强请假记录结构
    const excuseRecord = {
        operationId: operationId, // 🔥 新增：唯一操作ID
        studentName: name,
        reason: reason === 'sick' ? '生病' :
                reason === 'class_change' ? '调课' :
                reason === 'leave' ? '请假' : reason,
        duration: duration,
        durationText: durationText,
        endDate: endDate,
        timestamp: Date.now(),
        date: todayKey(),
        slots: []
    };

    target.forEach(stu => {
        const statusText = endDate 
            ? `已请假：${excuseRecord.reason}（${durationText}）`
            : `已请假：${excuseRecord.reason}（仅本次）`;
            
        stu.finalAttendanceStatus = 'excused';
        stu.finalStatusText = statusText;
        stu.excuseEndDate = endDate;
        stu.excuseOperationId = operationId; // 🔥 新增：关联操作ID
        
        excuseRecord.slots.push({
            start: stu.start,
            end: stu.end,
            major: stu.major
        });
    });
    
    // 🔥 新增：记录到操作历史
    excuseOperationHistory.push({
        operationId: operationId,
        studentName: name,
        reason: excuseRecord.reason,
        timestamp: excuseRecord.timestamp,
        duration: excuseRecord.duration,
        durationText: excuseRecord.durationText,
        affectedSlots: excuseRecord.slots.length,
        endDate: endDate
    });
    
    // 持久化历史记录
    lsSet('excuseOperationHistory', excuseOperationHistory);
    
    closeExcuseModal();
    renderAttendanceList(false);
    updateAttendanceBadge();
    
    // Firebase同步部分保持不变
    if (syncEnabled && isOnline && database) {
        syncEnabled = false;
        const excuseKey = `${excuseRecord.date}_${name}_${Date.now()}`;
        
        database.ref(`${FIREBASE_PATHS.EXCUSE_DATA}/${excuseKey}`).set(excuseRecord)
            .then(() => {
                console.log('✅ 请假记录已同步到云端');
                setTimeout(() => {
                    syncEnabled = true;
                }, 1000);
            })
            .catch((error) => {
                console.error('❌ 请假记录同步失败:', error);
                syncEnabled = true;
            });
    }
    
    logOperation('student_excuse', {
        student: name,
        reason: excuseRecord.reason,
        duration: duration,
        durationText: durationText,
        endDate: endDate,
        slotsCount: excuseRecord.slots.length,
        operationId: operationId // 🔥 新增：记录操作ID
    });
    
    // 清理异常提醒部分保持不变
    const beforeCount = practiceOverrunReminders.length;
    practiceOverrunReminders = practiceOverrunReminders.filter(rec => {
        if (rec.student === name) {
            console.log(`🧹 因请假清理异常提醒：${name} - ${rec.room}`);
            return false;
        }
        return true;
    });

    if (beforeCount !== practiceOverrunReminders.length) {
        persistOverruns(true, 'excuse_cleanup', {
            student: name,
            cleaned: beforeCount - practiceOverrunReminders.length
        });
        updateOverrunPanel();
    }
    
    showToast(`已记录请假（${durationText}）`);
}

// 🔥 新增：获取当前已请假的学生集合
function getExcusedStudents() {
    const excusedSet = new Set();
    
    // 检查考勤数据中的请假状态
    if (attendanceData && attendanceData.students) {
        attendanceData.students.forEach(stu => {
            if (stu.finalAttendanceStatus === 'excused') {
                // 检查请假是否仍然有效
                if (!stu.excuseEndDate) {
                    // 仅本次请假 - 仍然有效
                    excusedSet.add(stu.name);
                } else {
                    // 有期限的请假 - 检查是否过期
                    const endDate = new Date(stu.excuseEndDate);
                    const now = new Date();
                    if (now < endDate) {
                        excusedSet.add(stu.name);
                    }
                }
            }
        });
    }
    
    // 也检查已结束时段的请假状态（可能有跨时段的请假）
    if (attendanceData && attendanceData.endedSlots) {
        attendanceData.endedSlots.forEach(stu => {
            if (stu.finalAttendanceStatus === 'excused' && stu.excuseEndDate) {
                const endDate = new Date(stu.excuseEndDate);
                const now = new Date();
                if (now < endDate) {
                    excusedSet.add(stu.name);
                }
            }
        });
    }
    
    return excusedSet;
}

// 🔥 新增：检测请假状态与实际练琴的冲突
function checkExcuseConflicts() {
    const excusedStudents = getExcusedStudents();
    const conflicts = [];
    
    rooms.forEach(r => {
        if (r.student && excusedStudents.has(r.student)) {
            conflicts.push({
                student: r.student,
                room: r.name,
                registerTime: new Date(r.registerTime).toLocaleString()
            });
        }
    });
    
    if (conflicts.length > 0) {
        console.log('🔍 发现请假状态冲突:', conflicts);
        
        // 可以选择自动处理或提示管理员
        conflicts.forEach(conflict => {
            showToast(`⚠️ ${conflict.student} 已请假但在 ${conflict.room} 练琴`, 5000);
        });
    }
    
    return conflicts;
}

// 🔥 修复：取消请假操作 - 只同步取消请假状态
function cancelExcuse(name) {
    if (!confirm('取消请假并重新计算当前段状态?')) return;
    
    const targets = [...attendanceData.students, ...attendanceData.endedSlots].filter(s => s.name === name);
    const cancelRecord = {
        studentName: name,
        action: 'cancel_excuse',
        timestamp: Date.now(),
        date: todayKey(),
        slots: []
    };

    targets.forEach(stu => {
        // 重新取实时 & 练琴时长
        const practicedSec = getStudentPracticeTimeInSlot(stu.name, stu);
        const realtimeStatus = getStudentAttendanceStatus(stu.name);
        const calc = calculateAttendanceStatus(stu.name, stu, realtimeStatus, practicedSec);
        Object.assign(stu, calc, {
            practicedSec,
            practicedText: fmtPracticeSec(practicedSec)
        });
        
        // 记录取消请假的时间段信息
        cancelRecord.slots.push({
            start: stu.start,
            end: stu.end,
            major: stu.major
        });
    });
    
    renderAttendanceList(false);
    updateAttendanceBadge();
    
    // 🔥 关键修改：只同步取消请假操作
    if (syncEnabled && isOnline && database) {
        syncEnabled = false;
        
        const cancelKey = `cancel_${cancelRecord.date}_${name}_${Date.now()}`;
        
        database.ref(`${FIREBASE_PATHS.EXCUSE_DATA}/${cancelKey}`).set(cancelRecord)
            .then(() => {
                console.log('✅ 取消请假操作已同步');
                setTimeout(() => {
                    syncEnabled = true;
                }, 1000);
            })
            .catch((error) => {
                console.error('❌ 取消请假操作同步失败:', error);
                syncEnabled = true;
            });
    }
    
    showToast('已取消请假');
    
    // 🔥 新增：取消请假后，立即检查该学生是否需要异常提醒
    setTimeout(() => {
        checkPracticeAnomalies();
    }, 1000);
}

// 🔥 新增：检查并自动恢复过期的请假状态
function checkExpiredExcuses() {
    if (!attendanceData.students && !attendanceData.endedSlots) return;
    
    const now = new Date();
    let hasExpiredExcuses = false;
    
    // 检查当前学生的请假状态
    [...(attendanceData.students || []), ...(attendanceData.endedSlots || [])].forEach(stu => {
        if (stu.finalAttendanceStatus === 'excused' && stu.excuseEndDate) {
            const endDate = new Date(stu.excuseEndDate);
            
            // 如果请假已过期
            if (now >= endDate) {
                console.log(`🔄 请假已过期，恢复考勤：${stu.name}，过期时间：${endDate.toLocaleString()}`);
                
                // 重新计算考勤状态
                const practicedSec = getStudentPracticeTimeInSlot(stu.name, stu);
                const realtimeStatus = getStudentAttendanceStatus(stu.name);
                const calc = calculateAttendanceStatus(stu.name, stu, realtimeStatus, practicedSec);
                
                // 更新状态
                Object.assign(stu, calc, {
                    practicedSec,
                    practicedText: fmtPracticeSec(practicedSec),
                    excuseEndDate: null // 清除过期的请假结束日期
                });
                
                hasExpiredExcuses = true;
            }
        }
    });
    
    // 如果有过期的请假状态被恢复，刷新UI
    if (hasExpiredExcuses) {
        if (isAttendanceModalOpen) {
            renderAttendanceList(false);
        }
        updateAttendanceBadge();
        
        // 🔥 同步恢复状态到云端
        if (syncEnabled && isOnline && database) {
            const recoveryRecord = {
                action: 'auto_recover_expired_excuses',
                timestamp: Date.now(),
                date: todayKey(),
                recoveredAt: now.toISOString()
            };
            
            const recoveryKey = `recovery_${recoveryRecord.date}_${Date.now()}`;
            database.ref(`${FIREBASE_PATHS.EXCUSE_DATA}/${recoveryKey}`).set(recoveryRecord)
                .catch(error => console.error('❌ 自动恢复记录同步失败:', error));
        }
        
        console.log('✅ 已自动恢复过期的请假状态');
    }
}

/* ===== 缺失的考勤弹窗函数补齐 ===== */
function openAttendanceModal() {
    // 标记考勤面板打开状态
    isAttendanceModalOpen = true;
    
    // 强制刷新一次考勤（含 checkAttendance）
    renderAttendanceList(true);
    if (typeof populateAttendanceMajorFilter === 'function') {
        populateAttendanceMajorFilter();
    }
    
    // 🔥 关键：启动实时更新定时器（每10秒更新一次）
    if (attendanceRealTimeInterval) {
        clearInterval(attendanceRealTimeInterval);
    }
    attendanceRealTimeInterval = setInterval(() => {
        if (isAttendanceModalOpen) {
            checkAttendance(); // 这会触发 renderAttendanceList(false)
        }
    }, 3000); // 10秒更新一次，可根据需要调整
    
    const modal = $('attendanceModal');
    if (modal) modal.style.display = 'block';
}

function closeAttendanceModal() {
    // 标记考勤面板关闭状态
    isAttendanceModalOpen = false;
    
    // 🔥 关键：清除实时更新定时器
    if (attendanceRealTimeInterval) {
        clearInterval(attendanceRealTimeInterval);
        attendanceRealTimeInterval = null;
    }
    
    const modal = $('attendanceModal');
    if (modal) modal.style.display = 'none';
}

// 🔥 新增：页面卸载时清理定时器
window.addEventListener('beforeunload', () => {
    if (attendanceRealTimeInterval) {
        clearInterval(attendanceRealTimeInterval);
    }
    // 🔥 修改：清理房间状态同步定时器
    if (window.roomStatusSyncTimeout) {
        clearTimeout(window.roomStatusSyncTimeout);
    }
    // 清理异常检查定时器
    if (anomalyCheckInterval) {
        clearInterval(anomalyCheckInterval);
    }
    // 清理请假检查定时器
    if (excuseCheckInterval) {
        clearInterval(excuseCheckInterval);
    }
    // 🔥 新增：清理自动锁定定时器
    clearAutoLockTimers();
});



/**
 * 从考勤界面切换到超时管理界面
 */
function switchToOvertimeManagement() {
    // 关闭考勤界面
    closeAttendanceModal();
    
    // 打开超时管理界面
    setTimeout(() => {
        openOvertimeModal();
    }, 100); // 短暂延迟确保考勤界面完全关闭
}

/* =========================================================
 *                        练琴状态异常提醒功能
 * =======================================================*/

/**
 * 🔥 修改：生成唯一键时使用合并后的时间段
 */
function genOverrunKey(student, slot) {
    // 如果是合并段，使用合并后的开始和结束时间
    const start = slot.start;
    const end = slot.end;
    return `${todayKey()}|${student}|${start}|${end}`;
}
// 🔥 修复：incOverrunCount 函数
function incOverrunCount(student, slot){
  const d = todayKey();
  if(!overrunStats[d]) overrunStats[d] = {};
  if(!overrunStats[d][student]) overrunStats[d][student] = {count:0};
  overrunStats[d][student].count++;
  
  // 🔥 修复：使用统一的持久化函数
  persistOverruns(true, 'stats_update', { 
    student, 
    date: d, 
    newCount: overrunStats[d][student].count 
  });
}


function getTodayOverrunCount(student){
  const d = todayKey();
  return overrunStats[d]?.[student]?.count || 0;
}

function getTodayTotalOverrunCount(){
  const d = todayKey();
  if(!overrunStats[d]) return 0;
  return Object.values(overrunStats[d]).reduce((a,b)=>a + (b.count||0),0);
}
/**
 * 管理异常检查定时器 - 只在设置的时间范围内启动检查
 */
function manageAnomalyCheckTimer() {
  const now = new Date();
  const currentHour = now.getHours();
  const currentMinute = now.getMinutes();
  const startHour = systemSettings.startAnomalyCheckHour || 8;
  const startMinute = systemSettings.startAnomalyCheckMinute || 0;
  const stopHour = systemSettings.stopAnomalyCheckHour || 19;
  const stopMinute = systemSettings.stopAnomalyCheckMinute || 0;
  
  const currentTotalMinutes = currentHour * 60 + currentMinute;
  const startTotalMinutes = startHour * 60 + startMinute;
  const stopTotalMinutes = stopHour * 60 + stopMinute;
  
  const shouldBeActive = currentTotalMinutes >= startTotalMinutes && currentTotalMinutes < stopTotalMinutes;
  
  if (shouldBeActive && !isAnomalyCheckActive) {
    // 进入检查时间，启动定时器
    console.log(`🟢 异常检查已启动：当前时间 ${pad2(currentHour)}:${pad2(currentMinute)} 在检查范围 ${pad2(startHour)}:${pad2(startMinute)} - ${pad2(stopHour)}:${pad2(stopMinute)} 内`);
    isAnomalyCheckActive = true;
    
    // 立即执行一次检查
    checkPracticeAnomalies();
    
    // 设置30秒间隔的定时检查
    anomalyCheckInterval = setInterval(() => {
      if (isAnomalyCheckActive) {
        checkPracticeAnomalies();
      }
    }, 30000);
    
  } else if (!shouldBeActive && isAnomalyCheckActive) {
    // 离开检查时间，停止定时器
    console.log(`🔴 异常检查已停止：当前时间 ${pad2(currentHour)}:${pad2(currentMinute)} 超出检查范围 ${pad2(startHour)}:${pad2(startMinute)} - ${pad2(stopHour)}:${pad2(stopMinute)}`);
    isAnomalyCheckActive = false;
    
    if (anomalyCheckInterval) {
      clearInterval(anomalyCheckInterval);
      anomalyCheckInterval = null;
    }
  }
}

/**
 * 检查异常：每 30 秒调用（在 secondLoop 节流）
 * 条件：当前占用；该时间段结束超过15分钟仍在练；登记实际使用开始≤时间段结束
 * 🔥 新逻辑：如果学生在某时间段结束后15分钟内还有其他练琴时间段则不提醒，
 * 直到时间段过了15分钟后没有其他练琴时间段且还在登记练琴则提醒
 */
function checkPracticeAnomalies() {
    if (isLocked) return;

    const now = new Date();
    const weekday = WEEK_MAP[now.getDay()];
    if (!weekday) return; // 周末不检查

    // 限定在设置的时间范围内
    const curMin = now.getHours() * 60 + now.getMinutes();
    const startMin = (systemSettings.startAnomalyCheckHour   * 60) + (systemSettings.startAnomalyCheckMinute || 0);
    const stopMin  = (systemSettings.stopAnomalyCheckHour    * 60) + (systemSettings.stopAnomalyCheckMinute || 0);
    if (curMin < startMin || curMin >= stopMin) return;

    // 已请假学生集合
    const excused = getExcusedStudents();

    // 学生当前是否占用房间快速映射
    const roomByStudent = {};
    rooms.forEach(r => { if (r.student) roomByStudent[r.student] = r; });

    // 配置：超出段尾 >= 15分钟认定为异常
    const THRESHOLD_MIN = 15;

    // 避免同一 key 重复 push（使用 key 查重）
    const existingKeys = new Set(practiceOverrunReminders.map(r => r.key));

    let added = 0;

    Object.keys(studentTimeSlots).forEach(student => {
        if (excused.has(student)) return;
        const slots = studentTimeSlots[student]?.[weekday] || [];
        if (!slots.length) return;

        const room = roomByStudent[student];
        if (!room) return; // 不在房间，无法"持续占用"

        // 计算实际登记分钟（用于排除登记在段尾后才进入的怪情况）
        const reg = new Date(room.registerTime);
        const regMin = reg.getHours() * 60 + reg.getMinutes();

        // 🔥 关键修改：获取学生的所有时间段并按时间排序
        const sortedSlots = [...slots].sort((a, b) => timeToMinutes(a.start) - timeToMinutes(b.start));
        
        // 🔥 新逻辑：检查每个时间段，如果该时间段结束后15分钟内没有其他时间段，则提醒
        sortedSlots.forEach((slot, index) => {
            const endMin = timeToMinutes(slot.end);
            const diff = curMin - endMin;

            if (diff >= THRESHOLD_MIN) {
                // 必须是"登记开始 <= 段结束"才算在原时间段上继续占用
                if (regMin > endMin) return;

                // 🔥 关键检查：当前时间段结束后15分钟内是否有其他时间段
                let hasFollowingSlot = false;
                for (let j = index + 1; j < sortedSlots.length; j++) {
                    const nextSlot = sortedSlots[j];
                    const nextStartMin = timeToMinutes(nextSlot.start);
                    // 如果下一个时间段在当前时间段结束后15分钟内，则不提醒
                    if (nextStartMin <= endMin + 15) {
                        hasFollowingSlot = true;
                        break;
                    }
                }
                
                // 🔥 只有在当前时间段结束后15分钟内没有其他时间段时才提醒
                if (!hasFollowingSlot) {
                    const key = genOverrunKey(student, slot);
                    if (overrunIgnoredKeys.has(key)) return;
                    if (existingKeys.has(key)) return; // 已存在

                    practiceOverrunReminders.push({
                        key,
                        student,
                        room: room.name,
                        slotStart: slot.start,
                        slotEnd: slot.end,
                        createdAt: Date.now()
                    });
                    existingKeys.add(key);
                    added++;
                }
            }
        });
    });

    if (added > 0) {
        // 持久化 + 同步
        persistOverruns(true, 'scan_add', { added });
        updateOverrunPanel();
        console.log(`🔔 添加异常提醒 ${added} 条`);
    }
}

/**
 * 🔥 已弃用：合并重叠或连续的时间段（新逻辑不再需要合并）
 * 如果两个时间段之间的间隔 <= 10分钟，则认为是连续的
 */
/*
function mergeOverlappingSlots(slots) {
    if (!slots.length) return [];
    
    const merged = [];
    let current = {
        start: slots[0].start,
        end: slots[0].end,
        originalSlots: [slots[0]]
    };
    
    for (let i = 1; i < slots.length; i++) {
        const slot = slots[i];
        const currentEndMin = timeToMinutes(current.end);
        const slotStartMin = timeToMinutes(slot.start);
        
        // 🔥 关键逻辑：如果间隔 <= 10分钟，则合并
        if (slotStartMin - currentEndMin <= 10) {
            // 扩展当前合并段的结束时间
            const slotEndMin = timeToMinutes(slot.end);
            if (slotEndMin > currentEndMin) {
                current.end = slot.end;
            }
            current.originalSlots.push(slot);
        } else {
            // 间隔太大，保存当前段并开始新段
            merged.push(current);
            current = {
                start: slot.start,
                end: slot.end,
                originalSlots: [slot]
            };
        }
    }
    
    // 添加最后一个段
    merged.push(current);
    
    return merged;
}
*/

function updateOverrunPanel(){
  const panel = $('overrunReminderPanel');
  if(!panel) return;
  const body = $('overrunPanelBody');
  const badge = $('overrunCountBadge');

  const effective = practiceOverrunReminders.filter(r=>!overrunIgnoredKeys.has(r.key));
  
  // 🔥 关键修改：没有异常时完全隐藏面板
  if(!effective.length){
    badge.style.display='none';
    panel.style.display='none';
    // 🔥 新增：清除手动关闭标记（为下次异常做准备）
    panel.dataset.manuallyDismissed = 'false';
    return;
  }

  // 🔥 有异常时的处理 - 检查是否被用户手动关闭
  panel.style.display='flex';
  
  // 🔥 关键修改：只有在未被手动关闭时才自动展开
  const wasManuallyDismissed = panel.dataset.manuallyDismissed === 'true';
  if(!wasManuallyDismissed) {
    panel.classList.remove('collapsed');
  }
  
  badge.style.display='inline-block';
  badge.textContent=effective.length;

  const now = new Date();
  const todayTotal = getTodayTotalOverrunCount();
  
  // 🔥 关键：确保移除空状态显示
  const emptyEl = body.querySelector('.overrun-empty');
  if(emptyEl) {
    emptyEl.remove();
  }
  
  // 更新异常项目
  updateOrCreateOverrunItems(body, effective, now, todayTotal);
}



// 🔥 新增：增量更新函数
function updateOrCreateOverrunItems(container, items, now, todayTotal) {
  // 更新或创建顶部统计信息
  let statsDiv = container.querySelector('.overrun-stats');
  if(todayTotal > 0) {
    const statsHTML = `📊 今日已记录未还卡数：<strong>${todayTotal}</strong>`;
    if(!statsDiv) {
      statsDiv = document.createElement('div');
      statsDiv.className = 'overrun-stats';
      statsDiv.style.cssText = 'text-align:center;margin-bottom:12px;padding:8px;background:#e8f5e8;border-radius:8px;font-size:12px;color:#27ae60;';
      container.insertBefore(statsDiv, container.firstChild);
    }
    if(statsDiv.innerHTML !== statsHTML) {
      statsDiv.innerHTML = statsHTML;
    }
  } else if(statsDiv) {
    statsDiv.remove();
  }

  // 获取现有的异常项目
  const existingItems = container.querySelectorAll('.overrun-item');
  const existingKeys = Array.from(existingItems).map(item => item.dataset.key);
  const currentKeys = items.map(item => item.key);

  // 移除不再存在的项目
  existingItems.forEach(item => {
    if(!currentKeys.includes(item.dataset.key)) {
      item.remove();
    }
  });

  // 更新或创建项目
  items.forEach((rec, index) => {
    let itemEl = container.querySelector(`[data-key="${rec.key}"]`);
    
    if(!itemEl) {
      // 创建新项目
      itemEl = document.createElement('div');
      itemEl.className = 'overrun-item';
      itemEl.dataset.key = rec.key;
      container.appendChild(itemEl);
    }

    // 🔥 关键：只更新时间相关的动态内容
    updateOverrunItemContent(itemEl, rec, now);
  });
}

/**
 * 🔥 修改：更新异常项目内容显示，支持显示合并信息
 */
function updateOverrunItemContent(itemElement, rec, now) {
    const [dateStr, stu, start, end] = rec.key.split('|');
    const slotEndM = timeToMinutes(rec.slotEnd);
    const nowM = now.getHours() * 60 + now.getMinutes();
    const overMin = Math.max(0, nowM - slotEndM);
    const overTxt = overMin >= 60
        ? `${Math.floor(overMin / 60)}小时${overMin % 60 ? overMin % 60 + '分钟' : ''}`
        : `${overMin}分钟`;

    const major = getStudentMajor(rec.student) || '';
    
    // 🔥 新增：显示原始时间段信息（如果是合并的）
    let timeSlotDisplay = `${rec.slotStart} - ${rec.slotEnd}`;
    if (rec.originalSlots && rec.originalSlots.length > 1) {
        const originalTimes = rec.originalSlots.map(s => `${s.start}-${s.end}`).join('，');
        timeSlotDisplay += ` (合并: ${originalTimes})`;
    }

    // 检查是否需要更新（避免不必要的DOM操作）
    const expectedHTML = `
        <div class="overrun-item-header">
            <div>
                ${rec.student}
                <span class="student-major">(${major})</span>
            </div>
            <div class="overrun-over">异常${overTxt}</div>
        </div>
        <div class="overrun-item-room">琴房：${rec.room}</div>
        <div class="overrun-slot">时间段：${timeSlotDisplay}</div>
        <div class="overrun-actions">
            <button class="overrun-btn-ignore" onclick="ignoreOverrun('${rec.key}')" title="忽略此异常，不计入统计">
                <span>🤐</span> 忽略
            </button>
            <button class="overrun-btn-record" onclick="recordOverrun('${rec.key}')" title="记录到日志并计入异常段数">
                <span>📝</span> 记录
            </button>
        </div>
    `;

    // 只在内容真正改变时才更新DOM
    if (itemElement.innerHTML.trim() !== expectedHTML.trim()) {
        itemElement.innerHTML = expectedHTML;
    }
}

/**
 * 一键清空所有异常提醒
 */
function clearAllOverrunReminders() {
  if (!practiceOverrunReminders.length) {
    showToast('暂无异常提醒需要清空', 2000);
    return;
  }
  
  const count = practiceOverrunReminders.length;
  
  if (!confirm(`确定要清空所有 ${count} 条异常提醒吗？\n\n注意：清空后这些异常将不再提醒，但不会影响已记录的异常统计。`)) {
    return;
  }
  
  // 将所有提醒加入忽略列表（避免重复出现）
  practiceOverrunReminders.forEach(reminder => {
    overrunIgnoredKeys.add(reminder.key);
  });
  
  // 清空提醒列表
  practiceOverrunReminders = [];
  
  // 持久化并同步
  persistOverruns(true, 'clear_all', { 
    clearedCount: count,
    timestamp: Date.now(),
    source: 'one_click_clear'
  });
  
  // 更新面板显示
  updateOverrunPanel();
  
  // 记录操作日志
  logOperation('clear_all_overrun_reminders', {
    count: count,
    timestamp: Date.now(),
    method: 'one_click_clear'
  });
  
  showToast(`已清空 ${count} 条异常提醒`, 3000);
}

/**
 * 忽略（不统计超时段数）
 */
// 🔥 修复：忽略异常提醒
/**
 * 忽略（不统计超时段数）
 */
function ignoreOverrun(key) {
  const idx = practiceOverrunReminders.findIndex(r => r.key === key);
  if (idx === -1) {
    showToast('记录不存在或已处理'); 
    return;
  }
  const rec = practiceOverrunReminders[idx];

  console.log('🤐 忽略异常提醒:', key, rec);

  // 加入忽略集合并从提醒列表删除
  overrunIgnoredKeys.add(key);
  practiceOverrunReminders.splice(idx, 1);

  // 🔥 关键修复：确保同步
  persistOverruns(true, 'ignore', { 
    key, 
    student: rec.student, 
    room: rec.room,
    timestamp: Date.now()
  });
  
  updateOverrunPanel();
  showToast('已忽略该异常（不计入统计）');
  logOperation('overrun_ignore', { key, student: rec.student, room: rec.room });
}

/**
 * 记录（计入统计）
 */
function recordOverrun(key) {
  const rec = practiceOverrunReminders.find(r => r.key === key);
  if (!rec) {
    showToast('记录不存在或已处理');
    return;
  }

  console.log('📝 记录异常提醒:', key, rec);

  // 统计 + 移除
  incOverrunCount(rec.student, { start: rec.slotStart, end: rec.slotEnd });
  practiceOverrunReminders = practiceOverrunReminders.filter(r => r.key !== key);

  // 🔥 关键修复：确保同步
  persistOverruns(true, 'record', { 
    key, 
    student: rec.student, 
    room: rec.room,
    timestamp: Date.now(),
    newCount: getTodayOverrunCount(rec.student)
  });

  updateOverrunPanel();

  const attModal = $('attendanceModal');
  if (attModal && attModal.style.display === 'block') {
    renderAttendanceList(false);
  }

  showToast('已记录异常并计入未还卡数');
  logOperation('overrun_record', {
    key,
    student: rec.student,
    room: rec.room,
    slotStart: rec.slotStart,
    slotEnd: rec.slotEnd,
    newCount: getTodayOverrunCount(rec.student)
  });
}



/**
 * 展开 / 收起面板
 */
function toggleOverrunPanel(){
  const p=$('overrunReminderPanel');
  if(!p) return;
  
  const wasCollapsed = p.classList.contains('collapsed');
  p.classList.toggle('collapsed');
  
  // 🔥 修改：记录面板状态和手动关闭状态
  if(!wasCollapsed) {
    // 用户主动收起面板
    p.dataset.userCollapsed = 'true';
    p.dataset.manuallyDismissed = 'true';
  } else {
    // 用户主动展开面板 - 重置手动关闭状态
    p.dataset.userCollapsed = 'false';
    p.dataset.manuallyDismissed = 'false';
  }
}


/* =============== 11.5. 统一房间状态管理系统（合并实时状态） =============== */

/**
 * 🔥 优化：统一的房间状态变化处理
 * 替代原来的实时练琴状态系统，避免重复同步
 */
function handleRoomStatusChange(changeType, metadata = {}) {
    // 立即持久化房间状态
    persistRooms();
    
    // 🔥 关键：检测是否有实质性变化
    const hasSignificantChange = detectSignificantRoomChanges();
    
    if (hasSignificantChange || ['room_assign', 'room_clear', 'force_replace'].includes(changeType)) {
        console.log('🔄 检测到重要房间状态变化，准备同步...', changeType);
        
        // 🔥 优化：重要变化立即同步，其他变化延迟合并
        const isImmediate = ['room_assign', 'room_clear', 'force_replace'].includes(changeType);
        const delay = isImmediate ? 200 : 1000;
        
        // 清除之前的同步定时器
        if (window.roomStatusSyncTimeout) {
            clearTimeout(window.roomStatusSyncTimeout);
        }
        
        window.roomStatusSyncTimeout = setTimeout(() => {
            syncToFirebase(changeType, {
                ...metadata,
                timestamp: Date.now(),
                deviceId: deviceId,
                roomCount: rooms.filter(r => r.student).length
            });
            window.roomStatusSyncTimeout = null;
        }, delay);
        
        // 触发相关UI更新
        updateRelatedComponents(changeType);
        
        return true;
    }
    
    return false;
}
function forcePushRoomsImmediately(actionTag='manual_force'){
    if(!database || !isOnline){
        console.log('[forcePushRoomsImmediately] 跳过：离线或未初始化');
        return;
    }
    try{
        const cleanRooms = rooms
            .slice()
            .sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN',{numeric:true}))
            .map(r=>({
                ...r,
                student: r.student || null,
                registerTime: r.registerTime || null,
                lastModified: Date.now()
            }));
        const now = Date.now();
        const updatePayload = {
            [FIREBASE_PATHS.ROOMS]: cleanRooms,
            [FIREBASE_PATHS.LAST_UPDATE]: {
                timestamp: now,
                deviceId,
                action: 'force_push_'+actionTag
            }
        };
        database.ref().update(updatePayload)
          .then(()=>console.log('[forcePushRoomsImmediately] 已推送 =>', actionTag))
          .catch(err=>console.warn('[forcePushRoomsImmediately] 推送失败', err));
    }catch(e){
        console.warn('[forcePushRoomsImmediately] 出错', e);
    }
}

/**
 * 🔥 新增：检测房间状态的重要变化
 */
function detectSignificantRoomChanges() {
    // 生成当前房间状态的关键信息哈希
    const currentStateKey = rooms
        .filter(r => r.student)
        .map(r => `${r.name}:${r.student}:${r.registerTime}`)
        .sort()
        .join('|');
    
    // 检查是否与上次记录的状态不同
    if (window.lastRoomStateKey !== currentStateKey) {
        console.log('🔍 房间状态变化:', {
            old: window.lastRoomStateKey,
            new: currentStateKey
        });
        window.lastRoomStateKey = currentStateKey;
        return true;
    }
    
    return false;
}

/**
 * 🔥 新增：更新相关组件
 */
function updateRelatedComponents(changeType) {
    // 更新需求按钮状态
    updateDemandButtonsStatus();
    
    // 如果考勤面板打开，刷新考勤数据
    if (isAttendanceModalOpen) {
        setTimeout(() => {
            checkAttendance();
        }, 100);
    }
    
    // 如果超时管理面板打开，刷新数据
    const overtimeModal = document.getElementById('overtimeModal');
    if (overtimeModal && overtimeModal.style.display === 'block') {
        setTimeout(() => {
            renderOvertimeList(true);
        }, 100);
    }
    
    // 刷新搜索结果
    refreshSearchResults();
    
    // 更新时间轴
    if (timelineVisible) {
        setTimeout(updateTimeline, 100);
    }
}

/**
 * 🔥 兼容函数：获取学生实时练琴状态（从房间数据计算）
 */
function getStudentRealTimePracticeStatus(studentName) {
    const room = rooms.find(r => r.student === studentName);
    if (!room) return null;
    
    const now = Date.now();
    const prepEnd = room.registerTime + 60000;
    
    let status, currentDuration;
    
    if (now < prepEnd) {
        status = 'preparing';
        currentDuration = Math.floor((now - room.registerTime) / 1000);
    } else {
        status = 'practicing';
        currentDuration = Math.floor((now - prepEnd) / 1000);
    }
    
    return {
        currentDuration,
        lastUpdated: now,
        room: room.name,
        startTime: room.registerTime,
        status
    };
}

/**
 * 🔥 兼容函数：立即触发房间状态同步
 */
function triggerRealTimePracticeStatusUpdate() {
    handleRoomStatusChange('immediate_update', {
        source: 'manual_trigger',
        timestamp: Date.now()
    });
}

/* =============== 12. 系统设置 / 重置 / 备份 / 日志 / 导出日志 =============== */
/* =============== 云端考勤日志增强功能 =============== */

/**
 * 🔥 新增：将考勤数据持久化到云端
 */
function syncAttendanceToCloud(attendanceData, dateKey = null) {
    if (!database || !isOnline || !syncEnabled) return;
    
    const key = dateKey || todayKey();
    const cloudData = {
        lastUpdated: Date.now(),  // 🔥 添加这个关键字段
        date: key,
        timestamp: Date.now(),
        deviceId: deviceId,
        checkTime: attendanceData.checkTime,
        students: attendanceData.students || [],
        endedSlots: attendanceData.endedSlots || [],
        summary: {
            totalStudents: (attendanceData.students || []).length,
            absentCount: (attendanceData.students || []).filter(s => s.finalAttendanceStatus === 'absent').length,
            presentCount: (attendanceData.students || []).filter(s => s.finalAttendanceStatus === 'present').length,
            excusedCount: (attendanceData.students || []).filter(s => s.finalAttendanceStatus === 'excused').length,
            lowEfficiencyCount: (attendanceData.students || []).filter(s => s.finalAttendanceStatus === 'low_efficiency').length,  // 🔥 可选：添加低效率统计
            underReviewCount: (attendanceData.students || []).filter(s => s.finalAttendanceStatus === 'under_review').length     // 🔥 可选：添加观察中统计
        }
    };
    
    database.ref(`attendanceRecords/${key}`).set(cloudData)
        .then(() => {
            console.log('✅ 考勤数据已同步到云端:', key, 'lastUpdated:', new Date(cloudData.lastUpdated).toLocaleString());
        })
        .catch(error => {
            console.error('❌ 考勤数据同步失败:', error);
        });
}


/**
 * 🔥 新增：从云端获取历史考勤数据
 */
async function getCloudAttendanceHistory(startDate, endDate) {
    if (!database || !isOnline) {
        throw new Error('未连接到云端服务器');
    }
    
    try {
        const snapshot = await database.ref('attendanceRecords')
            .orderByKey()
            .startAt(startDate)
            .endAt(endDate)
            .once('value');
        
        const records = snapshot.val() || {};
        return Object.values(records).sort((a, b) => a.date.localeCompare(b.date));
    } catch (error) {
        console.error('❌ 获取云端考勤历史失败:', error);
        throw error;
    }
}

/**
 * 🔥 新增：云端考勤报告导出
 */
/**
 * 🔥 修复：云端考勤报告导出 - 使用与本地相同的智能汇总系统
 */
async function exportCloudAttendanceReport() {
    try {
        // 显示增强版日期选择器
        const options = await showCloudExportOptionsModal();
        if (!options) return;
        
        showToast('📥 正在从云端获取考勤数据...', 3000);
        
        // 从云端获取数据
        const cloudRecords = await getCloudAttendanceHistory(options.dateRange.start, options.dateRange.end);
        
        if (!cloudRecords.length) {
            alert('选择的日期范围内没有考勤记录');
            return;
        }
        
        // 🔥 关键修改：使用与本地相同的数据处理逻辑
        const reportData = processCloudDataForSmartReport(cloudRecords, options);
        
        // 🔥 关键修改：使用与本地相同的报告生成逻辑
        let csv = generateCloudReportHeader(options.dateRange, options);
        
        if (options.includeSummary) {
            csv += generateSummarySection(reportData, options.dateRange);
        }
        
        // 🔥 使用统一的学生汇总报告生成
        csv += generateStudentAggregatedReport(reportData, options, options.dateRange);
        
        if (options.includeAnalysis) {
            csv += generateProblemAnalysis(reportData, options.dateRange);
        }
        
        // 导出文件
        const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `云端考勤汇总报告_${options.dateRange.start}_${options.dateRange.end}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showToast(`✅ 云端考勤汇总报告已导出 (${cloudRecords.length}天数据)`, 5000);
        
    } catch (error) {
        console.error('❌ 云端考勤报告导出失败:', error);
        alert('导出失败: ' + error.message);
    }
}

/**
 * 🔥 新增：显示云端导出选项模态框（与本地导出选项一致）
 */
function showCloudExportOptionsModal() {
    return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.id = 'cloudExportOptionsModal';
        modal.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.6);z-index:3000;display:flex;align-items:center;justify-content:center;';
        
        const today = new Date();
        const todayStr = today.toISOString().split('T')[0];
        const weekAgo = new Date(today.getTime() - 6 * 24 * 60 * 60 * 1000);
        const weekAgoStr = weekAgo.toISOString().split('T')[0];
        
        modal.innerHTML = `
            <div style="background:#fff;padding:30px;border-radius:16px;max-width:600px;width:95%;max-height:90vh;overflow-y:auto;">
                <h3 style="margin:0 0 20px;color:var(--primary-color);text-align:center;">☁️ 云端考勤汇总导出</h3>
                
                <!-- 日期范围选择 -->
                <div class="export-section" style="margin-bottom:20px;padding:15px;background:#f8f9fa;border-radius:8px;">
                    <h4 style="margin:0 0 10px;color:#2c3e50;">📅 日期范围</h4>
                    <div style="display:flex;flex-direction:column;gap:8px;">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="radio" name="cloudDateRange" value="today" checked>
                            <span>仅今天 (${todayStr})</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="radio" name="cloudDateRange" value="yesterday">
                            <span>昨天</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="radio" name="cloudDateRange" value="week">
                            <span>最近7天 (${weekAgoStr} 至 ${todayStr})</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="radio" name="cloudDateRange" value="custom">
                            <span>自定义日期范围</span>
                        </label>
                    </div>
                    
                    <!-- 自定义日期输入 -->
                    <div id="cloudCustomDateInputs" style="display:none;margin-top:10px;padding:10px;background:#fff;border-radius:6px;border:1px solid #ddd;">
                        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
                            <label>开始日期：<input type="date" id="cloudStartDate" value="${weekAgoStr}" style="margin-left:5px;"></label>
                            <label>结束日期：<input type="date" id="cloudEndDate" value="${todayStr}" style="margin-left:5px;"></label>
                        </div>
                    </div>
                </div>
                
                <!-- 内容筛选 -->
                <div class="export-section" style="margin-bottom:20px;padding:15px;background:#f8f9fa;border-radius:8px;">
                    <h4 style="margin:0 0 10px;color:#2c3e50;">🔍 内容筛选</h4>
                    <div style="display:flex;flex-direction:column;gap:6px;">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" id="cloudIncludeAllStudents" checked>
                            <span>包含所有学生汇总</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" id="cloudHighlightProblems" checked>
                            <span>突出显示问题学生（缺勤/低效）</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" id="cloudIncludeExcused">
                            <span>包含请假学生详情</span>
                        </label>
                    </div>
                </div>
                
                <!-- 报告格式 -->
                <div class="export-section" style="margin-bottom:20px;padding:15px;background:#f8f9fa;border-radius:8px;">
                    <h4 style="margin:0 0 10px;color:#2c3e50;">📋 报告格式</h4>
                    <div style="display:flex;flex-direction:column;gap:6px;">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" id="cloudIncludeSummary" checked>
                            <span>包含整体统计汇总</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" id="cloudIncludeAnalysis" checked>
                            <span>包含问题学生分析</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" id="cloudIncludePracticeDetails" checked>
                            <span>包含详细练琴时间</span>
                        </label>
                    </div>
                </div>
                
                <!-- 专业筛选 -->
                <div class="export-section" style="margin-bottom:25px;padding:15px;background:#f8f9fa;border-radius:8px;">
                    <h4 style="margin:0 0 10px;color:#2c3e50;">🎓 专业筛选</h4>
                    <select id="cloudMajorFilterExport" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;">
                        <option value="">所有专业</option>
                        ${Object.keys(studentDatabase).sort().map(major => 
                            `<option value="${major}">${major}</option>`
                        ).join('')}
                    </select>
                </div>
                
                <!-- 操作按钮 -->
                <div style="display:flex;justify-content:flex-end;gap:12px;">
                    <button id="cancelCloudExportOptions" style="padding:10px 20px;background:#95a5a6;color:#fff;border:none;border-radius:6px;cursor:pointer;">取消</button>
                    <button id="generateCloudReportBtn" style="padding:10px 20px;background:var(--primary-color);color:#fff;border:none;border-radius:6px;cursor:pointer;">📊 生成云端汇总报告</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // 事件绑定
        modal.addEventListener('change', (e) => {
            if (e.target.name === 'cloudDateRange') {
                const customInputs = modal.querySelector('#cloudCustomDateInputs');
                if (customInputs) {
                    customInputs.style.display = e.target.value === 'custom' ? 'block' : 'none';
                }
            }
        });
        
        const cancelBtn = modal.querySelector('#cancelCloudExportOptions');
        const generateBtn = modal.querySelector('#generateCloudReportBtn');
        
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
                resolve(null);
            });
        }
        
        if (generateBtn) {
            generateBtn.addEventListener('click', () => {
                // 收集选项
                const options = {
                    dateRange: getCloudDateRange(modal),
                    includeAllStudents: modal.querySelector('#cloudIncludeAllStudents').checked,
                    highlightProblems: modal.querySelector('#cloudHighlightProblems').checked,
                    includeExcused: modal.querySelector('#cloudIncludeExcused').checked,
                    includeSummary: modal.querySelector('#cloudIncludeSummary').checked,
                    includeAnalysis: modal.querySelector('#cloudIncludeAnalysis').checked,
                    includePracticeDetails: modal.querySelector('#cloudIncludePracticeDetails').checked,
                    majorFilter: modal.querySelector('#cloudMajorFilterExport').value
                };
                
                document.body.removeChild(modal);
                resolve(options);
            });
        }
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
                resolve(null);
            }
        });
    });
}

/**
 * 🔥 新增：获取云端导出的日期范围
 */
function getCloudDateRange(modal) {
    const selectedRange = modal.querySelector('input[name="cloudDateRange"]:checked').value;
    const today = new Date();
    let startDate, endDate;
    
    switch (selectedRange) {
        case 'today':
            startDate = endDate = new Date(today);
            break;
        case 'yesterday':
            startDate = endDate = new Date(today.getTime() - 24 * 60 * 60 * 1000);
            break;
        case 'week':
            startDate = new Date(today.getTime() - 6 * 24 * 60 * 60 * 1000);
            endDate = new Date(today);
            break;
        case 'custom':
            startDate = new Date(modal.querySelector('#cloudStartDate').value);
            endDate = new Date(modal.querySelector('#cloudEndDate').value);
            break;
    }
    
    return {
        start: startDate.toISOString().split('T')[0],
        end: endDate.toISOString().split('T')[0],
        startStr: startDate.toISOString().split('T')[0],
        endStr: endDate.toISOString().split('T')[0],
        days: Math.ceil((endDate - startDate) / (24 * 60 * 60 * 1000)) + 1
    };
}

/**
 * 🔥 新增：处理云端数据以适配智能报告系统
 */
function processCloudDataForSmartReport(cloudRecords, options) {
    const data = {
        studentSummaries: new Map(),
        dailyStats: {},
        problemStudents: {
            consecutive: [],
            lowEfficiency: [],
            frequent: []
        }
    };
    
    // 处理每天的记录
    cloudRecords.forEach(dayRecord => {
        const allStudents = [...(dayRecord.students || []), ...(dayRecord.endedSlots || [])];
        
        // 按专业筛选
        const filteredStudents = options.majorFilter 
            ? allStudents.filter(s => s.major === options.majorFilter)
            : allStudents;
        
        // 按学生汇总数据
        filteredStudents.forEach(record => {
            const studentName = record.name;
            let studentMajor = record.major;
            
            // 确保专业信息正确
            if (!studentMajor || studentMajor === '未知专业') {
                studentMajor = getStudentMajor(studentName);
            }
            
            if (!data.studentSummaries.has(studentName)) {
                data.studentSummaries.set(studentName, {
                    name: studentName,
                    major: studentMajor,
                    totalSlots: 0,
                    presentSlots: 0,
                    lowEfficiencySlots: 0,
                    absentSlots: 0,
                    excusedSlots: 0,
                    underReviewSlots: 0,
                    totalPracticeTime: 0,
                    totalPlannedTime: 0,
                    timeSlots: [],
                    overrunCount: 0,
                    finalStatus: 'unknown',
                    attendanceRate: 0
                });
            }
            
            const summary = data.studentSummaries.get(studentName);
            
            // 确保专业信息一致
            if (!summary.major || summary.major === '未知专业') {
                summary.major = studentMajor;
            }
            
            summary.totalSlots++;
            summary.totalPracticeTime += record.practicedSec || 0;
            summary.totalPlannedTime += (record.totalPlannedMinutes || 0) * 60;
            summary.overrunCount += record.overrunCountToday || 0;
            
            // 记录时间段详情
            summary.timeSlots.push({
                date: dayRecord.date,
                timeRange: `${record.start}-${record.end}`,
                status: record.finalAttendanceStatus,
                statusText: record.finalStatusText,
                practiceTime: record.practicedSec || 0,
                plannedTime: (record.totalPlannedMinutes || 0) * 60
            });
            
            // 统计各状态数量
            switch (record.finalAttendanceStatus) {
                case 'present':
                    summary.presentSlots++;
                    break;
                case 'low_efficiency':
                    summary.lowEfficiencySlots++;
                    break;
                case 'absent':
                    summary.absentSlots++;
                    break;
                case 'excused':
                    summary.excusedSlots++;
                    break;
                case 'under_review':
                    summary.underReviewSlots++;
                    break;
            }
        });
    });
    
    // 计算最终统计
    data.studentSummaries.forEach((summary, studentName) => {
        // 计算出勤率（排除请假）
        const effectiveSlots = summary.totalSlots - summary.excusedSlots;
        if (effectiveSlots > 0) {
            summary.attendanceRate = ((summary.presentSlots + summary.lowEfficiencySlots) / effectiveSlots * 100);
        }
        
        // 计算练琴完成率
        summary.practiceCompletionRate = summary.totalPlannedTime > 0 
            ? (summary.totalPracticeTime / summary.totalPlannedTime * 100) 
            : 0;
        
        // 综合评估最终状态
        if (summary.excusedSlots === summary.totalSlots) {
            summary.finalStatus = 'excused';
        } else if (summary.absentSlots >= summary.totalSlots * 0.5) {
            summary.finalStatus = 'mostly_absent';
        } else if (summary.attendanceRate >= 80) {
            summary.finalStatus = 'good';
        } else if (summary.attendanceRate >= 60) {
            summary.finalStatus = 'fair';
        } else {
            summary.finalStatus = 'poor';
        }
    });
    
    // 分析问题学生
    data.problemStudents = analyzeProblemStudentsFromSummaries(data.studentSummaries, options.dateRange);
    
    return data;
}

/**
 * 🔥 新增：生成云端报告头部
 */
function generateCloudReportHeader(dateRange, options) {
    const rangeText = dateRange.days === 1 
        ? `${dateRange.startStr}` 
        : `${dateRange.startStr} 至 ${dateRange.endStr}`;
    
    return `云端考勤汇总报告
报告日期范围: ${rangeText}
生成时间: ${new Date().toLocaleString()}
数据来源: Firebase 云端数据库
筛选条件: ${options.majorFilter || '所有专业'}
${options.highlightProblems ? '✓ 突出问题学生' : ''}
${options.includeExcused ? '✓ 包含请假详情' : ''}

`;
}

/**
 * 🔥 新增：日期范围选择器
 */
function showDateRangeSelector() {
    return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.6);z-index:3000;display:flex;align-items:center;justify-content:center;';
        
        const today = new Date().toISOString().split('T')[0];
        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        modal.innerHTML = `
            <div style="background:#fff;padding:30px;border-radius:16px;max-width:500px;width:95%;">
                <h3 style="margin:0 0 20px;color:var(--primary-color);text-align:center;">☁️ 云端考勤报告导出</h3>
                
                <div style="margin-bottom:20px;">
                    <label style="display:block;margin-bottom:8px;font-weight:600;">开始日期：</label>
                    <input type="date" id="cloudStartDate" value="${weekAgo}" style="width:100%;padding:10px;border:1px solid #ddd;border-radius:6px;">
                </div>
                
                <div style="margin-bottom:25px;">
                    <label style="display:block;margin-bottom:8px;font-weight:600;">结束日期：</label>
                    <input type="date" id="cloudEndDate" value="${today}" style="width:100%;padding:10px;border:1px solid #ddd;border-radius:6px;">
                </div>
                
                <div style="display:flex;justify-content:flex-end;gap:12px;">
                    <button id="cancelCloudExport" style="padding:10px 20px;background:#95a5a6;color:#fff;border:none;border-radius:6px;cursor:pointer;">取消</button>
                    <button id="confirmCloudExport" style="padding:10px 20px;background:var(--primary-color);color:#fff;border:none;border-radius:6px;cursor:pointer;">导出</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        modal.querySelector('#cancelCloudExport').onclick = () => {
            document.body.removeChild(modal);
            resolve(null);
        };
        
        modal.querySelector('#confirmCloudExport').onclick = () => {
            const startDate = modal.querySelector('#cloudStartDate').value;
            const endDate = modal.querySelector('#cloudEndDate').value;
            
            if (!startDate || !endDate) {
                alert('请选择完整的日期范围');
                return;
            }
            
            if (startDate > endDate) {
                alert('开始日期不能晚于结束日期');
                return;
            }
            
            document.body.removeChild(modal);
            resolve({ start: startDate, end: endDate });
        };
    });
}

/**
 * 🔥 新增：生成综合考勤报告
 */
function generateComprehensiveAttendanceReport(cloudRecords, dateRange) {
    let report = `云端考勤综合报告
导出时间: ${new Date().toLocaleString()}
数据范围: ${dateRange.start} 至 ${dateRange.end}
数据来源: Firebase 云端数据库
记录天数: ${cloudRecords.length}

`;

    // 按学生汇总统计
    const studentStats = new Map();
    
    cloudRecords.forEach(dayRecord => {
        const allStudents = [...(dayRecord.students || []), ...(dayRecord.endedSlots || [])];
        
        allStudents.forEach(student => {
            if (!studentStats.has(student.name)) {
                studentStats.set(student.name, {
                    name: student.name,
                    major: student.major,
                    totalDays: 0,
                    presentDays: 0,
                    absentDays: 0,
                    excusedDays: 0,
                    lowEfficiencyDays: 0,
                    totalPracticeTime: 0,
                    details: []
                });
            }
            
            const stats = studentStats.get(student.name);
            stats.totalDays++;
            stats.totalPracticeTime += student.practicedSec || 0;
            
            switch (student.finalAttendanceStatus) {
                case 'present':
                    stats.presentDays++;
                    break;
                case 'absent':
                    stats.absentDays++;
                    break;
                case 'excused':
                    stats.excusedDays++;
                    break;
                case 'low_efficiency':
                    stats.lowEfficiencyDays++;
                    break;
            }
            
            stats.details.push({
                date: dayRecord.date,
                status: student.finalAttendanceStatus,
                statusText: student.finalStatusText,
                practiceTime: student.practicedSec || 0,
                timeSlot: `${student.start}-${student.end}`
            });
        });
    });
    
    // 生成学生汇总表
    report += `=== 学生考勤汇总 ===
学生姓名,专业,总天数,正常出勤,缺勤,请假,低效,出勤率,总练琴时长(小时)
`;
    
    Array.from(studentStats.values())
        .sort((a, b) => a.major.localeCompare(b.major) || a.name.localeCompare(b.name))
        .forEach(stats => {
            const attendanceRate = stats.totalDays > 0 
                ? ((stats.presentDays + stats.lowEfficiencyDays) / (stats.totalDays - stats.excusedDays) * 100).toFixed(1)
                : '0.0';
            const practiceHours = (stats.totalPracticeTime / 3600).toFixed(1);
            
            report += `${escapeCSV(stats.name)},${escapeCSV(stats.major)},${stats.totalDays},${stats.presentDays},${stats.absentDays},${stats.excusedDays},${stats.lowEfficiencyDays},${attendanceRate}%,${practiceHours}\n`;
        });
    
    // 生成每日详细记录
    report += `\n=== 每日详细记录 ===
日期,学生姓名,专业,时间段,考勤状态,状态详情,练琴时长(分钟)
`;
    
    cloudRecords.forEach(dayRecord => {
        const allStudents = [...(dayRecord.students || []), ...(dayRecord.endedSlots || [])];
        
        allStudents
            .sort((a, b) => a.major.localeCompare(b.major) || a.name.localeCompare(b.name))
            .forEach(student => {
                const practiceMinutes = Math.floor((student.practicedSec || 0) / 60);
                
                report += `${dayRecord.date},${escapeCSV(student.name)},${escapeCSV(student.major)},${student.start}-${student.end},${student.finalAttendanceStatus},${escapeCSV(student.finalStatusText)},${practiceMinutes}\n`;
            });
    });
    
    return report;
}

/**
 * 🔥 修改现有的考勤检查函数，添加云端同步
 */
const originalCheckAttendance = checkAttendance;
checkAttendance = function() {
    originalCheckAttendance();
    
    // 如果有考勤数据，同步到云端
    if (attendanceData && (attendanceData.students?.length > 0 || attendanceData.endedSlots?.length > 0)) {
        // 延迟同步，避免频繁写入
        clearTimeout(window.attendanceSyncTimeout);
        window.attendanceSyncTimeout = setTimeout(() => {
            syncAttendanceToCloud(attendanceData);
        }, 30000); // 30秒后同步
    }
};

function updateDurationPreview(){
  const m=parseInt($('baseDurationInput').value)||120;
  const h=Math.floor(m/60),mm=m%60;
  $('durationPreview').textContent='当前设置：'+(h?(h+'小时'+(mm?mm+'分钟':'')):m+'分钟');
}
function updateResetTimePreview(){
  const h=pad2(parseInt($('resetHourInput').value)||21);
  const m=pad2(parseInt($('resetMinuteInput').value)||45);
  $('resetTimePreview').textContent=`当前设置：${h}:${m}`;
}

function updateStartAnomalyPreview(){
  const h = parseInt($('startAnomalyHourInput').value) || 8;
  const m = parseInt($('startAnomalyMinuteInput').value) || 0;
  $('startAnomalyPreview').textContent = `当前设置：${pad2(h)}:${pad2(m)}开始`;
}

function updateStopAnomalyPreview(){
  const h = parseInt($('stopAnomalyHourInput').value) || 19;
  const m = parseInt($('stopAnomalyMinuteInput').value) || 0;
  $('stopAnomalyPreview').textContent = `当前设置：${pad2(h)}:${pad2(m)}后停止`;
}

function openSettingsModal(){
  if(isLocked){alert('系统已锁定');return;}
  $('baseDurationInput').value=systemSettings.basePracticeDuration;
  $('resetHourInput').value=systemSettings.autoResetHour;
  $('resetMinuteInput').value=systemSettings.autoResetMinute;
  $('startAnomalyHourInput').value=systemSettings.startAnomalyCheckHour;
  $('startAnomalyMinuteInput').value=systemSettings.startAnomalyCheckMinute || 0;
  $('stopAnomalyHourInput').value=systemSettings.stopAnomalyCheckHour;
  $('stopAnomalyMinuteInput').value=systemSettings.stopAnomalyCheckMinute || 0;
  $('loginPasswordInput').value='';
  $('adminPasswordInput').value='';
  
  // 🔥 新增：自动锁定设置初始化
  $('autoLockEnabledInput').checked = systemSettings.autoLockEnabled !== false;
  $('autoLockTimeInput').value = systemSettings.autoLockTimeMinutes || 10;
  
  // 🔥 新增：数据保护模式设置
  const dataProtectionCheckbox = document.getElementById('dataProtectionMode');
  if (dataProtectionCheckbox) {
    dataProtectionCheckbox.checked = systemSettings.dataProtectionMode || false;
  }
  
  updateDurationPreview();
  updateResetTimePreview();
  updateStartAnomalyPreview();
  updateStopAnomalyPreview();
  updateAutoLockPreview(); // 🔥 新增
  $('settingsModal').style.display='block';
}



function closeSettingsModal(){ $('settingsModal').style.display='none'; }
function togglePasswordVisibility(id){
  const inp=$(id); if(!inp)return;
  inp.type = inp.type==='password'?'text':'password';
}
// ===== 新增：基础练琴时长修改后的即时刷新 =====
function applyAfterBaseDurationChange(){
  // 强制重新渲染房间（含状态与样式）
  needsFullUpdate = true;
  updateRooms();

  // 重新计算队列等待时间（updateQueueDisplay 内部会重算 computeQueueWaits）
  updateQueueDisplay();

  // 时间轴 / Focus
  if (timelineVisible) {
    updateTimeline();
  }

  // 若超时管理面板打开，刷新
  const otModal = $('overtimeModal');
  if (otModal && otModal.style.display === 'block') {
    renderOvertimeList(true);
  }

  // 刷新徽章 / 按钮
  refreshOvertimeBadge();
  updateDemandButtonsStatus();

  // 若考勤面板打开（虽然考勤与基础时长关系较弱），可选择刷新
  const attModal = $('attendanceModal');
  if (attModal && attModal.style.display === 'block') {
    renderAttendanceList(true);
  }
}
function saveSettings(){
  const dur=parseInt($('baseDurationInput').value);
  const h=parseInt($('resetHourInput').value);
  const m=parseInt($('resetMinuteInput').value);
  const startHour=parseInt($('startAnomalyHourInput').value);
  const startMinute=parseInt($('startAnomalyMinuteInput').value);
  const stopHour=parseInt($('stopAnomalyHourInput').value);
  const stopMinute=parseInt($('stopAnomalyMinuteInput').value);
  const newPwd=$('loginPasswordInput').value.trim();
  const adminPwd=$('adminPasswordInput').value.trim();
  
  // 🔥 新增：自动锁定设置验证
  const autoLockEnabled = $('autoLockEnabledInput').checked;
  const autoLockTime = parseInt($('autoLockTimeInput').value);
  
  if(isNaN(dur)||dur<1||dur>240){alert('练琴时长1-240');return;}
  if(isNaN(h)||h<0||h>23||isNaN(m)||m<0||m>59){alert('重置时间不合法');return;}
  if(isNaN(startHour)||startHour<0||startHour>23||isNaN(startMinute)||startMinute<0||startMinute>59){
    alert('异常检查开始时间不合法');return;
  }
  if(isNaN(stopHour)||stopHour<0||stopHour>23||isNaN(stopMinute)||stopMinute<0||stopMinute>59){
    alert('异常检查停止时间不合法');return;
  }
  
  // 🔥 新增：自动锁定时间验证
  if(autoLockEnabled && (isNaN(autoLockTime)||autoLockTime<1||autoLockTime>120)){
    alert('自动锁定时间范围：1-120分钟');return;
  }
  
  let pwdChanged=false;
  if(newPwd){
    if(adminPwd!==systemSettings.adminPassword){alert('管理员密码错误');return;}
    systemSettings.loginPassword=newPwd;pwdChanged=true;
  }
  
  const oldReset=`${pad2(systemSettings.autoResetHour)}:${pad2(systemSettings.autoResetMinute)}`;
  const oldDur = systemSettings.basePracticeDuration;
  const oldAutoLockEnabled = systemSettings.autoLockEnabled;
  const oldAutoLockTime = systemSettings.autoLockTimeMinutes;

  systemSettings.basePracticeDuration=dur;
  systemSettings.autoResetHour=h;
  systemSettings.autoResetMinute=m;
  systemSettings.startAnomalyCheckHour=startHour;
  systemSettings.startAnomalyCheckMinute=startMinute;
  systemSettings.stopAnomalyCheckHour=stopHour;
  systemSettings.stopAnomalyCheckMinute=stopMinute;
  
  // 🔥 新增：保存自动锁定设置
  systemSettings.autoLockEnabled = autoLockEnabled;
  systemSettings.autoLockTimeMinutes = autoLockTime;
  
  persistSettings();
  closeSettingsModal();

  const newReset=`${pad2(h)}:${pad2(m)}`;
  const startTime=`${pad2(startHour)}:${pad2(startMinute)}`;
  const stopTime=`${pad2(stopHour)}:${pad2(stopMinute)}`;
  
  // 🔥 新增：自动锁定设置变化处理
  if(oldAutoLockEnabled !== autoLockEnabled || oldAutoLockTime !== autoLockTime) {
    if(autoLockEnabled) {
      // 重新启动自动锁定（如果系统未锁定）
      if(!isLocked) {
        disableAutoLock(); // 先停用旧的
        initAutoLock();    // 再启用新的
      }
      showToast(`自动锁定已${oldAutoLockEnabled ? '更新' : '启用'}：${autoLockTime}分钟无操作后锁定`);
    } else {
      // 禁用自动锁定
      disableAutoLock();
      showToast('自动锁定已禁用');
    }
  }
  
  if(oldReset!==newReset){
    const d=new Date();d.setDate(d.getDate()-1);
    lastResetDate = toDateKey(d);
    persistReset();
    showToast(`重置时间已修改为 ${newReset}，异常检查时间：${startTime}-${stopTime}`);
  }else{
    showToast('设置已保存');
  }

  logOperation('update_settings',{
    duration:dur,
    reset:newReset,
    startAnomalyTime:startTime,
    stopAnomalyTime:stopTime,
    autoLockEnabled: autoLockEnabled,      // 🔥 新增
    autoLockTimeMinutes: autoLockTime,     // 🔥 新增
    passwordChanged:pwdChanged
  });

  // 基础时长变化后立即刷新所有状态
  if(dur !== oldDur){
    applyAfterBaseDurationChange();
  }else{
    applyAfterBaseDurationChange();
  }
}


function manualReset(){
  if(isLocked){alert('系统已锁定');return;}
  if(!confirm('确定手动重置？'))return;
  
  // 🔥 新增：标记为用户主动操作
  lastUserDestructiveActionTs = Date.now();
  
  performAutoReset();
  cleanupEmptyMajors();
  refreshAllMajorSelectors();
  showToast('手动重置完成');
}

function performAutoReset(){
  const now=Date.now();
  const todayStr = todayKey();
  let cleared=0,queued=queueList.grand.length+queueList.upright.length+queueList.none.length;
  
  // 🔥 新增：标记为用户主动重置操作
  lastUserDestructiveActionTs = Date.now();
  
  rooms.forEach(r=>{
    if(r.student){
      addPracticeLog(r.student,r.name,r.registerTime,now,'系统重置');
      r.student=null;r.registerTime=null;cleared++;
    }
  });
  
  // 🔥 新增：结束所有活跃的练习会话
  practiceSessionTracker.forEach((session, sessionId) => {
      if (session.isActive) {
          endPracticeSession(sessionId, now, '系统重置');
      }
  });
  practiceSessionTracker.clear();

  queueList={grand:[],upright:[],none:[]};
  lastResetDate=todayKey();
  persistReset();
  persistRooms();persistQueues();
  
  // 🔥 关键修改：重置后立即强制同步到云端
  if (syncEnabled && isOnline && database) {
    // 禁用常规同步，使用强制同步
    syncEnabled = false;
    
    const resetData = {
      timestamp: now,
      deviceId: deviceId,
      action: 'system_reset',
      clearedRooms: cleared,
      clearedQueues: queued,
      resetDate: todayStr
    };
    
    // 立即推送重置状态到云端
    const updates = {};
    updates[FIREBASE_PATHS.ROOMS] = rooms.map(r => ({
      ...r,
      student: null,
      registerTime: null
    }));
    updates[FIREBASE_PATHS.QUEUE] = {grand:[],upright:[],none:[]};
    updates[FIREBASE_PATHS.LAST_UPDATE] = resetData;
    
    database.ref().update(updates)
      .then(() => {
        console.log('✅ 系统重置已同步到云端');
        // 延迟重新启用同步
        setTimeout(() => {
          syncEnabled = true;
        }, 2000);
      })
      .catch(error => {
        console.error('❌ 系统重置同步失败:', error);
        syncEnabled = true;
      });
  }
  
  needsFullUpdate=true;updateRooms();updateQueueDisplay();
  logOperation('auto_reset',{rooms:cleared,queues:queued});
}


function checkAutoReset(){
  const now = new Date();
  const todayKeyStr = todayKey();  // 统一格式 YYYY-MM-DD
  const currentM = now.getHours()*60 + now.getMinutes();
  const targetM = systemSettings.autoResetHour*60 + systemSettings.autoResetMinute;
  if (currentM >= targetM && lastResetDate !== todayKeyStr){
    performAutoReset();            // 内部已设置 lastResetDate = todayKey()
    showToast(`已自动重置 (${pad2(now.getHours())}:${pad2(now.getMinutes())})`);
  }
  updateAutoResetInfo();
}
function updateAutoResetInfo(){
  const info = $('autoResetInfo');
  if(!info) return;

  const now = new Date();
  const next = new Date();
  next.setHours(systemSettings.autoResetHour, systemSettings.autoResetMinute, 0, 0);
  if(now >= next) next.setDate(next.getDate()+1);

  const diff = next - now;
  const h = Math.floor(diff/3600000);
  const m = Math.floor((diff%3600000)/60000);

  const resetStr = `${pad2(systemSettings.autoResetHour)}:${pad2(systemSettings.autoResetMinute)}`;

  // 星期映射
  const WEEK_CN_FULL = ['日','一','二','三','四','五','六'];

  let tail = '';
  const today = todayKey();
  if(lastResetDate){
    if(lastResetDate === today){
      tail = ' · 今天已重置';
    }else{
      // 显示星期
      const dParts = lastResetDate.split('-');
      const d = new Date(Number(dParts[0]), Number(dParts[1])-1, Number(dParts[2]));
      const w = WEEK_CN_FULL[d.getDay()];
      tail = ` · 上次重置：${lastResetDate}（周${w}）`;
    }
  }

  info.innerHTML = `
    每日 ${resetStr} 自动重置
    <br><small>下次重置倒计时：${h}小时${m}分钟${tail}</small>
  `;
}

/* 备份与恢复 */
function backupSystemData() {
    try {
        // 🔥 确保所有数据都是最新的
        const success = persistAllData();
        if (!success) {
            throw new Error('数据持久化失败，无法创建可靠备份');
        }
        
        const backupData = {
            version: '13.1', // 🔥 更新版本号
            timestamp: Date.now(),
            deviceId: deviceId || getDeviceId(),
            
            // 🔥 核心数据 - 确保数据完整性
            rooms: JSON.parse(JSON.stringify(rooms)), // 深拷贝避免引用问题
            roomDatabase: JSON.parse(JSON.stringify(roomDatabase)),
            studentDatabase: JSON.parse(JSON.stringify(studentDatabase)),
            studentTimeSlots: JSON.parse(JSON.stringify(studentTimeSlots)),
            queueList: JSON.parse(JSON.stringify(queueList)),
            
            // 🔥 日志数据 - 直接从localStorage读取最新数据
            practiceLogs: lsGet(KEYS.PRACTICE_LOG, []),
            operationLogs: lsGet(KEYS.OPS, []),
            
            // 🔥 系统设置
            systemSettings: JSON.parse(JSON.stringify(systemSettings)),
            
            // 🔥 考勤数据
            attendanceData: attendanceData ? JSON.parse(JSON.stringify(attendanceData)) : {},
            
            // 🔥 异常提醒数据 - 确保Set正确转换
            practiceOverrunReminders: JSON.parse(JSON.stringify(practiceOverrunReminders)),
            overrunIgnoredKeys: Array.from(overrunIgnoredKeys || []),
            overrunStats: JSON.parse(JSON.stringify(overrunStats)),
            
            // 🔥 UI状态
            timelineVisible: timelineVisible,
            
            // 🔥 历史记录
            studentSlotHistory: lsGet(SLOT_HISTORY_KEY, {}),
            excuseOperationHistory: JSON.parse(JSON.stringify(excuseOperationHistory || [])),
            
            // 🔥 重置相关
            lastResetDate: lastResetDate,
            lastAttendanceCheck: lastAttendanceCheck,
            
            // 🔥 缓存统计（可选）
            cacheInfo: {
                totalSize: getTotalCacheSize(),
                itemCount: Object.keys(localStorage).length,
                backupSize: 0 // 稍后计算
            }
        };
        
        const jsonStr = JSON.stringify(backupData, null, 2);
        
        // 🔥 更新备份大小信息
        backupData.cacheInfo.backupSize = jsonStr.length;
        
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `琴房系统备份_${new Date().toISOString().slice(0,19).replace(/[:-]/g,'')}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        // 🔥 记录详细的操作日志
        logOperation('系统备份', {
            version: backupData.version,
            dataSize: `${(jsonStr.length/1024).toFixed(2)}KB`,
            roomCount: Object.keys(roomDatabase).length,
            studentCount: Object.values(studentDatabase).reduce((a,b)=>a+b.length,0),
            logCount: backupData.practiceLogs.length,
            timestamp: new Date().toLocaleString()
        });
        
        showToast('✅ 系统数据备份完成！', 3000);
        
    } catch (error) {
        console.error('❌ 备份失败:', error);
        showToast('❌ 备份失败: ' + error.message, 5000);
    }
}

function restoreSystemData() {
    if (isLocked) {
        alert('系统已锁定，无法恢复数据');
        return;
    }
    
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // 🔥 显示恢复确认
        const confirmMsg = `即将从备份文件恢复数据，这将：
        
⚠️  完全替换当前所有数据
⚠️  清除当前琴房占用状态
⚠️  清除当前排队信息
⚠️  可能影响正在进行的操作

备份文件：${file.name}
文件大小：${(file.size/1024).toFixed(2)}KB

确定要继续恢复吗？`;
        
        if (!confirm(confirmMsg)) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const backupData = JSON.parse(e.target.result);
                
                // 🔥 验证备份文件完整性
                if (!backupData.version || !backupData.timestamp) {
                    throw new Error('无效的备份文件格式：缺少版本信息或时间戳');
                }
                
                if (!backupData.rooms || !backupData.roomDatabase || !backupData.studentDatabase) {
                    throw new Error('备份文件不完整：缺少核心数据');
                }
                
                // 🔥 版本兼容性检查
                const backupVersion = parseFloat(backupData.version) || 0;
                const currentVersion = 13.1;
                
                if (backupVersion > currentVersion) {
                    const proceed = confirm(`备份文件版本(${backupData.version})高于当前系统版本(${currentVersion})，可能存在兼容性问题。是否继续？`);
                    if (!proceed) return;
                }
                
                // 🔥 清理当前占用状态（记录日志）
                const now = Date.now();
                let clearedRooms = 0;
                rooms.forEach(r => {
                    if (r.student) {
                        addPracticeLog(r.student, r.name, r.registerTime, now, '系统恢复清理');
                        clearedRooms++;
                    }
                });
                
                // 🔥 恢复核心数据
                if (backupData.rooms) rooms = [...backupData.rooms];
                if (backupData.roomDatabase) roomDatabase = {...backupData.roomDatabase};
                if (backupData.studentDatabase) studentDatabase = {...backupData.studentDatabase};
                if (backupData.studentTimeSlots) studentTimeSlots = {...backupData.studentTimeSlots};
                if (backupData.queueList) queueList = {...backupData.queueList};
                if (backupData.systemSettings) {
                    systemSettings = {...DEFAULT_SETTINGS, ...backupData.systemSettings};
                }
                
                // 🔥 恢复扩展数据
                if (backupData.attendanceData) {
                    attendanceData = {...backupData.attendanceData};
                }
                
                if (backupData.practiceOverrunReminders) {
                    practiceOverrunReminders = [...backupData.practiceOverrunReminders];
                }
                
                // 🔥 特殊处理：overrunIgnoredKeys 的兼容性
                if (backupData.overrunIgnoredKeys && Array.isArray(backupData.overrunIgnoredKeys)) {
                    overrunIgnoredKeys = new Set(backupData.overrunIgnoredKeys);
                } else if (backupData.overrunIgnored && Array.isArray(backupData.overrunIgnored)) {
                    // 兼容旧版本格式
                    overrunIgnoredKeys = new Set(backupData.overrunIgnored);
                } else {
                    overrunIgnoredKeys = new Set();
                }
                
                if (backupData.overrunStats) {
                    overrunStats = {...backupData.overrunStats};
                }
                
                if (backupData.timelineVisible !== undefined) {
                    timelineVisible = backupData.timelineVisible;
                }
                
                // 🔥 恢复请假操作历史
                if (backupData.excuseOperationHistory && Array.isArray(backupData.excuseOperationHistory)) {
                    excuseOperationHistory = [...backupData.excuseOperationHistory];
                } else {
                    excuseOperationHistory = [];
                }
                
                // 🔥 恢复其他状态
                if (backupData.lastResetDate) {
                    lastResetDate = backupData.lastResetDate;
                }
                if (backupData.lastAttendanceCheck) {
                    lastAttendanceCheck = backupData.lastAttendanceCheck;
                }
                
                // 🔥 恢复日志数据
                if (backupData.practiceLogs && Array.isArray(backupData.practiceLogs)) {
                    lsSet(KEYS.PRACTICE_LOG, backupData.practiceLogs);
                }
                if (backupData.operationLogs && Array.isArray(backupData.operationLogs)) {
                    lsSet(KEYS.OPS, backupData.operationLogs);
                }
                if (backupData.studentSlotHistory) {
                    lsSet(SLOT_HISTORY_KEY, backupData.studentSlotHistory);
                }
                
                // 🔥 重新加载日志到内存
                practiceLogs = lsGet(KEYS.PRACTICE_LOG, []);
                operationLogs = lsGet(KEYS.OPS, []);
                
                // 🔥 持久化所有恢复的数据
                const persistSuccess = persistAllData();
                if (!persistSuccess) {
                    throw new Error('数据持久化失败，恢复可能不完整');
                }
                
                // 🔥 刷新所有界面
                needsFullUpdate = true;
                updateRooms();
                updateQueueDisplay();
                updateDemandButtonsStatus();
                updateAttendanceBadge();
                refreshOvertimeBadge();
                updateOverrunPanel();
                
                // 🔥 刷新时间轴状态
                if (timelineVisible) {
                    toggleTimelineIfNeeded();
                }
                
                // 🔥 刷新缓存信息
                updateCacheInfo();
                
                const backupTime = new Date(backupData.timestamp).toLocaleString();
                const backupSize = backupData.cacheInfo ? `${(backupData.cacheInfo.backupSize/1024).toFixed(2)}KB` : '未知';
                
                // 🔥 记录恢复操作
                logOperation('系统恢复', {
                    backupVersion: backupData.version,
                    backupTime: backupTime,
                    backupSize: backupSize,
                    clearedRooms: clearedRooms,
                    restoredRooms: Object.keys(roomDatabase).length,
                    restoredStudents: Object.values(studentDatabase).reduce((a,b)=>a+b.length,0),
                    restoredLogs: practiceLogs.length,
                    timestamp: new Date().toLocaleString()
                });
                
                const successMsg = `✅ 系统数据恢复完成！
                
📊 恢复统计：
• 备份时间: ${backupTime}
• 备份版本: ${backupData.version}
• 备份大小: ${backupSize}
• 琴房数量: ${Object.keys(roomDatabase).length}
• 学生数量: ${Object.values(studentDatabase).reduce((a,b)=>a+b.length,0)}
• 练琴日志: ${practiceLogs.length} 条
• 清理占用: ${clearedRooms} 间

系统已完全恢复到备份时的状态。`;
                
                alert(successMsg);
                showToast('✅ 系统数据恢复完成！', 5000);
                
            } catch (error) {
                console.error('❌ 恢复失败:', error);
                alert(`❌ 恢复失败: ${error.message}\n\n请检查备份文件是否完整或联系管理员。`);
                showToast('❌ 恢复失败: ' + error.message, 5000);
            }
        };
        
        reader.onerror = function() {
            alert('❌ 文件读取失败，请重试');
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

/* =============== 统一持久化函数 =============== */
function persistAllData() {
    try {
        // 核心数据持久化
        persistRooms();
        persistRoomDb();
        persistStudents();
        persistStudentSlots();
        persistQueues();
        persistSettings();
        
        // 日志数据持久化
        persistLogs();
        persistOps();
        
        // 🔥 新增：异常提醒数据持久化
        persistOverruns(false); // 不触发云端同步，避免冲突
        
        // 🔥 新增：考勤相关数据持久化
        if (attendanceData && Object.keys(attendanceData).length > 0) {
            lsSet('attendanceData', attendanceData);
        }
        
        // 🔥 新增：其他状态数据
        lsSet(KEYS.TIMELINE_VISIBLE, timelineVisible.toString());
        
        // 🔥 新增：请假操作历史
        if (excuseOperationHistory && excuseOperationHistory.length > 0) {
            lsSet('excuseOperationHistory', excuseOperationHistory);
        }
        
        // 🔥 新增：重置日期
        if (lastResetDate) {
            persistReset();
        }
        
        // 🔥 删除：实时练琴状态持久化（已合并到房间状态）
        // lsSet('realTimePracticeStatus', realTimePracticeStatus);
        
        console.log('✅ 所有数据持久化完成');
        return true;
    } catch (error) {
        console.error('❌ 数据持久化失败:', error);
        return false;
    }
}

function getTotalCacheSize() {
    let total = 0;
    try {
        for (let key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
                const value = localStorage.getItem(key) || '';
                total += new Blob([value]).size;
            }
        }
    } catch (error) {
        console.warn('计算缓存大小失败:', error);
    }
    return total;
}
function addOperationLog(type, detail) {
    const log = {
        time: new Date().toISOString(),
        type: type,
        detail: detail
    };
    
    operationLogs.push(log);
    
    // 限制日志数量，避免过度增长
    if (operationLogs.length > 1000) {
        operationLogs = operationLogs.slice(-500); // 保留最新500条
    }
    
    persistOps();
}

/* =============== 统一持久化函数end =============== */
function toggleTimelineIfNeeded(){
  if(timelineVisible){
    $('timelineSection').style.display='block';
    const btn=$('timelineMainControlBtn');
    btn.classList.add('active');
    btn.querySelector('.timeline-control-text').textContent='隐藏琴房状态预测';
    btn.querySelector('.timeline-control-icon').textContent='👁️';
    updateTimeline();
  }
}
function exportPracticeLogs(){
  if(!practiceLogs.length){alert('暂无日志');return;}
  const choice=prompt("选择导出范围:\n1 仅今天\n2 最近7天\n3 最近30天\n4 全部\n5 自定义日期(YYYY-MM-DD,YYYY-MM-DD)");
  const today=new Date();
  let start,end;
  const norm=(d)=>{d.setHours(0,0,0,0);return d;};
  switch(choice){
    case '1':start=norm(new Date());end=new Date();break;
    case '2':start=norm(new Date(today-6*86400000));end=new Date();break;
    case '3':start=norm(new Date(today-29*86400000));end=new Date();break;
    case '4':start=new Date(0);end=new Date();break;
    case '5':
      const range=prompt('请输入开始与结束日期，逗号分隔(YYYY-MM-DD,YYYY-MM-DD)');
      if(!range) return;
      const [s,e]=range.split(',');
      start=norm(new Date(s));end=new Date(e);end.setHours(23,59,59,999);
      if(isNaN(start)||isNaN(end)){alert('日期无效');return;}
      break;
    default:return;
  }
  const filtered=practiceLogs.filter(l=>{
    const d=new Date(l.startTime);
    return d>=start&&d<=end;
  });
  if(!filtered.length){alert('范围内无记录');return;}
  filtered.sort((a,b)=>a.startTime-b.startTime);
  let csv='日期,学生,琴房,开始练琴时间,结束时间,练习时长(小时),结束原因\n';
  filtered.forEach(l=>{
    const dur=(l.duration/3600000).toFixed(2);
    csv+=`${escapeCSV(new Date(l.startTime).toLocaleDateString('zh-CN'))},${escapeCSV(l.student)},${escapeCSV(l.room)},${escapeCSV(new Date(l.actualStartTime||l.startTime).toLocaleString())},${escapeCSV(new Date(l.endTime).toLocaleString())},${dur},${escapeCSV(l.endReason||'')}\n`;
  });
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const a=document.createElement('a');a.href=URL.createObjectURL(blob);
  a.download='练琴日志_'+new Date().toISOString().slice(0,10)+'.csv';a.click();
  showToast('日志已导出');
}

/**
 * 清空除 “琴房库 / 学生库 / 学生时间段 / 系统设置” 以外的所有缓存数据
 * 保留 localStorage 键：
 *   - roomDatabase
 *   - studentDatabase
 *   - studentTimeSlots
 *   - systemSettings   (保留你当前配置/密码)
 *
 * 其它全部删除（练琴日志、排队、操作日志、重置记录、异常提醒、统计、时间轴开关等）
 *
 * 若想顺便保留备份 studentDatabaseBackup，可传 { preserveBackup:true }
 * 若想保留 AUTO_RESET(lastResetDate)，把 KEYS.AUTO_RESET 加入 whitelist（见注释）。
 */
function clearLocalStorage(options = { preserveBackup: false, preserveAutoReset: false }) {
  if (isLocked) {
    alert('系统已锁定'); return;
  }
  const whitelist = new Set([
    KEYS.ROOM_DB,        // 琴房库
    KEYS.STUD_DB,        // 学生库
    KEYS.STUD_SLOTS,     // 学生时间段
    KEYS.SETTINGS        // 系统设置（保留）
  ]);

  // 可选：保留学生数据库备份
  if (options.preserveBackup) {
    whitelist.add('studentDatabaseBackup');
  }
  // 可选：保留自动重置日期（上次执行日期）
  if (options.preserveAutoReset) {
    whitelist.add(KEYS.AUTO_RESET);
  }

  const confirmMsg =
`将清除除以下 4 项外的全部数据：
  • 琴房库(roomDatabase)
  • 学生库(studentDatabase)
  • 学生练琴时间段(studentTimeSlots)
  • 系统设置(systemSettings)

被清除的数据包括：
  - 当前所有琴房占用状态 
  - 排队信息 
  - 练琴日志
  - 操作日志 
  - 自动重置日期
  - 异常提醒 / 超时统计
  - 时间轴显示状态
  - 其它派生数据

确定继续？`;

  if (!confirm(confirmMsg)) return;

  // 1. 收集现有所有键
  const allKeys = [];
  for (let i = 0; i < localStorage.length; i++) {
    allKeys.push(localStorage.key(i));
  }

  // 统计大小
  const sizeMap = {};
  allKeys.forEach(k => {
    try {
      const v = localStorage.getItem(k) || '';
      sizeMap[k] = new Blob([v]).size;
    } catch {
      sizeMap[k] = 0;
    }
  });

  // 2. 删除非白名单
  const removed = [];
  allKeys.forEach(k => {
    if (!whitelist.has(k)) {
      localStorage.removeItem(k);
      removed.push(k);
    }
  });

  // 3. 重新加载保留的数据
  roomDatabase = lsGet(KEYS.ROOM_DB, {});
  studentDatabase = lsGet(KEYS.STUD_DB, {});
  studentTimeSlots = lsGet(KEYS.STUD_SLOTS, {});
  systemSettings = { ...DEFAULT_SETTINGS, ...lsGet(KEYS.SETTINGS, {}) }; // 合并(防止缺字段)

  // 4. 重置运行期内存（被清除的部分）
  rooms = [];
  rebuildRoomsFromDb();

  practiceLogs = [];
  queueList = { grand: [], upright: [], none: [] };
  operationLogs = [];

  attendanceData = {};
  lastAttendanceCheck = null;

  // 如果没有保留 autoReset，则 lastResetDate 设为 null
  if (!options.preserveAutoReset) {
    lastResetDate = null;
  } else {
    const resetObj = lsGet(KEYS.AUTO_RESET, { lastResetDate: null });
    lastResetDate = resetObj.lastResetDate;
  }

  timelineVisible = false;
  practiceOverrunReminders = [];
  overrunIgnoredKeys = new Set();
  overrunStats = {};

  // 5. 持久化“空容器”到存储（保留的库不动；系统设置保留）
  persistRooms();
  persistQueues();      // 空
  persistLogs();        // 空
  persistOps();         // 空

  if (!options.preserveAutoReset) {
    persistReset();     // 写入 lastResetDate=null
  }
  persistOverruns();     // 空
  persistOverruns(); // 空

  // 不写 persistSettings()（systemSettings 已经存在且未改），除非你想同步结构：
  persistSettings();

  // 6. UI 刷新
  needsFullUpdate = true;
  updateRooms();
  updateQueueDisplay();
  refreshOvertimeBadge();
  updateAttendanceBadge();
  updateDemandButtonsStatus();
  updateCacheInfo();

  // 7. 统计释放空间
  const savedBytes = removed.reduce((a, k) => a + (sizeMap[k] || 0), 0);
  const human = (n) => n > 1024 * 1024
    ? (n / 1024 / 1024).toFixed(1) + ' MB'
    : n > 1024
      ? (n / 1024).toFixed(1) + ' KB'
      : n + ' B';

  showToast(`运行数据已清理，移除 ${removed.length} 项，释放 ${human(savedBytes)}。系统设置已保留。`);

  logOperation('clear_cache_whitelist_keep_settings', {
    removedKeys: removed,
    keptKeys: [...whitelist],
    releasedBytes: savedBytes,
    preservedSettings: true,
    preserveBackup: !!options.preserveBackup,
    preserveAutoReset: !!options.preserveAutoReset
  });

  console.log('[清空缓存完成 - 保留系统设置] 保留键:', [...whitelist], '已删除:', removed);
}


/* 操作日志查看 */
function viewOperationLogs(){
  if(!operationLogs.length){alert('暂无日志');return;}
  const lines=operationLogs.slice(-200).map(l=>`[${l.time}] ${l.type} ${JSON.stringify(l.detail)}`);
  const blob=new Blob([lines.join('\n')],{type:'text/plain;charset=utf-8;'});
  const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='operation_logs.txt';a.click();
}
/* =============== 智能输入处理系统（支持中文输入法） =============== */

// 输入状态管理
const inputState = new Map();

/**
 * 智能输入处理器
 * 支持中文输入法，允许在任何输入阶段点击选择
 */
class SmartInputHandler {
  constructor(inputId, searchCallback) {
    this.inputId = inputId;
    this.searchCallback = searchCallback;
    this.isComposing = false;
    this.lastSearchValue = '';
    this.searchTimeout = null;
    this.selectedIndex = -1; // 当前选中的候选项索引
    
    this.bindEvents();
  }
  
  bindEvents() {
    const input = $(this.inputId);
    if (!input) return;
    
    // 中文输入法开始
    input.addEventListener('compositionstart', () => {
      this.isComposing = true;
    });
    
    // 中文输入法结束
    input.addEventListener('compositionend', (e) => {
      this.isComposing = false;
      this.handleSearch(e.target.value, true);
    });
    
    // 输入事件
    input.addEventListener('input', (e) => {
      this.selectedIndex = -1; // 重置选中索引
      this.handleSearch(e.target.value, false);
    });
    
    // 键盘事件（支持方向键选择和回车确认）
    input.addEventListener('keydown', (e) => {
      this.handleKeyNavigation(e);
    });
  }
  
  handleSearch(value, forceSearch = false) {
    // 清除之前的定时器
    if (this.searchTimeout) {
      clearTimeout(this.searchTimeout);
      this.searchTimeout = null;
    }
    
    // 如果正在输入中文且不是强制搜索，使用较短延迟
    const delay = this.isComposing && !forceSearch ? 100 : 50;
    
    this.searchTimeout = setTimeout(() => {
      // 避免重复搜索相同内容
      if (this.lastSearchValue !== value) {
        this.lastSearchValue = value;
        this.searchCallback(value);
        // 搜索完成后重置选中索引
        this.selectedIndex = -1;
      }
    }, delay);
  }
  
  handleKeyNavigation(e) {
    const resultContainer = this.getResultContainer();
    if (!resultContainer) return;
    
    // 根据不同输入框类型获取不同的选择器
    let selectableItems;
    if (this.inputId === 'globalSearch') {
      // 全局搜索使用不同的结构，这里可以选择跳过键盘导航
      return;
    } else {
      // 学生选择相关的搜索
      selectableItems = resultContainer.querySelectorAll('.student-item:not(.disabled-student)');
    }
    
    if (selectableItems.length === 0) return;
    
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        this.selectedIndex = Math.min(this.selectedIndex + 1, selectableItems.length - 1);
        this.updateSelection(selectableItems);
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
        this.updateSelection(selectableItems);
        break;
        
      case 'Enter':
        e.preventDefault();
        if (this.selectedIndex >= 0 && this.selectedIndex < selectableItems.length) {
          this.selectCurrentItem(selectableItems[this.selectedIndex]);
        }
        break;
        
      case 'Escape':
        e.preventDefault();
        this.selectedIndex = -1;
        this.updateSelection(selectableItems);
        break;
    }
  }
  
  selectCurrentItem(selectedItem) {
    const studentName = selectedItem.querySelector('.student-name-text')?.textContent;
    if (!studentName) return;
    
    // 根据不同的输入框执行不同的选择操作
    switch (this.inputId) {
      case 'modalStudentSearch':
        selectStudent(studentName);
        break;
      case 'queueStudentSearch':
        attemptQueueAdd(studentName);
        break;
      case 'studentDbSearch':
        // 学生数据库可能需要特殊处理，暂时跳过
        break;
      default:
        console.log('未处理的输入框类型:', this.inputId);
    }
  }
  
  updateSelection(selectableItems) {
    // 清除所有高亮
    selectableItems.forEach((item, index) => {
      if (index === this.selectedIndex) {
        item.classList.add('keyboard-selected');
      } else {
        item.classList.remove('keyboard-selected');
      }
    });
    
    // 滚动到选中项
    if (this.selectedIndex >= 0 && this.selectedIndex < selectableItems.length) {
      selectableItems[this.selectedIndex].scrollIntoView({
        block: 'nearest',
        behavior: 'smooth'
      });
    }
    
    // 显示选择状态提示（可选）
    this.updateSelectionHint(selectableItems.length);
  }
  
  updateSelectionHint(totalCount) {
    // 可选：显示选择状态提示
    if (this.selectedIndex >= 0 && totalCount > 0) {
      const hint = `${this.selectedIndex + 1}/${totalCount}`;
      // 这里可以在界面上显示提示，暂时在控制台输出
      // console.log('当前选择:', hint);
    }
  }
  
  getResultContainer() {
    // 根据不同的输入框ID返回对应的结果容器
    switch (this.inputId) {
      case 'modalStudentSearch':
        return $('modalStudentList');
      case 'queueStudentSearch':
        return $('queueStudentList');
      case 'globalSearch':
        return $('searchResults');
      case 'studentDbSearch':
        return $('studentDbContent');
      default:
        return null;
    }
  }
  
  // 获取当前实际输入值（包括合成中的值）
  getCurrentValue() {
    const input = $(this.inputId);
    return input ? input.value : '';
  }
  
  // 强制执行搜索
  forceSearch() {
    const value = this.getCurrentValue();
    this.searchCallback(value);
  }
}

// 输入处理器实例存储
const inputHandlers = new Map();

/**
 * 初始化智能输入处理
 */
function initSmartInputHandlers() {
  // 配置各个搜索输入框
  const configs = [
    { id: 'modalStudentSearch', callback: searchStudentsModal },
    { id: 'queueStudentSearch', callback: searchQueueStudents },
    { id: 'globalSearch', callback: performGlobalSearch },
    { id: 'studentDbSearch', callback: searchStudentDatabase }
  ];
  
  configs.forEach(config => {
    // 等待DOM元素可用后再初始化
    const initHandler = () => {
      const input = $(config.id);
      if (input && !inputHandlers.has(config.id)) {
        const handler = new SmartInputHandler(config.id, config.callback);
        inputHandlers.set(config.id, handler);
      }
    };
    
    // 立即尝试初始化
    initHandler();
    
    // 如果元素还不存在，延迟初始化
    if (!$(config.id)) {
      setTimeout(initHandler, 100);
    }
  });
}

/**
 * 获取输入处理器的当前值
 */
function getInputValue(inputId) {
  const handler = inputHandlers.get(inputId);
  return handler ? handler.getCurrentValue() : '';
}

/**
 * 强制执行搜索（用于模态框打开时）
 */
function forceInputSearch(inputId) {
  const handler = inputHandlers.get(inputId);
  if (handler) {
    handler.forceSearch();
  }
}

/* =============== 13. 搜索功能 =============== */
/**
 * 刷新搜索结果显示
 * 如果当前有搜索内容，重新执行搜索以更新结果
 */
// 在全局变量区域添加
let searchRefreshTimeout = null;

/**
 * 防抖版本的搜索结果刷新
 */
function refreshSearchResults() {
    // 清除之前的定时器
    if (searchRefreshTimeout) {
        clearTimeout(searchRefreshTimeout);
    }
    
    // 延迟刷新，避免频繁更新
    searchRefreshTimeout = setTimeout(() => {
        const searchInput = $('globalSearch');
        const searchResults = $('searchResults');
        
        if (searchInput && searchResults && searchResults.style.display === 'block') {
            const currentQuery = searchInput.value.trim();
            if (currentQuery) {
                performGlobalSearch(currentQuery);
                console.log('🔄 搜索结果已刷新');
            }
        }
        searchRefreshTimeout = null;
    }, 200); // 200ms 延迟
}


function performGlobalSearch(q){
  const resBox=$('searchResults');
  const clearBtn=$('clearSearchBtn');
  q=q.trim();
  if(!q){resBox.style.display='none';clearBtn.style.display='none';return;}
  clearBtn.style.display='block';
// 搜学生
  const students=[];
  for(const [m,arr] of Object.entries(studentDatabase)){
    arr.forEach(s=>{
      const studentName = getStudentName(s); // 🔥 修复：正确获取学生姓名
      if(matchPinyin(studentName,q)){
        students.push({...getStudentDetailedStatus(studentName),major:m});
      }
    });
  }

  // 搜琴房
  const roomRes=[];
  rooms.forEach(r=>{
    if(matchPinyin(r.name,q)||matchPinyin(r.location||'',q)||matchPinyin(r.pianoKind||'',q)){
      roomRes.push(getRoomDetailedStatus(r));
    }
  });
  let html='';
  if(students.length){
    html+='<div class="search-category">学生 ('+students.length+')</div>'+
      students.sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN')).map(st=>`
        <div class="search-item">
          <div class="search-item-info">
            <div class="search-item-name">${st.name}</div>
            <div class="search-item-status">
              <span class="${st.statusClass}">${st.statusText}</span>
              <span style="color:#999;margin-left:8px;">${st.major}</span>
            </div>
          </div>
          <div class="search-item-actions">
            ${st.actions.includes('clear')?`<button class="search-action-btn search-clear-btn" onclick="clearRoomWithConfirm('${st.roomName}')">清空</button>`:''}
          </div>
        </div>`).join('');
  }
  if(roomRes.length){
    html+='<div class="search-category">琴房 ('+roomRes.length+')</div>'+
      roomRes.sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN')).map(r=>`
        <div class="search-item">
          <div class="search-item-info">
            <div class="search-item-name">${r.name}</div>
            <div class="search-item-status">
              <span class="${r.statusClass}">${r.statusText}</span>
              <span style="color:#999;margin-left:8px;">${r.location} · ${r.pianoKind}</span>
            </div>
          </div>
          <div class="search-item-actions">
            ${r.actions.includes('clear')?`<button class="search-action-btn search-clear-btn" onclick="clearRoomWithConfirm('${r.name}')">清空</button>`:''}
            ${r.actions.includes('assign')?`<button class="search-action-btn search-assign-btn" onclick="assignRoomFromSearch('${r.name}')">分配学生</button>`:''}
          </div>
        </div>`).join('');
  }
  if(!html) html='<div class="search-no-results">未找到匹配结果</div>';
  resBox.innerHTML=html;
  resBox.style.display='block';
}
function getStudentDetailedStatus(name){
  const now=Date.now();
  const occ=rooms.find(r=>r.student===name);
  if(occ){
    const prepEnd=occ.registerTime+60000;
    if(now<prepEnd) return {name,status:'preparing',statusText:`在 ${occ.name} 准备中`,statusClass:'status-preparing',roomName:occ.name,actions:['clear']};
    const used=Math.floor((now-prepEnd)/1000);
    const limit=systemSettings.basePracticeDuration*60;
    if(used<=limit) return {name,status:'practicing',statusText:`在 ${occ.name} 练琴 (${formatHMS(used)})`,statusClass:'status-practicing',roomName:occ.name,actions:['clear']};
    return {name,status:'overtime',statusText:`在 ${occ.name} 超时 (${formatHMS(used)})`,statusClass:'status-overtime',roomName:occ.name,actions:['clear']};
  }
  if(queueList.grand.includes(name)){
    const p=queueList.grand.indexOf(name)+1;
    return {name,status:'queuing',statusText:`三角排队第${p}位`,statusClass:'status-queuing',actions:[]};
  }
  if(queueList.upright.includes(name)){
    const p=queueList.upright.indexOf(name)+1;
    return {name,status:'queuing',statusText:`立式排队第${p}位`,statusClass:'status-queuing',actions:[]};
  }
  if(queueList.none.includes(name)){
    const p=queueList.none.indexOf(name)+1;
    return {name,status:'queuing',statusText:`普通排队第${p}位`,statusClass:'status-queuing',actions:[]};
  }
  return {name,status:'free',statusText:'不在琴房',statusClass:'status-free',actions:[]};
}

function getRoomDetailedStatus(r){
  const now=Date.now();
  if(!r.student){
    return {
      name:r.name,
      location:r.location||'',
      pianoKind:r.pianoKind||'',
      status:'available',
      statusText:'空闲',
      statusClass:'status-available',   // 修改
      actions:['assign']
    };
  }
  const prepEnd=r.registerTime+60000;
  if(now<prepEnd){
    return {
      name:r.name,
      location:r.location||'',
      pianoKind:r.pianoKind||'',
      status:'preparing',
      statusText:`${r.student} 准备中`,
      statusClass:'status-preparing',   // 修改
      actions:['clear']
    };
  }
  const used=Math.floor((now-prepEnd)/1000);
  const limit=systemSettings.basePracticeDuration*60;
  if(used<=limit){
    return {
      name:r.name,
      location:r.location||'',
      pianoKind:r.pianoKind||'',
      status:'practicing',
      statusText:`${r.student} 使用中 (${formatHMS(used)})`,
      statusClass:'status-practicing',  // 修改
      actions:['clear']
    };
  }
  return {
    name:r.name,
    location:r.location||'',
    pianoKind:r.pianoKind||'',
    status:'overtime',
    statusText:`${r.student} 超时 (${formatHMS(used)})`,
    statusClass:'status-overtime',       // 修改
    actions:['clear']
  };
}

function assignRoomFromSearch(name){
  currentRoom = name;  // 确保设置了房间名
  const room = rooms.find(r => r.name === name);
  
  if (!room) {
    showToast('错误：琴房不存在');
    return;
  }
  
  console.log('🔍 从搜索分配房间:', name, 'currentRoom已设置为:', currentRoom);
  
  openStudentSelectModal(room);
  
  // 监听模态框关闭事件，关闭后刷新搜索
  const modal = $('studentListModal');
  if(modal) {
    modal.removeEventListener('modalClosed', refreshSearchResults);
    modal.addEventListener('modalClosed', refreshSearchResults, { once: true });
  }
}


function clearSearch(){
  $('globalSearch').value='';
  $('searchResults').style.display='none';
  $('clearSearchBtn').style.display='none';
}

/* =============== 14. 缓存监控 =============== */
function initCacheMonitor(){
  updateCacheInfo();
  setInterval(updateCacheInfo, 30000);
  
  // 添加点击缓存信息区域手动刷新功能
  const info = $('cacheInfo');
  if(info) {
    info.addEventListener('click', () => {
      updateCacheInfo();
      showToast('缓存信息已刷新', 1500);
    });
    info.style.cursor = 'pointer';
    info.title = '点击刷新缓存信息';
  }
}

function updateCacheInfo(){
  // 移除 isLocked 检查，让缓存监控始终工作
  const info=$('cacheInfo');
  if(!info) return;
  
  const data=calcCacheSize();
  info.style.display='block';
  $('cacheSize').textContent=data.human;
  $('cachePercentage').textContent=`${data.percent}% / 5MB`;
  
  const cs=$('cacheSize');
  cs.className='cache-size';
  if(data.percent>80) cs.classList.add('danger');
  else if(data.percent>60) cs.classList.add('warning');
  
  $('cacheDetails').innerHTML=`琴房:${data.roomsHuman}<br>学生:${data.studentHuman}<br>日志:${data.logsHuman}<br>其他:${data.otherHuman}`;
}

function calcCacheSize(){
  let total=0,roomsB=0,studB=0,logsB=0,otherB=0;
  
  function sizeOf(k){
    try {
      const v=localStorage.getItem(k)||'';
      return new Blob([v]).size;
    } catch {
      return 0;
    }
  }
  
  // 房间相关
  roomsB += sizeOf(KEYS.ROOMS) + sizeOf(KEYS.ROOM_DB);
  
  // 学生相关
  studB += sizeOf(KEYS.STUD_DB) + sizeOf(KEYS.STUD_SLOTS);
  
  // 日志相关
  logsB += sizeOf(KEYS.PRACTICE_LOG) + sizeOf(KEYS.OPS);
  
  // 其他数据
  [KEYS.SETTINGS, KEYS.AUTO_RESET, KEYS.TIMELINE_VISIBLE, KEYS.QUEUE].forEach(k => {
    otherB += sizeOf(k);
  });
  
  // 计算总大小
  total = roomsB + studB + logsB + otherB;
  const MB = 5*1024*1024;
  
  const human = (n) => {
    if(n > 1024*1024) return (n/1024/1024).toFixed(1) + ' MB';
    if(n > 1024) return (n/1024).toFixed(1) + ' KB';
    return n + ' B';
  };
  
  return {
    total,
    percent: Math.min(100, (total/MB*100)).toFixed(1), // 限制最大100%
    human: human(total),
    roomsHuman: human(roomsB),
    studentHuman: human(studB),
    logsHuman: human(logsB),
    otherHuman: human(otherB)
  };
}
/* =============== 14.5. 自动锁定功能 =============== */

/**
 * 重置自动锁定计时器
 */
function resetAutoLockTimer() {
    // 🔥 新增：检查是否启用自动锁定
    if (isLocked || !systemSettings.autoLockEnabled) return;
    
    lastActivityTime = Date.now();
    autoLockWarningShown = false;
    
    // 清除现有计时器
    if (autoLockTimer) {
        clearTimeout(autoLockTimer);
    }
    if (autoLockWarningTimer) {
        clearTimeout(autoLockWarningTimer);
    }
    
    // 关闭警告弹窗
    hideAutoLockWarning();
    
    // 🔥 修改：使用动态超时时间
    const autoLockTimeout = getAutoLockTimeout();
    
    // 设置警告计时器（提前30秒警告）
    autoLockWarningTimer = setTimeout(() => {
        if (!isLocked && systemSettings.autoLockEnabled) {
            showAutoLockWarning();
        }
    }, autoLockTimeout - AUTO_LOCK_WARNING_TIME);
    
    // 设置自动锁定计时器
    autoLockTimer = setTimeout(() => {
        if (!isLocked && systemSettings.autoLockEnabled) {
            performAutoLock();
        }
    }, autoLockTimeout);
}

/**
 * 显示自动锁定警告
 */
/**
 * 显示自动锁定警告
 */
function showAutoLockWarning() {
    if (isLocked || autoLockWarningShown || !systemSettings.autoLockEnabled) return;
    
    autoLockWarningShown = true;
    
    const warningDiv = document.createElement('div');
    warningDiv.id = 'autoLockWarning';
    warningDiv.className = 'auto-lock-warning';
    
    let countdown = Math.ceil(AUTO_LOCK_WARNING_TIME / 1000);
    
    // 🔥 修改：显示自定义的锁定时间
    const lockTimeMinutes = systemSettings.autoLockTimeMinutes || 10;
    
    warningDiv.innerHTML = `
        <h3>⏰ 系统即将自动锁定</h3>
        <p>检测到您已有 ${lockTimeMinutes} 分钟未操作系统</p>
        <div class="auto-lock-countdown" id="autoLockCountdown">${countdown} 秒</div>
        <p>系统将在倒计时结束后自动锁定以保护数据安全</p>
        <p style="font-size: 14px; color: rgba(255,255,255,0.8); margin-top: 15px;">
            💡 点击页面任意位置或按任意键可取消锁定
        </p>
    `;
    
    document.body.appendChild(warningDiv);
    
    // 倒计时更新
    const countdownInterval = setInterval(() => {
        countdown--;
        const countdownEl = document.getElementById('autoLockCountdown');
        if (countdownEl) {
            countdownEl.textContent = countdown + ' 秒';
        }
        
        if (countdown <= 0 || isLocked) {
            clearInterval(countdownInterval);
        }
    }, 1000);
    
    // 🔥 新增：点击弹窗任意位置取消锁定
    warningDiv.addEventListener('click', () => {
        hideAutoLockWarning();
        resetAutoLockTimer();
        const lockTimeMinutes = systemSettings.autoLockTimeMinutes || 10;
        showToast(`会话已延续，将在${lockTimeMinutes}分钟后再次检查`, 2000);
    });
    
    // 播放提示音（如果浏览器支持）
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
    } catch (e) {
        // 静默失败，不影响功能
        console.log('提示音播放失败，但不影响功能');
    }
}

/**
 * 隐藏自动锁定警告
 */
function hideAutoLockWarning() {
    const warning = document.getElementById('autoLockWarning');
    if (warning) {
        document.body.removeChild(warning);
    }
    autoLockWarningShown = false;
}


function continueSession() {
    hideAutoLockWarning();
    resetAutoLockTimer();
    // 🔥 修改：显示自定义时间
    const lockTimeMinutes = systemSettings.autoLockTimeMinutes || 10;
    showToast(`会话已延续，将在${lockTimeMinutes}分钟后再次检查`, 2000);
}

/**
 * 立即锁定系统
 */
function lockNow() {
    hideAutoLockWarning();
    clearAutoLockTimers();
    lockSystem();
}

/**
 * 执行自动锁定
 */
function performAutoLock() {
    if (isLocked || !systemSettings.autoLockEnabled) return;
    
    hideAutoLockWarning();
    clearAutoLockTimers();
    
    // 保存当前数据
    persistAllData();
    
    // 锁定系统
    isLocked = true;
    $('systemContent').style.display = 'none';
    $('cacheInfo').style.display = 'none';
    
    showUnlockModal();
    
    // 🔥 修改：显示自定义锁定时间
    const lockTimeMinutes = systemSettings.autoLockTimeMinutes || 10;
    showToast(`系统已自动锁定（${lockTimeMinutes}分钟无操作）`, 5000);
    
    // 记录自动锁定日志
    logOperation('auto_lock', {
        reason: 'inactivity_timeout',
        timeoutMinutes: lockTimeMinutes,
        lastActivity: new Date(lastActivityTime).toLocaleString(),
        inactiveMinutes: Math.round((Date.now() - lastActivityTime) / 60000)
    });
}

/**
 * 清除所有自动锁定计时器
 */
function clearAutoLockTimers() {
    if (autoLockTimer) {
        clearTimeout(autoLockTimer);
        autoLockTimer = null;
    }
    if (autoLockWarningTimer) {
        clearTimeout(autoLockWarningTimer);
        autoLockWarningTimer = null;
    }
}

/**
 * 初始化自动锁定功能
 */
function initAutoLock() {
    // 🔥 新增：检查是否启用自动锁定
    if (isLocked || !systemSettings.autoLockEnabled) {
        console.log('🔒 自动锁定功能已禁用');
        return;
    }
    
    // 监听用户活动事件
    const events = ['click', 'keydown', 'mousemove', 'scroll', 'touchstart'];
    
    events.forEach(event => {
        document.addEventListener(event, resetAutoLockTimer, { passive: true });
    });
    
    // 启动初始计时器
    resetAutoLockTimer();
    
    // 🔥 修改：显示自定义时间
    const lockTimeMinutes = systemSettings.autoLockTimeMinutes || 10;
    console.log(`🔒 自动锁定功能已启用（${lockTimeMinutes}分钟无操作后锁定）`);
}

/**
 * 停用自动锁定功能
 */
function disableAutoLock() {
    clearAutoLockTimers();
    hideAutoLockWarning();
    
    const events = ['click', 'keydown', 'mousemove', 'scroll', 'touchstart'];
    events.forEach(event => {
        document.removeEventListener(event, resetAutoLockTimer);
    });
    
    console.log('🔓 自动锁定功能已停用');
}



/* =============== 15. 解锁与初始化 =============== */
function showUnlockModal(){
  const modal=document.createElement('div');
  modal.id='unlockModal';
  modal.style.cssText='position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
    modal.innerHTML=`<div style="background:#fff;padding:40px 35px;border-radius:22px;max-width:420px;width:90%;box-shadow:0 10px 30px rgba(0,0,0,.3);text-align:center;">
    <h2 style="margin:0 0 18px;color:var(--primary-color);">🎹 耶胡迪梅纽因学校琴房管理系统</h2>
    <p style="margin:0 0 20px;color:#555;">请输入解锁密码</p>
    <input type="password" id="unlockPassword" style="width:100%;padding:14px 16px;font-size:16px;border:2px solid var(--border-color);border-radius:10px;text-align:left;margin-bottom:18px;" placeholder="请输入密码">

    <div style="margin-bottom:15px;">
      <button id="unlockConfirm" style="width:100%;padding:14px;font-size:16px;font-weight:600;">解锁系统</button>
    </div>
    <p style="font-size:12px;color:#999;margin:0;">按回车键快速确认</p>
  </div>`;
  document.body.appendChild(modal);
  const pwd=$('unlockPassword');
  pwd.focus();
  
  function doUnlock(){
    const v=pwd.value.trim();
    if(v===systemSettings.loginPassword){
      isLocked=false;
      document.body.removeChild(modal);
      $('systemContent').style.display='block';
      $('cacheInfo').style.display='block';
      showToast('解锁成功');
      updateCacheInfo();
      // 🔥 新增：解锁后启动自动锁定
      initAutoLock();
    }else{
      pwd.value='';
      pwd.placeholder='密码错误，请重新输入';
      pwd.style.borderColor='var(--danger-color)';
      modal.querySelector('div').style.animation='shake .5s';
      setTimeout(()=>{
        modal.querySelector('div').style.animation='';
        pwd.style.borderColor='var(--border-color)';
        pwd.placeholder='请输入密码';
      }, 1500);
    }
  }
  
  $('unlockConfirm').onclick=doUnlock;
  pwd.addEventListener('keydown',e=>{if(e.key==='Enter')doUnlock();});
  
  // 防止用户通过ESC键或点击背景关闭模态框
  modal.addEventListener('click', e => {
    if(e.target === modal) {
      // 点击背景时给出提示
      pwd.focus();
      modal.querySelector('div').style.animation='pulse .3s';
      setTimeout(()=>modal.querySelector('div').style.animation='', 300);
    }
  });
}

function lockSystem(){
  isLocked=true;
  $('systemContent').style.display='none';
  $('cacheInfo').style.display='none';
  // 🔥 新增：锁定时停用自动锁定
  disableAutoLock();
  showUnlockModal();
  showToast('系统已锁定，请输入密码解锁', 3000);
}
// 🔥 新增：检测和修复重复分配
function detectAndFixDuplicateAssignments() {
    const studentRoomMap = new Map();
    const duplicates = [];
    
    // 检测重复分配
    rooms.forEach(room => {
        if (room.student) {
            if (studentRoomMap.has(room.student)) {
                duplicates.push({
                    student: room.student,
                    rooms: [studentRoomMap.get(room.student), room.name],
                    times: [
                        rooms.find(r => r.name === studentRoomMap.get(room.student))?.registerTime,
                        room.registerTime
                    ]
                });
            } else {
                studentRoomMap.set(room.student, room.name);
            }
        }
    });
    
    // 修复重复分配
    if (duplicates.length > 0) {
        console.warn('🚨 检测到重复分配:', duplicates);
        
        duplicates.forEach(dup => {
            const [room1, room2] = dup.rooms;
            const [time1, time2] = dup.times;
            
            // 保留时间戳较新的分配
            const keepRoom = (time2 || 0) > (time1 || 0) ? room2 : room1;
            const removeRoom = keepRoom === room1 ? room2 : room1;
            const removeTime = keepRoom === room1 ? time1 : time2;
            
            // 清空较旧的分配
            const roomToUpdate = rooms.find(r => r.name === removeRoom);
            if (roomToUpdate) {
                addPracticeLog(
                    dup.student,
                    removeRoom,
                    removeTime,
                    Date.now(),
                    '重复分配清理'
                );
                roomToUpdate.student = null;
                roomToUpdate.registerTime = null;
            }
            
            console.log(`🔧 修复重复分配: ${dup.student} 保留在 ${keepRoom}，清空 ${removeRoom}`);
        });
        
        persistRooms();
        needsFullUpdate = true;
        updateRooms();
        showToast(`🔧 检测并修复了 ${duplicates.length} 个重复分配`, 3000);
    }
}
// 🔥 新增：定期检测重复分配（每30秒）
function periodicDuplicateCheck() {
    if (isLocked) return;
    detectAndFixDuplicateAssignments();
}
/* =============== 16. 自动刷新循环 =============== */
function mainLoop(){
  updateClock();
}
function secondLoop(){
  updateRooms();
  // 自动重置检查
  checkAutoReset();
  // 管理异常检查定时器
  manageAnomalyCheckTimer();
  // 每秒刷新面板时长展示
  updateOverrunPanel();
  // 🔥 新增：每分钟更新练习会话（只在每分钟的第0秒执行）
  const now = new Date();
  if (now.getSeconds() === 0) {
      updatePracticeSessions();
}


}


/* =============== 睡眠状态检测与数据保护 =============== */

function initSleepProtection() {
    // 检测页面可见性变化
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            // 页面进入后台/睡眠前保存状态
            console.log('📱 设备进入睡眠，保存当前状态...');
            deviceSleepTime = Date.now();
            localStorage.setItem('deviceSleepTime', deviceSleepTime);
            
            // 强制保存所有数据
            persistAllData();
            
            // 如果有占用状态，立即推送到云端
            const occupiedRooms = rooms.filter(r => r.student);
            if (occupiedRooms.length > 0) {
                console.log('💾 睡眠前推送占用状态到云端:', occupiedRooms.map(r => `${r.name}:${r.student}`));
                if (isOnline && syncEnabled) {
                    pushDataToCloud();
                }
            }
            
        } else {
            // 页面重新激活
            console.log('📱 设备唤醒，检查数据完整性...');
            const sleepTime = localStorage.getItem('deviceSleepTime');
            lastWakeupTime = Date.now();
            
            if (sleepTime) {
                const sleepDuration = Date.now() - parseInt(sleepTime);
                console.log(`睡眠时长: ${Math.round(sleepDuration/1000)}秒`);
                
                // 如果睡眠时间较长，启用保护模式
                if (sleepDuration > 30000) { // 30秒以上
                    handleWakeUpSync(sleepDuration);
                }
                
                // 清除睡眠时间记录
                localStorage.removeItem('deviceSleepTime');
                deviceSleepTime = null;
            }
        }
    });
    
    // 检测窗口焦点变化（补充保护）
    window.addEventListener('focus', function() {
        console.log('🔍 窗口获得焦点，检查数据状态...');
        setTimeout(checkDataIntegrity, 500);
    });
    
    window.addEventListener('blur', function() {
        console.log('💾 窗口失去焦点，保存数据...');
        persistAllData();
    });
}

function handleWakeUpSync(sleepDuration) {
    console.log('🛡️ 启动唤醒保护模式...');
    
    // 检查本地占用状态
    const localOccupiedRooms = rooms.filter(r => r.student && r.registerTime);
    
    if (localOccupiedRooms.length > 0) {
        console.log('🔒 本地有占用数据，优先保护本地状态');
        console.log('占用房间:', localOccupiedRooms.map(r => `${r.name}:${r.student}`));
        
        // 暂时禁用云端数据拉取
        const originalSyncEnabled = syncEnabled;
        syncEnabled = false;
        
        // 延迟推送本地状态到云端
        setTimeout(() => {
            console.log('🔄 推送本地占用状态到云端...');
            syncEnabled = originalSyncEnabled;
            if (isOnline) {
                pushDataToCloud();
            }
        }, 2000);
        
        showToast(`🛡️ 数据保护：已保护 ${localOccupiedRooms.length} 个占用状态`, 4000);
        
        // 延迟恢复正常同步
        setTimeout(() => {
            syncEnabled = originalSyncEnabled;
            console.log('🔄 恢复正常同步模式');
        }, 10000); // 10秒后恢复
        
    } else {
        console.log('📥 本地无占用数据，可以安全拉取云端数据');
        // 延迟拉取，给其他设备时间
        setTimeout(() => {
            if (isOnline) {
                pullDataFromCloud();
            }
        }, 1000);
    }
}

function checkDataIntegrity() {
    const occupiedCount = rooms.filter(r => r.student).length;
    const queueCount = queueList.grand.length + queueList.upright.length + queueList.none.length;
    
    console.log('🔍 数据完整性检查:', {
        占用房间: occupiedCount,
        排队人数: queueCount,
        数据保护模式: systemSettings.dataProtectionMode
    });
    
    // 如果检测到异常（比如数据突然清空），可以尝试恢复
    if (occupiedCount === 0 && queueCount === 0) {
        const lastBackupTime = localStorage.getItem('lastDataBackupTime');
        if (lastBackupTime && Date.now() - parseInt(lastBackupTime) < 300000) { // 5分钟内
            console.warn('⚠️ 检测到数据可能异常清空，考虑恢复机制');
            // 这里可以添加自动恢复逻辑
        }
    }
}


/* =============== 17. 初始化入口 =============== */
// 在 init 函数中添加检测
function init(){
    loadAll();
    // 🔥 新增：启动时进行数据库健康检查
    setTimeout(() => {
        performDatabaseHealthCheck();
    }, 1000);
    initFirebase();
    showUnlockModal();
    updateClock();
    initAttendanceCheck();
    initCacheMonitor();
    updateDemandButtonsStatus();
    if(timelineVisible) toggleTimelineIfNeeded();
    
    // 🔥 新增：启动时检测重复分配
    setTimeout(detectAndFixDuplicateAssignments, 2000);
    
    setInterval(mainLoop,1000);
    setInterval(secondLoop,1000);
    updateQueueDisplay();
    updateOverrunPanel();
    setTimeout(initSmartInputHandlers, 100);
    // 🔥 新增：每30秒检测一次重复分配
    setInterval(periodicDuplicateCheck, 30000);
    // 🔥 新增：启动请假状态定期检查（每分钟检查一次）
    excuseCheckInterval = setInterval(checkExpiredExcuses, 60000);
    
    // 🔥 新增：初始化睡眠保护
    initSleepProtection();
    
    // 🔥 新增：启动后数据完整性检查
    setTimeout(checkDataIntegrity, 3000);
    
    // 🔥 新增：操作锁定期清理（每30秒清理一次超时锁）
    setInterval(cleanupExpiredOperationLocks, 30000);
}

/* =============== 时间段预览功能 =============== */
function showStudentSlotsPreview(studentName) {
  const slots = studentTimeSlots[studentName];
  if(!slots) {
    alert('该学生未设置时间段');
    return;
  }
  
  const modal = document.createElement('div');
  modal.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.6);z-index:2000;display:flex;align-items:center;justify-content:center;';
  
  let totalSlots = 0;
  let previewHTML = '';
  
  ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'].forEach(day => {
    const daySlots = slots[day] || [];
    if(daySlots.length > 0) {
      totalSlots += daySlots.length;
      previewHTML += `
        <div style="margin-bottom:15px;">
          <h4 style="margin:0 0 8px;color:#2c3e50;">${WEEK_CN[day]} (${daySlots.length}段)</h4>
          <div style="display:flex;flex-wrap:wrap;gap:8px;">
            ${daySlots.map(slot => 
              `<span style="background:#e3f2fd;color:#1976d2;padding:4px 8px;border-radius:12px;font-size:12px;">
                ${slot.start}-${slot.end} <small>(${slot.duration})</small>
              </span>`
            ).join('')}
          </div>
        </div>
      `;
    }
  });
  
  modal.innerHTML = `
    <div style="background:#fff;padding:25px;border-radius:16px;max-width:600px;width:95%;max-height:80vh;overflow-y:auto;">
      <h3 style="margin:0 0 20px;color:#3498db;text-align:center;">${studentName} 的练琴时间安排</h3>
      <div style="text-align:center;margin-bottom:20px;color:#666;">
        共 ${totalSlots} 个时间段，覆盖 ${Object.keys(slots).filter(day => slots[day] && slots[day].length > 0).length} 天
      </div>
      ${previewHTML || '<div style="text-align:center;color:#999;padding:20px;">暂无时间段设置</div>'}
      <div style="text-align:center;margin-top:20px;">
        <button onclick="this.closest('div[style*=\"position:fixed\"]').remove()" style="background:#3498db;color:#fff;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;">关闭</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  modal.addEventListener('click', (e) => {
    if(e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

/* =============== 18. 需求按钮状态 =============== */
function updateDemandButtonsStatus(){
  ['grand','upright','none'].forEach(type=>{
    const el=$(type==='grand'?'grandStatus':type==='upright'?'uprightStatus':'noneStatus');
    if(!el) return;
    el.className='';
    if(queueList[type].length){
      el.textContent=`👥 ${queueList[type].length} 人排队中`;
      el.className='status-queue';
      return;
    }
    const res=analyzeDemandAvailability(type);
    if(res.available.length){
      el.textContent=`✅ ${res.available.length} 间空闲`;
      el.className='status-available';
    }else if(res.overtime.length){
      el.textContent=`⚠️ ${res.overtime.length} 间超时可替换`;
      el.className='status-overtime';
    }else{
      el.textContent='🚫 需要排队';
      el.className='status-queue';
    }
  });
}

/* =============== 19. 兼容旧函数名映射 (保持 HTML on* 调用不报错) =============== */
window.handleRoomClick=handleRoomClick;
window.clearRoomWithConfirm=clearRoomWithConfirm;
window.manualReset=manualReset;
window.lockSystem=lockSystem;
window.registerStudent=()=>{};
window.registerGrandPianoStudent=()=>{};
window.searchStudentsModal=searchStudentsModal;
window.closeModal=closeModal;
window.showMajorStudents=showMajorStudents;
window.selectStudent=selectStudent;
window.addNewStudent=addNewStudent;
window.manageStudentDatabase=manageStudentDatabase;
window.closeStudentDatabaseModal=closeStudentDatabaseModal;
window.addNewStudentToDatabase=addNewStudentToDatabase;
window.editStudent=editStudent;
window.saveStudentChanges=saveStudentChanges;
window.closeEditStudentModal=closeEditStudentModal;
window.deleteStudent=deleteStudent;
window.manageRoomDatabase=()=>{$('roomDatabaseModal').style.display='block';displayRoomDatabase();};
window.closeRoomDatabaseModal=()=>{$('roomDatabaseModal').style.display='none';};
window.clearLocalStorage=clearLocalStorage;
window.exportPracticeLogs=exportPracticeLogs;
window.backupSystemData=backupSystemData;
window.restoreSystemData=restoreSystemData;
window.viewOperationLogs=viewOperationLogs;
window.openSettingsModal=openSettingsModal;
window.closeSettingsModal=closeSettingsModal;
window.saveSettings=saveSettings;
window.togglePasswordVisibility=togglePasswordVisibility;
window.openOvertimeModal=openOvertimeModal;
window.closeOvertimeModal=closeOvertimeModal;
window.clearQueue=clearQueue;
window.clearAllQueues=clearAllQueues;
window.showQueueStudentModal=showQueueStudentModal;
window.closeQueueStudentModal=closeQueueStudentModal;
window.searchQueueStudents=searchQueueStudents;
window.addNewQueueStudent=addNewQueueStudent;
window.attemptQueueAdd=attemptQueueAdd;
window.moveQueueItem=moveQueueItem;
window.removeFromQueue=removeFromQueue;
window.handleDemandRequest=handleDemandRequest;
window.closeAvailableRoomsModal=closeAvailableRoomsModal;
window.selectDemandRoom=selectDemandRoom;
window.showReplaceableRoomsModal=showReplaceableRoomsModal;
window.closeReplaceableRoomsModal=closeReplaceableRoomsModal;
window.replaceWithQueueStudent=replaceWithQueueStudent;
window.toggleTimeline=toggleTimeline;
window.openAttendanceModal=openAttendanceModal;
window.closeAttendanceModal=closeAttendanceModal;
window.renderAttendanceList=renderAttendanceList;
window.excuseStudent=excuseStudent;
window.cancelExcuse=cancelExcuse;
window.exportAttendanceReport=exportAttendanceReport;
window.performGlobalSearch=performGlobalSearch;
window.clearSearch=clearSearch;
window.assignRoomFromSearch=assignRoomFromSearch;
window.manageStudentTimeSlots=manageStudentTimeSlots;
window.selectWeekday=selectWeekday;
window.addTimeSlot=addTimeSlot;
window.deleteTimeSlot=deleteTimeSlot;
window.clearAllTimeSlots=clearAllTimeSlots;
window.closeTimeSlotModal=closeTimeSlotModal;
window.toggleOverrunPanel = toggleOverrunPanel;
window.ignoreOverrun = ignoreOverrun;
window.recordOverrun = recordOverrun;
window.toggleMajorCollapse = toggleMajorCollapse;
window.switchToOvertimeManagement = switchToOvertimeManagement;
window.updateStartAnomalyPreview=updateStartAnomalyPreview;
window.updateStopAnomalyPreview=updateStopAnomalyPreview;
window.showStudentSlotsPreview = showStudentSlotsPreview;
// 🔥 新增：操作锁管理函数
window.clearAllOperationLocks = clearAllOperationLocks;
window.cleanupExpiredOperationLocks = cleanupExpiredOperationLocks;

// 🔥 新增：年级相关函数映射
window.filterByGrade = filterByGrade;
window.populateGradeFilter = populateGradeFilter;
window.parseGradeInput = parseGradeInput;
window.formatGradeDisplay = formatGradeDisplay;
window.getStudentGrade = getStudentGrade;
window.getStudentInfo = getStudentInfo;
window.getStudentName = getStudentName;
window.upgradeStudentDatabaseStructure = upgradeStudentDatabaseStructure;
window.getStudentRealTimePracticeStatus = getStudentRealTimePracticeStatus;
window.triggerRealTimePracticeStatusUpdate = triggerRealTimePracticeStatusUpdate;
// 🔥 新增：练习时长相关函数映射
window.exportStudentPracticeReport = exportStudentPracticeReport;
window.getStudentPracticeRecord = getStudentPracticeRecord;
window.getStudentPracticeStats = getStudentPracticeStats;
window.formatPracticeTime = formatPracticeTime;
// 🔥 新增：自动锁定相关函数映射
window.resetAutoLockTimer = resetAutoLockTimer;
window.initAutoLock = initAutoLock;
window.disableAutoLock = disableAutoLock;

// 🔥 新增：自动锁定设置相关函数映射
window.updateAutoLockPreview = updateAutoLockPreview;
window.getAutoLockTimeout = getAutoLockTimeout;
window.clearAllOverrunReminders = clearAllOverrunReminders;



/* ======== 房间数据库增强块（新增 / 编辑 / 导入 / 导出） ======== */

/**
 * 数据结构说明
 * roomDatabase: { [name]: { name, location, pianoType, remark } }
 * rooms[]: 运行态对象 (包含占用状态 student, registerTime)
 * 本模块所有改动 -> 先改 roomDatabase -> 同步 rooms -> persist
 */

/* ---------- 工具 ---------- */
const ROOM_TYPE_ALIASES = {
  '三角钢琴': [
    '三角','三角琴','三角钢琴','三角钢琴房','grand','grandpiano','grand-piano',
    'gp','concert','concertgrand','concertpiano','triangle'  // triangle 也兼容
  ],
  '立式钢琴': [
    '立式','立式琴','立式钢琴','立式钢琴房','upright','uprightpiano','upright-piano',
    'upr','up','upright'
  ],
  '无钢琴': [
    '无钢琴','无','none','no','nopiano','普通','普通琴房','空','other','其它','其他','null',
    'room','practice','练功房','练习房'
  ]
};

// 归一：去掉空白 / 破折号 / 下划线 / 全角空格，转小写
function roomDbNormalizeType(raw, warnCollector){
  if(!raw) return '无钢琴';
  let s = String(raw)
    .replace(/\u3000/g,' ')       // 全角空格
    .trim()
    .toLowerCase();
  // 去掉内部空白、横杠、下划线
  const key = s.replace(/[\s\-_]/g,'');
  for(const std in ROOM_TYPE_ALIASES){
    if(ROOM_TYPE_ALIASES[std].some(a=>key===a.replace(/[\s\-_]/g,'').toLowerCase())){
      return std;
    }
  }
  // 兜底：尝试包含关键字（避免“这是一个三角琴房A”仍识别）
  if(/三角/.test(s)) return '三角钢琴';
  if(/立式/.test(s)) return '立式钢琴';

  // 未识别
  if(Array.isArray(warnCollector)){
    warnCollector.push(raw);
  }
  return '无钢琴';
}

function roomDbSyncRoomsFromDatabase(){
  // 🔥 关键修复：不仅要添加新房间，还要删除不在数据库中的房间
  
  // 获取数据库中的房间名称集合
  const dbRoomNames = new Set(Object.keys(roomDatabase));
  
  // 🔥 新增：删除不在数据库中的房间
  for(let i = rooms.length - 1; i >= 0; i--) {
    const room = rooms[i];
    if(room && room.name && !dbRoomNames.has(room.name)) {
      console.log(`🗑️ 删除不在数据库中的房间: ${room.name}`);
      
      // 如果房间被占用，记录日志
      if(room.student) {
        addPracticeLog(room.student, room.name, room.registerTime, Date.now(), '房间数据库同步删除');
      }
      
      rooms.splice(i, 1);
    }
  }
  
  // 现有名字集合（更新后的）
  const existingNames = new Set(rooms.map(r=>r.name));
  
  // 更新已有房间的元数据
  rooms.forEach(r=>{
    const meta = roomDatabase[r.name];
    if(meta){
      r.location = meta.location || '';
      r.pianoKind = meta.pianoType;
      r.type = (meta.pianoType === '三角钢琴') ? 'grand' : 'other';
      r.remark = meta.remark || '';
    }
  });
  
  // 添加新增房间
  Object.values(roomDatabase).forEach(meta=>{
    if(!existingNames.has(meta.name)){
      console.log(`➕ 添加新房间: ${meta.name}`);
      rooms.push({
        name: meta.name,
        type: meta.pianoType === '三角钢琴' ? 'grand':'other',
        pianoKind: meta.pianoType,
        location: meta.location || '',
        remark: meta.remark || '',
        student: null,
        registerTime: null,
      });
    }
  });
  
  // 🔥 保持：对 rooms 数组按名称进行自然排序
  rooms.sort((a, b) => {
    return a.name.localeCompare(b.name, 'zh-Hans-CN', {
      numeric: true,
      sensitivity: 'base'
    });
  });
  
  persistRoomDb();
  persistRooms();
  needsFullUpdate = true;
  updateRooms();
}

function roomDbCollectLocations(){
  const set = new Set();
  Object.values(roomDatabase).forEach(r=>{
    if(r.location && r.location.trim()) set.add(r.location.trim());
  });
  return Array.from(set).sort((a,b)=>a.localeCompare(b,'zh-Hans-CN'));
}

function roomDbRefreshLocationFilter(){
  const sel = $('roomLocationFilter');
  if(!sel) return;
  const current = sel.value;
  const locs = roomDbCollectLocations();
  sel.innerHTML = '<option value="">所有位置</option>' +
    locs.map(l=>`<option value="${l}">${l}</option>`).join('');
  if(locs.includes(current)) sel.value = current;
}

function roomDbValidateName(name){
  if(!name) return '名称不能为空';
  if(/[,\r\n]/.test(name)) return '名称不能包含逗号或换行';
  if(name.length > 40) return '名称过长';
  return null;
}

/* ---------- 新增 ---------- */
function roomDbAddRoom(){
  if(isLocked){alert('系统已锁定');return;}

  // 关键：先正确读取名称，避免使用到 window.name
  const name  = $('newRoomNameInput').value.trim();
  const loc   = $('newRoomLocationInput').value.trim();
  const type  = $('newRoomTypeSelect').value;
  const remark= $('newRoomRemarkInput').value.trim();

  const err = roomDbValidateName(name);
  if(err){
    alert(err);
    $('newRoomNameInput').focus();
    return;
  }

  if(roomDatabase[name]){
    alert('已存在同名琴房');
    $('newRoomNameInput').focus();
    return;
  }

  roomDatabase[name] = {
    name,
    location: loc || '',
    pianoType: roomDbNormalizeType(type),
    remark
  };

  persistRoomDb();
  roomDbSyncRoomsFromDatabase();   // 同步到运行态 rooms
  roomDbClearQuickAddInputs();
  logOperation('room_add',{
    name,
    location: loc,
    rawType: type,
    typeNormalized: roomDatabase[name].pianoType
  });
  showToast('新增琴房成功');
  roomDbRenderList();
  
  // 🔥 新增：刷新房间布局显示，确保新楼层出现在切换按钮中
  needsFullUpdate = true;
  updateRooms();
}


function roomDbClearQuickAddInputs(){
  $('newRoomNameInput').value='';
  $('newRoomLocationInput').value='';
  $('newRoomTypeSelect').value='三角钢琴';
  $('newRoomRemarkInput').value='';
}

/* ---------- 列表渲染与状态 ---------- */
let roomDbEditingName = null; // 当前处于编辑状态的原始名称

function roomDbRenderList(){
  const list = $('roomDatabaseList');
  if(!list) return;
  roomDbRefreshLocationFilter();

  const search = ($('roomSearchInput')?.value||'').trim().toLowerCase();
  const locF = $('roomLocationFilter')?.value || '';
  const typeF = $('roomTypeFilter')?.value || '';

  const all = Object.values(roomDatabase)
    .sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN'));

  let html =
    '<div class="room-db-item header">'+
    '<div>名称</div><div>位置</div><div>类型</div><div>备注</div><div>操作</div></div>';

  let total=0, grand=0, upright=0, none=0;

  all.forEach(meta=>{
    if(locF && meta.location !== locF) return;
    if(typeF && meta.pianoType !== typeF) return;
    const keyword = (meta.name+' '+(meta.location||'')+' '+meta.pianoType+' '+(meta.remark||'')).toLowerCase();
    if(search && !keyword.includes(search)) return;
    total++;
    if(meta.pianoType==='三角钢琴') grand++;
    else if(meta.pianoType==='立式钢琴') upright++;
    else none++;

    const occupied = rooms.some(r=>r.name===meta.name && r.student);
    const editing = roomDbEditingName === meta.name;
    if(editing){
      html += `
        <div class="room-db-item" data-room="${meta.name}">
          <div>${occupied? meta.name : `<input class="room-inline-input" id="editRoomName" value="${meta.name}" style="width:100%;box-sizing:border-box;">`}</div>
          <div><input class="room-inline-input" id="editRoomLocation" value="${meta.location||''}"></div>
          <div>
            <select class="room-inline-select" id="editRoomType">
              <option value="三角钢琴" ${meta.pianoType==='三角钢琴'?'selected':''}>三角钢琴</option>
              <option value="立式钢琴" ${meta.pianoType==='立式钢琴'?'selected':''}>立式钢琴</option>
              <option value="无钢琴" ${meta.pianoType==='无钢琴'?'selected':''}>无钢琴</option>
            </select>
          </div>
            <div><input class="room-inline-input" id="editRoomRemark" value="${meta.remark||''}"></div>
          <div>
            <button class="room-save-btn" onclick="roomDbSaveEdit('${meta.name}',${occupied})">保存</button>
            <button class="room-cancel-btn" onclick="roomDbCancelEdit()">取消</button>
          </div>
        </div>
      `;
    }else{
      html += `
        <div class="room-db-item" data-room="${meta.name}">
          <div>${meta.name}</div>
          <div>${meta.location||''}</div>
          <div><span class="room-tag ${meta.pianoType==='三角钢琴'?'tag-grand':meta.pianoType==='立式钢琴'?'tag-upright':'tag-none'}">${meta.pianoType}</span></div>
          <div title="${meta.remark||''}">${meta.remark||''}</div>
          <div>
            <button class="room-edit-btn" onclick="roomDbStartEdit('${meta.name}')">编辑</button>
            <button class="room-del-btn" onclick="roomDbDeleteRoom('${meta.name}')">删除</button>
          </div>
        </div>
      `;
    }
  });

  list.innerHTML = html;
  $('roomDbStats').innerHTML =
    `共 ${total} 间；三角 ${grand}，立式 ${upright}，无钢琴/其他 ${none}`;
}

function roomDbStartEdit(name){
  if(isLocked){alert('系统已锁定');return;}
  if(roomDbEditingName && roomDbEditingName !== name){
    if(!confirm('已有正在编辑的行，放弃并切换？')) return;
  }
  roomDbEditingName = name;
  roomDbRenderList();
}

function roomDbCancelEdit(){
  roomDbEditingName = null;
  roomDbRenderList();
}

function roomDbSaveEdit(originalName, occupied){
  if(isLocked){alert('系统已锁定');return;}
  const meta = roomDatabase[originalName];
  if(!meta){showToast('记录不存在');roomDbCancelEdit();return;}

  const newName = occupied ? originalName : $('editRoomName').value.trim();
  const location = $('editRoomLocation').value.trim();
  const type = $('editRoomType').value;
  const remark = $('editRoomRemark').value.trim();

  if(!occupied){
    const err = roomDbValidateName(newName);
    if(err){alert(err);return;}
    if(newName !== originalName && roomDatabase[newName]){
      alert('存在同名琴房');return;
    }
  }

  // 如果改名（非占用）
  if(!occupied && newName !== originalName){
    // 更新 roomDatabase 键
    delete roomDatabase[originalName];
    roomDatabase[newName] = {
      name: newName,
      location,
      pianoType: roomDbNormalizeType(type),
      remark
    };
    // 更新 rooms[] 中对应项名称
    rooms.forEach(r=>{
      if(r.name === originalName){
        r.name = newName;
      }
    });
  }else{
    // 不改名
    meta.location = location;
    meta.pianoType = roomDbNormalizeType(type);
    meta.remark = remark;
  }

  persistRoomDb();
  roomDbSyncRoomsFromDatabase();
  logOperation('room_edit',{
    original: originalName,
    newName,
    location,
    pianoType: type,
    normalized: roomDbNormalizeType(type),
    remark,
    renamed: (!occupied && newName!==originalName)
  });

  showToast('保存成功');
  roomDbEditingName = null;
  roomDbRenderList();
}

function roomDbDeleteRoom(name){
  if(isLocked){alert('系统已锁定');return;}
  if(!roomDatabase[name]) return;
  
  const roomObj = rooms.find(r=>r.name===name);
  const occupied = roomObj && roomObj.student;

  if(occupied){
    if(!confirm(`琴房 ${name} 正在被 ${roomObj.student} 使用，删除将清除占用并记录日志。继续？`)) return;
    addPracticeLog(roomObj.student, roomObj.name, roomObj.registerTime, Date.now(),'房间删除');
  }else{
    if(!confirm(`确定删除琴房 ${name} ?`)) return;
  }

  // 🔥 强制清理：多重检查确保完全移除
  // 1. 从 rooms 数组中移除所有匹配的房间
  let removedCount = 0;
  for(let i = rooms.length - 1; i >= 0; i--) {
    if(rooms[i] && rooms[i].name === name) {
      rooms.splice(i, 1);
      removedCount++;
    }
  }
  
  // 2. 删除数据库记录
  delete roomDatabase[name];
  
  // 3. 立即持久化
  persistRoomDb();
  persistRooms();
  
  // 4. 🔥 新增：强制清理DOM中可能残留的卡片
  const roomCard = document.querySelector(`[data-room-name="${name}"]`);
  if(roomCard) {
    roomCard.remove();
    console.log(`🗑️ 强制清理DOM中的房间卡片: ${name}`);
  }
  
  // 5. 🔥 新增：验证清理结果
  const stillExists = rooms.find(r => r.name === name);
  if(stillExists) {
    console.error(`❌ 房间删除失败，仍存在: ${name}`, stillExists);
    // 再次尝试清理
    rooms = rooms.filter(r => !r || r.name !== name);
    persistRooms();
  }
  
  // 6. 同步到云端
  if (syncEnabled && isOnline && database) {
    const updates = {};
    updates[FIREBASE_PATHS.ROOM_DB] = roomDatabase;
    updates[FIREBASE_PATHS.ROOMS] = rooms.map(r => ({
      ...r,
      student: r.student || null,
      registerTime: r.registerTime || null
    }));
    
    database.ref().update(updates)
      .then(() => {
        console.log('✅ 房间删除已同步到云端');
      })
      .catch(error => {
        console.error('❌ 房间删除同步失败:', error);
      });
  }
  
  // 7. 清理相关引用
  if(currentRoom === name) {
    currentRoom = null;
  }
  
  // 8. 强制刷新UI
  needsFullUpdate = true;
  updateRooms();
  roomDbRenderList();
  
  logOperation('room_delete',{
    name, 
    occupied, 
    removedCount,
    finalRoomCount: rooms.length
  });
  
  showToast(`已删除琴房 ${name}${removedCount > 1 ? ` (清理了${removedCount}个重复项)` : ''}`);
}



/* ---------- 导出 ---------- */
function exportRoomDatabase(){
  if(!Object.keys(roomDatabase).length){
    alert('无房间可导出');return;
  }
  const choice = prompt('选择导出格式:\n1 CSV (默认)\n2 JSON','1') || '1';
  if(choice==='2'){
    roomDbExportJSON();
  }else{
    roomDbExportCSV();
  }
}

function roomDbExportCSV(){
  const lines = [];
  lines.push('名称,位置,类型,备注');
  Object.values(roomDatabase)
    .sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN'))
    .forEach(r=>{
      const esc = v=>{
        if(v==null) return '';
        const s=String(v);
        return /[",\n]/.test(s)?`"${s.replace(/"/g,'""')}"`:s;
      };
      lines.push([esc(r.name),esc(r.location||''),esc(r.pianoType),esc(r.remark||'')].join(','));
    });
  const csv = '\uFEFF'+lines.join('\n');
  const blob = new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='琴房库_'+new Date().toISOString().slice(0,10)+'.csv';
  a.click();
  showToast('房间 CSV 已导出');
  logOperation('room_export',{format:'csv',count:Object.keys(roomDatabase).length});
}

function roomDbExportJSON(){
  const payload = {
    version: 'room-db-v1',
    exportedAt: new Date().toISOString(),
    rooms: Object.values(roomDatabase)
  };
  const blob = new Blob([JSON.stringify(payload,null,2)],{type:'application/json;charset=utf-8;'});
  const a = document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='琴房库_'+new Date().toISOString().replace(/[:T]/g,'-').split('.')[0]+'.json';
  a.click();
  showToast('房间 JSON 已导出');
  logOperation('room_export',{format:'json',count:Object.keys(roomDatabase).length});
}

/* ---------- 导入 ---------- */
function importRoomDatabase(){
  if(isLocked){alert('系统已锁定');return;}
  const input=document.createElement('input');
  input.type='file';
  input.accept='.csv,.json';
  input.onchange=e=>{
    const file=e.target.files[0];
    if(!file) return;
    const isCSV = /\.csv$/i.test(file.name);
    const reader=new FileReader();
    reader.onload = ev=>{
      try{
        const text=ev.target.result;
        if(isCSV){
          roomDbHandleCSVImport(text);
        }else{
          roomDbHandleJSONImport(text);
        }
      }catch(err){
        console.error(err);
        alert('导入失败: '+err.message);
      }
    };
    reader.readAsText(file,'utf-8');
  };
  input.click();
}

function roomDbHandleJSONImport(text){
  let data = JSON.parse(text);
  if(data.version && Array.isArray(data.rooms)){
    data = data.rooms;
  }else if(!Array.isArray(data)){
    throw new Error('JSON 结构无 rooms 数组');
  }
  const warnings = [];
  const records = data.map(r=>{
    const normType = roomDbNormalizeType(r.pianoType || r.type || r.roomType, warnings);
    return {
      name: (r.name||'').trim(),
      location: (r.location||'').trim(),
      pianoType: normType,
      remark: (r.remark||'').trim()
    };
  }).filter(r=>r.name);
  roomDbProceedImport(records,'json',warnings);
}


function roomDbHandleCSVImport(csv){
  if(csv.charCodeAt(0)===0xFEFF) csv=csv.slice(1);
  csv = csv.replace(/\r/g,'');
  const lines = csv.split('\n').map(l=>l.trim()).filter(l=>l);
  if(!lines.length) throw new Error('空文件');
  const header = lines[0].split(/[,，]/).map(h=>h.trim().toLowerCase());
  const idx = {
    name: header.findIndex(h=>/^(名称|房间|name)$/.test(h)),
    location: header.findIndex(h=>/^(位置|loc|location)$/.test(h)),
    type: header.findIndex(h=>/^(类型|type|房型)$/.test(h)),
    remark: header.findIndex(h=>/^(备注|remark|note)$/.test(h))
  };
  if(idx.name===-1) throw new Error('缺少“名称”列');

  const warnings = [];
  const records=[];
  for(let i=1;i<lines.length;i++){
    const cols = parseCSVLine(lines[i], header.length);
    const name = (cols[idx.name]||'').trim();
    if(!name) continue;
    const location = idx.location>-1 ? (cols[idx.location]||'').trim() : '';
    const rawType  = idx.type>-1 ? (cols[idx.type]||'').trim() : '无钢琴';
    const normType = roomDbNormalizeType(rawType, warnings);
    const remark = idx.remark>-1 ? (cols[idx.remark]||'').trim() : '';
    records.push({
      name,
      location,
      pianoType: normType,
      remark
    });
  }
  roomDbProceedImport(records,'csv',warnings);
}


function parseCSVLine(line, expected){
  const out=[];
  let cur='',inQ=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i];
    if(ch === '"'){
      if(inQ && line[i+1] === '"'){cur+='"';i++;}
      else inQ = !inQ;
    }else if(ch === ',' && !inQ){
      out.push(cur);cur='';
    }else{
      cur+=ch;
    }
  }
  out.push(cur);
  while(out.length<expected) out.push('');
  return out;
}

function roomDbProceedImport(records, source, warnings=[]){
  if(!records.length){
    alert('无有效数据');return;
  }
  const strategy = prompt('选择导入策略:\n1 合并更新(默认)\n2 仅新增\n3 覆盖(更新已有+新增)\n4 全量重置','1') || '1';
  if(!/^[1-4]$/.test(strategy)){alert('取消');return;}

  const summary = {
    source,
    strategy,
    input: records.length,
    added:0,
    updated:0,
    skipped:0,
    reset:false,
    unknownTypes: warnings.length ? Array.from(new Set(warnings)) : []
  };

  if(strategy==='4'){
    rooms.forEach(r=>{
      if(r.student){
        addPracticeLog(r.student,r.name,r.registerTime,Date.now(),'房间全量重置');
      }
    });
    rooms=[];
    roomDatabase={};
    summary.reset=true;
  }

  records.forEach(rec=>{
    const exist = roomDatabase[rec.name];
    if(!exist){
      if(strategy==='2'){ // 仅新增
        roomDatabase[rec.name]=rec;
        summary.added++;
      }else{
        roomDatabase[rec.name]=rec;
        summary.added++;
      }
    }else{
      if(strategy==='2'){
        summary.skipped++;
      }else if(strategy==='1' || strategy==='3'){
        exist.location = rec.location;
        exist.pianoType = rec.pianoType;
        exist.remark = rec.remark;
        summary.updated++;
      }
    }
  });

  persistRoomDb();
  roomDbSyncRoomsFromDatabase();
  roomDbRenderList();
  logOperation('room_import',summary);

  const warnText = summary.unknownTypes.length
    ? `\n未识别类型(已按“无钢琴”处理): ${summary.unknownTypes.join(' / ')}`
    : '';
  alert(
    `导入完成:
来源: ${source}
策略: ${({'1':'合并更新','2':'仅新增','3':'覆盖','4':'全量重置'})[strategy]}
输入记录: ${summary.input}
新增: ${summary.added}
更新: ${summary.updated}
跳过: ${summary.skipped}
${summary.reset?'已执行全量重置':''}${warnText}`
  );
  showToast('房间导入完成');
}


/* ---------- 对外映射 ---------- */
function displayRoomDatabase(){
  roomDbRenderList();
}

window.displayRoomDatabase = displayRoomDatabase;
window.importRoomDatabase = importRoomDatabase;
window.exportRoomDatabase = exportRoomDatabase;
window.roomDbAddRoom = roomDbAddRoom;


/* =============== 启动 =============== */
document.addEventListener('click',e=>{
  // 点击模态外围关闭
  ['studentListModal','queueStudentModal','queueModal','availableRoomsModal','replaceableRoomsModal','timeSlotModal','settingsModal','attendanceModal','overtimeModal','studentDatabaseModal','roomDatabaseModal','majorSelectionModal']
    .forEach(id=>{
      const m=$(id);
      if(m && e.target===m) m.style.display='none';
    });
  // 🔥 修改：异常提醒面板点击外部关闭行为 - 只收起，不自动重新弹出
  const overrunPanel = $('overrunReminderPanel');
  if(overrunPanel && overrunPanel.style.display !== 'none' && !overrunPanel.classList.contains('collapsed')){
    // 检查点击是否在面板外部
    if(!overrunPanel.contains(e.target)){
      // 点击在面板外部，收起面板并标记为用户主动关闭
      overrunPanel.classList.add('collapsed');
      overrunPanel.dataset.userCollapsed = 'true';
      overrunPanel.dataset.manuallyDismissed = 'true'; // 🔥 新增：标记为手动关闭
      
      showToast('异常提醒面板已收起', 1500);
    }
  }
});

document.addEventListener('keydown',e=>{
  if(e.key==='Escape'){
    ['studentListModal','queueStudentModal','queueModal','availableRoomsModal','replaceableRoomsModal','timeSlotModal','settingsModal','attendanceModal','overtimeModal','studentDatabaseModal','roomDatabaseModal','majorSelectionModal']
      .forEach(id=>{const m=$(id);if(m) m.style.display='none';});
    currentRoom=null;currentQueueType=null;
  }
});
// 🔥 新增：智能同步触发器（只在真正需要时同步）
function triggerSmartSync(changeType, data = {}) {
    // 根据变化类型决定是否需要立即同步
    const immediateSync = [
        'room_assign',
        'room_clear', 
        'queue_add',
        'queue_remove',
        'student_assign',
        'force_replace'
    ];
    
    const delayedSync = [
        'room_update',
        'queue_update',
        'status_update'
    ];
    
    if (immediateSync.includes(changeType)) {
        // 立即同步，但仍使用防抖
        syncToFirebase(changeType, data);
    } else if (delayedSync.includes(changeType)) {
        // 延迟同步，给更多时间让多个变化合并
        clearTimeout(window.delayedSyncTimeout);
        window.delayedSyncTimeout = setTimeout(() => {
            syncToFirebase(changeType, data);
        }, 2000);
    }
}

// 🔥 新增：同步状态监控
function monitorSyncHealth() {
    setInterval(() => {
        if (!isOnline) return;
        
        const now = Date.now();
        const timeSinceLastSync = now - (lastSyncTime || 0);
        
        // 如果超过5分钟没有同步，可能有问题
        if (timeSinceLastSync > 5 * 60 * 1000) {
            console.warn('⚠️ 长时间未同步，检查连接状态...');
            
            // 尝试一次心跳检测
            database.ref('.info/connected').once('value')
                .then(snapshot => {
                    if (snapshot.val() === true) {
                        console.log('🔄 连接正常，执行健康检查同步...');
                        syncToFirebase('health_check', { 
                            lastSyncTime, 
                            timeSinceLastSync 
                        });
                    }
                })
                .catch(error => {
                    console.error('❌ 健康检查失败:', error);
                });
        }
    }, 60000); // 每分钟检查一次
}
// 统一格式：'08:00' => '8:00'
function BTM_normalizeTime(t){
  if(!t) return t;
  const [H,M] = t.split(':');
  return parseInt(H,10)+':'+M;
}

// 时间段字符串 -> 归一：'08:00-08:50' => '8:00-8:50'
function BTM_normRange(r){
  if(!r) return r;
  const [s,e]=r.split('-');
  return BTM_normalizeTime(s)+'-'+BTM_normalizeTime(e);
}

// 比较两个时间段是否“完全同一范围”（用分钟数）
function BTM_rangeEqual(a,b){
  if(!a||!b) return false;
  const toMin = r=>{
    const [s,e]=r.split('-');
    const sm = s.split(':').map(Number);
    const em = e.split(':').map(Number);
    return [sm[0]*60+sm[1], em[0]*60+em[1]];
  };
  const [as,ae]=toMin(a);
  const [bs,be]=toMin(b);
  return as===bs && ae===be;
}

/* ================= 批量时间管理系统整合（BTM Namespace） ================= */
(function(){
  if(window.BTM){return;} // 防重复注入

  const BTM = {
    /* ================== 现有属性（部分保留 / 扩展） ================== */
    timeSlots:[
      '8:00-8:50',
      '9:00-9:50',
      '9:40-10:00',
      '10:00-10:50',
      '11:00-11:50',
      '11:50-13:00',
      '13:00-13:50',
      '14:00-14:50',
      '14:50-15:10',
      '15:10-16:00',
      '16:10-17:00',
      '17:10-18:00'
    ],
    wednesdaySlots:[
      '8:00-8:50',
      '9:00-9:50',
      '9:40-10:00',
      '10:00-10:50',
      '11:00-11:50',
      ['11:50-12:50','午间音乐会'],
      ['13:30-14:20'],
      ['14:30-15:20'],
      '15:20-15:40',
      ['15:40-16:30'],
      ['16:40-17:30'],
      ['17:40-18:30']
    ],
    breakIdx:[2,8],
    lunchIdx:[5],
    students:[],           // 全量学生（按姓名排序）
    filteredStudents:[],   // 筛选后的子集
    selectionMap:{},       // { studentName:Set(keys) }
    currentIndex:-1,       // 在 filteredStudents 中的索引
    filters:{              // 当前筛选条件
      search:'',
      major:'',
      grade:''
    },
    majors:[],             // 去重后的专业
    grades:[],             // 去重后的年级（仅非空）
    dom:{
      modal: document.getElementById('bulkTimeManagerModal'),
      studentSelect: null,
      tbody: null,
      selectedList: null,
      stuInfo: null,
      searchInput: null,
      majorFilter: null,
      gradeFilter: null,
      resetBtn: null
    },

    /* ================== 初始化 / 打开关闭 ================== */
    initDom(){
      this.dom.studentSelect = document.getElementById('btmStudentSelect');
      this.dom.tbody = document.getElementById('btmTbody');
      this.dom.selectedList = document.getElementById('btmSelectedList');
      this.dom.stuInfo = document.getElementById('btmStudentInfo');
      this.dom.searchInput = document.getElementById('btmSearchInput');
      this.dom.majorFilter = document.getElementById('btmMajorFilter');
      this.dom.gradeFilter = document.getElementById('btmGradeFilter');
      this.dom.resetBtn = document.getElementById('btmFilterResetBtn');
    },
    open(){
      this.buildStudentsFromDB();
      this.buildSelectionsFromTimeSlots();
      this.initFiltersUI();          // 初始化筛选下拉
      this.applyFilters();           // 生成 filteredStudents
      this.renderTable();
      if(this.filteredStudents.length){
        this.currentIndex=0;
        this.dom.studentSelect.value='0';
        this.updateStudentInfo();
        this.refreshSelectedList();
        this.highlightStudentSelections();
      }else{
        this.currentIndex=-1;
        this.renderEmptyStudentSelect();
        this.dom.stuInfo.innerHTML='<span style="color:#999;">无匹配学生</span>';
        this.dom.selectedList.innerHTML='<div class="btm-filter-empty">筛选结果为空</div>';
      }
      this.dom.modal.style.display='block';
    },
    close(){
      this.dom.modal.style.display='none';
    },

    /* ================== 数据构建 ================== */
    buildStudentsFromDB(){
      this.students=[];
      Object.entries(studentDatabase).forEach(([major,arr])=>{
        arr.forEach(s=>{
          const name=typeof s==='string'?s:(s.name||'');
          if(!name) return;
            const grade=(typeof s==='object' && s.grade)? s.grade : '';
          this.students.push({name,major,grade});
        });
      });
      this.students.sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN'));
      // 统计专业 & 年级
      const majorSet=new Set(), gradeSet=new Set();
      this.students.forEach(s=>{
        if(s.major) majorSet.add(s.major);
        if(s.grade) gradeSet.add(s.grade);
      });
      this.majors=Array.from(majorSet).sort((a,b)=>a.localeCompare(b,'zh-Hans-CN'));
      this.grades=Array.from(gradeSet).sort((a,b)=>{
        // 尝试 G+数字 排序
        const gm=a.match(/^G(\d{1,2})$/i);
        const gn=b.match(/^G(\d{1,2})$/i);
        if(gm && gn){
          return parseInt(gm[1])-parseInt(gn[1]);
        }
        return a.localeCompare(b,'zh-Hans-CN');
      });
    },
    buildSelectionsFromTimeSlots(){
      this.selectionMap={};
      this.students.forEach(st=>{
        this.selectionMap[st.name]=new Set();
        const weekly=studentTimeSlots[st.name];
        if(!weekly) return;
        ['monday','tuesday','wednesday','thursday','friday'].forEach((dayKey,dayIndex)=>{
          const daySlots=weekly[dayKey]||[];
          daySlots.forEach(slot=>{
            const rawRange = slot.start + '-' + slot.end;
            const key = this.matchSlotToFixedKey(dayIndex, rawRange);
            if(key) this.selectionMap[st.name].add(key);
          });
        });
      });
    },

    /* ================== 筛选相关 ================== */
    initFiltersUI(){
      // 下拉填充
      const majorSel=this.dom.majorFilter;
      const gradeSel=this.dom.gradeFilter;
      if(majorSel){
        majorSel.innerHTML='<option value="">所有专业</option>'+this.majors.map(m=>`<option value="${m}">${m}</option>`).join('');
      }
      if(gradeSel){
        gradeSel.innerHTML='<option value="">所有年级</option><option value="_no_grade">未设置年级</option>'+
          this.grades.map(g=>`<option value="${g}">${g}</option>`).join('');
      }
      // 事件
      if(this.dom.searchInput){
        this.dom.searchInput.oninput=()=>{
          this.filters.search=this.dom.searchInput.value.trim();
          this.applyFilters();
        };
      }
      if(majorSel){
        majorSel.onchange=()=>{
          this.filters.major=majorSel.value;
          this.applyFilters();
        };
      }
      if(gradeSel){
        gradeSel.onchange=()=>{
          this.filters.grade=gradeSel.value;
          this.applyFilters();
        };
      }
    },
    resetFilters(){
      this.filters={search:'',major:'',grade:''};
      if(this.dom.searchInput) this.dom.searchInput.value='';
      if(this.dom.majorFilter) this.dom.majorFilter.value='';
      if(this.dom.gradeFilter) this.dom.gradeFilter.value='';
      this.applyFilters();
    },
    applyFilters(){
      const {search,major,grade}=this.filters;
      const keyword=search.toLowerCase();
      this.filteredStudents=this.students.filter(st=>{
        if(major && st.major!==major) return false;
        if(grade){
          if(grade==='_no_grade'){
            if(st.grade) return false;
          }else{
            if(st.grade!==grade) return false;
          }
        }
        if(keyword){
          // 支持中文模糊 + 首字母（利用已有 matchPinyin）
          if(!matchPinyin(st.name,keyword)) return false;
        }
        return true;
      });
      // 重新渲染学生下拉
      this.renderStudentSelect();
      // 保持或重置 currentIndex
      if(!this.filteredStudents.length){
        this.currentIndex=-1;
        this.renderEmptyStudentSelect();
        this.dom.stuInfo.innerHTML='<span style="color:#999;">无匹配学生</span>';
        this.dom.selectedList.innerHTML='<div class="btm-filter-empty">筛选结果为空</div>';
        this.clearTableSelectionHighlight();
        return;
      }
      if(this.currentIndex<0) this.currentIndex=0;
      if(this.currentIndex>=this.filteredStudents.length) this.currentIndex=this.filteredStudents.length-1;
      this.dom.studentSelect.value=this.currentIndex.toString();
      this.updateStudentInfo();
      this.refreshSelectedList();
      this.highlightStudentSelections();
    },

    /* ================== 渲染（学生 / 表 / 选中） ================== */
    renderEmptyStudentSelect(){
      if(!this.dom.studentSelect) return;
      this.dom.studentSelect.innerHTML='<option value="">(无)</option>';
    },
    renderStudentSelect(){
      const sel=this.dom.studentSelect;
      if(!sel) return;
      sel.innerHTML='';
      this.filteredStudents.forEach((st,i)=>{
        const opt=document.createElement('option');
        const g=st.grade?`[${st.grade}] `:'';
        opt.value=i;
        opt.textContent=`${g}${st.name} - ${st.major}`;
        sel.appendChild(opt);
      });
    },
    renderTable(){
      const tbody=this.dom.tbody;
      tbody.innerHTML='';
      for(let i=0;i<this.timeSlots.length;i++){
        const tr=document.createElement('tr');
        const timeTd=document.createElement('td');
        timeTd.className='btm-cell btm-time-col';
        timeTd.textContent=this.timeSlots[i];
        tr.appendChild(timeTd);
        for(let d=0;d<5;d++){
          const td=document.createElement('td');
          if(d===2){
            const w=this.wednesdaySlots[i];
            if(typeof w==='string'){
              if(this.isRestCell(i,d,true)){
                td.className='btm-cell-rest';
                td.textContent=this.isBreak(i)?'休息':'午餐';
              }else{
                td.className='btm-cell';
                td.dataset.key=`wed-${i}-0-2`;
                td.textContent=w;
                td.onclick=()=>this.toggleCell(td.dataset.key);
              }
            }else{
              const subWrap=document.createElement('div');
              subWrap.className='btm-wed-subwrap';
              w.forEach((subStr,idx)=>{
                const sub=document.createElement('div');
                let key=`wed-${i}-${idx}-2`;
                sub.dataset.key=key;
                if(this.isSubRest(i,idx)){
                  sub.className='btm-wed-sub rest';
                  sub.textContent=subStr==='11:50-12:50'||subStr==='11:50-13:00'?'午餐':subStr;
                }else{
                  sub.className='btm-wed-sub';
                  sub.textContent=subStr;
                  sub.onclick=()=>this.toggleCell(key,true);
                }
                subWrap.appendChild(sub);
              });
              td.appendChild(subWrap);
            }
          }else{
            if(this.isRestCell(i,d,false)){
              td.className='btm-cell-rest';
              td.textContent=this.isBreak(i)?'休息':'午餐';
            }else{
              td.className='btm-cell btm-cell-normal';
              td.dataset.key=`${i}-${d}`;
              td.textContent=this.timeSlots[i];
              td.onclick=()=>this.toggleCell(td.dataset.key);
            }
          }
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
    },
    clearTableSelectionHighlight(){
      const all=this.dom.tbody.querySelectorAll('.btm-cell-selected');
      all.forEach(c=>c.classList.remove('btm-cell-selected'));
      const subs=this.dom.tbody.querySelectorAll('.btm-wed-sub.selected');
      subs.forEach(s=>s.classList.remove('selected'));
    },
    highlightStudentSelections(){
      if(this.currentIndex<0){this.clearTableSelectionHighlight();return;}
      const st=this.filteredStudents[this.currentIndex];
      const set=this.selectionMap[st.name] || new Set();
      const cells=this.dom.tbody.querySelectorAll('.btm-cell');
      cells.forEach(c=>{
        const k=c.dataset.key;
        if(!k) return;
        c.classList.toggle('btm-cell-selected',set.has(k));
      });
      const subs=this.dom.tbody.querySelectorAll('.btm-wed-sub:not(.rest)');
      subs.forEach(s=>{
        const k=s.dataset.key;
        if(!k) return;
        s.classList.toggle('selected',set.has(k));
      });
    },
    refreshSelectedList(){
      if(this.currentIndex<0){
        this.dom.selectedList.innerHTML='<div class="btm-filter-empty">无学生</div>';
        return;
      }
      const st=this.filteredStudents[this.currentIndex];
      const set=this.selectionMap[st.name];
      if(!set || !set.size){
        this.dom.selectedList.innerHTML='<div style="color:#999;font-style:italic;">暂无选择</div>';
        return;
      }
      const groups={0:[],1:[],2:[],3:[],4:[]};
      set.forEach(k=>{
        if(k.startsWith('wed-')){
          const parts=k.split('-');
          const di=parseInt(parts[3]);
          groups[di].push(k);
        }else{
          const [ti,di]=k.split('-').map(Number);
          groups[di].push(k);
        }
      });
      let html='';
      Object.entries(groups).forEach(([d,arr])=>{
        if(!arr.length) return;
        arr.sort();
        html+=`<div style="margin-bottom:6px;"><b>${['周一','周二','周三','周四','周五'][d]}:</b><br>`;
        arr.forEach(k=>{
          if(k.startsWith('wed-')){
            const p=k.split('-');
            const ti=parseInt(p[1]);
            const si=parseInt(p[2]);
            const slot=this.wednesdaySlots[ti];
            const txt=Array.isArray(slot)?slot[si]:slot;
            html+=`<span class="btm-chip wed">${txt}</span>`;
          }else{
            const [ti]=k.split('-');
            html+=`<span class="btm-chip">${this.timeSlots[ti]}</span>`;
          }
        });
        html+='</div>';
      });
      this.dom.selectedList.innerHTML=html;
    },

    /* ================== 交互（选择 / 导航） ================== */
    selectStudent(){
      const idx=parseInt(this.dom.studentSelect.value);
      if(isNaN(idx)){this.currentIndex=-1;return;}
      this.currentIndex=idx;
      this.updateStudentInfo();
      this.highlightStudentSelections();
      this.refreshSelectedList();
    },
    prevStudent(){
      if(!this.filteredStudents.length) return;
      this.currentIndex = (this.currentIndex<=0?this.filteredStudents.length-1:this.currentIndex-1);
      this.dom.studentSelect.value=this.currentIndex;
      this.updateStudentInfo();
      this.highlightStudentSelections();
      this.refreshSelectedList();
    },
    nextStudent(){
      if(!this.filteredStudents.length) return;
      this.currentIndex = (this.currentIndex>=this.filteredStudents.length-1?0:this.currentIndex+1);
      this.dom.studentSelect.value=this.currentIndex;
      this.updateStudentInfo();
      this.highlightStudentSelections();
      this.refreshSelectedList();
    },
    updateStudentInfo(){
      if(this.currentIndex<0){
        this.dom.stuInfo.innerHTML='';
        return;
      }
      const st=this.filteredStudents[this.currentIndex];
      const g=st.grade||'未指定';
      this.dom.stuInfo.innerHTML=`<b>学生：</b>${st.name}　<b>专业：</b>${st.major}　<b>年级：</b>${g}`;
    },

    /* ================== 选择格子 / Key 对应 ================== */
    toggleCell(key){
      if(this.currentIndex<0) return;
      const st=this.filteredStudents[this.currentIndex];
      const set=this.selectionMap[st.name];
      if(set.has(key)) set.delete(key); else set.add(key);
      this.highlightStudentSelections();
      this.refreshSelectedList();
    },
    matchSlotToFixedKey(dayIndex,timeRange){
        // 归一化来规避前导 0
        const normInput = BTM_normRange(timeRange); // 例如 '08:00-08:50' -> '8:00-8:50'

        if(dayIndex===2){ // 周三
            for(let t=0;t<this.wednesdaySlots.length;t++){
                const w=this.wednesdaySlots[t];
                if(Array.isArray(w)){
                    for(let s=0;s<w.length;s++){
                        const wItem=w[s];
                        // 只处理形如 HH:MM-HH:MM 的子段
                        if(/^\d{1,2}:\d{2}-\d{1,2}:\d{2}$/.test(wItem)){
                            if(BTM_rangeEqual(BTM_normRange(wItem), normInput)){
                                return `wed-${t}-${s}-2`;
                            }
                        }
                    }
                }else{
                    if(/^\d{1,2}:\d{2}-\d{1,2}:\d{2}$/.test(w)){
                        if(BTM_rangeEqual(BTM_normRange(w), normInput)){
                            return `wed-${t}-0-2`;
                        }
                    }
                }
            }
            return null;
        }else{
            // 普通工作日
            for(let i=0;i<this.timeSlots.length;i++){
                const fixed = this.timeSlots[i];      // 如 '8:00-8:50'
                if(BTM_rangeEqual(BTM_normRange(fixed), normInput)){
                    return `${i}-${dayIndex}`;
                }
            }
            return null;
        }
    },

    isBreak(i){return this.breakIdx.includes(i);},
    isLunch(i){return this.lunchIdx.includes(i);},
    isRestCell(i,day,isWed){
      if(isWed){
        if(i===2||i===8) return true;
        if(i===5) return true;
      }else{
        if(this.breakIdx.includes(i)) return true;
        if(this.lunchIdx.includes(i)) return true;
      }
      return false;
    },
    isSubRest(i,subIdx){
      if(i===2||i===8) return true;
      if(i===5) return true;
      return false;
    },

    /* ================== 清空 / 保存 ================== */
    clearAllSelections(){
      if(!confirm('确定清空所有学生当前的批量选择？(仅本界面缓存)')) return;
      Object.values(this.selectionMap).forEach(set=>set.clear());
      this.highlightStudentSelections();
      this.refreshSelectedList();
      showToast('已清空全部选择');
    },
    applyAndSave(){
      let changedStudents=0;
      this.students.forEach(st=>{
        const set=this.selectionMap[st.name];
        if(!set) return;
        const before=JSON.stringify(studentTimeSlots[st.name]||{});
        const original=studentTimeSlots[st.name]||{monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]};
        const fixedSet=new Set();
        const newStruct={monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]};
        set.forEach(k=>{
          if(k.startsWith('wed-')){
            const p=k.split('-');
            const ti=parseInt(p[1]);
            const si=parseInt(p[2]);
            const slot=this.wednesdaySlots[ti];
            let timeStr=Array.isArray(slot)?slot[si]:slot;
            if(timeStr){
              const [s,e]=timeStr.split('-');
              // 标准化时间格式
              const normalizedStart = normalizeTimeFormat(s);
              const normalizedEnd = normalizeTimeFormat(e);
              newStruct.wednesday.push({start:normalizedStart,end:normalizedEnd,duration:calcDurationText(normalizedStart,normalizedEnd)});
              fixedSet.add('wednesday_'+normalizedStart+'-'+normalizedEnd);
            }
          }else{
            const [ti,di]=k.split('-').map(Number);
            const ts=this.timeSlots[ti];
            const [s,e]=ts.split('-');
            // 标准化时间格式
            const normalizedStart = normalizeTimeFormat(s);
            const normalizedEnd = normalizeTimeFormat(e);
            const dayKey=['monday','tuesday','wednesday','thursday','friday'][di];
            newStruct[dayKey].push({start:normalizedStart,end:normalizedEnd,duration:calcDurationText(normalizedStart,normalizedEnd)});
            fixedSet.add(dayKey+'_'+normalizedStart+'-'+normalizedEnd);
          }
        });
        Object.keys(newStruct).forEach(day=>{
          newStruct[day].sort((a,b)=>a.start.localeCompare(b.start));
          const uniq=[];
          newStruct[day].forEach(sl=>{
            if(!uniq.some(u=>u.start===sl.start && u.end===sl.end)) uniq.push(sl);
          });
          newStruct[day]=uniq;
        });
        const keeper={monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]};
        Object.entries(original).forEach(([day,arr])=>{
          arr.forEach(sl=>{
            // 标准化时间格式进行比较
            const normalizedStart = normalizeTimeFormat(sl.start);
            const normalizedEnd = normalizeTimeFormat(sl.end);
            const key=day+'_'+normalizedStart+'-'+normalizedEnd;
            if(!fixedSet.has(key) && !this.isFixedSlot(day,normalizedStart+'-'+normalizedEnd)){
              // 保存时也使用标准化格式
              keeper[day].push({
                start: normalizedStart,
                end: normalizedEnd,
                duration: sl.duration || calcDurationText(normalizedStart, normalizedEnd)
              });
            }
          });
        });
        const merged={monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]};
        Object.keys(merged).forEach(day=>{
          merged[day]=[...newStruct[day],...keeper[day]];
          merged[day].sort((a,b)=>a.start.localeCompare(b.start));
        });
        studentTimeSlots[st.name]=merged;
        const after=JSON.stringify(studentTimeSlots[st.name]);
        if(after!==before) changedStudents++;
      });
      persistStudentSlots();
      if($('studentDatabaseModal').style.display==='block'){
        renderStudentDatabaseList();
      }
      if(syncEnabled && isOnline && database){
        try{database.ref(FIREBASE_PATHS.STUDENT_SLOTS).set(studentTimeSlots);}catch(e){}
      }
      showToast(`已保存 ${changedStudents} 名学生的节次`);
    },
    isFixedSlot(day,timeRange){
      // 标准化输入的时间格式
      const normalizedTimeRange = timeRange.split('-').map(t => normalizeTimeFormat(t)).join('-');
      
      if(day==='wednesday'){
        for(let i=0;i<this.wednesdaySlots.length;i++){
          const w=this.wednesdaySlots[i];
          if(Array.isArray(w)){
            // 标准化数组中的时间格式进行比较
            const normalizedW = w.map(t => t.split('-').map(tt => normalizeTimeFormat(tt)).join('-'));
            if(normalizedW.includes(normalizedTimeRange)) return true;
          }else{
            // 标准化单个时间格式进行比较
            const normalizedW = w.split('-').map(t => normalizeTimeFormat(t)).join('-');
            if(normalizedW === normalizedTimeRange) return true;
          }
        }
        return false;
      }
      // 标准化timeSlots中的时间格式进行比较
      const normalizedTimeSlots = this.timeSlots.map(t => t.split('-').map(tt => normalizeTimeFormat(tt)).join('-'));
      return normalizedTimeSlots.includes(normalizedTimeRange);
    }
  };


  window.BTM=BTM;

  window.openBulkTimeManager=function(){
    BTM.initDom();
    BTM.open();
  };
  window.closeBulkTimeManager=function(){
    BTM.close();
  };

})();

window.addEventListener('load',init);
</script>
</body>
</html>

