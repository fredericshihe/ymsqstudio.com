<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>学生练琴 - 收纳视图</title>
  <!-- 已移除 Google Fonts，使用系统字体以避免外部 400 报错 -->
  <style>
    :root{
      --bg-gradient-start:#f5f7fa;
      --bg-gradient-end:#c3cfe2;
      --surface:#ffffff;
      --surface-muted:#f6f8fa;
      --border:#e5e7eb;
      --border-strong:#d0d7de;
      --text:#1f2937;
      --text-muted:#6b7280;
      --primary:#6366f1;
      --primary-600:#5458ee;
      --primary-700:#4f46e5;
      --success:#22c55e;
      --warning:#f59e0b;
      --info:#0ea5e9;
      --shadow:0 8px 24px rgba(31,41,55,.08);
      --shadow-strong:0 12px 32px rgba(31,41,55,.12);
      --radius-lg:16px;
      --radius-md:12px;
      --radius-sm:8px;
      --card-pad:24px;
      --gap-md:16px;
    }
    /*
     * ==============================
     *  样式区（CSS）— 概览
     *  1) 全局与布局
     *  2) 首页概览（卡片/圆环/标签）
     *  3) 列表视图
     *  4) 学生详情视图（信息/状态/时间轴/历史7天）
     *  注：仅添加结构化注释，不改现有样式含义
     * ==============================
     */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      /* 系统 / 本地字体栈：避免外部字体请求失败 */
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Helvetica, "Segoe UI", Arial, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "WenQuanYi Micro Hei", Roboto, sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      color: #1d1d1f;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    /* 修正：删除 iOS 边缘滑动相关代码（CSS 部分已去除） */
    /* 原功能说明：屏幕左缘右滑返回上一视图；已按用户要求完全移除。 */

    /* 布局容器 */
    .container {
      width: 100%;
      max-width: 960px;
      padding: 24px 16px 32px;
      margin: 0 auto;
    }
    /* 首页居中展示 */
    #homeView { 
      min-height: 100vh;
      padding: 24px 16px;
      overflow-y: auto;
    }

    /* 页面标题 */
    .page-header {
      text-align: center;
      margin-bottom: 40px;
    }

    .page-title {
      font-size: 28px;
      font-weight: 700;
      color: #24292f;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }

    .page-subtitle {
      font-size: 16px;
      color: #656d76;
      font-weight: 500;
    }

    /* 搜索区域 */
    .search-section {
      margin-bottom: 32px;
      display: flex;
      justify-content: center;
    }

    .search-container {
      position: relative;
      width: 100%;
      max-width: 400px;
    }

    .search-input {
      width: 100%;
      padding: 12px 16px 12px 44px;
      border: 2px solid #e1e4e8;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 500;
      background: #ffffff;
      transition: all 0.2s ease;
      box-sizing: border-box;
    }

    .search-input:focus {
      outline: none;
      border-color: #0969da;
      box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.1);
    }

    .search-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      color: #656d76;
      font-size: 16px;
    }

    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #ffffff;
      border: 2px solid #e1e4e8;
      border-top: none;
      border-radius: 0 0 12px 12px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }

    .search-result-item {
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid #f6f8fa;
      transition: background-color 0.2s ease;
    }

    .search-result-item:hover {
      background-color: #f6f8fa;
    }

    .search-result-item:last-child {
      border-bottom: none;
    }

    .search-no-results {
      padding: 12px 16px;
      color: #656d76;
      text-align: center;
      font-style: italic;
    }

    /* 概览卡片容器调整 */
    .overview-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 32px;
    }

    /* 主卡片容器 */
    .overview-card {
      background: #ffffff;
      border-radius: 24px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      padding: 32px;
      width: 100%;
      max-width: 400px;
      text-align: center;
    }

    /* 排行榜卡片 */
    .ranking-card {
      background: #ffffff;
      border-radius: 24px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
  padding: 24px 20px;
      width: 100%;
      max-width: 400px;
      margin-top: 24px;
    }

    /* 排行榜列表 */
  .ranking-list { margin: 0 4px 24px 4px; }

    .ranking-item {
      display: flex;
      align-items: center;
      padding: 16px 0;
      border-bottom: 1px solid #f6f8fa;
      transition: background-color 0.2s ease;
      position: relative;
      z-index: 0; /* 创建堆叠上下文，便于 ::before 放到内容下方 */
    }

    .ranking-item:last-child {
      border-bottom: none;
    }

  /* 稳定的 hover 高亮：不改变 padding/尺寸，使用内部伪元素过渡 */
  .ranking-item { cursor: pointer; }
  .ranking-item::before {
    content: "";
    position: absolute;
    left: -8px; right: -8px; top: 4px; bottom: 4px;
    border-radius: 12px;
    background: transparent;
    transition: background .18s ease, box-shadow .18s ease;
    pointer-events: none;
    z-index: -1; /* 置于文字下方，避免遮挡 */
  }
  .ranking-item:hover { background: transparent; }
  .ranking-item:hover::before { background: var(--surface-0); box-shadow: var(--shadow-1); }

    .ranking-position {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      margin-right: 16px;
      flex-shrink: 0;
    }

    .ranking-position.rank-1 {
      background: linear-gradient(45deg, #ffd700, #ffa500);
      color: #ffffff;
      box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
    }

    .ranking-position.rank-2 {
      background: linear-gradient(45deg, #c0c0c0, #a8a8a8);
      color: #ffffff;
      box-shadow: 0 2px 8px rgba(192, 192, 192, 0.3);
    }

    .ranking-position.rank-3 {
      background: linear-gradient(135deg, #cd7f32, #b8860b);
      color: #ffffff;
      box-shadow: 0 2px 8px rgba(205, 127, 50, 0.3);
    }

    .ranking-student-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-right: 16px;
    }

    .ranking-student-name {
      font-size: 16px;
      font-weight: 600;
      color: #24292f;
      margin-bottom: 4px;
    }

    .ranking-student-meta {
      font-size: 12px;
      color: #656d76;
    }

    .ranking-score {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .ranking-score-value {
      font-size: 18px;
      font-weight: 700;
      color: #0969da;
      margin-bottom: 2px;
    }

    .ranking-score-label {
      font-size: 12px;
      color: #656d76;
    }

    /* ===== 排行榜骨架屏 (首屏加速感知) ===== */
    .ranking-item--skeleton { pointer-events: none; }
    .ranking-item--skeleton .sk-bar { 
      background: linear-gradient(90deg,#f1f5f9 25%,#e2e8f0 37%,#f1f5f9 63%);
      background-size: 400% 100%;
      height: 14px;
      border-radius: 4px;
      animation: skShine 1.3s ease infinite;
    }
    .ranking-item--skeleton .ranking-position { background:#e2e8f0; color:transparent; }
    .ranking-item--skeleton .ranking-student-name,
    .ranking-item--skeleton .ranking-student-meta,
    .ranking-item--skeleton .ranking-score-value,
    .ranking-item--skeleton .ranking-score-label { color:transparent; }
    @keyframes skShine { 0%{background-position:100% 0;} 100%{background-position:0 0;} }

/* 平滑淡入动画 */
#rankingFullList { position: relative; }
.ranking-fade-in { animation: rankingFade .28s ease; }
@keyframes rankingFade { from { opacity:0; transform:translateY(4px); } to { opacity:1; transform:translateY(0); } }

/* 管理员模式样式 */
.admin-score-btn {
  animation: adminPulse 2s infinite;
}
@keyframes adminPulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.3); }
}
.admin-score-btn:hover {
  animation: none !important;
  background: rgba(239, 68, 68, 1) !important;
  transform: scale(1.1);
}
.admin-adjustment {
  animation: adminGlow 3s ease-in-out infinite;
}
@keyframes adminGlow {
  0%, 100% { opacity: 0.9; }
  50% { opacity: 1; box-shadow: 0 0 8px rgba(16, 185, 129, 0.3); }
}    /* 排行榜详情按钮 */
    .ranking-details-btn {
      width: 100%;
      padding: 16px 24px;
      background: linear-gradient(135deg, #f6f8fa 0%, #ffffff 100%);
      border: 2px solid #e1e4e8;
      border-radius: 16px;
      font-size: 16px;
      font-weight: 600;
      color: #24292f;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .ranking-details-btn:hover {
      background: linear-gradient(135deg, #e1e4e8 0%, #f6f8fa 100%);
      border-color: #d0d7de;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .ranking-details-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .card-subtitle {
      font-size: 14px;
      color: #656d76;
      font-weight: 500;
    }

    /* 头部标题区域 */
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 32px;
    }

    .card-title {
      font-size: 24px;
      font-weight: 700;
      color: #24292f;
      letter-spacing: -0.02em;
    }

    .card-date {
      font-size: 16px;
      font-weight: 500;
      color: #656d76;
      cursor: default;
    }

    /* 分类标签区域 */
    .category-tabs {
      display: flex;
      background: #f6f8fa;
      border-radius: 16px;
      padding: 4px;
      margin-bottom: 32px;
      gap: 2px;
    }

    .category-tab {
      flex: 1;
      padding: 8px 12px;
      border: none;
      background: transparent;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 500;
      color: #656d76;
      cursor: pointer;
      transition: all 200ms ease;
      text-align: center;
    }

    .category-tab.active {
      background: #8b5cf6;
      color: #ffffff;
      box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
    }

    .category-tab:hover:not(.active) {
      background: #e5e7eb;
      color: #374151;
    }

    /* 圆形进度图 */
    .progress-circle {
      position: relative;
      width: 160px;
      height: 160px;
      margin: 0 auto 24px;
    }

    .progress-circle svg {
      width: 100%;
      height: 100%;
      transform: rotate(-90deg);
    }

    .progress-bg {
      fill: none;
      stroke: #f1f3f4;
      stroke-width: 12;
      stroke-linecap: round;
    }

    .progress-fill {
      fill: none;
      /* stroke color will be set dynamically by JavaScript */
      stroke-width: 12;
      stroke-linecap: round;
      stroke-dasharray: 439.82;
      stroke-dashoffset: 439.82;
      transition: stroke-dashoffset 800ms cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* 中心显示区域 */
    .progress-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    .progress-percentage {
      font-size: 32px;
      font-weight: 800;
      color: #24292f;
      line-height: 1;
      letter-spacing: -0.02em;
      display: inline;
    }

    .progress-percentage-symbol {
      font-size: 18px;
      color: #656d76;
      font-weight: 600;
      margin-left: 2px;
      display: inline;
    }

    /* 进度条下方信息 */
    .progress-info {
      text-align: center;
      margin-bottom: 32px;
    }

    .progress-count {
      font-size: 24px;
      font-weight: 700;
      color: #24292f;
      margin-bottom: 4px;
    }

    .progress-count-unit {
      font-size: 16px;
      color: #656d76;
      margin-left: 4px;
    }

    .progress-description {
      font-size: 14px;
      color: #656d76;
      font-weight: 500;
    }

    /* 查看详情按钮 */
    .view-details-btn {
      width: 100%;
      padding: 16px 24px;
      background: #8b5cf6;
      color: #ffffff;
      border: none;
      border-radius: 16px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 200ms ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .view-details-btn:hover {
      background: #7c3aed;
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(139, 92, 246, 0.3);
    }

    .view-details-btn:active {
      transform: translateY(0);
    }

    /* 列表视图 */
    .list-view {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      z-index: 100;
      transform: scale(0);
      opacity: 0;
      transform-origin: center center;
      transition: all 400ms cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
  will-change: transform, opacity;
    }
    .list-view.expanding {
      transform: scale(1);
      opacity: 1;
    }
    .list-view[hidden] { 
      display: none !important; 
    }

    .list-header { 
      display: flex; 
      align-items: center; 
      gap: 12px; 
      margin-bottom: 16px; 
      padding: 24px 16px 0;
      position: sticky;
      top: 0;
      /* 与主背景统一，无底边线 */
      background: var(--bg);
      border-bottom: none;
      box-shadow: none;
      z-index: 10;
    }
    .back-btn {
      appearance: none; border: none; 
      background: #ffffff; 
      border-radius: 8px; padding: 8px 16px; cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
      border: 1px solid #d0d7de; 
      font-weight: 600; color: #24292f;
      transition: all 150ms ease;
    }
    .back-btn:hover { 
      background: #f6f8fa;
      border-color: #8c959f;
    }
    .list-title { 
      font-size: 20px; 
      font-weight: 600; 
      color: #24292f; 
      letter-spacing: -0.01em; 
    }

    /* 排行榜切换标签页 */
    .ranking-header-tabs {
      display: flex;
      gap: 4px;
      margin-left: auto;
    }
    .ranking-tab {
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--surface-0);
      color: var(--text-2);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .ranking-tab:hover {
      background: var(--surface-1);
      border-color: var(--border-hover);
    }
    .ranking-tab.active {
      background: var(--brand-600);
      color: var(--text-on-accent);
      border-color: var(--brand-600);
    }
    .ranking-tab.active:hover {
      background: var(--brand-700);
      border-color: var(--brand-700);
    }

    /* 排行榜标题样式 */
    .ranking-title {
      text-align: center;
      margin-bottom: 24px;
    }
    .ranking-title h2 {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-1);
      margin: 0 0 4px 0;
      letter-spacing: -0.02em;
    }
    .ranking-subtitle {
      font-size: 14px;
      color: var(--text-2);
      margin: 0;
      font-weight: 500;
    }

    .student-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
      gap: 12px;
      width: 100%;
      max-width: 960px;
      margin: 0 auto;
      padding: 0 16px 32px;
    }
    .stu-card {
      border-radius: 12px;
      background: #ffffff;
      border: 1px solid #d0d7de;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
      padding: 16px;
      display: flex; flex-direction: column; gap: 8px;
      transition: transform 150ms ease, box-shadow 150ms ease;
      opacity: 0;
      transform: translateY(20px);
      animation: slideInUp 300ms ease forwards;
      will-change: transform; /* 优化动画性能 */
    }
    /* 移动端：去除逐项延迟，提升点击响应速度 */
    @media (max-width: 640px) {
      .stu-card { 
        animation-delay: 0ms !important; 
        animation-duration: 150ms !important; 
        touch-action: manipulation; 
      }
      .list-view { transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1); }
    }
    .stu-card:hover { 
      transform: translateY(-1px); 
      box-shadow: 0 3px 12px rgba(0,0,0,0.1);
      border-color: #8c959f;
    }

    /* 性能优化：减少重绘 */
    .stu-card, .ranking-item, .ranking-row, .info-card, .status-card {
      contain: layout;
    }
    
    @keyframes slideInUp {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .stu-line1 { display: flex; align-items: center; gap: 8px; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; }
    .status-dot.active { background: #22c55e; }
    .status-dot.offline { background: #9ca3af; }
    .status-dot.attendance { background: #22c55e; } /* 出勤 - 绿色 */
    .status-dot.absent { background: #ef4444; } /* 缺勤 - 红色 */
    .status-dot.self-practice { background: #f59e0b; } /* 自主练琴 - 橙色 */
    .status-dot.not-practice { background: #3b82f6; } /* 未练琴 - 蓝色 */
    .stu-name { 
      font-weight: 600; 
      color: #24292f; 
      font-size: 15px; 
      letter-spacing: -0.005em; 
    }
    .stu-meta { 
      color: #656d76; 
      font-size: 13px; 
      font-weight: 500; 
    }
    .stu-mins { 
      margin-top: 2px; 
      font-weight: 700; 
      color: #24292f; 
      font-size: 18px; 
      letter-spacing: -0.01em; 
    }
    .stu-detail {
      color: #656d76;
      font-size: 11px;
      font-weight: 500;
      margin-top: 1px;
    }

    /* 详情页面样式 */
    .detail-view {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
      z-index: 200;
      transform: translateX(100%);
      transition: transform 400ms cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .detail-view.active {
      transform: translateX(0);
    }
    
    .detail-view[hidden] { 
      display: none !important; 
    }

    .detail-container {
      flex: 1;
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
    }

    .detail-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 24px 16px 16px;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .detail-title {
      font-size: 20px;
      font-weight: 600;
      color: #24292f;
      letter-spacing: -0.01em;
    }

  .detail-content { padding: 12px 16px 32px; display: flex; flex-direction: column; gap: var(--gap-md); }
  @media (max-width: 560px){ .detail-content { padding-top: 16px; } }

    /* 个人信息卡片 */
    .info-card, .status-card, .timeline-card, .history-card {
      background: var(--surface);
      border-radius: var(--radius-lg);
      padding: var(--card-pad);
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
      transition: box-shadow .2s ease, transform .15s ease, border-color .2s ease;
    }
    .info-card:hover, .status-card:hover, .timeline-card:hover, .history-card:hover {
      box-shadow: var(--shadow-strong);
      transform: translateY(-1px);
      border-color: var(--border-strong);
    }

  .student-info h2 { font-size: 28px; font-weight: 700; color: var(--text); margin: 0 0 4px 0; letter-spacing: -0.02em; }

  .student-meta { display: flex; align-items: center; gap: 8px; font-size: 16px; color: var(--text-muted); font-weight: 500; }

    .separator {
      color: #d0d7de;
    }

    /* 学生详情头部右侧：今日排行榜分徽章 */
    .info-head { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .today-score {
      display: inline-flex; align-items: center; gap: 10px;
      padding: 10px 12px;
      background: linear-gradient(135deg, var(--brand-600), var(--brand-700));
      color: var(--text-on-accent);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.28);
      box-shadow: 0 6px 18px rgba(2,6,23,0.18);
      white-space: nowrap;
    }
    .today-score-label { font-size: 12px; font-weight: 700; opacity: .92; letter-spacing: .02em; }
    .today-score-value { font-size: 22px; font-weight: 800; letter-spacing: -.02em; line-height: 1; }
    @media (prefers-color-scheme: light){
      .today-score { border-color: rgba(255,255,255,0.35); }
    }
    @media (max-width: 480px){
      .info-head { flex-direction: column; align-items: flex-start; gap: 10px; }
      .today-score { align-self: stretch; justify-content: space-between; width: 100%; }
    }

    /* 状态卡片 */
    .status-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }

  .status-card h3, .timeline-card h3, .history-card h3 { font-size: 18px; font-weight: 600; color: var(--text); margin: 0 0 16px 0; letter-spacing: -0.01em; }

  .status-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: var(--gap-md); }

  .status-item { position: relative; text-align: center; padding: 16px 12px; background: var(--surface-muted); border-radius: var(--radius-md); border: 1px solid var(--border); transition: background .2s ease, border-color .2s ease, transform .15s ease; }
  .status-item:hover { background: #eef2ff; border-color: #c7d2fe; transform: translateY(-1px); }

  .status-label { display: block; font-size: 12px; color: var(--text-muted); font-weight: 600; margin-bottom: 6px; letter-spacing: .02em; text-transform: uppercase; }

  .status-value { display: block; font-size: 20px; font-weight: 700; color: var(--text); letter-spacing: -0.01em; }

  .status-help-btn { 
    position: absolute; 
    top: 8px; 
    right: 8px; 
    width: 18px; 
    height: 18px; 
    border: none; 
    background: var(--primary); 
    color: white; 
    border-radius: 50%; 
    font-size: 11px; 
    font-weight: 600; 
    cursor: pointer; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    transition: all 0.2s ease; 
    opacity: 0.7; 
  }
  
  .status-help-btn:hover { 
    opacity: 1; 
    transform: scale(1.1); 
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3); 
  }

    /* 时间轴卡片 */
    .timeline-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }

  /* 时间轴标题行：左标题 + 右侧操作按钮 */
  .timeline-head { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 12px; }
  .timeline-actions { display: inline-flex; align-items: center; gap: 8px; }
  .timeline-head h3 { margin: 0; }

    .timeline-card h3 {
      font-size: 18px;
      font-weight: 600;
      color: #24292f;
      margin: 0 0 16px 0;
      letter-spacing: -0.01em;
    }

    .timeline-container {
      position: relative;
    }

  .timeline-item { display: flex; align-items: center; gap: 12px; padding: 12px 10px 12px 16px; border-left: 3px solid var(--border); margin-left: 8px; position: relative; border-radius: var(--radius-sm); }
  .timeline-item:hover { background: #f9fafb; }

  .timeline-item::before { content: ''; position: absolute; left: -6px; top: 18px; width: 8px; height: 8px; border-radius: 50%; background: var(--primary); box-shadow: 0 0 0 3px rgba(99,102,241,.15); }

  .timeline-item.in-schedule::before { background: var(--success); box-shadow: 0 0 0 3px rgba(34,197,94,.15); }
  .timeline-item.out-schedule::before { background: var(--warning); box-shadow: 0 0 0 3px rgba(245,158,11,.15); }

  .timeline-time { font-size: 14px; font-weight: 700; color: var(--text); min-width: 120px; letter-spacing: -0.01em; }

  .ongoing-indicator {
    color: #666;
    font-weight: 500;
  }

  .timeline-duration { font-size: 14px; color: var(--text-muted); font-weight: 600; }
  
  .live-duration {
    color: var(--text-muted);
    font-weight: 600;
  }
  
  .live-indicator {
    margin-left: 2px;
    font-size: 12px;
  }

  .timeline-room { font-size: 12px; color: var(--primary); background: #eef2ff; padding: 2px 8px; border-radius: 6px; font-weight: 600; border: 1px solid #c7d2fe; }

    .timeline-empty {
      text-align: center;
      padding: 32px;
      color: #656d76;
      font-size: 16px;
    }

    /* 历史总结卡片 */
  /* .history-card inherits card styles */

    .history-card h3 {
      font-size: 18px;
      font-weight: 600;
      color: #24292f;
      margin: 0 0 16px 0;
      letter-spacing: -0.01em;
    }

    /* 周练琴图表 */
    .week-chart {
      padding-top: 20px;
    }

  .chart-container { display: flex; align-items: end; gap: 10px; height: 130px; padding: 0 8px; }

    .chart-bar {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
  cursor: pointer;
    }

    .bar-container {
      width: 100%;
      height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: end;
      align-items: center;
      position: relative;
    }

  .bar-fill { width: 18px; background: linear-gradient(to top, var(--primary-700) 0%, var(--primary) 100%); border-radius: 5px 5px 0 0; transition: height 500ms ease; min-height: 2px; }

  .bar-label { font-size: 12px; color: var(--text-muted); font-weight: 600; letter-spacing: .02em; }

  .bar-value { font-size: 10px; color: var(--text); font-weight: 700; position: absolute; top: -16px; white-space: nowrap; }

    /* 交互与提示 */
    .chart-bar:hover .bar-fill { filter: brightness(1.06); }
    .bar-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translate(-50%, -6px);
      background: #111827;
      color: #fff;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 10px;
      line-height: 1.4;
      white-space: nowrap;
      box-shadow: 0 8px 24px rgba(140,149,159,0.2);
      opacity: 0;
      pointer-events: none;
      transition: opacity 150ms ease, transform 150ms ease;
    }
    .chart-bar.show-tooltip .bar-tooltip {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -10px);
    }

    /* 完整排行榜样式 - 简洁专业 */
  .ranking-root { max-width: 1200px; margin: 0 auto; padding: 0 24px; }
  @media (max-width: 640px){ .ranking-root { padding: 0 16px; } }
    .ranking-hero {
      background: linear-gradient(135deg, #f8fafc, #ffffff);
      color: #1e293b;
      border-radius: 20px;
      border: 1px solid #e2e8f0;
      padding: 24px 20px 18px;
      margin: 16px 0 20px;
      box-shadow: 0 1px 3px rgba(15,23,42,0.04), 0 1px 2px rgba(15,23,42,0.06);
    }
    .ranking-hero-sub { opacity: .85; margin-top: 6px; font-weight: 500; color: #64748b; font-size: 14px; }

  .top3-wrap { display: grid; grid-template-columns: repeat(3, 1fr); gap: 18px; margin-top: 20px; align-items: end; }
  .top3-card { position: relative; background: #ffffff; color: #1e293b; border-radius: 16px; padding: 20px 18px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(15,23,42,0.06); text-align: center; transition: transform .2s ease, box-shadow .25s ease; cursor: pointer; }
    .top3-card.first-place { transform: translateY(-16px); box-shadow: 0 4px 12px rgba(15,23,42,0.08); }
    .top3-card.second-place { transform: translateY(6px); }
    .top3-card.third-place { transform: translateY(6px); }
    .top3-card:hover { box-shadow: 0 6px 20px rgba(15,23,42,0.12); }
  .top3-name { font-weight: 600; font-size: 16px; margin-top: 8px; letter-spacing: -0.01em; color: #1e293b; }
  .top3-points { font-size: 13px; color: #64748b; font-weight: 600; margin-top: 8px; }
  .rank-badge { position: absolute; top: -12px; right: -10px; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #ffffff; border: 3px solid #ffffff; box-shadow: 0 2px 8px rgba(15,23,42,0.12); }
  .rank-1 { background: linear-gradient(135deg,#f59e0b,#d97706); }
  .rank-2 { background: linear-gradient(135deg,#6b7280,#4b5563); }
  /* unify rank-3 color with list badge (bronze) */
  .rank-3 { background: linear-gradient(135deg,#cd7f32,#b8860b); }

  .ranking-section { padding: 12px 0 32px; }
  .ranking-rows { display: flex; flex-direction: column; gap: 12px; }
  .ranking-row { display: grid; grid-template-columns: 52px 1fr 130px; align-items: center; gap: 16px; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 14px; padding: 16px 18px; box-shadow: 0 1px 3px rgba(15,23,42,0.04); transition: background .2s ease, box-shadow .25s ease, transform .15s ease, border-color .2s ease; cursor: pointer; }
  .ranking-row:hover { background: #f8fafc; box-shadow: 0 2px 8px rgba(15,23,42,0.08); border-color: #cbd5e1; }
  .rank-num { font-weight: 700; color: #64748b; text-align: center; font-size: 16px; }
  .row-user { display: flex; align-items: center; gap: 12px; min-width: 0; }
  .row-name { font-weight: 600; color: #1e293b; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 15px; }
  .row-points { text-align: right; font-weight: 700; color: #1e293b; font-size: 15px; }

    @media (prefers-reduced-motion: reduce) { 
      .bin-card, .back-btn, .detail-view, .bar-fill { 
        transition: none !important; 
      } 
    }

    /* ===== 评分详情按钮和模态框样式 ===== */
    .score-detail-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
      background: #f1f5f9;
      color: #3b82f6;
      font-size: 12px;
      font-weight: 600;
      line-height: 1;
      cursor: pointer;
      padding: 0;
      margin-left: 8px;
      transition: all 0.2s ease;
    }
    
    .score-detail-btn:hover {
      background: #3b82f6;
      color: #ffffff;
      border-color: #3b82f6;
      transform: scale(1.08);
      box-shadow: 0 2px 8px rgba(59,130,246,0.25);
    }
    
    .score-detail-btn:active {
      transform: scale(0.95);
    }

    /* 评分详情模态框 */
    .score-detail-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.45);
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.18s ease;
      backdrop-filter: blur(2px);
    }
    
    .score-detail-modal.show {
      opacity: 1;
    }
    
    .score-detail-content {
      background: #1f2429;
      color: #f0f6fc;
      border: 1px solid #30363d;
      border-radius: 14px;
      box-shadow: 0 12px 36px rgba(0,0,0,0.45);
      padding: 18px 20px 20px;
      width: min(480px, 90vw);
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
      font-size: 13px;
      line-height: 1.55;
      animation: scoreModalIn 0.22s cubic-bezier(0.32, 0.72, 0.33, 1);
    }

    @keyframes scoreModalIn {
      from {
        opacity: 0;
        transform: translateY(6px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .score-detail-close {
      position: absolute;
      top: 8px;
      right: 10px;
      background: transparent;
      border: none;
      color: #8b949e;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      padding: 2px;
      border-radius: 6px;
    }
    
    .score-detail-close:hover {
      color: #fff;
      background: rgba(255,255,255,0.08);
    }

    /* 评分卡片样式 */
    .dimension-card {
      background: rgba(255,255,255,0.04);
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
      border-left: 3px solid;
    }
    
    .dimension-card.d1 { border-left-color: #1976d2; }
    .dimension-card.d2 { border-left-color: #8e24aa; }
    .dimension-card.d3 { border-left-color: #f57c00; }
    
    .dimension-title {
      font-weight: 600;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .dimension-score {
      font-size: 18px;
      font-weight: 700;
      color: #58a6ff;
    }
    
    .score-bar {
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      overflow: hidden;
      margin: 6px 0;
    }
    
    .score-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.5s ease;
    }
    
    .score-fill.d1 { background: linear-gradient(90deg, #1976d2, #42a5f5); }
    .score-fill.d2 { background: linear-gradient(90deg, #8e24aa, #ab47bc); }
    .score-fill.d3 { background: linear-gradient(90deg, #f57c00, #ff9800); }

    /* 日间模式适配 */
    @media (prefers-color-scheme: light) {
      .score-detail-content {
        background: #fff;
        color: #1f2937;
        border-color: #e5e7eb;
      }
      
      .score-detail-close {
        color: #6b7280;
      }
      
      .score-detail-close:hover {
        color: #1f2937;
        background: rgba(0,0,0,0.05);
      }
      
      .dimension-card {
        background: rgba(0,0,0,0.02);
      }
      
      .dimension-score {
        color: #1976d2;
      }
      
      .score-bar {
        background: rgba(0,0,0,0.08);
      }
    }

    /* ===== 统一弹窗/卡片/分区样式（专业 · 简洁） ===== */
    .lb-modal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(17,24,39,.5); backdrop-filter: blur(2px); z-index: 10000; opacity: 0; transition: opacity .2s ease; }
    .lb-modal.show { opacity: 1; }
    .lb-dialog { width: min(760px, 92vw); max-height: 84vh; display: flex; flex-direction: column; background: #0b1220; color: #e5e7eb; border: 1px solid rgba(148,163,184,.25); border-radius: 16px; box-shadow: 0 20px 60px rgba(2,6,23,.5); overflow: hidden; animation: lbIn .22s cubic-bezier(.32,.72,.33,1); }
    .lb-dialog__header { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 14px 16px; border-bottom: 1px solid rgba(148,163,184,.18); background: linear-gradient(180deg, rgba(148,163,184,.06), rgba(148,163,184,0)); }
    .lb-dialog__title { font-size: 16px; font-weight: 700; letter-spacing: .2px; color: #e2e8f0; }
    .lb-dialog__body { padding: 14px 16px 16px; overflow: auto; }
    .lb-dialog__close { appearance: none; background: transparent; border: none; color: #94a3b8; width: 28px; height: 28px; border-radius: 8px; font-size: 18px; line-height: 1; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; }
    .lb-dialog__close:hover { color: #e2e8f0; background: rgba(148,163,184,.12); }
    @keyframes lbIn { from { opacity: 0; transform: translateY(6px) scale(.98); } to { opacity: 1; transform: translateY(0) scale(1); } }

    /* 统一分区与卡片 */
    .lb-section { margin: 10px 0 14px; }
    .lb-section__title { margin: 0 0 8px; font-size: 14px; font-weight: 700; color: #cbd5e1; display: flex; align-items: center; gap: 8px; }
    .lb-section__title span { font-size: 12px; font-weight: 600; color: #60a5fa; background: rgba(56,189,248,.18); padding: 2px 8px; border-radius: 999px; }
    .lb-card { background: rgba(148,163,184,.06); border: 1px solid rgba(148,163,184,.18); border-radius: 12px; padding: 12px; box-shadow: 0 2px 8px rgba(2,6,23,.25); transition: box-shadow .2s ease, transform .15s ease, border-color .2s ease; }
    .lb-card:hover { transform: translateY(-1px); box-shadow: 0 10px 24px rgba(2,6,23,.35); border-color: rgba(148,163,184,.35); }
    .lb-card h4 { margin: 0 0 6px; font-size: 14px; font-weight: 700; color: #e2e8f0; }
    .lb-card p { margin: 0; font-size: 12px; color: #94a3b8; }
  /* 渐变卡片高对比文本（浅色/深色均强制白字） */
  .lb-card--gradient,
  .lb-card--gradient h1,
  .lb-card--gradient h2,
  .lb-card--gradient h3,
  .lb-card--gradient h4,
  .lb-card--gradient p,
  .lb-card--gradient .lb-kv,
  .lb-card--gradient .lb-kv span,
  .lb-card--gradient .lb-kv strong { color: #ffffff !important; text-shadow: 0 1px 2px rgba(0,0,0,.25); }
  .lb-grid { display: grid; gap: 10px; }
  .lb-grid--1 { grid-template-columns: minmax(0,1fr); }
    .lb-grid--2 { grid-template-columns: repeat(2, minmax(0,1fr)); }
    .lb-grid--3 { grid-template-columns: repeat(3, minmax(0,1fr)); }
    .lb-grid--4 { grid-template-columns: repeat(4, minmax(0,1fr)); }
    @media (max-width: 560px){ .lb-grid--3, .lb-grid--4 { grid-template-columns: repeat(2, minmax(0,1fr)); } }

    /* 评分详情维度卡片与进度条统一视觉 */
    .lb-card--d1 { border-left: 3px solid #1976d2; }
    .lb-card--d2 { border-left: 3px solid #8e24aa; }
    .lb-card--d3 { border-left: 3px solid #f59e0b; }
    .lb-kv { display: flex; align-items: center; justify-content: space-between; gap: 8px; font-size: 12px; color: #94a3b8; }
    .lb-kv strong { color: #e2e8f0; }

    /* 详情/列表统一样式 */
    .lb-list { margin: 6px 0 0; padding-left: 18px; color: #94a3b8; font-size: 12px; }
    .lb-list li { margin: 2px 0; }

    /* 统一明细控件 */
    .lb-details summary { cursor: pointer; font-size: 12px; color: #94a3b8; }
    .lb-details[open] summary { color: #e2e8f0; }

    /* 统一浅色模式 */
    @media (prefers-color-scheme: light){
      .lb-dialog { background: #ffffff; color: #0f172a; border-color: #e5e7eb; box-shadow: 0 20px 60px rgba(15,23,42,.15); }
      .lb-dialog__header { border-color: #e5e7eb; background: linear-gradient(180deg,#f8fafc,#ffffff); }
      .lb-dialog__title { color: #0f172a; }
      .lb-dialog__close { color: #64748b; }
      .lb-dialog__close:hover { color: #0f172a; background: rgba(2,6,23,.06); }
      .lb-card { background: #ffffff; border-color: #e5e7eb; box-shadow: 0 1px 2px rgba(16,24,40,.06); }
      .lb-card:hover { box-shadow: 0 6px 14px rgba(16,24,40,.12); }
      .lb-card h4 { color: #0f172a; }
      .lb-card p, .lb-list { color: #475569; }
      .lb-section__title { color: #0f172a; }
  /* 提升浅色模式下分类得分可读性 */
  .lb-kv { color: #64748b; }
  .lb-kv strong { color: #0f172a; }
  /* 明细 summary 在浅色模式下的可读性 */
  .lb-details summary { color: #64748b; }
  .lb-details[open] summary { color: #0f172a; }
    }
    /* 轻量提示（Toast） */
    .lb-toast { position: fixed; left: 50%; bottom: 26px; transform: translateX(-50%) translateY(8px); z-index: 20000; pointer-events: none; opacity: 0; transition: opacity .18s ease, transform .18s ease; background: rgba(15,23,42,.92); color: #e5e7eb; border: 1px solid rgba(148,163,184,.28); border-radius: 12px; box-shadow: 0 8px 28px rgba(2,6,23,.45); padding: 10px 14px; font-size: 14px; font-weight: 600; letter-spacing: .01em; }
    .lb-toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    @media (prefers-color-scheme: light){
      .lb-toast { background: rgba(255,255,255,.98); color: #0f172a; border-color: rgba(2,6,23,.08); box-shadow: 0 8px 24px rgba(15,23,42,.15); }
    }
    /* ===== 休息时间明细新样式 ===== */
    .break-summary { background: color-mix(in oklab, var(--brand-600) 4%, var(--surface-1)); border:1px solid var(--border); border-radius:12px; padding:12px 14px; }
    .break-total { font-size:14px; font-weight:600; color: var(--text-1); margin-bottom:8px; }
    .break-list { list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:6px; }
    .break-row { display:grid; grid-template-columns: 115px 1fr 48px; align-items:center; background: var(--surface-0); padding:6px 10px; border:1px solid var(--border); border-radius:8px; font-size:12px; gap:8px; }
    .break-row .br-time { font-weight:600; letter-spacing:.5px; color: var(--text-1); }
    .break-row .br-type { justify-self:start; padding:2px 8px; border-radius:999px; font-weight:600; font-size:11px; letter-spacing:.5px; background:var(--surface-1); border:1px solid var(--border); color: var(--text-2); }
    .break-row .br-dur { text-align:right; font-weight:600; color: var(--brand-600); }
    /* 类型色彩区分 */
    .br-small { background:linear-gradient(135deg,#f1f5f9,#e2e8f0); }
    .br-large { background:linear-gradient(135deg,#fee2e2,#fecaca); border-color:#fca5a5 !important; color:#b91c1c !important; }
    .br-meal { background:linear-gradient(135deg,#fef3c7,#fde68a); border-color:#fcd34d !important; color:#92400e !important; }
    .br-dinner { background:linear-gradient(135deg,#ede9fe,#ddd6fe); border-color:#c4b5fd !important; color:#5b21b6 !important; }
    .break-hint { margin-top:10px; font-size:11px; color: var(--text-3); line-height:1.5; }
    @media (prefers-color-scheme: dark){
      .break-summary { background: color-mix(in oklab, var(--brand-600) 8%, var(--surface-1)); }
      .break-row { background: color-mix(in oklab, var(--surface-0) 90%, black); }
      .br-small { background:linear-gradient(135deg,#1e293b,#334155); color:#e2e8f0 !important; }
      .br-large { background:linear-gradient(135deg,#3f2d2d,#5b3a3a); color:#fecaca !important; }
      .br-meal { background:linear-gradient(135deg,#3a2f17,#5c4420); color:#fde68a !important; }
      .br-dinner { background:linear-gradient(135deg,#2f2a55,#453c7d); color:#ddd6fe !important; }
    }
    /* 计算过程盒子主题适配 */
    .calc-box { background: var(--surface-0); padding:16px; border-radius:12px; font-size:14px; border:1px solid var(--border); }
    .calc-box .warn { color:#dc2626; }
    .calc-sep { border:none; border-top:1px solid var(--border); margin:12px 0; }
    @media (prefers-color-scheme: dark){
      .calc-box { background: color-mix(in oklab, var(--surface-1) 92%, black); }
    }
  </style>
  <!-- ===== Global Design Layer: Tokens + Baseline + Components (Unified) ===== -->
  <style>
    /* Design Tokens (Light) */
    :root {
      /* brand */
      --brand-50:#eef6ff; --brand-100:#daeaff; --brand-200:#b9d6ff; --brand-300:#91bdff;
      --brand-400:#5fa1ff; --brand-500:#3b82f6; --brand-600:#2563eb; --brand-700:#1d4ed8; --brand-800:#1e40af; --brand-900:#1e3a8a;

      /* background & surface & border */
      --bg: #f7f9fc;               /* App background */
      --surface-0:#f1f5f9;         /* Secondary background */
      --surface-1:#ffffff;         /* Card/dialog background */
      --surface-2:#f8fafc;         /* Hero/strip background */
      --border:#e2e8f0;            /* Hairline */

      /* text */
      --text-1:#0f172a;            /* Primary text */
      --text-2:#334155;            /* Secondary */
      --text-3:#64748b;            /* Tertiary */
      --text-on-accent:#ffffff;    /* On brand */

      /* overlay */
      --backdrop: rgba(2, 6, 23, 0.55);

      /* radius */
      --radius-sm: 8px; --radius-md: 12px; --radius-lg: 16px; --radius-xl: 20px;

      /* spacing */
      --space-1: 4px; --space-2: 8px; --space-3: 12px; --space-4: 16px; --space-5: 20px; --space-6: 24px; --space-8: 32px; --space-10: 40px;

      /* elevation */
      --shadow-1: 0 1px 2px rgba(15, 23, 42, 0.06), 0 1px 1px rgba(15, 23, 42, 0.04);
      --shadow-2: 0 6px 18px rgba(15, 23, 42, 0.08), 0 2px 8px rgba(15, 23, 42, 0.06);

      /* container widths */
      --container-xs: 640px; --container-sm: 768px; --container-md: 1024px; --container-lg: 1200px;

      /* typography */
      --font-sans: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', 'Hiragino Sans GB', 'Noto Sans CJK SC', 'Microsoft YaHei', Arial, 'Helvetica Neue', Helvetica, sans-serif;
      --fs-xs: 12px; --fs-sm: 13.5px; --fs-base: 15px; --fs-md: 16.5px; --fs-lg: 18px; --fs-xl: 20px; --fs-2xl: 24px;
      --lh-tight: 1.2; --lh-base: 1.5; --lh-relaxed: 1.7;

      /* controls */
      --control-sm-h: 30px; --control-md-h: 36px; --control-lg-h: 44px;

      /* motion */
      --ease-1: cubic-bezier(.2,.7,.4,1); --dur-1: 160ms;
    }

    /* Tokens (Dark) - follows system */
    @media (prefers-color-scheme: dark) {
      :root {
        --bg:#0b1220; --surface-0:#0e1627; --surface-1:#0f172a; --surface-2:#111b2e; --border:#22314a;
        --text-1:#e6edf6; --text-2:#c8d2e3; --text-3:#94a3b8;
        --brand-500:#5ea1ff; --brand-600:#4a8df0; --brand-700:#3b78e0;
        --shadow-1: 0 1px 2px rgba(0,0,0,0.35);
        --shadow-2: 0 12px 36px rgba(0,0,0,0.35), 0 2px 10px rgba(0,0,0,0.25);
        --backdrop: rgba(2, 6, 23, 0.7);
      }
    }

    /* Optional manual theme: <html data-theme="dark"> */
    html[data-theme="dark"] {
      --bg:#0b1220; --surface-0:#0e1627; --surface-1:#0f172a; --surface-2:#111b2e; --border:#22314a;
      --text-1:#e6edf6; --text-2:#c8d2e3; --text-3:#94a3b8;
      --brand-500:#5ea1ff; --brand-600:#4a8df0; --brand-700:#3b78e0;
      --shadow-1: 0 1px 2px rgba(0,0,0,0.35);
      --shadow-2: 0 12px 36px rgba(0,0,0,0.35), 0 2px 10px rgba(0,0,0,0.25);
      --backdrop: rgba(2, 6, 23, 0.7);
    }

    /* Baseline overrides (keep structure, unify look) */
    body {
      background: var(--bg) !important;
      color: var(--text-1);
      font-family: var(--font-sans);
      font-size: var(--fs-base);
      line-height: var(--lh-base);
    }

    .container {
      max-width: var(--container-lg) !important;
      padding-inline: var(--space-4) !important;
    }
    @media (max-width: 1024px) { .container { max-width: var(--container-md) !important; } }
    @media (max-width: 800px)  { .container { max-width: var(--container-sm) !important; padding-inline: var(--space-3) !important; } }
    @media (max-width: 640px)  { .container { max-width: var(--container-xs) !important; } }

    /* Headings & text */
    h1,h2,h3,h4 { color: var(--text-1); letter-spacing: -0.01em; line-height: var(--lh-tight); font-weight: 700; }
    h1 { font-size: var(--fs-2xl); }
    h2 { font-size: var(--fs-xl); }
    h3 { font-size: var(--fs-lg); }
    h4 { font-size: var(--fs-md); }
    p  { color: var(--text-2); }
    .text-muted { color: var(--text-3); }

    /* Cards unification: map existing classes to shared skin */
    .overview-card, .ranking-card, .info-card, .status-card, .timeline-card, .history-card, .stu-card, .ranking-row, .top3-card, .card {
      background: var(--surface-1) !important;
      border: 1px solid var(--border) !important;
      border-radius: var(--radius-lg) !important;
      box-shadow: var(--shadow-1) !important;
    }
    /* 仅非渐变类的 lb-card 使用统一皮肤，保留渐变卡片原有背景与无边框设计 */
    .lb-card:not(.lb-card--gradient) {
      background: var(--surface-1) !important;
      border: 1px solid var(--border) !important;
      border-radius: var(--radius-lg) !important;
      box-shadow: var(--shadow-1) !important;
    }
    .overview-card, .ranking-card, .info-card, .status-card, .timeline-card, .history-card, .card, .lb-card { padding: var(--space-5) !important; }
    .stu-card { padding: var(--space-4) !important; }

    /* Hero/strips */
    .ranking-hero {
      background: linear-gradient(180deg, var(--surface-2), var(--surface-1)) !important;
      border: 1px solid var(--border) !important;
      border-radius: var(--radius-xl) !important;
      padding: var(--space-6) !important;
      box-shadow: var(--shadow-1) !important;
      color: var(--text-1) !important;
    }

  /* Ensure full ranking view uses the same width as container */
  .ranking-root { width: 100% !important; max-width: var(--container-lg) !important; margin-inline: auto !important; }
  #rankingFullList { width: 100% !important; }
  /* Relax row columns so the score column isn't cramped */
  .ranking-row { grid-template-columns: 64px 1fr 160px !important; }
  @media (max-width: 560px) { .ranking-row { grid-template-columns: 44px 1fr auto !important; } }

    /* Buttons unification */
    .view-details-btn, .ranking-details-btn, .back-btn, .btn {
      display: inline-flex; align-items: center; justify-content: center; gap: 8px;
      height: var(--control-md-h); padding: 0 var(--space-4);
      font-size: var(--fs-sm); font-weight: 600;
      border-radius: var(--radius-md); border: 1px solid var(--border);
      background: var(--surface-1); color: var(--text-1);
      transition: all var(--dur-1) var(--ease-1);
    }
  .btn--sm { height: var(--control-sm-h); padding: 0 var(--space-3); font-size: var(--fs-xs); border-radius: 10px; }
  .btn--lg { height: var(--control-lg-h); padding: 0 var(--space-5); }
  .btn--ghost { background: var(--surface-0); }
  .btn--ghost:hover { background: var(--surface-1); }
    .view-details-btn, .ranking-details-btn { width: 100%; }
    .view-details-btn:hover, .ranking-details-btn:hover, .back-btn:hover, .btn:hover {
      border-color: color-mix(in oklab, var(--brand-600) 30%, var(--border));
      box-shadow: var(--shadow-1);
      transform: translateY(-1px);
    }
    .view-details-btn:active, .ranking-details-btn:active, .back-btn:active, .btn:active { transform: translateY(0); }
    .btn--primary, .view-details-btn.btn--primary { background: var(--brand-600); color: var(--text-on-accent); border-color: transparent; }
    .btn--primary:hover { background: var(--brand-700); color: var(--text-on-accent); }

    /* Score detail icon button keeps accent but adopts sizing */
    .score-detail-btn {
      width: 22px; height: 22px; border-radius: 6px;
      border: 1px solid var(--border); background: var(--surface-0); color: var(--brand-600);
      box-shadow: none; transition: all var(--dur-1) var(--ease-1);
    }
    .score-detail-btn:hover { background: var(--brand-600); color: var(--text-on-accent); border-color: var(--brand-600); box-shadow: 0 2px 8px rgba(59,130,246,0.25); transform: scale(1.06); }

    /* Lists & rows */
    .ranking-row { padding: var(--space-4) var(--space-5) !important; }
    .ranking-row:hover { border-color: color-mix(in oklab, var(--brand-600) 24%, var(--border)) !important; box-shadow: var(--shadow-1) !important; }
    .row-name { color: var(--text-1) !important; font-size: var(--fs-md) !important; }
    .row-points, .rank-num, .ranking-student-name { color: var(--text-1) !important; }
    .ranking-student-meta, .ranking-score-label { color: var(--text-3) !important; }

    /* Modals unify (lb-*) */
    .lb-modal { background: var(--backdrop) !important; }
    .lb-dialog { background: var(--surface-1) !important; border: 1px solid var(--border) !important; border-radius: var(--radius-xl) !important; box-shadow: var(--shadow-2) !important; }
    .lb-dialog__title { color: var(--text-1) !important; }
    .lb-dialog__body { color: var(--text-2) !important; }
    .lb-dialog__close { color: var(--text-3) !important; }
    .lb-dialog__close:hover { color: var(--text-1) !important; }

    /* Grid gap normalization */
    .lb-grid { gap: var(--space-4) !important; }

    /* Detail/list backgrounds unify */
    .list-view, .detail-view { background: var(--bg) !important; }
  .detail-header { background: linear-gradient(180deg, var(--surface-2), var(--surface-1)) !important; border-bottom: 1px solid var(--border); }

    /* Progress circle colors - allow dynamic setting */
    .progress-bg { stroke: color-mix(in oklab, var(--border) 85%, white); }
    /* Remove fixed stroke color to allow dynamic category colors */

    /* Section spacing */
    .section, .ranking-section, .overview-container { margin-bottom: var(--space-6); }

    /* Light/Dark readability helpers */
    .text-on-brand, .on-gradient { color: var(--text-on-accent) !important; text-shadow: 0 1px 0 rgba(0,0,0,.18); }
  </style>
    <!-- Accessibility & Contrast Fixes: enforce readable colors in light/dark -->
    <style>
      /* Primary text surfaces */
      .page-title, .card-title, .detail-title, .stu-name, .status-value,
      .ranking-student-name, .row-name, .row-points, .rank-num,
      .timeline-time, .progress-count, .progress-percentage,
      .lb-dialog__title { color: var(--text-1) !important; }
  /* 列表标题与分钟数（仍有浅色硬编码） */
  .list-title, .stu-mins { color: var(--text-1) !important; }

      /* Secondary/tertiary text */
      .page-subtitle, .card-subtitle, .ranking-student-meta, .ranking-score-label,
      .progress-description, .stu-meta, .stu-detail, .status-label,
      .timeline-duration, .bar-label, .ranking-hero-sub,
      .lb-dialog__body, .lb-list, .text-muted { color: var(--text-3) !important; }

      /* Brand accents */
      .ranking-score-value, .bar-tooltip .em, .timeline-room { color: var(--brand-600) !important; }

      /* Inputs & result lists */
      .search-input { color: var(--text-1) !important; background: var(--surface-1) !important; border-color: var(--border) !important; }
      .search-results { background: var(--surface-1) !important; border-color: var(--border) !important; }
      .search-result-item { color: var(--text-1) !important; }
      .search-result-item:hover { background: var(--surface-0) !important; }

  /* Hover rows in both themes */
  .timeline-item:hover { background: var(--surface-0) !important; }
  /* 排行列表分隔线在深色下可见 */
  .ranking-item { border-bottom-color: var(--border) !important; }

      /* Timeline room pill adapts to theme */
      .timeline-room { 
        background: color-mix(in oklab, var(--brand-600) 12%, transparent);
        border: 1px solid color-mix(in oklab, var(--brand-600) 55%, var(--border));
      }

      /* Chart tooltip */
      .bar-tooltip { 
        background: color-mix(in oklab, var(--text-1) 92%, transparent) !important;
        color: var(--surface-1) !important; 
        border: 1px solid color-mix(in oklab, var(--border) 70%, var(--text-1));
        box-shadow: var(--shadow-2);
      }

      /* Additional text elements */
      .card-date, .progress-count-unit, .progress-percentage-symbol { color: var(--text-3) !important; }
      .separator { color: var(--border) !important; }

      /* Category tabs: theme-aware */
      .category-tabs { background: var(--surface-0) !important; }
      .category-tab { color: var(--text-2) !important; }
      .category-tab.active { background: var(--brand-600) !important; color: var(--text-on-accent) !important; box-shadow: 0 2px 8px color-mix(in oklab, var(--brand-600) 35%, transparent) !important; }
      .category-tab:hover:not(.active) { background: var(--surface-0) !important; color: var(--text-1) !important; }

      /* Inputs: focus ring brand-aware */
      .search-input:focus { border-color: var(--brand-600) !important; box-shadow: 0 0 0 3px color-mix(in oklab, var(--brand-600) 20%, transparent) !important; }

      /* Buttons hover on neutral surfaces */
      .back-btn:hover { background: var(--surface-0) !important; }

      /* Status item hover unify */
      .status-item:hover { background: color-mix(in oklab, var(--brand-600) 10%, transparent) !important; border-color: color-mix(in oklab, var(--brand-600) 45%, var(--border)) !important; }

      /* Bars adopt brand gradient */
      .bar-fill { background: linear-gradient(to top, var(--brand-700) 0%, var(--brand-500) 100%) !important; }
  
      /* Ensure ranking hover row background in dark */
      .ranking-row:hover { background: var(--surface-0) !important; }

      /* Top3 区域在深色模式下的可读性修复 */
      .top3-card { background: var(--surface-1) !important; border-color: var(--border) !important; color: var(--text-1) !important; }
      .top3-card:hover { background: var(--surface-2) !important; }
      .top3-name { color: var(--text-1) !important; }
      .top3-points { color: var(--text-3) !important; }
      .ranking-hero-sub { color: var(--text-3) !important; }

      /* Top3 卡片内“评分详情 ?”按钮增强对比度 */
      .top3-card .score-detail-btn {
        color: var(--brand-600) !important;
        border-color: var(--brand-600) !important;
        background: color-mix(in oklab, var(--brand-600) 12%, transparent) !important;
      }
      .top3-card .score-detail-btn:hover {
        background: var(--brand-600) !important;
        color: var(--text-on-accent) !important;
        border-color: var(--brand-600) !important;
        box-shadow: 0 2px 10px rgba(59,130,246,.35) !important;
      }

  /* 细节补齐：旧变量 var(--text) 定义的标题在深色下偏暗 */
  .student-info h2,
  .status-card h3,
  .timeline-card h3,
  .history-card h3 { color: var(--text-1) !important; }
  .status-label { color: var(--text-3) !important; }
  .status-value { color: var(--text-1) !important; }

  /* 状态小卡默认底/边改为主题令牌，避免浅色硬编码 */
  .status-item { background: var(--surface-0) !important; border-color: var(--border) !important; }

  /* 排行按钮与查看详情按钮在深色下保持对比度 */
  .ranking-details-btn,
  .view-details-btn { background: var(--surface-1) !important; border-color: var(--border) !important; color: var(--text-1) !important; }
  .ranking-details-btn:hover,
  .view-details-btn:hover { border-color: color-mix(in oklab, var(--brand-600) 30%, var(--border)) !important; box-shadow: var(--shadow-1) !important; }

  /* 指定两个主要按钮为品牌蓝色填充（覆盖上面的中性底规则） */
  #viewDetailsBtn,
  #rankingDetailsBtn { background: var(--brand-600) !important; color: var(--text-on-accent) !important; border-color: transparent !important; }
  #viewDetailsBtn:hover,
  #rankingDetailsBtn:hover { background: var(--brand-700) !important; box-shadow: 0 6px 16px rgba(59,130,246,.35) !important; }
  #viewDetailsBtn:active,
  #rankingDetailsBtn:active { background: var(--brand-800) !important; }

  /* ===== 442评分趋势图样式 ===== */
  .trend-card { 
    background: var(--surface-1); 
    border: 1px solid var(--border); 
    border-radius: var(--radius-lg); 
    padding: 20px; 
    margin-top: var(--gap-md); 
  }

  .trend-card h3 {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-1);
    margin: 0 0 16px 0;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .trend-container {
    position: relative;
    height: 200px;
    background: var(--surface-0);
    border-radius: var(--radius-md);
    border: 1px solid var(--border);
    overflow-x: auto;
    overflow-y: hidden;
  }

  .trend-chart {
    width: 100%;
    height: 100%;
  }

  .trend-grid-line {
    stroke: var(--border);
    stroke-width: 1;
    stroke-dasharray: 2,2;
    opacity: 0.5;
  }

  .trend-axis {
    stroke: var(--border);
    stroke-width: 1;
  }

  .trend-line {
    fill: none;
    stroke: var(--brand-600);
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .trend-point {
    fill: #3b82f6; /* 蓝色 */
    stroke: #ffffff;
    stroke-width: 2;
    cursor: pointer;
    transition: fill 0.2s ease, stroke-width 0.2s ease;
  }

  .trend-point:hover {
    fill: #2563eb; /* 深蓝色 */
    stroke-width: 3;
  }

  .trend-point.today {
    fill: #f59e0b; /* 橙色，代表今日 */
    stroke: #ffffff;
    stroke-width: 3;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  .trend-label {
    font-size: 11px;
    fill: var(--text-3);
    text-anchor: middle;
    dominant-baseline: central;
  }

  .trend-value-label {
    font-size: 11px;
    fill: var(--text-2);
    text-anchor: end;
    dominant-baseline: central;
  }

  .trend-tooltip {
    position: absolute;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 10px;
    font-size: 12px;
    color: var(--text-1);
    pointer-events: none;
    z-index: 10;
    opacity: 0;
    transform: translateY(-5px);
    transition: opacity 0.2s ease, transform 0.2s ease;
    box-shadow: var(--shadow-1);
  }

  .trend-tooltip.show {
    opacity: 1;
    transform: translateY(0);
  }

  .trend-empty {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--text-3);
    font-size: 14px;
  }

  /* 每个数据点简化标签（分数 · 名次） */
  .trend-point-mini {
    font-size: 10px;
    fill: var(--text-2);
    text-anchor: middle;
    dominant-baseline: central;
  /* 文本描边避免被趋势线“穿过”造成视觉重叠 */
  paint-order: stroke fill;
  stroke: var(--surface-1);
  stroke-width: 3;
  pointer-events: none; /* 不抢占 hover，避免影响 tooltip */
  }
  .trend-point-mini.today {
    fill: var(--warning);
    font-weight: 700;
  }
  .trend-point-mini .sub { 
    font-size: 9px; 
    fill: var(--text-3); 
    font-weight: 600;
  paint-order: stroke fill;
  stroke: var(--surface-1);
  stroke-width: 2;
  }
  /* === Progress Detail Delta Coloring & Sparkline === */
  .delta { font-weight:600; }
  .delta-pos { color:#16a34a; }
  .delta-neg { color:#dc2626; }
  .delta-zero { color:#64748b; }
  .sparkline { width:140px; height:34px; display:block; margin:6px 0 2px; }
  .spark-prev { stroke:#cbd5e1; fill:none; stroke-width:1.4; vector-effect:non-scaling-stroke; }
  .spark-cur { stroke:#2563eb; fill:none; stroke-width:1.6; vector-effect:non-scaling-stroke; }
  .spark-bg { stroke:#f1f5f9; fill:none; stroke-width:1; }
  .sparkline:hover .spark-cur { stroke:#1d4ed8; }
  
  /* （已移除：原 iOS 边缘右滑返回手势样式） */
    </style>
    <!-- Admin FAB style -->
    <style>
      .admin-fab {
        position: fixed; right: 16px; bottom: 84px; z-index: 12000;
        height: 44px; padding: 0 14px; border-radius: 12px;
        border: 1px solid var(--border); background: var(--brand-600);
        color: var(--text-on-accent); font-weight: 700; font-size: 13px;
        box-shadow: var(--shadow-2); cursor: pointer;
        display: inline-flex; align-items: center; gap: 8px;
      }
      .admin-fab:hover { background: var(--brand-700); }
      .admin-fab:active { background: var(--brand-800); transform: translateY(1px); }
    </style>
    
</head>
<body>
  <main class="container">
    <!-- 首页：今日纵览 -->
    <section id="homeView" class="home-view">
      <!-- 页面标题 -->
      <div class="page-header">
        <h1 class="page-title">青岛耶胡迪梅纽因学校</h1>
        <p class="page-subtitle">练琴跟踪系统</p>
      </div>

      <!-- 搜索功能 -->
      <div class="search-section">
        <div class="search-container">
          <span class="search-icon">🔍</span>
          <input 
            type="text" 
            class="search-input" 
            placeholder="搜索学生姓名..." 
            id="studentSearchInput"
          />
          <div class="search-results" id="searchResults"></div>
        </div>
      </div>

      <!-- 概览区域 -->
      <div class="overview-container">
        <div class="overview-card">
          <!-- 头部 -->
          <div class="card-header">
            <h1 class="card-title">实时总览</h1>
            <div class="card-date" id="currentDate">9月16日</div>
          </div>

        <!-- 分类标签 -->
        <div class="category-tabs">
          <button class="category-tab" data-category="attendance">出勤</button>
          <button class="category-tab" data-category="absent">缺勤</button>
          <button class="category-tab" data-category="self-practice">自主</button>
          <button class="category-tab" data-category="not-practice">未练</button>
        </div>

        <!-- 圆形进度图 -->
        <div class="progress-circle">
          <svg viewBox="0 0 160 160">
            <circle 
              class="progress-bg" 
              cx="80" 
              cy="80" 
              r="70"
            />
            <circle 
              id="progressPath"
              class="progress-fill" 
              cx="80" 
              cy="80" 
              r="70"
            />
          </svg>
          <div class="progress-center">
            <div style="white-space: nowrap;">
              <span class="progress-percentage" id="progressPercentage">0</span>
              <span class="progress-percentage-symbol">%</span>
            </div>
          </div>
        </div>

        <!-- 进度条下方信息 -->
        <div class="progress-info">
          <div class="progress-count">
            <span id="progressCount">0</span>
            <span class="progress-count-unit">人</span>
          </div>
          <div class="progress-description" id="progressDescription">
            在规定时间段练琴的人数占总人数的比例
          </div>
        </div>

        <!-- 查看详情按钮 -->
        <button class="view-details-btn btn--primary btn--lg" id="viewDetailsBtn">
          <span>查看详情</span>
        </button>
        </div>

        <!-- 442排行榜 -->
        <div class="ranking-card">
          <!-- 头部 -->
          <div class="card-header">
            <h2 class="card-title">442排行榜</h2>
            <div class="card-subtitle">每日练琴质量排名</div>
          </div>

          <!-- 排行榜列表 -->
          <div class="ranking-list" id="rankingList">
            <!-- 动态生成排行榜内容 -->
          </div>

          <!-- 排行规则详情按钮 -->
          <button class="ranking-details-btn" id="rankingRulesBtn" style="margin-bottom:8px;">
            <span>📊 排行规则详情</span>
          </button>

          <!-- 查看完整排行榜按钮 -->
          <button class="ranking-details-btn btn--primary btn--lg" id="rankingDetailsBtn">
            <span>查看完整排行榜</span>
          </button>
        </div>
      </div>
    </section>

    <!-- 列表：平铺学生卡片 -->
    <section id="listView" class="list-view" hidden>
      <div class="list-header">
        <button id="backBtn" class="back-btn" aria-label="返回">← 返回</button>
        <div class="list-title" id="listTitle">正在练琴</div>
      </div>
      <div id="studentGrid" class="student-grid"></div>
    </section>

    <!-- 完整排行榜视图 -->
    <section id="rankingView" class="list-view" hidden>
      <div class="ranking-root">
        <div class="list-header">
          <button id="rankingBackBtn" class="back-btn" aria-label="返回">← 返回</button>
          <div class="ranking-header-tabs">
            <button id="dailyRankingTab" class="ranking-tab active">日榜</button>
            <button id="weeklyRankingTab" class="ranking-tab">周榜</button>
          </div>
        </div>
        <div id="rankingFullList"></div>
      </div>
    </section>

    <!-- 学生详情页面 -->
    <section id="detailView" class="detail-view" hidden>
      <div class="detail-container">
        <div class="detail-header">
          <button id="detailBackBtn" class="back-btn" aria-label="返回">← 返回</button>
          <div class="detail-title" id="detailTitle">学生详情</div>
        </div>
        
        <div class="detail-content">
          <!-- 个人信息卡片 -->
          <div class="info-card">
            <div class="info-head">
              <div class="student-info">
                <h2 id="studentName">劲豪</h2>
                <div class="student-meta">
                  <span id="studentGrade">2024级</span>
                  <span class="separator">·</span>
                  <span id="studentMajor">钢琴专业</span>
                </div>
              </div>
              <div class="today-score" id="todayScoreBadge" title="今日 442 综合分">
                <span class="today-score-label">今日442分</span>
                <span class="today-score-value" id="todayScoreValue">--</span>
                <button class="score-detail-btn" id="todayScoreDetailBtn" title="查看评分详情">?</button>
              </div>
            </div>
          </div>

          <!-- 当前状态卡片 -->
          <div class="status-card">
            <h3>当前状态</h3>
            <div class="status-grid">
              <div class="status-item">
                <span class="status-label">练琴开始时间</span>
                <span class="status-value" id="currentStartTime">--</span>
              </div>
              <div class="status-item">
                <span class="status-label">当前时长</span>
                <span class="status-value" id="currentDuration">--</span>
              </div>
              <div class="status-item">
                <span class="status-label">当前琴房</span>
                <span class="status-value" id="currentRoom">--</span>
              </div>
              <div class="status-item">
                <span class="status-label">今日总计</span>
                <span class="status-value" id="todayTotal">0分钟</span>
                <button class="status-help-btn" id="todayTotalHelpBtn" title="查看时间计算说明">?</button>
              </div>
            </div>
          </div>

          <!-- 今日时间轴 -->
          <div class="timeline-card">
            <div class="timeline-head">
              <h3>今日练琴时间轴</h3>
              <div class="timeline-actions">
                <button class="btn btn--sm btn--ghost" id="viewWeekSlotsBtn" title="查看每周时段">🗓 查看周时段</button>
              </div>
            </div>
            <div class="timeline-container" id="todayTimeline">
              <!-- 时间轴内容将通过JavaScript生成 -->
            </div>
          </div>

          <!-- 历史七天总结 -->
          <div class="history-card">
            <h3>近七天练琴总结</h3>
            
            <!-- 七天练琴条形图 -->
            <div class="week-chart">
              <div class="chart-container" id="weekChart">
                <!-- 条形图将通过JavaScript生成 -->
              </div>
            </div>
          </div>

          <!-- 442评分趋势图 -->
          <div class="trend-card">
            <h3>📈 442评分趋势</h3>
            <div class="trend-container" id="trendChart">
              <!-- 趋势图将通过JavaScript生成 -->
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
  /**
   * ==============================
   *  脚本区（JS）— 源码导览
   *  A. 常量与配置（Supabase、时间常量、休息时间）
   *  B. 工具函数（utils：时间/格式化/判断）
   *  C. 全局状态（appState、连接状态）
   *  D. 数据获取（fetchAllData、订阅）
   *  E. 数据分析计算（processStudentLogs、calculateDayPracticeTime 等）
   *  F. UI 渲染（首页、列表、详情、图表）
   *  G. 交互与事件（点击、切换、搜索）
   *  H. 初始化（initializeApp）
   *  
   *  🚀 性能优化总结：
   *  - 排行榜更新防抖从150ms增加到2秒
   *  - 实时监听添加5秒节流控制
   *  - 新增30秒排行榜缓存机制
   *  - 数据变化检测：只在真正变化时更新
   *  - 周末跳过自动同步，减少不必要请求
   *  - 添加更新频率监控和性能指标
   * ==============================
   */

  // === 调试日志统一入口 ===
  // 将 DEBUG 置为 false 可静默所有 dbg 日志，而不影响 console.error/warn。
  const DEBUG = false; // 默认关闭，避免大量日志阻塞首次渲染；手动调试可在控制台改为 true
  // 日志节流：每秒最多输出 MAX_LOGS_PER_SEC 条；超过的合并为一条摘要。
  const MAX_LOGS_PER_SEC = 80; // 安全上限（可调）
  let __logWindowStart = Date.now();
  let __logCount = 0;
  let __logBuffered = 0;
  let __logLastFlushTimer = null;
  function dbg(...args) {
    if (!DEBUG) return;
    const now = Date.now();
    if (now - __logWindowStart >= 1000) {
      // 窗口更新前，如果有缓冲摘要先输出
      if (__logBuffered) {
        try { console.log(`[DBG][throttled] +${__logBuffered} logs suppressed`); } catch {}
        __logBuffered = 0;
      }
      __logWindowStart = now;
      __logCount = 0;
    }
    if (__logCount < MAX_LOGS_PER_SEC) {
      __logCount++;
      try { console.log('[DBG]', ...args); } catch {}
    } else {
      __logBuffered++;
      // 延迟在当前秒结束或下一个 tick 输出一次摘要
      if (!__logLastFlushTimer) {
        __logLastFlushTimer = setTimeout(()=>{
          __logLastFlushTimer = null;
          if (!DEBUG) { __logBuffered = 0; return; }
            if (__logBuffered) {
              try { console.log(`[DBG][throttled] +${__logBuffered} logs suppressed`); } catch {}
              __logBuffered = 0;
            }
        }, Math.max(0, 1000 - (now - __logWindowStart)) + 10);
      }
    }
  }

  /** =============================================
   * 性能基础设施 (批处理 / 监控 / Worker 雏形)
   * ============================================== */
  // DOM 批处理：收集任务在 rAF 中集中写入，避免布局抖动；默认 8ms 预算，剩余任务下一帧继续
  const __domQueue = [];
  let __domFlushScheduled = false;
  function scheduleDOM(task, priority = 1) {
    __domQueue.push({ task, priority, t: Date.now() });
    if (!__domFlushScheduled) {
      __domFlushScheduled = true;
      requestAnimationFrame(flushDOMQueue);
    }
  }
  function flushDOMQueue() {
    const start = performance.now();
    // 稳定排序（优先级 + 任务加入顺序）
    __domQueue.sort((a, b) => a.priority - b.priority || a.t - b.t);
    while (__domQueue.length) {
      const item = __domQueue.shift();
      try { item.task(); } catch (e) { console.error('[dom-task-error]', e); }
      if (performance.now() - start > 8) break; // 超预算，留到下一帧
    }
    if (__domQueue.length) {
      requestAnimationFrame(flushDOMQueue);
    } else {
      __domFlushScheduled = false;
    }
  }

  // 全局性能开关（可在控制台动态修改）
  window.__perfFlags = Object.assign({
    chunkStudentList: true,
    chunkTimeline: true,
    monitorFPS: false,
    instrumentRanking: true,
    instrumentTimeline: true
  }, window.__perfFlags || {});

  // addEventListener 被动监听增强：touch / wheel 默认 passive:true（若调用方需要阻止默认需显式 { passive:false }）
  (function enhancePassive() {
    const orig = EventTarget.prototype.addEventListener;
    try {
      EventTarget.prototype.addEventListener = function(type, listener, options) {
        if (options == null) {
          if (type === 'touchstart' || type === 'touchmove' || type === 'wheel') {
            options = { passive: true };
          }
        } else if (typeof options === 'object') {
            if ((type === 'touchstart' || type === 'touchmove' || type === 'wheel') && options.passive === undefined) {
              options.passive = true;
            }
        }
        return orig.call(this, type, listener, options);
      };
    } catch (e) { /* ignore */ }
  })();

  // FPS + Long Task 监控（?perf=1 时显示角标）
  function startPerfMon() {
    if (window.__perfStarted) return; window.__perfStarted = true;
    const showPanel = location.search.includes('perf=1');
    let fpsEl = null;
    if (showPanel) {
      fpsEl = document.createElement('div');
      fpsEl.textContent = '-- FPS';
      fpsEl.style.cssText = 'position:fixed;left:8px;bottom:8px;z-index:99999;background:rgba(0,0,0,.55);color:#fff;padding:2px 6px;font:12px/1 monospace;border-radius:4px;';
      document.body.appendChild(fpsEl);
    }
    let frames = 0, lastSec = performance.now();
    function loop(now) {
      frames++;
      if (now - lastSec >= 1000) {
        if (fpsEl) fpsEl.textContent = frames + ' FPS';
        frames = 0; lastSec = now;
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
    try {
      const po = new PerformanceObserver(list => {
        list.getEntries().forEach(en => {
          if (en.duration > 50 && fpsEl) {
            fpsEl.style.background = 'rgba(220,38,38,.75)';
            clearTimeout(fpsEl.__t); fpsEl.__t = setTimeout(() => fpsEl.style.background = 'rgba(0,0,0,.55)', 700);
          }
        });
      });
      po.observe({ type: 'longtask', buffered: true });
    } catch (e) { /* safari < 16 无 longtask */ }
  }
  document.addEventListener('DOMContentLoaded', () => startPerfMon(), { once: true });

  // 轻量 Worker 雏形：后续可扩展将重计算/排序迁移
  let __computeWorker = null;
  function getComputeWorker() {
    if (__computeWorker) return __computeWorker;
    const code = `self.__pending=new Map();self.onmessage=e=>{const {id,type,payload}=e.data;try{if(type==='hash'){let h=0,s=payload||'';for(let i=0;i<s.length;i++){h=(h*131+s.charCodeAt(i))>>>0;}postMessage({id,ok:true,hash:h});}else{postMessage({id,ok:false,reason:'unknown_task'});}}catch(err){postMessage({id,ok:false,error:err.message});}};`;
    const blob = new Blob([code], { type: 'application/javascript' });
    __computeWorker = new Worker(URL.createObjectURL(blob));
    __computeWorker.__wait = new Map();
    __computeWorker.onmessage = ev => { const { id, ...rest } = ev.data || {}; const cb = __computeWorker.__wait.get(id); if (cb) { __computeWorker.__wait.delete(id); cb(rest); } };
    return __computeWorker;
  }
  function workerHash(str) {
    return new Promise(resolve => {
      try {
        const w = getComputeWorker();
        const id = 'h_' + Math.random().toString(36).slice(2);
        w.__wait.set(id, res => resolve(res.hash || 0));
        w.postMessage({ id, type: 'hash', payload: str });
      } catch { resolve(0); }
    });
  }

  // 导出到全局便于临时调试
  window.__perfTools = { scheduleDOM, workerHash };

  // 轻量提示：显示 1.8s 后自动隐藏
  function showToast(message) {
    try {
      const el = document.getElementById('lbToast');
      if (!el) { alert(message); return; }
      el.textContent = message;
      el.hidden = false;
      // 强制回流以应用过渡
      void el.offsetWidth;
      el.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => {
        el.classList.remove('show');
        // 等过渡结束再隐藏
        setTimeout(() => { el.hidden = true; el.textContent = ''; }, 200);
      }, 1800);
    } catch { /* no-op */ }
  }

    // ==== 性能优化工具函数 ====
    function debounce(func, wait, immediate) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          timeout = null;
          if (!immediate) func(...args);
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func(...args);
      };
    }

    function throttle(func, limit) {
      let inThrottle;
      return function executedFunction(...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }

        // 智能防抖机制：根据页面状态动态调整延迟
    const createSmartDebounce = (func, normalDelay, hiddenDelay) => {
      let timeout;
      return function executedFunction(...args) {
        const delay = (!document.hidden) ? normalDelay : hiddenDelay; // 直接使用 document.hidden
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
      };
    };
    
    // 防抖函数将在所有函数定义后创建
    let debouncedUpdateRanking;
    let debouncedRenderHomeBins;

    // 增强缓存机制：避免重复计算排行榜
    let lastRankingUpdateTime = 0;
    let rankingDataCache = null;
    let RANKING_CACHE_DURATION = 30000; // 动态缓存时间，将在页面可见性变化时更新
    
    // 数据变化检测优化
    let lastDataHash = null;
    let consecutiveNoChangeCount = 0; // 连续无变化计数器
    
    // 网络状态监听
    window.addEventListener('online', () => {
      dbg('网络已连接，检查实时连接状态');
      // 延迟执行以确保变量已初始化
      setTimeout(() => {
        if (!realtimeChannel && typeof isConnected !== 'undefined' && isConnected) {
          setupRealtime();
        }
      }, 1000);
    });
    
    window.addEventListener('offline', () => {
      dbg('网络已断开，进入离线模式');
      // 延迟执行以确保 setConnectionStatus 函数已定义
      setTimeout(() => {
        if (typeof setConnectionStatus === 'function') {
          setConnectionStatus('offline', '网络离线');
        }
      }, 100);
    });    // 生成数据哈希值用于检测变化
    function generateDataHash(students) {
      if (!students || !students.size) return '';
      const dataPoints = [];
      students.forEach((student, name) => {
        dataPoints.push(`${name}:${student.todayMinutes.in}:${student.todayMinutes.out}:${student.currentStatus}`);
      });
      // 修复：使用安全的哈希方法，避免中文字符导致的 btoa 错误
      try {
        const dataString = dataPoints.sort().join('|');
        // 使用简单的字符串哈希算法替代 btoa
        let hash = 0;
        for (let i = 0; i < dataString.length; i++) {
          const char = dataString.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // 转换为32位整数
        }
        return hash.toString();
      } catch (e) {
        console.warn('生成数据哈希失败:', e);
        return Date.now().toString(); // 降级方案：使用时间戳
      }
    }

    // ==== 配置和常量 ====
    const SUPABASE_URL = 'https://waesizzoqodntrlvrwhw.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndhZXNpenpvcW9kbnRybHZyd2h3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc4MjIyOTYsImV4cCI6MjA3MzM5ODI5Nn0.kE5gSV68q1nLo4z2IqgwqfTBVqNOJw5qs08f6r0SQH0';
  // 手动同步入口开关：置为 false 可完全禁用手动调用入口（包括控制台手动触发）
  const ENABLE_MANUAL_SYNC = false;

    // 休息时间配置 - 剔除大课间、午餐、晚餐等休息时间
    const BREAK_SCHEDULE = {
      monTueThuFri: [
        {start: 8*60+50, end: 9*60},      // 大课间 08:50-09:00
        {start: 9*60+50, end: 10*60},     // 大课间 09:50-10:00
        {start: 10*60+50, end: 11*60},    // 大课间 10:50-11:00
        {start: 12*60+10, end: 12*60+40}, // 午餐时间 12:10-12:40（更新）
        {start: 13*60+50, end: 14*60},    // 大课间 13:50-14:00
        {start: 14*60+50, end: 15*60+10}, // 大课间 14:50-15:10
        {start: 16*60, end: 16*60+10},    // 大课间 16:00-16:10
        {start: 17*60, end: 17*60+10},    // 大课间 17:00-17:10
        {start: 18*60+10, end: 18*60+40}  // 晚餐时间 18:10-18:40（更新）
      ],
      wed: [
        {start: 8*60+50, end: 9*60},      // 大课间 08:50-09:00
        {start: 9*60+50, end: 10*60},     // 大课间 09:50-10:00
        {start: 10*60+50, end: 11*60},    // 大课间 10:50-11:00
        {start: 12*60+10, end: 13*60+20}, // 午餐时间 12:10-13:20（更新）
        {start: 14*60+20, end: 14*60+30}, // 大课间 14:20-14:30
        {start: 15*60+20, end: 15*60+40}, // 大课间 15:20-15:40
        {start: 16*60+30, end: 16*60+40}, // 大课间 16:30-16:40
        {start: 17*60+30, end: 17*60+40}, // 大课间 17:30-17:40
        {start: 18*60+40, end: 19*60+10}  // 晚餐时间 18:40-19:10（更新）
      ]
    };

  /**
   * 默认“规定时间段内”的窗口（当学生未配置个性化时段时使用）
   */
  // 允许统计窗口（排除 21:30-次日07:30）。需求：不统计 21:30-07:30。
  const STATS_WINDOW = { start: 7*60+30, end: 21*60+30 }; // 07:30-21:30
  const DEFAULT_SCHEDULE_IN = { start: STATS_WINDOW.start, end: STATS_WINDOW.end };

  /**
   * 系统有效统计时间窗口：所有工作日统一统计至 21:30；周末不统计。
   */
  function getEffectiveDayWindow(date) {
    const weekday = date.getDay(); // 0=Sunday, 1=Monday, ..., 6=Saturday
  // 周一到周日统一使用 07:30-21:30 有效统计窗口
  return { start: STATS_WINDOW.start, end: STATS_WINDOW.end };
  }
  
  // 保持兼容性，使用默认时间窗口（周1245的时间）
  const EFFECTIVE_DAY_WINDOW = { start: STATS_WINDOW.start, end: STATS_WINDOW.end };

    // ==== 全局状态 ====
    let supabaseClient = null;
    let realtimeChannel = null;
    let isConnected = false;

    const appState = {
      students: new Map(), // studentName -> StudentData
  studentsMeta: new Map(), // studentName -> {major, grade} （external_id 已下线）
      timeSlots: new Map(), // studentName -> {1..7: [{start,end}]}
      practiceLogs: [],
      currentFilter: 'all',
  searchQuery: '',
  // 缓存：后端备份的每日排行榜（dateKey -> Map<student_key, rank>）
  dailyLeaderboards: new Map()
    };

    // ==== 工具函数 ====
    const utils = {
  // ISO 日期字符串（不含时间）
  toIsoDate: (d) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`,
        // 统一学生姓名：去首尾空格、压缩中间空白、标准化全角空格与括号
        normalizeStudentName: (name) => {
          if (!name) return '';
          let s = String(name);
          // 去除零宽与不可见控制字符、BOM
          s = s.replace(/[\u200B-\u200D\uFEFF\u2060]/g, '');
          // 全角空格/不间断空格 -> 半角空格
          s = s.replace(/[\u3000\u00A0]/g, ' ');
          // 全角括号 -> 半角
          s = s.replace(/（/g, '(').replace(/）/g, ')');
          // 规范尾部括号内部空格
          s = s.replace(/[\(]\s*([^)]*?)\s*[)]$/, '($1)');
          // 去首尾并压缩多余内部空白
          s = s.trim().replace(/\s+/g, ' ');
          return s;
        },

        // 安全获取指定学生的时段 Map（已标准化姓名，并支持 weekday 0->7 归一化）
        getStudentTimeSlots: (name) => {
          const key = utils.normalizeStudentName(name);
          const m = appState.timeSlots.get(key) || appState.timeSlots.get(name) || {};
          // 复制并将 0 号星期映射为 7，避免取不到
          const fixed = {};
          Object.keys(m || {}).forEach(k => {
            const wk = Number(k);
            if (!Number.isFinite(wk)) return;
            const norm = wk === 0 ? 7 : wk;
            fixed[norm] = (m[k] || []).slice();
          });
          return fixed;
        },
      formatTime: (date) => {
        return new Intl.DateTimeFormat('zh-CN', {
          hour: '2-digit',
          minute: '2-digit'
        }).format(date);
      },

      formatDuration: (minutes) => {
        if (minutes < 60) return `${Math.round(minutes)}分钟`;
        const hours = Math.floor(minutes / 60);
        const mins = Math.round(minutes % 60);
        return mins > 0 ? `${hours}小时${mins}分钟` : `${hours}小时`;
      },

      // 简洁格式，用于近七天练琴总结
      formatDurationShort: (minutes) => {
        if (minutes < 60) return `${Math.round(minutes)}分`;
        const hours = Math.floor(minutes / 60);
        const mins = Math.round(minutes % 60);
        return mins > 0 ? `${hours}时${mins}分` : `${hours}时`;
      },

      // 完整格式，用于学生卡片
      formatDurationFull: (minutes) => {
        if (minutes < 60) return `${Math.round(minutes)}分钟`;
        const hours = Math.floor(minutes / 60);
        const mins = Math.round(minutes % 60);
        return mins > 0 ? `${hours}小时${mins}分钟` : `${hours}小时`;
      },

      getDateKey: (timestamp) => {
        const date = new Date(timestamp);
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
      },

      getWeekday: (date) => {
        const day = date.getDay();
        return day === 0 ? 7 : day;
      },

      minutesFromDayStart: (date) => {
        return date.getHours() * 60 + date.getMinutes();
      },

      parseTimeSlot: (timeStr) => {
        if (!timeStr) return null;
        // 统一全角冒号/空白与零宽字符
        const raw = String(timeStr)
          .replace(/[\u200B-\u200D\uFEFF\u2060]/g, '')
          .replace(/[\u3000\u00A0]/g, ' ')
          .replace(/：/g, ':')
          .trim();
        const parts = raw.split(':').map(s => s.trim());
        if (parts.length < 2) return null;
        const hours = Number(parts[0]);
        const minutes = Number(parts[1]);
        if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return null;
        return hours * 60 + minutes;
      },

      getStudentInitials: (name) => {
        if (!name) return '?';
        const parts = name.trim().split('');
        return parts.length >= 2 ? parts.slice(-2).join('') : parts[0] || '?';
      },

      // 将多种星期表示归一到 1..7（周一..周日）；无法识别时返回 NaN
      normalizeWeekday: (val) => {
        if (val === null || val === undefined) return NaN;
        const n = Number(val);
        if (Number.isFinite(n)) {
          if (n === 0) return 7;
          if (n >= 1 && n <= 7) return n;
        }
        const s = String(val).trim();
        const map = {
          '1':1,'一':1,'周一':1,'星期一':1,'Mon':1,'Monday':1,
          '2':2,'二':2,'周二':2,'星期二':2,'Tue':2,'Tues':2,'Tuesday':2,
          '3':3,'三':3,'周三':3,'星期三':3,'Wed':3,'Wednesday':3,
          '4':4,'四':4,'周四':4,'星期四':4,'Thu':4,'Thur':4,'Thursday':4,
          '5':5,'五':5,'周五':5,'星期五':5,'Fri':5,'Friday':5,
          '6':6,'六':6,'周六':6,'星期六':6,'Sat':6,'Saturday':6,
          '7':7,'日':7,'天':7,'周日':7,'星期日':7,'星期天':7,'Sun':7,'Sunday':7
        };
        return map[s] ?? NaN;
      },

      // 简单编辑距离（Levenshtein）用于相似姓名排查
      editDistance: (a, b) => {
        a = String(a); b = String(b);
        const m = a.length, n = b.length;
        if (!m) return n; if (!n) return m;
        const dp = Array.from({length:m+1}, (_,i)=>Array(n+1).fill(0));
        for (let i=0;i<=m;i++) dp[i][0]=i;
        for (let j=0;j<=n;j++) dp[0][j]=j;
        for (let i=1;i<=m;i++){
          for (let j=1;j<=n;j++){
            const cost = a[i-1]===b[j-1]?0:1;
            dp[i][j] = Math.min(
              dp[i-1][j]+1,
              dp[i][j-1]+1,
              dp[i-1][j-1]+cost
            );
          }
        }
        return dp[m][n];
      },

      // 在 timeSlots 的键中找与给定姓名相似的候选（返回前5个）
  findSimilarStudentKeys: (name) => {
        const norm = utils.normalizeStudentName(name);
        const keys = Array.from(appState.timeSlots.keys());
        const scored = keys.map(k=>({k, d: utils.editDistance(norm, k)}));
        scored.sort((a,b)=>a.d-b.d);
        return scored.slice(0,5).map(x=>x.k);
  },

      isWithinTimeRange: (minutes, range) => {
        return minutes >= range.start && minutes < range.end;
      }
    };

    // ==== 后端备份读取辅助 ====
    // 统计用自然日 key（不受排行榜07:30切换影响）
    function getStatsDayKey(d){
      // 使用本地时区自然日：YYYY-MM-DD
      const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const da=String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    }
  const ENABLE_DAILY_PRACTICE_SUMMARIES = false; // 后端若无该表，保持 false 避免 404
    async function fetchDailyPracticeSummaries(studentName, startDate, endDate) {
      if (!ENABLE_DAILY_PRACTICE_SUMMARIES) return new Map();
      try {
        if (!supabaseClient) return new Map();
        const key = utils.normalizeStudentName(studentName);
        const from = utils.toIsoDate(startDate);
        const to = utils.toIsoDate(endDate);
        const { data, error } = await supabaseClient
          .from('daily_practice_summaries')
          .select('date,total_minutes')
          .eq('student_key', key)
          .gte('date', from)
          .lte('date', to)
          .order('date', { ascending: true });
  if (error) { console.warn('fetchDailyPracticeSummaries error:', error); return new Map(); }
        const map = new Map();
        (data||[]).forEach(r => map.set(r.date, Number(r.total_minutes)||0));
        return map;
      } catch (e) { console.warn('fetchDailyPracticeSummaries exception:', e); return new Map(); }
    }

    async function fetchDailyLeaderboardMap(date) {
      try {
        if (!supabaseClient) return null;
        const d = utils.toIsoDate(date);
        const { data, error } = await supabaseClient
          .from('leaderboard_daily')
          .select('student_key,rank')
          .eq('date', d);
        if (error) { console.warn('fetchDailyLeaderboardMap error:', error); return null; }
        if (!data || data.length === 0) return null;
        const m = new Map();
        data.forEach(r => m.set(utils.normalizeStudentName(r.student_key), r.rank));
        return m;
      } catch (e) { console.warn('fetchDailyLeaderboardMap exception:', e); return null; }
    }

  // 获取周榜数据：查询最近5个工作日的平均分（0分填充 + 今日实时覆盖）
    async function fetchWeeklyLeaderboardData() {
      try {
        if (!supabaseClient) return [];

    // 用与日榜一致的口径：活跃排行榜日期（07:30 切换）
    const refDate = getActiveLeaderboardDate();
    const endWorkday = nearestWorkdayOnOrBefore(refDate);
    const workdayDates = getLastNWorkdayDates(endWorkday, 5); // 最近5个工作日（含今天的活跃口径）
    const workdays = workdayDates.map(d => utils.toIsoDate(d));
    const todayStr = utils.toIsoDate(refDate);
    const isIncludeToday = workdays.includes(todayStr);
        
        dbg('周榜查询日期范围:', workdays);
        dbg('是否包含今天:', isIncludeToday, todayStr);
        
  // 查询这5天的所有数据（包含 no_practice=true 的记录，用0分填充）
        const { data, error } = await supabaseClient
          .from('leaderboard_daily')
          .select('student_key, total, date, no_practice')
          .in('date', workdays);
          
        if (error) { 
          console.warn('fetchWeeklyLeaderboardData error:', error); 
          return []; 
        }
        
        // 获取所有学生名单（从当前活跃学生和历史数据中）
        const allStudentNames = new Set();
        
        // 从历史数据中获取学生名单
        if (data) {
          data.forEach(record => {
            allStudentNames.add(record.student_key);
          });
        }
        
  // 从当前活跃学生中获取名单
        try {
          const activeStudents = Array.from(appState.students?.values?.() || []);
          activeStudents.forEach(student => {
            allStudentNames.add(student.name);
          });
        } catch (e) {
          // 如果没有活跃学生数据，从studentsMeta获取
          try {
            const metaEntries = Array.from(appState.studentsMeta?.entries?.() || []);
            metaEntries.forEach(([name]) => {
              allStudentNames.add(name);
            });
          } catch (e2) {
            dbg('无法获取学生名单:', e2);
          }
        }
        
        dbg('所有学生名单:', Array.from(allStudentNames));
        
        // 构建每个学生的5天数据映射
        const studentScores = new Map();
        
        // 初始化所有学生的5天数据为0分
        allStudentNames.forEach(studentName => {
          const normalizedName = utils.normalizeStudentName(studentName);
          const scoresByDate = {};
          workdays.forEach(date => {
            scoresByDate[date] = 0; // 默认0分
          });
          
          studentScores.set(normalizedName, {
            studentName: studentName,
            scoresByDate: scoresByDate,
            scores: []
          });
        });
        
        // 填入历史数据
        if (data) {
          data.forEach(record => {
            const normalizedName = utils.normalizeStudentName(record.student_key);
            if (studentScores.has(normalizedName)) {
              const studentData = studentScores.get(normalizedName);
              studentData.scoresByDate[record.date] = record.no_practice ? 0 : (record.total || 0);
            }
          });
        }
        
        // 如果包含今天（活跃口径），用实时分数覆盖今天的数据（对所有学生尝试实时计算）
        if (isIncludeToday) {
          try {
            const names = Array.from(allStudentNames);
            for (const name of names) {
              const normalizedName = utils.normalizeStudentName(name);
              if (!studentScores.has(normalizedName)) continue;
              try {
                // computeScore442 仅依赖 name，因此可用占位对象
                const realTimeScore = await computeScore442({ name });
                const studentData = studentScores.get(normalizedName);
                studentData.scoresByDate[todayStr] = realTimeScore.total || 0;
                // dbg(`${name} 实时分数:`, realTimeScore.total);
              } catch (e) {
                // 保持默认的0分
                dbg(`计算 ${name} 实时分数失败:`, e);
              }
            }
          } catch (e) {
            dbg('获取实时分数失败:', e);
          }
        }
        
        // 计算每个学生的5天平均分
        const weeklyRanking = [];
        studentScores.forEach((data, normalizedName) => {
          const scores = workdays.map(date => data.scoresByDate[date] || 0);
          const totalScore = scores.reduce((sum, score) => sum + score, 0);
          const averageScore = totalScore / 5; // 固定5天平均
          
          weeklyRanking.push({
            studentKey: normalizedName,
            studentName: data.studentName,
            averageScore: +averageScore.toFixed(2),
            dayCount: 5, // 固定显示5天
            scores: scores // 保留详细分数用于调试
          });
        });
        
        // 按平均分排序
        weeklyRanking.sort((a, b) => b.averageScore - a.averageScore);
        
        // 添加排名
        weeklyRanking.forEach((item, index) => {
          item.rank = index + 1;
        });
        
  dbg('周榜数据 (5天平均):', weeklyRanking.slice(0, 10)); // 只显示前10名避免日志过长
        return weeklyRanking;
        
      } catch (e) { 
        console.warn('fetchWeeklyLeaderboardData exception:', e); 
        return []; 
      }
    }

    // ==== 数据处理 ====
    class StudentData {
      constructor(name) {
        this.name = name;
        this.todayMinutes = { in: 0, out: 0 };
        this.weekMinutes = { in: 0, out: 0 };
        this.isPresent = false;
        this.currentStatus = 'offline'; // 'practicing-in', 'practicing-out', 'offline'
        this.currentRoom = null;
        this.currentStartTime = null;
        this.achievementRate = 0;
        this.weekStreak = 0;
        this.totalSessions = 0;
      }
    }

    // ==== Supabase 初始化 ====
    async function initializeSupabase() {
      try {
        setConnectionStatus('syncing', '连接中...');
        
        // 尝试加载 Supabase
        if (!window.supabase && !window.Supabase) {
          await loadSupabaseScript();
        }
        
        const supabase = window.supabase || window.Supabase;
        if (!supabase) {
          throw new Error('Supabase 库未找到');
        }
        
        supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        isConnected = true;
        setConnectionStatus('online', '已连接');
        
        return true;
      } catch (error) {
        console.error('Supabase 初始化失败:', error);
        setConnectionStatus('offline', '连接失败');
        return false;
      }
    }

    function loadSupabaseScript() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
        script.onload = resolve;
        script.onerror = () => {
          // 尝试备用 CDN
          const fallbackScript = document.createElement('script');
          fallbackScript.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/supabase.min.js';
          fallbackScript.onload = resolve;
          fallbackScript.onerror = reject;
          document.head.appendChild(fallbackScript);
        };
        document.head.appendChild(script);
      });
    }

    function setConnectionStatus(status, text) {
      const statusEl = document.getElementById('connectionStatus');
      if (!statusEl) return;
      
      statusEl.className = `connection-status ${status}`;
      statusEl.querySelector('span').textContent = text;
    }

    // 通用：分页获取整表/大结果集（避免 1000 行上限）
    async function fetchAllRowsPaginated({ table, select = '*', orderBy = 'id', ascending = true, pageSize = 1000, apply }) {
      if (!supabaseClient) throw new Error('Supabase 未初始化');
      const all = [];
      let from = 0;
      while (true) {
        let query = supabaseClient
          .from(table)
          .select(select)
          .order(orderBy, { ascending });
        if (typeof apply === 'function') {
          query = apply(query);
        }
        const { data, error } = await query.range(from, from + pageSize - 1);
        if (error) throw error;
        const batch = data || [];
        all.push(...batch);
        dbg(`[分页] ${table} 批次 ${from}-${from + pageSize - 1} 返回 ${batch.length} 行`);
        if (batch.length < pageSize) break;
        from += pageSize;
      }
      dbg(`[分页] ${table} 合计加载 ${all.length} 行`);
      return all;
    }

    // ==== 数据差异同步系统 ====
    
    // 数据版本管理
    const dataVersions = {
      practice_logs: { lastSync: 0, hash: null, count: 0 },
      student_database: { lastSync: 0, hash: null, count: 0 },
      student_time_slots: { lastSync: 0, hash: null, count: 0 },
      rooms: { lastSync: 0, hash: null, count: 0 }
    };
    
    // 计算数据哈希值
    function calculateDataHash(data, tableName) {
      if (!data || !Array.isArray(data)) return null;
      
      try {
        // 根据表类型选择关键字段进行哈希
        let keyFields;
        switch (tableName) {
          case 'practice_logs':
            keyFields = ['id', 'timestamp', 'student_name', 'room_name'];
            break;
          case 'student_database':
            keyFields = ['name', 'major', 'grade'];
            break;
          case 'student_time_slots':
            keyFields = ['id', 'student_name', 'day_of_week', 'time_slots'];
            break;
          case 'rooms':
            keyFields = ['id', 'name', 'room_type', 'updated_at'];
            break;
          default:
            keyFields = Object.keys(data[0] || {});
        }
        
        const hashData = data.map(item => 
          keyFields.map(field => item[field]).join('|')
        ).sort().join('||');
        
        // 简单哈希算法
        let hash = 0;
        for (let i = 0; i < hashData.length; i++) {
          const char = hashData.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // 转为32位整数
        }
        
        return hash.toString();
      } catch (e) {
        console.warn(`计算${tableName}哈希失败:`, e);
        return Date.now().toString();
      }
    }
    
    // 检查数据是否需要更新
    function needsDataUpdate(tableName, newData) {
      const version = dataVersions[tableName];
      if (!version) return true;
      
      const newHash = calculateDataHash(newData, tableName);
      const newCount = newData ? newData.length : 0;
      
      // 检查数据数量或哈希值是否变化
      const changed = version.hash !== newHash || version.count !== newCount;
      
      if (changed) {
        dbg(`${tableName} 数据变更: 数量 ${version.count}->${newCount}, 哈希 ${version.hash?.substr(0,8)}->${newHash?.substr(0,8)}`);
        
        // 更新版本信息
        dataVersions[tableName] = {
          lastSync: Date.now(),
          hash: newHash,
          count: newCount
        };
      }
      
      return changed;
    }
    
    // 差异同步特定表数据
    async function fetchDataWithDiff(tables) {
      if (!isConnected) return;
      
      const tablesToSync = Array.isArray(tables) ? tables : [tables];
      let hasChanges = false;
      
      try {
        setConnectionStatus('syncing', '检查数据变更...');
        
        for (const table of tablesToSync) {
          let data;
          
          // 根据表类型获取数据
          switch (table) {
            case 'practice_logs':
              const weekAgo = Date.now() - 8 * 24 * 60 * 60 * 1000;
              data = await fetchAllRowsPaginated({
                table: 'practice_logs',
                select: '*',
                orderBy: 'timestamp',
                ascending: true,
                pageSize: 1000,
                apply: (q) => q.gte('timestamp', new Date(weekAgo).toISOString())
              });
              break;
              
            case 'student_database':
              const result = await supabaseClient
                .from('student_database')
                .select('name, major, grade');
              data = result.data;
              break;
              
            case 'student_time_slots':
              data = await fetchAllRowsPaginated({
                table: 'student_time_slots',
                select: '*',
                orderBy: 'id',
                ascending: true,
                pageSize: 1000
              });
              break;
              
            case 'rooms':
              const roomsResult = await supabaseClient
                .from('rooms')
                .select('*');
              data = roomsResult.data;
              break;
          }
          
          // 检查是否需要更新
          if (needsDataUpdate(table, data)) {
            hasChanges = true;
            
            // 更新对应的全局数据
            switch (table) {
              case 'practice_logs':
                window.practiceLogsData = data || [];
                break;
              case 'student_database':
                window.studentDatabaseData = data || [];
                break;
              case 'student_time_slots':
                window.studentTimeSlotsData = data || [];
                break;
              case 'rooms':
                window.roomsData = data || [];
                break;
            }
            
            dbg(`${table} 数据已更新 (${data?.length || 0} 条记录)`);
          } else {
            dbg(`${table} 数据无变化，跳过更新`);
          }
        }
        
        if (hasChanges) {
          // 只有在有数据变化时才重新处理和渲染
          processAllData();
          setConnectionStatus('online', '数据已同步');
        } else {
          setConnectionStatus('online', '数据最新');
        }
        
      } catch (error) {
        console.error('差异同步失败:', error);
        setConnectionStatus('offline', '同步失败');
        throw error;
      }
    }
    
    // 处理所有数据的函数（从fetchAllData中提取）
    function processAllData() {
      try {
        dbg('=== 开始处理数据 ===');
        dbg('练琴日志数量:', window.practiceLogsData?.length || 0);
        dbg('学生信息数量:', window.studentDatabaseData?.length || 0);
        dbg('时间段数据数量:', window.studentTimeSlotsData?.length || 0);
        
        // 将处理后的数据更新到 appState
        if (window.practiceLogsData) {
          appState.practiceLogs = window.practiceLogsData;
        }
        if (window.studentDatabaseData) {
          appState.studentsMeta.clear();
          window.studentDatabaseData.forEach(student => {
            appState.studentsMeta.set(student.name, {
              major: student.major || '',
              grade: student.grade || ''
            });
          });
        }
        if (window.studentTimeSlotsData) {
          appState.timeSlots.clear();
          window.studentTimeSlotsData.forEach(slot => {
            const studentName = slot.student_name;
            if (!appState.timeSlots.has(studentName)) {
              appState.timeSlots.set(studentName, {});
            }
            const studentSlots = appState.timeSlots.get(studentName);
            studentSlots[slot.weekday] = slot.time_slots || [];
          });
        }
        
        // 重新分析学生数据（这会更新 appState.students）
        analyzeStudentData(window.roomsData || []);
        
        // 智能同步：检查数据是否真正发生变化再更新排行榜
        const currentDataHash = generateDataHash();
        if (currentDataHash !== lastDataHash) {
          lastDataHash = currentDataHash;
          consecutiveNoChangeCount = 0;
          
          dbg('数据确实发生变化，更新排行榜');
          if (typeof debouncedUpdateRanking === 'function') debouncedUpdateRanking();
          if (typeof debouncedRenderHomeBins === 'function') debouncedRenderHomeBins();
        } else {
          consecutiveNoChangeCount++;
          dbg(`数据无变化 (连续${consecutiveNoChangeCount}次)`);
          
          // 如果连续多次无变化，降低更新频率
          if (consecutiveNoChangeCount >= 5) {
            dbg('连续无变化，跳过UI更新');
            return;
          }
        }
        
      } catch (error) {
        console.error('数据处理失败:', error);
        setConnectionStatus('offline', '处理失败');
      }
    }
    
    // ==== 原始数据获取函数（完整同步） ====
    async function fetchAllData() {
      dbg('=== fetchAllData 开始执行 ===');
      if (!isConnected) {
        dbg('fetchAllData: 连接未建立，跳过');
        return;
      }
      
      try {
        setConnectionStatus('syncing', '同步数据...');
        dbg('开始 Supabase 查询...');
        
        const now = Date.now();
        const weekAgo = now - 8 * 24 * 60 * 60 * 1000;
        
  const [logsData, metaResult, slotsData, roomsResult] = await Promise.all([
          fetchAllRowsPaginated({
            table: 'practice_logs',
            select: '*',
            orderBy: 'timestamp',
            ascending: true,
            pageSize: 1000,
            apply: (q) => q.gte('timestamp', new Date(weekAgo).toISOString())
          }),
          supabaseClient
            .from('student_database')
            .select('name, major, grade'),
          fetchAllRowsPaginated({
            table: 'student_time_slots',
            select: '*',
            orderBy: 'id',
            ascending: true,
            pageSize: 1000
          }),
          supabaseClient
            .from('rooms')
            .select('*')
        ]);

        if (metaResult && metaResult.error) {
          console.error('学生信息查询错误:', metaResult.error);
          throw metaResult.error;
        }
        if(!roomsResult || roomsResult.error){
          console.warn('房间数据查询异常:', roomsResult && roomsResult.error ? roomsResult.error.message : '返回空对象');
        }
        
        dbg('=== 开始处理数据 ===');
        dbg('练琴日志数量:', Array.isArray(logsData) ? logsData.length : 0);
        dbg('学生信息数量:', metaResult.data?.length || 0);
        dbg('时间段数据数量:', Array.isArray(slotsData) ? slotsData.length : 0);
        
        // 存储到全局变量以供差异同步使用
        window.practiceLogsData = logsData || [];
        window.studentDatabaseData = metaResult.data || [];
        window.studentTimeSlotsData = slotsData || [];
        window.roomsData = roomsResult.data || [];
        
        // 更新版本信息
        needsDataUpdate('practice_logs', window.practiceLogsData);
        needsDataUpdate('student_database', window.studentDatabaseData);
        needsDataUpdate('student_time_slots', window.studentTimeSlotsData);
        needsDataUpdate('rooms', window.roomsData);
        
        // 处理数据
        appState.practiceLogs = logsData || [];
        // 新增：标准化日志（兼容不同列名），便于后续统一处理
        if(!Array.isArray(appState.practiceLogsNormalized)) appState.practiceLogsNormalized = [];
        appState.practiceLogsNormalized = appState.practiceLogs.map(r=>({
          student_name: r.student_name || r.student || r.studentName || '',
          room_name: r.room_name || r.room || r.roomName || '',
          action: (r.action||'').toLowerCase(),
          timestamp: r.timestamp,
          // 优先使用新列，回退旧列
          session_start: r.session_start || r.start_time || null,
          session_end: r.session_end || r.end_time || null,
          practice_duration: r.practice_duration || r.duration || null
        }));
        
        // 学生元信息
        appState.studentsMeta.clear();
        (metaResult.data || []).forEach(student => {
          if (student.name) {
            const norm = utils.normalizeStudentName(student.name);
            appState.studentsMeta.set(norm, {
              major: student.major || '',
              grade: student.grade || ''
              // external_id 字段已从后端移除，保留注释防止误用
            });
          }
        });

        // === 补丁：剔除已不在 student_database 的旧缓存学生 ===
        (function purgeRemovedStudents(){
          if(!appState.students || !(appState.students instanceof Map)) return;
          const currentNames = new Set((metaResult.data||[]).map(s=>utils.normalizeStudentName(s.name||'')));
          const removed = [];
          for(const name of Array.from(appState.students.keys())){
            if(!currentNames.has(utils.normalizeStudentName(name))){
              removed.push(name);
              appState.students.delete(name);
            }
          }
          if(removed.length){
            try{ localStorage.removeItem('rank_cache_v2'); }catch(_){ }
            if(window.__scoreCache) window.__scoreCache.clear();
            dbg('已剔除已删除学生并失效排行榜缓存:', removed);
          }
        })();
        
        // 时间段配置
        appState.timeSlots.clear();
        dbg('时间段原始数据:', slotsData);
        dbg('时间段原始数据长度:', Array.isArray(slotsData) ? slotsData.length : 0);
        // 处理时间段数据 - 优化版本
        if (Array.isArray(slotsData) && slotsData.length > 0) {
          // 批量处理，减少单条处理开销
          const nameCache = new Map();
          
          slotsData.forEach(slot => {
            // 使用缓存减少重复的姓名标准化
            let nameRaw = slot?.student_name ?? slot?.student ?? slot?.studentName ?? slot?.name ?? '';
            // external_id 反查逻辑已移除（字段下线）
            
            const name = utils.normalizeStudentName(nameRaw);
            if (!name) return;
            
            // 兼容列名：weekday/day_of_week, start_time/start, end_time/end
            const weekdayRaw = slot.weekday ?? slot.day_of_week ?? slot.dow;
            const weekday = utils.normalizeWeekday(weekdayRaw);

            const startTime = slot.start_time ?? slot.start; // 字符串 "HH:MM"
            const endTime = slot.end_time ?? slot.end;       // 字符串 "HH:MM"
            
            if (isFinite(weekday) && startTime && endTime) {
              if (!appState.timeSlots.has(name)) {
                appState.timeSlots.set(name, {});
              }
              const timeMap = appState.timeSlots.get(name);
              if (!timeMap[weekday]) timeMap[weekday] = [];
              timeMap[weekday].push({ 
                start_time: startTime, 
                end_time: endTime,
                duration_minutes: slot.duration_minutes || 0
              });
            }
          });
        }
        
        // 处理当前房间状态
        const roomsData = (roomsResult && Array.isArray(roomsResult.data)) ? roomsResult.data : [];
        if(!roomsResult || !Array.isArray(roomsResult.data)){
          dbg('roomsResult 非预期：', roomsResult);
        }
        
        // 分析数据并生成学生状态
        analyzeStudentData(roomsData);
        
        // 智能同步：检查数据是否真正发生变化再更新排行榜
        const currentDataHash = generateDataHash(appState.students);
        if (!lastDataHash || lastDataHash !== currentDataHash) {
          dbg('数据发生变化，清除缓存并更新排行榜');
          // 清除所有缓存确保一致性
          try {
            localStorage.removeItem('rank_cache_v2');
            rankingDataCache = null;
            lastRankingUpdateTime = 0;
          } catch(_) {}
          if (typeof debouncedUpdateRanking === 'function') debouncedUpdateRanking();
          lastDataHash = currentDataHash;
        } else {
          dbg('数据未变化，跳过排行榜更新');
        }
        
        setConnectionStatus('online', '已连接');
        
      } catch (error) {
        console.error('数据获取失败:', error);
        try { showToast('数据获取失败: '+ (error && error.message ? error.message : '未知错误')); } catch(_){}
        setConnectionStatus('offline', '同步失败');
      }
    }

  function analyzeStudentData(roomsData) {
      appState.students.clear();
      
      // 从练琴日志分析每个学生的数据
      const studentLogs = new Map();
      
      appState.practiceLogs.forEach(log => {
        const studentName = utils.normalizeStudentName(log.student_name || log.student || log.studentName);
        if (!studentName) return;
        
        if (!studentLogs.has(studentName)) {
          studentLogs.set(studentName, []);
        }
        studentLogs.get(studentName).push(log);
      });
      
      // 获取所有学生（包括有时间段配置但没有练琴日志的学生）
      const allStudentNames = new Set();
      
      // 从练琴日志中获取学生名单
      studentLogs.forEach((logs, studentName) => {
        allStudentNames.add(studentName);
      });
      
      // 从学生数据库中获取学生名单
      appState.studentsMeta.forEach((meta, studentName) => {
        allStudentNames.add(studentName);
      });
      
      // 从时间段配置中获取学生名单
      appState.timeSlots.forEach((slots, studentName) => {
        allStudentNames.add(studentName);
      });
      
      // 调试时段数据状态
      dbg('=== 时段数据状态检查 ===');
      dbg('timeSlots 总数:', appState.timeSlots.size);
      dbg('timeSlots 所有键:', Array.from(appState.timeSlots.keys()));
      dbg('王申崚的时段数据:', appState.timeSlots.get('王申崚'));
      
      // 处理每个学生的数据
  dbg('所有学生名单:', Array.from(allStudentNames));
      allStudentNames.forEach(studentName => {
        const studentData = new StudentData(studentName);
        const logs = studentLogs.get(studentName) || [];
        processStudentLogs(studentData, logs);
        
  dbg(`学生 ${studentName} 的数据:`, {
          todayMinutes: studentData.todayMinutes,
          hasSchedule: hasScheduleToday(studentName),
          timeSlots: appState.timeSlots.get(studentName)
        });
        
        // 检查当前状态（从rooms表）
        const currentRoom = roomsData.find(room => {
          const occupant = utils.normalizeStudentName(room.occupant_student_name || room.occupant_student || room.occupant);
          return occupant === studentName;
        });
        
        if (currentRoom) {
          // 跨日/过期会话保护：只在“自然日”为今天且在统计窗口(07:30-21:30)内才认定为当前练琴
          let startTs = currentRoom.register_time ? new Date(currentRoom.register_time) : null;
          const now = new Date();
          const isSameDay = startTs && startTs.getFullYear()===now.getFullYear() && startTs.getMonth()===now.getMonth() && startTs.getDate()===now.getDate();
          const minutesNow = utils.minutesFromDayStart(now);
          const win = getEffectiveDayWindow(now);
          const startMin = startTs ? utils.minutesFromDayStart(startTs) : -1;
          const inWindowNow = minutesNow>=win.start && minutesNow<=win.end;
          const inWindowStart = startMin>=win.start && startMin<=win.end;
          if(isSameDay && inWindowNow && inWindowStart){
            studentData.currentStatus = getCurrentPracticeStatus(studentName);
            studentData.currentRoom = currentRoom.name || currentRoom.room_name || '未知房间';
            studentData.currentStartTime = startTs;
          }else{
            // 过期：视为离线
            studentData.currentStatus = 'offline';
            studentData.currentRoom = null;
            studentData.currentStartTime = null;
          }
        }
        
        appState.students.set(studentName, studentData);
      });
      
  // 更新UI
  updateStatistics();
  updateViews();
    }

  /**
  * 根据日志构建日区间并计算今日/近7天练琴分钟数（剔除休息时间与无效时间段）。
  * 注：总体统计窗口已采用 07:30-21:30（含周末），排行榜使用独立窗口：周一/二/四/五 08:00-18:40，周三 08:00-19:10；排行榜日界定 07:30 切换。
   */
  function processStudentLogs(studentData, logs) {
  // 不预先过滤日志，先按 assign/clear 配对，再将所得区间裁剪到有效窗口
  // 这样可避免一端落在窗口外导致整段被丢弃的情况（如 07:59-08:20 或 18:50-19:10）
  dbg(`学生 ${studentData.name}: 原始日志 ${logs.length} 条（将先配对后裁剪）`);

  const sortedLogs = [...logs].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      
      const today = new Date();
      const todayKey = utils.getDateKey(today);
      const dayIntervals = new Map(); // dateKey -> intervals
      
      let currentSessionStart = null;
      
      // 构建练琴区间
      sortedLogs.forEach(log => {
        const timestamp = new Date(log.timestamp);
        const dateKey = utils.getDateKey(timestamp);
        
        if (!dayIntervals.has(dateKey)) {
          dayIntervals.set(dateKey, []);
        }
        
        if (log.action === 'assign') {
          if (!currentSessionStart) {
            currentSessionStart = timestamp;
          }
        } else if (log.action === 'clear' && currentSessionStart) {
          // 记录一个完整的练琴区间
          const startDay = utils.getDateKey(currentSessionStart);
          const endDay = dateKey;
          
          if (startDay === endDay) {
            // 同一天：裁剪到对应星期的有效时间窗口
            const dayWindow = getEffectiveDayWindow(currentSessionStart);
            const rawStart = utils.minutesFromDayStart(currentSessionStart);
            const rawEnd = utils.minutesFromDayStart(timestamp);
            const clampedStart = Math.max(rawStart, dayWindow.start);
            const clampedEnd = Math.min(rawEnd, dayWindow.end);
            if (clampedEnd > clampedStart) {
              dayIntervals.get(dateKey).push({ start: clampedStart, end: clampedEnd });
              dbg(`区间(同日) ${startDay} 原始 ${rawStart}-${rawEnd} 裁剪为 ${clampedStart}-${clampedEnd}`);
            } else {
              dbg(`丢弃区间(同日) ${startDay} 原始 ${rawStart}-${rawEnd}（与有效窗口无交集）`);
            }
          } else {
            // 跨天处理：
            // 第一天：max(start, 当天开始时间) -> 当天结束时间
            const firstDayWindow = getEffectiveDayWindow(currentSessionStart);
            const startMinutes = utils.minutesFromDayStart(currentSessionStart);
            const dayStartLimit = firstDayWindow.start;
            const dayEndLimit = firstDayWindow.end;
            const firstDayStart = Math.max(startMinutes, dayStartLimit);
            if (firstDayStart < dayEndLimit) {
              if (!dayIntervals.has(startDay)) dayIntervals.set(startDay, []);
              dayIntervals.get(startDay).push({ start: firstDayStart, end: dayEndLimit });
              dbg(`区间(跨日-首日) ${startDay} 原始 ${startMinutes}-? 裁剪为 ${firstDayStart}-${dayEndLimit}`);
            } else {
              dbg(`丢弃区间(跨日-首日) ${startDay} 原始 ${startMinutes}-?（与有效窗口无交集）`);
            }

            // 第二天：当天开始时间 -> min(clear, 当天结束时间)
            const secondDayWindow = getEffectiveDayWindow(timestamp);
            const endMinutes = utils.minutesFromDayStart(timestamp);
            const secondDayEnd = Math.min(endMinutes, secondDayWindow.end);
            if (secondDayEnd > secondDayWindow.start) {
              if (!dayIntervals.has(endDay)) dayIntervals.set(endDay, []);
              dayIntervals.get(endDay).push({ start: secondDayWindow.start, end: secondDayEnd });
              dbg(`区间(跨日-次日) ${endDay} 原始 ?-${endMinutes} 裁剪为 ${secondDayWindow.start}-${secondDayEnd}`);
            } else {
              dbg(`丢弃区间(跨日-次日) ${endDay} 原始 ?-${endMinutes}（与有效窗口无交集）`);
            }
          }
          
          currentSessionStart = null;
          studentData.totalSessions++;
        }
      });
      
      // 如果还有未结束的会话，计算到现在或当日统计截止（21:30），不超过当天有效时间
      if (currentSessionStart) {
        const now = new Date();
        const nowWindow = getEffectiveDayWindow(now);
        const nowMinutes = utils.minutesFromDayStart(now);
        
        // 只要当前时间未早于开始窗口，就将会话结算到 min(当前时刻, 截止 21:30)
        if (nowMinutes >= nowWindow.start) {
          const startDay = utils.getDateKey(currentSessionStart);
          const nowDay = utils.getDateKey(now);
          
          if (startDay === nowDay) {
            const rawStart = utils.minutesFromDayStart(currentSessionStart);
            const clampedStart = Math.max(rawStart, nowWindow.start);
            const clampedEnd = Math.min(nowMinutes, nowWindow.end);
            if (clampedEnd > clampedStart) {
              if (!dayIntervals.has(nowDay)) {
                dayIntervals.set(nowDay, []);
              }
              dayIntervals.get(nowDay).push({ start: clampedStart, end: clampedEnd });
              dbg(`区间(未结束-同日) ${nowDay} 原始 ${rawStart}-${nowMinutes} 裁剪为 ${clampedStart}-${clampedEnd}`);
            }
          }
        }
        
        studentData.totalSessions++;
      }
      
      // 计算今日和本周的练琴时间
      dayIntervals.forEach((intervals, dateKey) => {
        const date = new Date(dateKey + 'T00:00:00');
        const dayData = calculateDayPracticeTime(studentData.name, date, intervals);
        
        if (dateKey === todayKey) {
          studentData.todayMinutes = dayData;
          studentData.isPresent = dayData.in > 0;
        }
        
        // 计算是否在本周范围内（过去7天）
        const daysDiff = Math.floor((today - date) / (24 * 60 * 60 * 1000));
        if (daysDiff >= 1 && daysDiff <= 7) {
          studentData.weekMinutes.in += dayData.in;
          studentData.weekMinutes.out += dayData.out;
        }
      });
      
      // 计算成就率和连续天数
      studentData.achievementRate = calculateAchievementRate(studentData.name, studentData.todayMinutes.in);
      studentData.weekStreak = calculateWeekStreak(studentData.name, dayIntervals);
    }

  /**
   * 计算某日的“规定时间内”和“规定时间外”的分钟数。
   * 会在剔除休息时间后再与学生个性化时段进行交集计算。
   */
  function calculateDayPracticeTime(studentName, date, intervals) {
      const dateKey = utils.getDateKey(date);
      
      // 检查 practiceLogs 是否存在
      if (!appState.practiceLogs || !Array.isArray(appState.practiceLogs)) {
        console.warn('practiceLogs not available for calculateDayPracticeTime');
        return { in: 0, out: 0 };
      }
      
      const studentLogs = appState.practiceLogs.filter(log => {
        const logStudentName = log.student_name || log.student || log.studentName;
        return logStudentName === studentName && utils.getDateKey(new Date(log.timestamp)) === dateKey;
      });

      if (studentLogs.length === 0) {
        return { in: 0, out: 0 };
      }

      // 构建当天的练琴间隔 - 与calculateDayData保持一致
      const sessions = buildPracticeSessions(studentLogs, studentName);
      const dayWindow = getEffectiveDayWindow(date);
      const sessionIntervals = sessions.map(session => {
        const start = utils.minutesFromDayStart(new Date(session.start));
        const end = session.end ? utils.minutesFromDayStart(new Date(session.end)) : utils.minutesFromDayStart(new Date());
        // 裁剪到当天的有效时间窗口
        return { start: Math.max(start, dayWindow.start), end: Math.min(end, dayWindow.end) };
      }).filter(i => i.end > i.start);

      // 剔除休息时间（周末不剔除）
      const weekday = utils.getWeekday(date);
      let practiceIntervals;
      if (weekday === 6 || weekday === 7) {
        // 周末：直接使用裁剪后的 sessionIntervals
        practiceIntervals = sessionIntervals;
      } else {
        const breaks = weekday === 3 ? BREAK_SCHEDULE.wed : BREAK_SCHEDULE.monTueThuFri;
        practiceIntervals = subtractBreaks(sessionIntervals, breaks);
      }
      
      // 获取学生的个性化时间窗口
      const timeSlots = utils.getStudentTimeSlots(studentName);
      // 将字符串形式的个性化时段转换为分钟区间，若无配置则使用默认窗口
      const daySlots = (timeSlots && timeSlots[weekday] && timeSlots[weekday].length > 0)
        ? timeSlots[weekday].map(slot => {
            if (typeof slot.start === 'number' && typeof slot.end === 'number') return slot; // 已是数值窗口
            const start = utils.parseTimeSlot(slot.start_time || slot.start);
            const end = utils.parseTimeSlot(slot.end_time || slot.end);
            return { start, end };
          }).filter(w => Number.isFinite(w.start) && Number.isFinite(w.end) && w.end > w.start)
        : [
            typeof DEFAULT_SCHEDULE_IN.start === 'number' ? DEFAULT_SCHEDULE_IN : {
              start: utils.parseTimeSlot(DEFAULT_SCHEDULE_IN.start_time || DEFAULT_SCHEDULE_IN.start || '08:00'),
              end: utils.parseTimeSlot(DEFAULT_SCHEDULE_IN.end_time || DEFAULT_SCHEDULE_IN.end || '19:30')
            }
          ];
      
      // 分离段内和段外时间
      const { inTime, outTime } = splitByTimeWindows(practiceIntervals, daySlots);
      
      return {
        in: inTime,
        out: outTime
      };
    }
    
    // 验证练琴时间是否在有效统计范围内（按星期几判断）
    function isValidPracticeTime(timestamp) {
      const date = new Date(timestamp);
      const window = getEffectiveDayWindow(date);
      const minutes = date.getHours() * 60 + date.getMinutes();
      return minutes >= window.start && minutes <= window.end;
    }

    function subtractBreaks(intervals, breaks) {
      let result = [...intervals];
      
      breaks.forEach(breakTime => {
        result = result.flatMap(interval => {
          if (interval.end <= breakTime.start || interval.start >= breakTime.end) {
            return [interval];
          }
          
          const parts = [];
          if (interval.start < breakTime.start) {
            parts.push({
              start: interval.start,
              end: Math.min(interval.end, breakTime.start)
            });
          }
          if (interval.end > breakTime.end) {
            parts.push({
              start: Math.max(interval.start, breakTime.end),
              end: interval.end
            });
          }
          return parts;
        });
      });
      
      return result;
    }

  /**
   * 将给定区间按窗口集合拆分为 in/out 两类分钟总和。
   */
  function splitByTimeWindows(intervals, windows) {
      let inTime = 0;
      let outTime = 0;
      
      intervals.forEach(interval => {
        const duration = interval.end - interval.start;
        
        // 检查是否与任何时间窗口重叠 - 使用更准确的重叠检测
        const isInWindow = windows.some(window => {
          // 两个区间重叠的条件：interval.start < window.end && interval.end > window.start
          return interval.start < window.end && interval.end > window.start;
        });
        
        if (isInWindow) {
          inTime += duration;
        } else {
          outTime += duration;
        }
      });
      
      return { inTime, outTime };
    }

  /**
  * 获取当前时刻学生练琴状态：
  * - 有效时间窗口（总体统计）之外一律 offline（总体统计窗口 07:30-21:30）
  * - 排行榜窗口与此不同（周1/2/4/5 08:00-18:40；周3 08:00-19:10；07:30 日界定仅用于排名天切换）
  * - 其余根据是否落入“规定时间段内”返回 practicing-in / practicing-out
   */
  function getCurrentPracticeStatus(studentName) {
      const now = new Date();
      const nowWindow = getEffectiveDayWindow(now);
      const todayMinutes = utils.minutesFromDayStart(now);
      
      // 有效时间窗口外不记录练琴状态，直接返回offline
  if (todayMinutes < nowWindow.start || todayMinutes > nowWindow.end) {
        return 'offline';
      }

      // 复用 isCurrentlyScheduled，内部已处理个性化时段
      const scheduled = isCurrentlyScheduled(studentName);
      return scheduled ? 'practicing-in' : 'practicing-out';
    }

  /**
   * 计算今日成就率：今日“规定时间内”分钟 / 今日“规定时间内”目标分钟（基于时段配置）。
   */
  function calculateAchievementRate(studentName, todayInMinutes) {
      const today = new Date();
      const weekday = utils.getWeekday(today);
  const timeSlots = utils.getStudentTimeSlots(studentName);
      
      if (!timeSlots || !timeSlots[weekday]) return 0;
      // 统一转换为分钟窗口
      const windows = timeSlots[weekday]
        .map(slot => {
          if (typeof slot.start === 'number' && typeof slot.end === 'number') return slot;
          const start = utils.parseTimeSlot(slot.start_time || slot.start);
          const end = utils.parseTimeSlot(slot.end_time || slot.end);
          return { start, end };
        })
        .filter(w => Number.isFinite(w.start) && Number.isFinite(w.end) && w.end > w.start);

      const totalScheduled = windows.reduce((sum, w) => sum + (w.end - w.start), 0);
      
      return totalScheduled > 0 ? Math.min(100, Math.round((todayInMinutes / totalScheduled) * 100)) : 0;
    }

    function calculateWeekStreak(studentName, dayIntervals) {
      const today = new Date();
      let streak = 0;
      
      for (let i = 0; i < 7; i++) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateKey = utils.getDateKey(date);
        
        const intervals = dayIntervals.get(dateKey) || [];
        const dayData = calculateDayPracticeTime(studentName, date, intervals);
        
        if (dayData.in > 0) {
          streak++;
        } else if (i === 0) {
          break; // 今天没练，连续记录中断
        }
      }
      
      return streak;
    }

    function hasScheduleToday(studentName) {
      const today = new Date();
      const weekday = utils.getWeekday(today);
  const timeSlots = utils.getStudentTimeSlots(studentName);
      return timeSlots && timeSlots[weekday] && timeSlots[weekday].length > 0;
    }

  /** 检查当前时间是否在学生的练琴时段内（基于个性化时段配置） */
    function isCurrentlyScheduled(studentName) {
      const now = new Date();
      const weekday = utils.getWeekday(now);
      const currentTime = now.getHours() * 60 + now.getMinutes(); // 当前时间转换为分钟
      
  const timeSlots = utils.getStudentTimeSlots(studentName);
      if (!timeSlots || !timeSlots[weekday]) {
  dbg(`学生 ${studentName} 在星期${weekday}没有时间段配置`);
        return false;
      }
      
      const isScheduled = timeSlots[weekday].some(slot => {
        // 支持两种格式：字符串 start_time/end_time 或数值 start/end
        let startMinutes, endMinutes;
        if (typeof slot.start === 'number' && typeof slot.end === 'number') {
          startMinutes = slot.start; endMinutes = slot.end;
        } else {
          const start = utils.parseTimeSlot(slot.start_time || slot.start);
          const end = utils.parseTimeSlot(slot.end_time || slot.end);
          startMinutes = start; endMinutes = end;
        }
        const inRange = currentTime >= startMinutes && currentTime < endMinutes;
        dbg(`学生 ${studentName} 时间段 ${startMinutes}-${endMinutes}，当前 ${currentTime}，inRange=${inRange}`);
        return inRange;
      });
      
  dbg(`学生 ${studentName} 当前是否应该练琴: ${isScheduled}`);
      return isScheduled;
    }

    // ==== UI 渲染和交互 ====
    function updateStatistics() { /* 精简版：不显示顶部统计，保留数据计算备用 */ }

    const uiState = { 
      view: 'home', // 'home', 'list', 'detail'
      category: 'attendance', // 'attendance', 'absent', 'self-practice', 'not-practice'
      clickedElement: null,
      selectedStudent: null,
  previousView: null, // 记录上一个视图，用于控制动画
  rankingOrigin: null // 记录进入“完整排行榜”的来源（home 或 list）
    };

    // 排行榜显示模式
    let rankingMode = 'daily'; // 'daily' 或 'weekly'
    // 排行榜模式 HTML 内存缓存，避免日/周切换闪烁
    if(!window.rankingModeHtmlCache){
      window.rankingModeHtmlCache = { daily: null, weekly: null };
    }
    const RANKING_FADE_CLASS = 'ranking-fade-in';

    // 管理员模式相关
    let adminMode = false;
  const ADMIN_PASSWORD = 'gaifen2022';
    // 不再依赖 localStorage 持久化调分（之前已移除），仅内存缓存
    const adminScoreAdjustments = {};
  // 排行榜缓存 key（供首页小榜与完整榜共享 & 清理）
  const RANK_CACHE_KEY = 'rank_cache_v2';
  // 统一规则版本（避免硬编码分散 & 确保 NOT NULL 约束）
  const RULE_VERSION = 'LB442-2025-09-24';
    // 自定义异步密码弹窗，每次都要求输入密码
    function ensureAdminAuthenticated(){
      return new Promise(resolve => {
        if(document.querySelector('.admin-auth-dialog')) return; // 已存在则不重复
        const wrap = document.createElement('div');
        wrap.className = 'admin-auth-dialog';
        wrap.innerHTML = `
          <div class="admin-auth-backdrop"></div>
          <div class="admin-auth-content">
            <h3 style="margin:0 0 16px;font-size:18px;color:#111827;font-weight:600;">管理员验证</h3>
            <label style="display:block;font-size:14px;color:#374151;margin-bottom:6px;">请输入管理员密码</label>
            <div style="position:relative;">
              <input id="adminAuthPassword" type="password" autocomplete="off" placeholder="密码" style="width:100%;padding:10px 40px 10px 12px;border:1px solid #d1d5db;border-radius:6px;font-size:14px;outline:none;">
              <button type="button" id="adminAuthToggle" aria-label="显示/隐藏密码" style="position:absolute;right:8px;top:50%;transform:translateY(-50%);border:none;background:transparent;cursor:pointer;font-size:16px;">👁️</button>
            </div>
            <div id="adminAuthError" style="color:#ef4444;font-size:12px;min-height:16px;margin-top:6px;"></div>
            <div style="display:flex;justify-content:flex-end;margin-top:20px;gap:8px;">
              <button type="button" id="adminAuthCancel" style="padding:8px 16px;border:1px solid #d1d5db;background:white;border-radius:6px;cursor:pointer;font-size:14px;">取消</button>
              <button type="button" id="adminAuthOk" style="padding:8px 16px;background:#2563eb;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;">确认</button>
            </div>
          </div>`;
        const style = document.createElement('style');
        style.textContent = `
          .admin-auth-dialog{position:fixed;inset:0;z-index:11000;display:flex;align-items:center;justify-content:center;font-family:inherit;}
          .admin-auth-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);}
          .admin-auth-content{position:relative;background:#fff;border-radius:10px;padding:24px 24px 20px;box-shadow:0 20px 25px -5px rgba(0,0,0,.1),0 10px 10px -5px rgba(0,0,0,.04);width:90%;max-width:360px;animation:adminAuthPop .18s ease;}
          @keyframes adminAuthPop{0%{transform:scale(.92);opacity:0;}100%{transform:scale(1);opacity:1;}}
          .admin-auth-shake{animation:adminAuthShake .4s;}@keyframes adminAuthShake{10%,90%{transform:translateX(-1px);}20%,80%{transform:translateX(2px);}30%,50%,70%{transform:translateX(-4px);}40%,60%{transform:translateX(4px);}}
        `;
        document.head.appendChild(style);
        document.body.appendChild(wrap);
        const inputEl = wrap.querySelector('#adminAuthPassword');
        const errEl = wrap.querySelector('#adminAuthError');
        const okBtn = wrap.querySelector('#adminAuthOk');
        const cancelBtn = wrap.querySelector('#adminAuthCancel');
        const toggleBtn = wrap.querySelector('#adminAuthToggle');
        function close(res){ wrap.remove(); resolve(res); }
        toggleBtn.addEventListener('click',()=>{
          if(inputEl.type==='password'){ inputEl.type='text'; toggleBtn.textContent='🙈'; }
          else { inputEl.type='password'; toggleBtn.textContent='👁️'; }
          inputEl.focus();
        });
        okBtn.addEventListener('click',()=>{
          const v = inputEl.value.trim();
          if(v===ADMIN_PASSWORD){ close(true); }
          else { errEl.textContent='密码错误'; wrap.querySelector('.admin-auth-content').classList.remove('admin-auth-shake'); void wrap.querySelector('.admin-auth-content').offsetWidth; wrap.querySelector('.admin-auth-content').classList.add('admin-auth-shake'); inputEl.focus(); inputEl.select(); }
        });
        cancelBtn.addEventListener('click',()=>close(false));
        wrap.querySelector('.admin-auth-backdrop').addEventListener('click',()=>close(false));
        inputEl.addEventListener('keydown',e=>{ if(e.key==='Enter') okBtn.click(); if(e.key==='Escape') close(false); });
        document.addEventListener('keydown',function escHandler(e){ if(e.key==='Escape'){ document.removeEventListener('keydown',escHandler); if(document.body.contains(wrap)) close(false);} });
        setTimeout(()=>inputEl.focus(),50);
      });
    }
    
    // 监听快捷键进入管理员模式 (Mac: Cmd+Shift+Option+A, Windows: Ctrl+Shift+Alt+A)
    document.addEventListener('keydown', async function(e) {
      const isMac = navigator.platform.toUpperCase().includes('MAC');
      const ctrlOrCmd = isMac ? e.metaKey : e.ctrlKey;
      const altOrOption = e.altKey;
      
      // 使用 keyCode 或 code 来确保跨平台兼容性
      const isAKey = e.key === 'A' || e.key === 'a' || e.code === 'KeyA' || e.keyCode === 65;
      
      if (ctrlOrCmd && e.shiftKey && altOrOption && isAKey) {
        e.preventDefault();
        if(!adminMode){
          const ok = await ensureAdminAuthenticated();
          if(!ok) return; // 未通过验证不进入
        }
        toggleAdminMode();
      }
    });

    function mapStudentToCardData(s) {
      const meta = appState.studentsMeta.get(s.name) || {};
  // 统一今日总时长口径（段内+段外），排除 NaN 并向下取整
  const totalMinutes = getTodayTotalMinutes(s);
      
      return {
        name: s.name,
        metaText: `${meta.grade || ''}${meta.grade ? ' · ' : ''}${meta.major || ''}`,
        minutes: Math.round(totalMinutes),
        status: s.currentStatus !== 'offline' ? 'active' : 'offline',
      };
    }

    // 统一今日总时长计算（列表与详情共用）
    function getTodayTotalMinutes(student){
      if(!student || !student.todayMinutes) return 0;
      const a = Number(student.todayMinutes.in)||0;
      const b = Number(student.todayMinutes.out)||0;
      return Math.max(0, Math.round(a + b));
    }

  /**
   * 首页分组统计：
   * - attendance: 当前应练且当前正在练（实时 currentStatus）
   * - absent: 当前应练但当前未练
   * - selfPractice: 当前不应练但当前在练
   * - notPractice: 当前不应练且当前未练
   */
  function getGroups() {
      const all = Array.from(appState.students.values());
      const now = new Date();
      const currentTime = now.getHours() * 60 + now.getMinutes();
      const weekday = now.getDay();
      
  dbg(`当前时间: ${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')} (${currentTime}分钟), 星期${weekday}`);
  dbg('所有学生数据:', all.map(s => ({ 
        name: s.name, 
        todayMinutes: s.todayMinutes, 
        currentStatus: s.currentStatus 
      })));
  dbg('时间段配置:', Array.from(appState.timeSlots.entries()));
      
      // 获取当前时间段应该练琴的学生
      const currentlyScheduled = all.filter(s => isCurrentlyScheduled(s.name));
      
  dbg('当前应该练琴的学生:', currentlyScheduled.map(s => s.name));
      
      // 分类逻辑：基于当前时间段和实时状态
      // 出勤：当前时间段应该练琴且当前正在练琴的学生
      const attendance = currentlyScheduled.filter(s => s.currentStatus !== 'offline');
      
      // 缺勤：当前时间段应该练琴但当前没有练琴的学生
      const absent = currentlyScheduled.filter(s => s.currentStatus === 'offline');
      
      // 自主练琴：当前时间段不需要练琴但当前正在练琴的学生
      const notScheduledNow = all.filter(s => !isCurrentlyScheduled(s.name));
      const selfPractice = notScheduledNow.filter(s => s.currentStatus !== 'offline');
      
      // 未练琴：当前时间段不需要练琴且当前没有练琴的学生
      const notPractice = notScheduledNow.filter(s => s.currentStatus === 'offline');
      
      // 当前应练琴人数（当前时间段应该练琴的学生）
      const shouldPracticeNow = currentlyScheduled.length;
      const totalCount = all.length;

  dbg(`分类结果: 出勤${attendance.length}人, 缺勤${absent.length}人, 自主练琴${selfPractice.length}人, 未练琴${notPractice.length}人`);
  dbg(`当前应练琴人数: ${shouldPracticeNow}, 总人数: ${totalCount}`);
  dbg('详细分类:', {
        attendance: attendance.map(s => ({ name: s.name, status: s.currentStatus })),
        absent: absent.map(s => ({ name: s.name, status: s.currentStatus })),
        selfPractice: selfPractice.map(s => ({ name: s.name, status: s.currentStatus })),
        notPractice: notPractice.map(s => ({ name: s.name, status: s.currentStatus }))
      });

      return { attendance, absent, selfPractice, notPractice, shouldPracticeNow, totalCount, mapped: false };
    }

    // 初始加载标志和用户交互标志
    let isInitialLoad = true;
    let userHasInteracted = false;
    let smartSelectionApplied = false; // 确保智能选择只应用一次
    
    // 智能选择优先显示的分类
    function selectPriorityCategory(groups) {
      const { attendance, selfPractice, notPractice } = groups;
      
      dbg(`🔍 智能选择分析:`);
      dbg(`  - 出勤: ${attendance.length}人 ${attendance.map(s => s.name).join(', ')}`);
      dbg(`  - 自主: ${selfPractice.length}人 ${selfPractice.map(s => s.name).join(', ')}`);
      dbg(`  - 未练: ${notPractice.length}人 ${notPractice.map(s => s.name).join(', ')}`);
      
      // 优先级判断：出勤 > 自主 > 未练
      if (attendance.length > 0) {
        dbg(`🎯 智能选择结果: "出勤" (${attendance.length}人)`);
        return 'attendance';
      } else if (selfPractice.length > 0) {
        dbg(`🎯 智能选择结果: "自主" (${selfPractice.length}人)`);
        return 'self-practice';
      } else {
        dbg(`🎯 智能选择结果: "未练" (${notPractice.length}人) - 默认选项`);
        return 'not-practice'; // 默认未练
      }
    }
    
    // 更新分类按钮的激活状态
    function updateCategoryTabs(selectedCategory) {
      const categoryTabs = document.querySelectorAll('.category-tab');
      let foundTab = false;
      categoryTabs.forEach(tab => {
        if (tab.dataset.category === selectedCategory) {
          tab.classList.add('active');
          foundTab = true;
        } else {
          tab.classList.remove('active');
        }
      });
      
      if (foundTab) {
        dbg(`✅ 分类按钮已更新为: ${selectedCategory}`);
      } else {
        dbg(`⚠️ 未找到分类按钮: ${selectedCategory}`);
      }
    }

    function renderHomeBins() {
      const groups = getGroups();
      const { attendance, absent, selfPractice, notPractice, shouldPracticeNow, totalCount } = groups;
      
      // 智能分类选择：仅在数据准备好且用户未交互时执行一次
      const totalStudents = attendance.length + absent.length + selfPractice.length + notPractice.length;
      
      dbg(`📋 智能选择状态检查:`);
      dbg(`  - smartSelectionApplied: ${smartSelectionApplied}`);
      dbg(`  - userHasInteracted: ${userHasInteracted}`);
      dbg(`  - totalStudents: ${totalStudents}`);
      dbg(`  - 当前分类: ${uiState.category}`);
      
      if (!smartSelectionApplied && !userHasInteracted && totalStudents > 0) {
        dbg('✅ 条件满足，执行智能分类选择...');
        dbg(`📊 当前数据统计: 出勤${attendance.length}人, 缺勤${absent.length}人, 自主${selfPractice.length}人, 未练${notPractice.length}人`);
        
        const priorityCategory = selectPriorityCategory(groups);
        const oldCategory = uiState.category;
        
        uiState.category = priorityCategory;
        updateCategoryTabs(priorityCategory);
        smartSelectionApplied = true;
        
        dbg(`🎯 智能选择完成: ${oldCategory} → ${priorityCategory}`);
      } else if (!smartSelectionApplied && userHasInteracted) {
        dbg('❌ 用户已交互，跳过智能选择');
        smartSelectionApplied = true;
      } else if (!smartSelectionApplied && totalStudents === 0) {
        dbg('⏳ 数据尚未准备好，延迟智能选择...');
      } else if (smartSelectionApplied) {
        dbg('✨ 智能选择已应用过，跳过');
      }
      
      // 标记初始加载完成（用于其他逻辑）
      if (isInitialLoad) {
        isInitialLoad = false;
      }
      
      // 更新日期显示
      const today = new Date();
      const dateStr = `${today.getMonth() + 1}月${today.getDate()}日`;
      document.getElementById('currentDate').textContent = dateStr;
      
      // 根据当前选中的分类更新显示
      const categoryData = {
        'attendance': { 
          data: attendance, 
          label: '出勤人数占当前应练琴人数的比例', 
          color: '#22c55e',
          denominator: shouldPracticeNow
        },
        'absent': { 
          data: absent, 
          label: '缺勤人数占当前应练琴人数的比例', 
          color: '#ef4444',
          denominator: shouldPracticeNow
        },
        'self-practice': { 
          data: selfPractice, 
          label: '自主练琴人数占总人数的比例', 
          color: '#f59e0b',
          denominator: totalCount
        },
        'not-practice': { 
          data: notPractice, 
          label: '未练琴人数占总人数的比例', 
          color: '#3b82f6', // 蓝色
          denominator: totalCount
        }
      };
      
      const currentCategory = categoryData[uiState.category];
      const currentCount = currentCategory.data.length;
      const denominatorCount = currentCategory.denominator;
      const percentage = denominatorCount > 0 ? Math.round((currentCount / denominatorCount) * 100) : 0;
      
      // 更新百分比和人数
      document.getElementById('progressPercentage').textContent = percentage;
      document.getElementById('progressCount').textContent = currentCount;
      document.getElementById('progressDescription').textContent = currentCategory.label;
      
      // 更新圆形进度条
      const progressPath = document.getElementById('progressPath');
      const circumference = 2 * Math.PI * 70; // 圆周长，半径为70
      const offset = circumference - (percentage / 100) * circumference;
      
      // 设置圆形进度条样式
      progressPath.style.strokeDasharray = circumference;
      progressPath.style.strokeDashoffset = offset;
      progressPath.style.stroke = currentCategory.color;

      // 按钮状态提示：当该分类没人时，给出提示文案（仍允许点击，点击时将弹出提示，不跳页）
      const detailsBtn = document.getElementById('viewDetailsBtn');
      if (detailsBtn) {
        if (currentCount === 0) {
          detailsBtn.title = '当前分类暂无学生';
          detailsBtn.setAttribute('aria-disabled', 'true');
        } else {
          detailsBtn.title = '查看详情';
          detailsBtn.removeAttribute('aria-disabled');
        }
      }
    }
    
    function renderUserAvatars(users) {
      const container = document.getElementById('userAvatars');
      const maxShow = 4;
      const showUsers = users.slice(0, maxShow);
      const remainingCount = Math.max(0, users.length - maxShow);
      
      let html = '';
      showUsers.forEach(user => {
        const initials = utils.getStudentInitials(user.name);
        html += `<div class="user-avatar">${initials}</div>`;
      });
      
      if (remainingCount > 0) {
        html += `<div class="user-avatar more">+${remainingCount}</div>`;
      }
      
      container.innerHTML = html;
    }

    function renderStudentList(category) {
  // 防抖/去重：如果数据签名未变化则不重绘，避免返回详情页时多次触发导致闪烁
  if(!window.__studentListRender){ window.__studentListRender={ lastSig:null }; }
      const groups = getGroups();
      const categoryMap = {
        'attendance': groups.attendance,
        'absent': groups.absent,
        'self-practice': groups.selfPractice,
        'not-practice': groups.notPractice
      };
      
      const categoryLabels = {
        'attendance': '出勤学生（规定时间内练琴）',
        'absent': '缺勤学生（规定时间内未练琴）',
        'self-practice': '自主练琴（规定时间外练琴）',
        'not-practice': '未练琴（目前未练琴）'
      };
      
      const list = categoryMap[category] || [];
      const grid = document.getElementById('studentGrid');
      const title = document.getElementById('listTitle');
      title.textContent = categoryLabels[category];

      const items = list.map(mapStudentToCardData);

      // 生成签名：分类|人数|每人 name:minutes:status 按姓名排序
      const sig = (()=>{
        const sorted=[...items].sort((a,b)=>a.name.localeCompare(b.name));
        return category + '|' + sorted.length + '|' + sorted.map(s=>`${s.name}:${s.minutes}:${s.status}`).join(',');
      })();
      if(window.__studentListRender.lastSig === sig){
        return; // 无变化，跳过
      }
      window.__studentListRender.lastSig = sig;

      const isMobile = window.matchMedia && window.matchMedia('(max-width: 640px)').matches;
      const html = items.map((s, index) => `
        <div class=\"stu-card\" data-name=\"${s.name}\" style=\"${isMobile ? '' : `animation-delay: ${Math.min(index * 15, 180)}ms;`}\" onclick=\"openStudentDetail('${s.name}')\">
          <div class=\"stu-line1\">
            <span class=\"status-dot ${category}\"></span>
            <span class=\"stu-name\">${s.name}</span>
          </div>
          <div class=\"stu-meta\">${s.metaText || ''}</div>
          <div class=\"stu-mins\">${utils.formatDurationFull(Math.max(0, s.minutes))}</div>
          <div class=\"stu-detail\">今日总练习时长</div>
        </div>
      `).join('');
      scheduleDOM(()=>{ grid.innerHTML = html; }, 2);
    }

    function updateViews() {
      console.log('updateViews 被调用，当前 uiState.view:', uiState.view);
      
      const home = document.getElementById('homeView');
      const list = document.getElementById('listView');
      const detail = document.getElementById('detailView');
  const ranking = document.getElementById('rankingView');
      
      console.log('视图元素状态:', {
        home: home ? '存在' : '不存在',
        list: list ? '存在' : '不存在', 
        detail: detail ? '存在' : '不存在',
        ranking: ranking ? '存在' : '不存在'
      });
      
  if (uiState.view === 'home') {
        // 收起列表视图和详情视图
        const isMobile = window.matchMedia && window.matchMedia('(max-width: 640px)').matches;
        
        if (!list.hidden) {
          list.classList.remove('expanding');
          if (isMobile) {
            scheduleDOM(()=>{ list.hidden = true; home.hidden = false; },1);
          } else {
            setTimeout(() => { scheduleDOM(()=>{ list.hidden = true; home.hidden = false; },1); }, 90);
          }
        } else { scheduleDOM(()=>{ home.hidden = false; },1); }
        if (ranking) {
          ranking.classList.remove('expanding');
          ranking.hidden = true;
        }
        if (detail) {
          detail.classList.remove('active');
          if (isMobile) {
            // 移动端：立即隐藏详情页
            detail.hidden = true;
          } else {
            // 桌面端：短动画
            setTimeout(() => {
              detail.hidden = true;
            }, 120);
          }
        }
        renderHomeBins();
      } else if (uiState.view === 'list') {
        // 展开列表视图
        home.hidden = true;
        if (ranking) {
          ranking.classList.remove('expanding');
          ranking.hidden = true;
        }
        if (detail) {
          detail.classList.remove('active');
          detail.hidden = true;
        }
        list.hidden = false;
  stopWeekChartAutoRefresh();
  stopCurrentDurationUpdate();
  stopLiveTimelineUpdate();
        
  // 只有从首页切换到列表时才播放展开动画（移动端跳过以提高响应）
  const isMobile = window.matchMedia && window.matchMedia('(max-width: 640px)').matches;
  if (uiState.previousView === 'home' && !isMobile) {
          // 设置展开起点为卡片中心
          const overviewCard = document.querySelector('.overview-card');
          if (overviewCard) {
            const rect = overviewCard.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // 设置变换原点为卡片中心
            list.style.transformOrigin = `${centerX}px ${centerY}px`;
          }
          
          // 触发展开动画
          requestAnimationFrame(() => {
            list.classList.add('expanding');
          });
  } else {
          // 从详情页返回，直接显示列表不播放动画
          list.classList.add('expanding');
        }
        
        renderStudentList(uiState.category);
      } else if (uiState.view === 'detail') {
        // 展开详情视图
        home.hidden = true;
        if (ranking) {
          ranking.classList.remove('expanding');
          ranking.hidden = true;
        }
        list.classList.remove('expanding');
        list.hidden = true;
        detail.hidden = false;
        detail.classList.add('active');
        renderStudentDetail(uiState.selectedStudent);
  startWeekChartAutoRefresh();
  startCurrentDurationUpdate();
      } else if (uiState.view === 'ranking') {
        // 展开完整排行榜
        home.hidden = true;
        list.hidden = true;
        if (detail) {
          detail.classList.remove('active');
          detail.hidden = true;
        }
        if (ranking) {
          dbg('进入 ranking 视图，开始渲染完整排行榜');
          ranking.hidden = false;
          ranking.classList.add('expanding'); // 添加展开样式
          renderRankingFull({ silent:false, keepScroll:false }).then(() => {
            // 如果管理员模式已开启，添加控制按钮
            if (adminMode) {
              setTimeout(() => addAdminControls(), 100);
            }
          });
        } else { dbg('ranking 容器未找到'); }
      }
    }

    function setupHomeInteractions() {
      // 分类标签切换
      const categoryTabs = document.querySelectorAll('.category-tab');
      categoryTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          // 标记用户已手动交互，阻止后续智能选择
          userHasInteracted = true;
          smartSelectionApplied = true;
          
          // 移除所有活跃状态
          categoryTabs.forEach(t => t.classList.remove('active'));
          // 添加当前活跃状态
          tab.classList.add('active');
          // 更新状态
          uiState.category = tab.dataset.category;
          
          dbg(`👆 用户手动选择分类: ${tab.dataset.category}`);
          
          // 重新渲染
          renderHomeBins();
        });
      });

      // 查看详情按钮
  const viewDetailsBtn = document.getElementById('viewDetailsBtn');
  const backBtn = document.getElementById('backBtn');
  const detailBackBtn = document.getElementById('detailBackBtn');
  const rankingDetailsBtn = document.getElementById('rankingDetailsBtn');
  const rankingRulesBtn = document.getElementById('rankingRulesBtn');
  const rankingBackBtn = document.getElementById('rankingBackBtn');

      if (viewDetailsBtn) {
        viewDetailsBtn.addEventListener('click', (e) => {
          // 进入列表前判断当前分类是否有人
          const groups = getGroups();
          const map = {
            'attendance': groups.attendance,
            'absent': groups.absent,
            'self-practice': groups.selfPractice,
            'not-practice': groups.notPractice
          };
          const cur = (map[uiState.category] || []);
          if (!cur.length) {
            showToast('当前分类暂无学生');
            return; // 不跳页
          }
          uiState.previousView = uiState.view;
          uiState.view = 'list';
          uiState.clickedElement = e.currentTarget;
          updateViews();
        });
      } else { dbg('viewDetailsBtn 未找到，跳过绑定'); }

      // 排行榜详情按钮 -> 进入完整排行榜
    if (rankingDetailsBtn) {
        rankingDetailsBtn.addEventListener('click', (e) => {
      uiState.previousView = uiState.view;
      uiState.rankingOrigin = uiState.view; // 进入排行榜前记录来源
          uiState.view = 'ranking';
          uiState.clickedElement = e.currentTarget;
          updateViews();
        });
      }
      // 排行规则详情 -> 打开规则说明模态
      if (rankingRulesBtn) {
        rankingRulesBtn.addEventListener('click', () => {
          showLeaderboardRuleDoc();
        });
      }
    if (rankingBackBtn) {
        console.log('成功找到排行榜返回按钮，正在绑定事件');
        rankingBackBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('排行榜返回按钮被点击');
          console.log('当前 uiState:', uiState);
          
          // 优先回到进入排行榜时的来源；否则退回首页
          const targetView = uiState.rankingOrigin || uiState.previousView || 'home';
          console.log('排行榜目标视图:', targetView);
          
          // 如果目标视图和当前视图相同，强制返回到首页
          if (targetView === 'ranking') {
            console.warn('排行榜目标视图和当前视图相同，强制返回到首页');
            uiState.previousView = 'ranking';
            uiState.view = 'home';
          } else {
            uiState.previousView = 'ranking'; // 设置上一个视图为排行榜页
            uiState.view = targetView;
          }
          
          uiState.rankingOrigin = null; // 清除来源，避免后续循环
          console.log('排行榜更新后 uiState:', uiState);
          updateViews();
        });
        console.log('排行榜返回按钮事件绑定完成');
      } else {
        console.error('rankingBackBtn 元素未找到！无法绑定返回事件');
      }

      // 排行榜标签页切换事件
      const dailyRankingTab = document.getElementById('dailyRankingTab');
      const weeklyRankingTab = document.getElementById('weeklyRankingTab');
      
      if (dailyRankingTab) {
        dailyRankingTab.addEventListener('click', () => {
          switchRankingMode('daily');
        });
      }
      
      if (weeklyRankingTab) {
        weeklyRankingTab.addEventListener('click', () => {
          switchRankingMode('weekly');
        });
      }
      
      if (backBtn) {
        backBtn.addEventListener('click', () => { 
          uiState.previousView = 'list'; // 设置上一个视图为列表页
          uiState.view = 'home'; 
          updateViews(); 
        });
      } else { dbg('backBtn 未找到，跳过绑定'); }

  if (detailBackBtn) {
        console.log('成功找到详情页返回按钮，正在绑定事件');
        detailBackBtn.addEventListener('click', (e) => { 
          e.preventDefault();
          e.stopPropagation();
          console.log('详情页返回按钮被点击');
          console.log('当前 uiState:', uiState);
          
          // 根据previousView返回到正确的页面
          const targetView = uiState.previousView || 'list';
          console.log('目标视图:', targetView);
          
          // 如果目标视图和当前视图相同，说明有循环问题，使用默认返回策略
          if (targetView === 'detail') {
            console.warn('目标视图和当前视图相同，使用默认返回策略');
            // 智能后备策略：优先级为 list > ranking > home
            let fallbackView = 'home';
            if (uiState.rankingOrigin) {
              // 如果之前是从排行榜页面的流程，返回排行榜
              fallbackView = 'ranking';
            } else {
              // 否则尝试返回列表页
              fallbackView = 'list';
            }
            uiState.previousView = 'detail';
            uiState.view = fallbackView;
            console.log('使用默认返回策略，目标视图:', fallbackView);
          } else {
            uiState.previousView = 'detail'; // 设置上一个视图为详情页
            uiState.view = targetView;
          }
          
          console.log('更新后 uiState:', uiState);
          updateViews(); 
        });
        console.log('详情页返回按钮事件绑定完成');
  } else { 
        console.error('detailBackBtn 元素未找到！无法绑定返回事件');
        dbg('detailBackBtn 未找到，跳过绑定'); 
  }

      // 搜索功能
      setupSearchFunction();
    }

  // 原 iOS 边缘右滑返回手势 setupSwipeGestures 已彻底移除（占位以避免后续引用）。
  function setupSwipeGestures() { /* 已移除，保留空函数避免残留调用报错 */ }

    // 搜索功能设置
    function setupSearchFunction() {
      const searchInput = document.getElementById('studentSearchInput');
      const searchResults = document.getElementById('searchResults');
      
      if (!searchInput || !searchResults) return;

      let searchTimeout = null;

      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          performSearch(query);
        }, 300);
      });

      searchInput.addEventListener('focus', () => {
        if (searchInput.value.trim()) {
          performSearch(searchInput.value.trim());
        }
      });

      // 点击外部区域隐藏搜索结果
      document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
          searchResults.style.display = 'none';
        }
      });
    }

    // 执行搜索
    function performSearch(query) {
      const searchResults = document.getElementById('searchResults');
      
      if (!query) {
        searchResults.style.display = 'none';
        return;
      }

      // 获取所有学生数据 - 从正确的字段获取
      let allStudents = [];
      if (appState.students && appState.students.size > 0) {
        allStudents = Array.from(appState.students.values());
      } else {
        // 如果没有加载学生数据，尝试从分组中获取
        const groups = getGroups();
        allStudents = [
          ...groups.attendance,
          ...groups.absent, 
          ...groups.selfPractice,
          ...groups.notPractice
        ];
      }
      
      // 搜索匹配的学生
      const matchedStudents = allStudents.filter(student => 
        student && student.name && student.name.toLowerCase().includes(query.toLowerCase())
      );

      // 生成搜索结果HTML
      if (matchedStudents.length === 0) {
        searchResults.innerHTML = '<div class="search-no-results">未找到匹配的学生</div>';
      } else {
        searchResults.innerHTML = matchedStudents.slice(0, 5).map(student => 
          `<div class="search-result-item" onclick="openStudentDetailFromSearch('${student.name}')">
            ${student.name}
          </div>`
        ).join('');
      }

      searchResults.style.display = 'block';
    }

    // 从搜索结果打开学生详情
    function openStudentDetailFromSearch(studentName) {
      const searchInput = document.getElementById('studentSearchInput');
      const searchResults = document.getElementById('searchResults');
      
      // 清空搜索框和隐藏结果
      searchInput.value = '';
      searchResults.style.display = 'none';
      
      // 设置前一个视图为首页（因为是从搜索进入的）
      uiState.previousView = 'home';
      uiState.view = 'detail';
      uiState.selectedStudent = studentName;
      updateViews();
    }

    // 打开学生详情页面
    function openStudentDetail(studentName) {
      console.log('从通用方式进入学生详情:', studentName);
      console.log('当前视图:', uiState.view);
      console.log('当前 rankingOrigin:', uiState.rankingOrigin);
      
      uiState.previousView = uiState.view;
      uiState.view = 'detail';
      uiState.selectedStudent = studentName;
      
      // 如果不是从排行榜进入的，清除 rankingOrigin，避免影响返回逻辑
      if (uiState.view !== 'ranking') {
        uiState.rankingOrigin = null;
        console.log('清除 rankingOrigin（非排行榜路径）');
      }
      
      console.log('更新后的 uiState:', uiState);
      updateViews();
    }

    function openRankingView() {
  uiState.previousView = uiState.view;
  uiState.rankingOrigin = uiState.view; // 记录来源
      uiState.view = 'ranking';
      updateViews();
    }

    // 管理员模式功能
  async function toggleAdminMode() {
      adminMode = !adminMode;
      if (adminMode) {
        showAdminNotification('管理员模式启用中...', 'info');
        
        // 从云端同步最新的调分数据
        const syncSuccess = await loadAdminScoresFromCloud();
        
        if (syncSuccess) {
          showAdminNotification('管理员模式已启用，数据已同步', 'success');
        } else {
          showAdminNotification('管理员模式已启用（使用本地数据）', 'info');
        }
        
        addAdminControls();
        
        // 如果在学生详情页面，刷新显示调分按钮
        if (uiState.view === 'detail' && uiState.selectedStudent) {
          renderStudentDetail(uiState.selectedStudent);
        }
      } else {
        showAdminNotification('管理员模式已关闭', 'info');
        removeAdminControls();
        
        // 如果在学生详情页面，移除调分按钮
        if (uiState.view === 'detail' && uiState.selectedStudent) {
          renderStudentDetail(uiState.selectedStudent);
        }
      }
    }

    function showAdminNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `admin-notification admin-notification--${type}`;
      notification.textContent = message;
      notification.style.cssText = `
        position: fixed; top: 20px; right: 20px; z-index: 9999;
        padding: 12px 20px; border-radius: 8px; color: white; font-weight: 500;
        background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#6366f1'};
        box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; transform: translateX(100%);
        transition: all 0.3s ease;
      `;
      document.body.appendChild(notification);
      
      // 动画显示
      requestAnimationFrame(() => {
        notification.style.opacity = '1';
        notification.style.transform = 'translateX(0)';
      });
      
      // 3秒后自动消失
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    function addAdminControls() {
      // 管理员控制现在只在学生详情页面显示，此函数保留用于其他可能的管理员功能
      dbg('管理员控制已启用');
    }

    function removeAdminControls() {
      // 移除所有管理员相关按钮
      document.querySelectorAll('.admin-score-btn, .admin-detail-btn').forEach(btn => btn.remove());
    }



    function openAdminScoreDialog(studentName) {
      const currentAdjustment = adminScoreAdjustments[studentName] || { score: 0, reason: '' };
  let selectedDelta = 0; // 记录当前选择（六个固定值或 0 表示复原）
      
      const dialog = document.createElement('div');
      dialog.className = 'admin-score-dialog';
      dialog.innerHTML = `
        <div class="admin-dialog-backdrop" onclick="closeAdminDialog()"></div>
        <div class="admin-dialog-content">
          <div class="admin-dialog-header">
            <h3>管理员调分 - ${studentName}</h3>
            <button onclick="closeAdminDialog()" style="border:none;background:none;font-size:20px;cursor:pointer;">×</button>
          </div>
          <div class="admin-dialog-body">
            <div class="admin-form-group">
              <div style="font-size:13px;margin-bottom:6px;color:#374151;">当前调分状态：<span id="currentAdjustStatus" style="font-weight:600;">加载中...</span></div>
              <label>调整分数（六选一，可再次点击取消选择）：</label>
              <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;">
                <button type="button" data-delta="1" class="delta-btn" style="padding:10px 0;border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;cursor:pointer;font-size:14px;">+1</button>
                <button type="button" data-delta="2" class="delta-btn" style="padding:10px 0;border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;cursor:pointer;font-size:14px;">+2</button>
                <button type="button" data-delta="3" class="delta-btn" style="padding:10px 0;border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;cursor:pointer;font-size:14px;">+3</button>
                <button type="button" data-delta="-1" class="delta-btn" style="padding:10px 0;border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;cursor:pointer;font-size:14px;">-1</button>
                <button type="button" data-delta="-2" class="delta-btn" style="padding:10px 0;border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;cursor:pointer;font-size:14px;">-2</button>
                <button type="button" data-delta="-3" class="delta-btn" style="padding:10px 0;border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;cursor:pointer;font-size:14px;">-3</button>
              </div>
              <div style="display:flex;align-items:center;justify-content:space-between;margin-top:6px;">
                <div style="color:#6b7280;font-size:12px;">当前选择：<span id="deltaCurrentValue" style="font-weight:600;color:#111827;">0</span></div>
                <button type="button" id="deltaResetBtn" style="padding:4px 10px;font-size:12px;border:1px solid #d1d5db;background:#fff;border-radius:4px;cursor:pointer;">复原(清除)</button>
              </div>
            </div>
            <div class="admin-form-group">
              <label>调整说明：</label>
              <textarea id="adminReasonInput" placeholder="请输入调整原因..." 
                        style="width: 100%; height: 80px; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; resize: vertical;">${currentAdjustment.reason}</textarea>
            </div>
            <div style="color: #6b7280; font-size: 12px; margin-top: 8px;">
              只能选择 +1 / +2 / +3 / -1 / -2 / -3；“复原”将移除已存在的调分。调整需填写原因；复原可不填。提交前会二次确认。
            </div>
          </div>
          <div class="admin-dialog-footer">
            <button onclick="closeAdminDialog()" style="padding: 8px 16px; margin-right: 8px; border: 1px solid #d1d5db; background: white; border-radius: 4px; cursor: pointer;">取消</button>
            <button onclick="saveAdminScoreAdjustment('${studentName}')" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">保存</button>
          </div>
        </div>
      `;
      
      dialog.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000;
        display: flex; align-items: center; justify-content: center;
      `;
      
      // 添加样式
      const style = document.createElement('style');
      style.textContent = `
        .admin-dialog-backdrop {
          position: absolute; top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(0,0,0,0.5); backdrop-filter: blur(2px);
        }
        .admin-dialog-content {
          position: relative; background: white; border-radius: 8px;
          box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
          width: 90%; max-width: 400px; max-height: 80vh; overflow-y: auto;
        }
        .admin-dialog-header {
          display: flex; justify-content: space-between; align-items: center;
          padding: 16px 20px; border-bottom: 1px solid #e5e7eb;
        }
        .admin-dialog-header h3 {
          margin: 0; font-size: 18px; font-weight: 600; color: #1f2937;
        }
        .admin-dialog-body {
          padding: 20px;
        }
        .admin-form-group {
          margin-bottom: 16px;
        }
        .admin-form-group label {
          display: block; margin-bottom: 4px; font-weight: 500; color: #374151;
        }
        .admin-dialog-footer {
          padding: 16px 20px; border-top: 1px solid #e5e7eb;
          display: flex; justify-content: flex-end;
        }
      `;
      
      document.head.appendChild(style);
      document.body.appendChild(dialog);
      
      // 绑定 delta 选择按钮
      const deltaBtns = dialog.querySelectorAll('.delta-btn');
      const currentEl = dialog.querySelector('#deltaCurrentValue');
      const statusEl = dialog.querySelector('#currentAdjustStatus');
      const resetBtn = dialog.querySelector('#deltaResetBtn');
      // 打开时如果已有调分预选
      if([1,2,3,-1,-2,-3].includes(currentAdjustment.score)) selectedDelta = currentAdjustment.score;
      function renderStatus(){
        if(currentAdjustment.score && [1,2,3,-1,-2,-3].includes(currentAdjustment.score)){
          statusEl.textContent = (currentAdjustment.score>0? ('已加'+currentAdjustment.score+'分') : ('已扣'+Math.abs(currentAdjustment.score)+'分'));
        } else {
          statusEl.textContent = '未调整';
        }
      }
      function updateHighlight(){
        deltaBtns.forEach(btn=>{
          const v = parseInt(btn.getAttribute('data-delta'));
          if(v===selectedDelta){
            btn.style.background='#2563eb';
            btn.style.color='#fff';
            btn.style.borderColor='#2563eb';
          }else{
            btn.style.background='#f9fafb';
            btn.style.color='#111827';
            btn.style.borderColor='#d1d5db';
          }
        });
        currentEl.textContent = selectedDelta;
      }
      deltaBtns.forEach(btn=>btn.addEventListener('click',()=>{
        const v = parseInt(btn.getAttribute('data-delta'));
        if(selectedDelta === v) selectedDelta = 0; else selectedDelta = v;
        updateHighlight();
      }));
      resetBtn.addEventListener('click',()=>{ selectedDelta = 0; updateHighlight(); });
      renderStatus();
      updateHighlight();
    }

    function closeAdminDialog() {
      const dialog = document.querySelector('.admin-score-dialog');
      if (dialog) dialog.remove();
    }

    async function saveAdminScoreAdjustment(studentName) {
      const reasonInput = document.getElementById('adminReasonInput');
      const reason = reasonInput ? reasonInput.value.trim() : '';
      // 读取当前选择的 delta
      const dialog = document.querySelector('.admin-score-dialog');
      const currentSpan = dialog ? dialog.querySelector('#deltaCurrentValue') : null;
      const score = currentSpan ? parseInt(currentSpan.textContent) : 0;
      let adjustmentData = null;
      if(score !== 0){
        if(![1,2,3,-1,-2,-3].includes(score)){
          showAdminNotification('非法分值', 'error');
          return;
        }
        if(!reason){
          showAdminNotification('请填写原因', 'error');
          return;
        }
        const confirmMsg = `${studentName} 将${score>0? '加' + score : '扣' + Math.abs(score)}分\n原因：${reason}\n确认提交？`;
        if(!confirm(confirmMsg)) return;
        adjustmentData = {
          score: score,
          reason: reason,
          timestamp: Date.now(),
          date: new Date().toISOString().split('T')[0],
          operator: 'admin'
        };
      } else {
        // 复原流程
        if(!confirm(`${studentName} 将复原调分（清除已存在的加/扣分）。确认继续？`)) return;
      }
      
      try {
        const saveBtn = document.querySelector('.admin-dialog-footer button:last-child');
        if (saveBtn) { saveBtn.disabled = true; saveBtn.textContent = '保存中...'; }

        // 1. 云端同步
        const cloudRes = await syncAdminScoreToCloud(studentName, adjustmentData);
        closeAdminDialog();

        // 2. 如果云端成功，才更新内存缓存
        if (cloudRes.ok) {
          if (adjustmentData) adminScoreAdjustments[studentName] = adjustmentData; else delete adminScoreAdjustments[studentName];
        }

        // 3. 尝试写入 leaderboard_daily（不影响最终是否重复弹窗）
        let lbErr = null;
        try {
          if (cloudRes.ok) { // 仅在云端真正成功时再写排行榜
            await updateLeaderboardDailyScore(studentName, adjustmentData);
          }
        } catch(e){ lbErr = e; console.error('updateLeaderboardDailyScore error:', e); }

        // 4. 刷新视图（失败也不抛出）
        try {
          if (cloudRes.ok) { // 只有成功状态下才刷新避免误导
            clearAllCaches();
            // 额外：清除首页用的 442 分缓存，确保加减分立即可见
            if (window.__scoreCache) { try { window.__scoreCache.clear(); dbg('已清空 __scoreCache'); } catch(_) {} }
            // 无论当前视图为何，都同时刷新三个区域（并行触发，不 await）
            updateRanking(); // 首页小榜
            renderRankingFull({ silent: true }); // 完整榜
            renderStudentDetail(studentName); // 详情
          }
        } catch (e) { console.warn('刷新视图失败（忽略）:', e); }

        // 5. 单一通知出口
        if (cloudRes.ok && !lbErr) {
          showAdminNotification(`${studentName} ${adjustmentData? '调分已保存' : '调分已复原'}`, 'success');
        } else if (cloudRes.ok && lbErr) {
          showAdminNotification(`${studentName} ${adjustmentData? '调分已保存' : '调分已复原'}（排行榜稍后刷新）`, 'warning');
        } else if (cloudRes.fatal) {
          showAdminNotification(`${studentName} 调分保存失败`, 'error');
        } else { // 非致命：schema 缺失等
          showAdminNotification(`${studentName} 调分未生效（需检查云端表结构）`, 'warning');
        }

      } catch (err) {
        console.error('保存调分过程异常(外围):', err);
        showAdminNotification('保存失败', 'error');
        const saveBtn = document.querySelector('.admin-dialog-footer button:last-child');
        if (saveBtn) { saveBtn.disabled = false; saveBtn.textContent = '保存'; }
      }
    }

    // ========= 云端调分同步（结构化结果，避免误报） =========
  async function syncAdminScoreToCloud(studentName, adjustmentData) {
      if (!supabaseClient) {
        return { ok:false, fatal:true, reason:'supabase_not_initialized' };
      }
      const normalizedName = utils.normalizeStudentName(studentName);
      try {
        if (adjustmentData) {
          // 手动 upsert：先 update，如果未命中再 insert，避免 42P10 约束错误
          let { data: updData, error: updErr } = await supabaseClient
            .from('admin_score_adjustments')
            .update({
              score_adjustment: adjustmentData.score,
              reason: adjustmentData.reason,
              timestamp: new Date(adjustmentData.timestamp).toISOString(),
              date: adjustmentData.date,
              operator: adjustmentData.operator,
              updated_at: new Date().toISOString()
            })
            .eq('student_name', normalizedName)
            .select();

          if (updErr) {
            if (/relation .* does not exist/i.test(updErr.message) || /column .* does not exist/i.test(updErr.message)) {
              console.warn('[admin-adjust] 表或列缺失（非致命）:', updErr.message);
              return { ok:false, fatal:false, reason:'schema_missing' };
            }
            console.error('[admin-adjust] update 错误:', updErr);
            return { ok:false, fatal:true, reason:updErr.message };
          }

          if (!updData || updData.length === 0) {
            const { error: insErr } = await supabaseClient
              .from('admin_score_adjustments')
              .insert({
                student_name: normalizedName,
                score_adjustment: adjustmentData.score,
                reason: adjustmentData.reason,
                timestamp: new Date(adjustmentData.timestamp).toISOString(),
                date: adjustmentData.date,
                operator: adjustmentData.operator,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
              });
            if (insErr) {
              if (/relation .* does not exist/i.test(insErr.message) || /column .* does not exist/i.test(insErr.message)) {
                console.warn('[admin-adjust] 表或列缺失（非致命）:', insErr.message);
                return { ok:false, fatal:false, reason:'schema_missing' };
              }
              console.error('[admin-adjust] insert 错误:', insErr);
              return { ok:false, fatal:true, reason:insErr.message };
            }
          }
        } else {
          const { error } = await supabaseClient
            .from('admin_score_adjustments')
            .delete()
            .eq('student_name', normalizedName);
          if (error) {
            if (/relation .* does not exist/i.test(error.message)) {
              console.warn('[admin-adjust] 删除时表缺失（忽略）');
              return { ok:false, fatal:false, reason:'schema_missing' };
            }
            return { ok:false, fatal:true, reason:error.message };
          }
        }
        return { ok:true };
      } catch (e) {
    console.error('[admin-adjust] 同步异常:', e);
        return { ok:false, fatal:true, reason:e.message };
      }
    }

    // 从云端加载管理员调分数据
    async function loadAdminScoresFromCloud() {
      try {
        if (!supabaseClient) {
          dbg('Supabase 客户端未初始化，使用本地数据');
          return false;
        }
        
        // 首先尝试创建表（如果不存在）
        await ensureAdminScoreTable();
        
        const { data, error } = await supabaseClient
          .from('admin_score_adjustments')
          .select('*');
        
        if (error) {
          // 如果表不存在，尝试创建后重试
          if (error.code === '42P01') { // relation does not exist
            dbg('管理员调分表不存在，使用本地数据');
            return false;
          }
          throw error;
        }
        
        // 更新本地缓存
        const cloudAdjustments = {};
        if (data) {
          data.forEach(record => {
            const studentName = record.student_name;
            cloudAdjustments[studentName] = {
              score: record.score_adjustment,
              reason: record.reason,
              timestamp: new Date(record.timestamp).getTime(),
              date: record.date,
              operator: record.operator
            };
          });
        }
        
        // 合并云端数据到本地，云端数据优先
        Object.assign(adminScoreAdjustments, cloudAdjustments);
        localStorage.setItem('adminScoreAdjustments', JSON.stringify(adminScoreAdjustments));
        
        dbg('管理员调分数据已从云端同步');
        return true;
      } catch (error) {
        console.error('从云端加载管理员调分失败:', error);
        return false;
      }
    }

    // 更新 leaderboard_daily 表中的学生分数
  async function updateLeaderboardDailyScore(studentName, adjustmentData) {
      if (!supabaseClient) {
        dbg('Supabase 客户端未初始化，跳过 leaderboard_daily 更新');
        return;
      }
      
      try {
        const normalizedName = utils.normalizeStudentName(studentName);
        const activeDate = getActiveLeaderboardDate();
        const activeIso = utils.toIsoDate(activeDate);
        
        // 获取当前学生在 leaderboard_daily 中的记录
        const { data: existingRecord, error: fetchError } = await supabaseClient
          .from('leaderboard_daily')
          .select('*')
          .eq('student_key', normalizedName)
          .eq('date', activeIso)
          .single();
        
        if (fetchError && fetchError.code !== 'PGRST116') { // PGRST116 = no rows returned
          throw fetchError;
        }
        
        if (!existingRecord) {
          // 若还没有记录，但我们需要写入调分：先尝试创建空基础行（需依赖 RULE_VERSION 常量）
          const baseInsert = {
            student_key: normalizedName,
            date: activeIso,
            d1: 0,
            d2: 0,
            d3: 0,
            total: 0,
            rank: null,
            rule_version: (typeof RULE_VERSION!=='undefined'? RULE_VERSION : 1),
            admin_adjustment: 0,
            created_at: new Date().toISOString()
          };
          const { error: insertErr } = await supabaseClient
            .from('leaderboard_daily')
            .insert(baseInsert);
          if (insertErr) {
            dbg('插入空 leaderboard_daily 行失败，跳过调分写入', insertErr);
            return;
          }
          dbg(`已为 ${studentName} 创建 leaderboard_daily 初始记录`);
        }
        
        // 重新计算包含管理员调整的总分
        // 重新获取（若刚插入则需再 select 一次）
        let record = existingRecord;
        if (!record) {
          const { data: rec2 } = await supabaseClient
            .from('leaderboard_daily')
            .select('d1,d2,d3,admin_adjustment')
            .eq('student_key', normalizedName)
            .eq('date', activeIso)
            .single();
          record = rec2 || { d1:0,d2:0,d3:0,admin_adjustment:0 };
        }
        const baseTotal = (record.d1 || 0) + (record.d2 || 0) + (record.d3 || 0);
        const adminAdjustment = adjustmentData ? adjustmentData.score : 0;
        const newTotal = +(Math.max(0, Math.min(100, baseTotal + adminAdjustment))).toFixed(2);
        
        // 尝试更新记录（包含 admin_adjustment 字段）
        let updateData = {
          total: newTotal,
          updated_at: new Date().toISOString()
        };
        
        // 尝试添加 admin_adjustment 字段，如果字段不存在会被忽略
        try {
          updateData.admin_adjustment = adminAdjustment;
        } catch (e) {
          // 字段可能不存在，继续更新其他字段
        }
        
        const { error: updateError } = await supabaseClient
          .from('leaderboard_daily')
          .update(updateData)
          .eq('student_key', normalizedName)
          .eq('date', activeIso);
        
        if (updateError) {
          // 如果包含 admin_adjustment 字段失败，尝试只更新 total
          if (updateError.message && updateError.message.includes('admin_adjustment')) {
            dbg('admin_adjustment 字段不存在，仅更新 total 分数');
            const { error: retryError } = await supabaseClient
              .from('leaderboard_daily')
              .update({
                total: newTotal,
                updated_at: new Date().toISOString()
              })
              .eq('student_key', normalizedName)
              .eq('date', activeIso);
            
            if (retryError) throw retryError;
          } else {
            throw updateError;
          }
        }
        
        // 重新计算当日排名
        await recalculateDailyRanking(activeIso);
        
        dbg(`已更新 ${studentName} 在 leaderboard_daily 中的分数: ${baseTotal} -> ${newTotal} (调整: ${adminAdjustment})`);
        
      } catch (error) {
        console.error('更新 leaderboard_daily 失败:', error);
        // 不抛出错误，因为这不应该阻止管理员调分功能
      }
    }

    // 重新计算指定日期的排名
    async function recalculateDailyRanking(dateIso) {
      if (!supabaseClient) return;

      // 在重新计算排名前，先尝试补齐缺失的 rule_version（一次性修复历史脏数据）
      try {
        const { error: fixErr } = await supabaseClient
          .from('leaderboard_daily')
          .update({ rule_version: RULE_VERSION })
          .is('rule_version', null)
          .eq('date', dateIso);
        if (fixErr) dbg('补齐缺失 rule_version 失败(可忽略):', fixErr.message || fixErr);
      } catch (e) { /* ignore */ }
      
      try {
        // 获取该日期所有有分数的记录（需要 window 字段避免 upsert 时 NOT NULL 约束违反）
        const { data: records, error: fetchError } = await supabaseClient
          .from('leaderboard_daily')
          .select('student_key, total, window')
          .eq('date', dateIso)
          .gt('total', 0)
          .order('total', { ascending: false });
        
        if (fetchError) throw fetchError;
        if (!records || records.length === 0) return;
        
        // 计算当前日期的 window（备用，以防记录中缺失）
        const targetDate = new Date(dateIso + 'T00:00:00');
        const weekday0to6 = targetDate.getDay();
        const fallbackWindow = __leaderboardWindowJSON(weekday0to6);
        
        // 计算排名（处理并列情况）
        let rank = 1;
        const updates = [];
        for (let i = 0; i < records.length; i++) {
          if (i > 0 && records[i].total < records[i - 1].total) {
            rank = i + 1;
          }
          updates.push({
            student_key: records[i].student_key,
            date: dateIso,
            rank: rank,
            // 确保不会因为缺失字段触发 NOT NULL 约束错误
            rule_version: RULE_VERSION,
            window: records[i].window || fallbackWindow
          });
        }
        
        // 批量更新排名
        const { error: updateError } = await supabaseClient
          .from('leaderboard_daily')
          .upsert(updates, { onConflict: 'date,student_key' });
        
        if (updateError) throw updateError;
        
        dbg(`已重新计算 ${dateIso} 的排名，涉及 ${updates.length} 名学生`);
        
      } catch (error) {
        console.error('重新计算排名失败:', error);
      }
    }

    // 确保管理员调分表存在，并同步现有的调分数据到 leaderboard_daily
    async function ensureAdminScoreTable() {
      try {
        // 注意：这需要数据库管理员权限，实际使用时应该预先在 Supabase 控制台创建表
        // 管理员调分表结构
        dbg('管理员调分表结构（需要在 Supabase 控制台手动创建）:');
        dbg(`
          CREATE TABLE IF NOT EXISTS admin_score_adjustments (
            id SERIAL PRIMARY KEY,
            student_name TEXT NOT NULL,
            score_adjustment DECIMAL(5,2) NOT NULL,
            reason TEXT NOT NULL,
            timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            date DATE NOT NULL,
            operator TEXT NOT NULL DEFAULT 'admin',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
          );
          -- 可选：添加唯一约束以支持数据库级别幂等（当前前端已手动 upsert）
          -- ALTER TABLE admin_score_adjustments ADD CONSTRAINT admin_score_adjustments_student_name_key UNIQUE(student_name);
          
          -- 为 leaderboard_daily 表添加管理员调分字段（可选）
          ALTER TABLE leaderboard_daily ADD COLUMN IF NOT EXISTS admin_adjustment DECIMAL(5,2) DEFAULT 0;
        `);
        
        // 同步现有的管理员调分到 leaderboard_daily
        await syncExistingAdminScoresToLeaderboard();
        
      } catch (error) {
        console.error('确保管理员调分表存在失败:', error);
      }
    }

    // 同步现有的管理员调分数据到 leaderboard_daily
    async function syncExistingAdminScoresToLeaderboard() {
      if (!supabaseClient) return;
      
      try {
        const activeDate = getActiveLeaderboardDate();
        const activeIso = utils.toIsoDate(activeDate);
        
        // 遍历本地的管理员调分数据
        for (const [studentName, adjustment] of Object.entries(adminScoreAdjustments)) {
          if (adjustment && adjustment.score !== 0) {
            await updateLeaderboardDailyScore(studentName, adjustment);
          }
        }
        
        dbg('已同步现有管理员调分数据到 leaderboard_daily');
      } catch (error) {
        console.error('同步现有管理员调分失败:', error);
      }
    }

    function clearAllCaches() {
      // 清除所有相关缓存
      rankingDataCache = null;
      lastRankingUpdateTime = 0;
  try { if (typeof RANK_CACHE_KEY !== 'undefined') localStorage.removeItem(RANK_CACHE_KEY); } catch(_) {}
      localStorage.removeItem('home_ranking_sync');
      if (window.rankingModeHtmlCache) {
        window.rankingModeHtmlCache.daily = null;
        window.rankingModeHtmlCache.weekly = null;
      }
      dbg('管理员调分后清除所有缓存');
    }

    function getAdminScoreAdjustment(studentName) {
      const adjustment = adminScoreAdjustments[studentName];
      return adjustment ? adjustment.score : 0;
    }

    function getAdminScoreAdjustmentDetails(studentName) {
      return adminScoreAdjustments[studentName] || null;
    }

  async function renderRankingFull(options) {
      options = options || {};
      const { keepScroll=true, silent=false, minimalAutoRefresh=true } = options;
      dbg('renderRankingFull() 调用, 模式:', rankingMode, 'opts:', options);
      const container = document.getElementById('rankingFullList');
      if (!container) { dbg('rankingFullList 容器未找到'); return; }

      // 记录滚动位置（父容器及窗口）
      let winScrollY = window.scrollY;
      let containerScrollTop = container.scrollTop;

      // 若已有内容且不是显式模式切换刷新，则避免整个 innerHTML 重置骨架
      const hasExisting = container.innerHTML.trim().length > 0 && !container.querySelector('.ranking-item--skeleton');
      if (!hasExisting && !silent) {
        const skeletonHTML = `
          <div class="ranking-hero">
            <div class="ranking-hero-sub">正在加载排行榜数据...</div>
          </div>
          <div class="ranking-section">
            <div class="ranking-rows">
              ${Array.from({length: 8}).map((_, i) => `
                <div class="ranking-row" style="opacity: 0.5; pointer-events: none;">
                  <div class="rank-num">${i + 1}</div>
                  <div class="row-user">
                    <div class="row-name" style="background: #e2e8f0; color: transparent; border-radius: 4px;">加载中...</div>
                  </div>
                  <div class="row-points" style="background: #e2e8f0; color: transparent; border-radius: 4px; width: 60px; height: 20px;"></div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
        scheduleDOM(()=>{ container.innerHTML = skeletonHTML; });
        await new Promise(r=>requestAnimationFrame(r));
      }
      
      // 更新标签页状态
      updateRankingTabs();
      
      // 日榜模式：周末不展示具体内容
      if (rankingMode === 'daily') {
        const __today = getActiveLeaderboardDate();
        if (!isWorkday(__today)) {
          const wkHTML = `
            <div class="ranking-hero">
              <div class="ranking-hero-sub">周末（周六/周日）不展示日榜；工作日排行榜窗口：周一/二/四/五 08:00–18:40，周三 08:00–19:10；维度三历史评分参考不包含周六周日，且排除当日无练琴的工作日；当日无练琴则不计分。请在工作日查看。</div>
            </div>`;
          scheduleDOM(()=>{ container.innerHTML = wkHTML; });
          return;
        }
      }
      let items = [];
  // 周榜详情映射（name -> { scores: number[5], datesIso: string[5], datesLabel: string[5] }）
  let weeklyDetailMap = null;
  let weeklyDatesIso = null;
  let weeklyDatesLabel = null;
      
      if (rankingMode === 'weekly') {
        // 周榜模式：从数据库获取最近5天平均分
        const weeklyData = await fetchWeeklyLeaderboardData();
        if (weeklyData.length === 0) {
          const emptyWeekly = `
            <div class="ranking-hero">
              <div class="ranking-hero-sub">暂无周榜数据，需要至少5个工作日的练琴记录</div>
            </div>`;
          scheduleDOM(()=>{ container.innerHTML = emptyWeekly; });
          return;
        }
        // 计算与周榜一致的5个工作日（用于弹窗展示日期）
        const refDate = getActiveLeaderboardDate();
        const endWorkday = nearestWorkdayOnOrBefore(refDate);
        const workdayDates = getLastNWorkdayDates(endWorkday, 5);
        weeklyDatesIso = workdayDates.map(d => utils.toIsoDate(d));
        weeklyDatesLabel = workdayDates.map(d => `${d.getMonth() + 1}/${d.getDate()}`);
        weeklyDetailMap = {};
        weeklyData.forEach(d => {
          weeklyDetailMap[d.studentName] = {
            scores: Array.isArray(d.scores) ? d.scores : [],
            datesIso: weeklyDatesIso,
            datesLabel: weeklyDatesLabel
          };
        });
        // 暴露到全局，供按钮点击时查询
        window.__weeklyDetailMap = weeklyDetailMap;
        window.__weeklyDatesIso = weeklyDatesIso;
        window.__weeklyDatesLabel = weeklyDatesLabel;
        // 转换为统一格式
        items = weeklyData.map(data => ({
          name: data.studentName,
          rankingScore: data.averageScore,
          dayCount: data.dayCount,
          isWeekly: true,
          weeklyScores: Array.isArray(data.scores) ? data.scores : []
        }));
      } else {
        // 日榜模式：实时计算当日评分
        let all = [];
        try {
          all = Array.from(appState.students?.values?.() || []);
        } catch { all = []; }

        dbg('获取学生数据:', { allCount: all.length });
        dbg('appState.students 状态:', appState.students);
        dbg('appState.studentsMeta 状态:', appState.studentsMeta);

        // 若分析数据为空，尝试用 studentsMeta 构造占位项
        if (!all.length) {
          const metaEntries = Array.from(appState.studentsMeta?.entries?.() || []);
          dbg('studentsMeta 条目数:', metaEntries.length);
          if (!metaEntries.length) {
            dbg('显示无数据提示');
            container.innerHTML = `
              <div class="ranking-hero">
                <div class="ranking-hero-sub">暂无排行榜数据</div>
              </div>`;
            return;
          }
          all = metaEntries.map(([name, meta]) => ({ name, todayMinutes: { in: 0, out: 0 }, currentStatus: 'offline' }));
          dbg('使用 studentsMeta 构造占位项:', all.length);
        }

        // 异步预热缓存，不阻塞UI（后台进行）
        const prefetchPromise = (async () => {
          try {
            const activeDate = getActiveLeaderboardDate();
            const endWorkday = nearestWorkdayOnOrBefore(activeDate);
            const curDates = getLastNWorkdayDates(endWorkday, 7);
            const prevWindowEnd = previousWorkday(curDates[0]);
            const prevDates = getLastNWorkdayDates(prevWindowEnd, 7);
            await __prefetchD12ForWindows(all.map(s => utils.normalizeStudentName(s.name)), [...curDates, ...prevDates]);
            await __getPrevDayRankMapCached(previousWorkday(activeDate));
            await __getPrevTopByDateCached(activeDate);
            dbg('缓存预热完成');
          } catch(e) {
            dbg('缓存预热失败:', e);
          }
        })();

        // ===== 性能优化：缓存 + 分块异步计算 + 进度骨架 =====
        const activeDate = getActiveLeaderboardDate();
        const activeIso = utils.toIsoDate(activeDate);

        const RANK_CACHE_SIG = (() => {
          const studentCount = (appState.studentsMeta && appState.studentsMeta.size) || 0;
          return `v2|${RULE_VERSION}|${studentCount}`; // 版本|规则|学生数
        })();
        function loadRankCache(dateIso){
          try{ 
            const raw = localStorage.getItem(RANK_CACHE_KEY); 
            if (!raw) return null; 
            const obj = JSON.parse(raw); 
            if (obj && obj.date === dateIso && typeof obj.html === 'string' && obj.sig === RANK_CACHE_SIG) { 
              // 检查缓存是否过期（5分钟）
              const now = Date.now();
              if (now - obj.ts < 300000) { // 5分钟有效期
                return obj; 
              }
            } 
          } catch(_) {}
          return null;
        }
        function saveRankCache(dateIso, html, meta){
          try{ 
            const timestamp = Date.now();
            const dataHash = generateDataHash([...logs, ...students]);
            const payload = { 
              date: dateIso, 
              html, 
              ts: timestamp,
              dataHash,
              sig: RANK_CACHE_SIG,
              ...meta 
            };
            localStorage.setItem(RANK_CACHE_KEY, JSON.stringify(payload)); 
            // 同步到首页缓存（确保一致性 + 签名）
            localStorage.setItem('home_ranking_sync', JSON.stringify({
              date: dateIso,
              ts: timestamp,
              dataHash,
              sig: RANK_CACHE_SIG
            }));
            dbg('排行榜缓存已保存并同步到首页', { dateIso, timestamp, dataHash, sig: RANK_CACHE_SIG });
          } catch(_) {/* 忽略 */}
        }
        function clearRankCache() {
          try {
            localStorage.removeItem(RANK_CACHE_KEY);
            // 同时清除全局缓存
            rankingDataCache = null;
            lastRankingUpdateTime = 0;
            dbg('排行榜缓存已清除');
          } catch(_) {}
        }
        function renderProgress(done, total) {
          const percent = total ? Math.min(100, Math.floor(done / total * 100)) : 0;
          const sub = container.querySelector('.ranking-hero-sub');
          if (sub) {
            // 只更新进度文本，保持现有骨架结构
            sub.innerHTML = `正在计算排行榜 <span style="color: #6366f1; font-weight: 600;">${percent}%</span> (${done}/${total})`;
          }
        }
        function renderIncrementalRows(processed){
          if(!container.__lbProgress) return; // 没有骨架不更新
          const rowsWrap = container.querySelector('.ranking-rows');
          if(!rowsWrap) return;
          const list = processed.slice();
          const CHUNK = 20;
          let idx = 0;
          rowsWrap.innerHTML='';
          const appendChunk = () => {
            const slice = list.slice(idx, idx+CHUNK);
            if(!slice.length) return;
            const html = slice.map(s=>`<div class='ranking-row' data-student='${s.name}'>`+
              `<div class='rank-num'>${s.__rankTmp}</div>`+
              `<div class='row-user'><div class='row-name'>${s.name}</div></div>`+
              `<div class='row-points'>${Number.isFinite(s.rankingScore)?s.rankingScore.toFixed(1):'-'}分 <button class="score-detail-btn" onclick="event.stopPropagation(); showScoreDetail('${s.name}')" title="查看评分详情">?</button></div>`+
            `</div>`).join('');
            scheduleDOM(()=>{ rowsWrap.insertAdjacentHTML('beforeend', html); });
            idx += CHUNK;
            if(idx < list.length) requestAnimationFrame(appendChunk);
          };
          appendChunk();
        }

        // 检查缓存一致性
        function isCacheConsistent() {
          try {
            const homeSync = localStorage.getItem('home_ranking_sync');
            const rankCache = localStorage.getItem(RANK_CACHE_KEY);
            if (!homeSync || !rankCache) return false;
            
            const homeSyncData = JSON.parse(homeSync);
            const rankCacheData = JSON.parse(rankCache);
            
            // 检查日期和时间戳是否接近（5分钟内）
            return homeSyncData.date === rankCacheData.date && 
                   Math.abs(homeSyncData.ts - rankCacheData.ts) < 300000;
          } catch(_) {
            return false;
          }
        }
        
        // 先尝试展示缓存（确保一致性）
        const cached = loadRankCache(activeIso);
        if (cached && cached.html && cached.html.length > 100 && isCacheConsistent()) {
          dbg('使用排行榜缓存展示（已验证一致性）', cached);
          try { 
            container.innerHTML = cached.html;
            // 显示缓存提示
            const heroSub = container.querySelector('.ranking-hero-sub');
            if (heroSub && !heroSub.textContent.includes('缓存')) {
              heroSub.innerHTML += ' <span style="color: #10b981; font-size: 12px;">(已同步)</span>';
            }
            return; // 使用缓存，直接返回
          } catch(_) { 
            dbg('缓存加载失败，继续计算');
          }
        } else if (cached) {
          dbg('缓存存在但与首页不一致，清除缓存重新计算');
          clearRankCache();
        }

        // 分块计算（避免长时间阻塞 & 空白）
        const allStudents = all.slice();
        const concurrency = 10; // 每批并发量
        let processed = [];
        let index = 0;

        async function processBatch() {
          const start = performance.now();
          if(window.__perfFlags && window.__perfFlags.instrumentRanking){ performance.mark && performance.mark('ranking_batch_start'); }
          const batch = allStudents.slice(index, index + concurrency);
          
          // 立即更新进度，提供用户反馈
          if (!cached) {
            renderProgress(index, allStudents.length);
          }
          
          const results = await Promise.all(batch.map(async (student) => {
            try { 
              const s = await computeScore442(student); 
              return { student, s }; 
            } catch(e) { 
              dbg('计算学生分数出错:', student.name, e); 
              return { student, s: { total: 0, d1: 0, d2: 0, d3: 0 } }; 
            }
          }));
          
          results.forEach(r => { 
            processed.push({ ...r.student, rankingScore: r.s.total, __442: r.s }); 
          });
          
          index += concurrency;
          
          if (index < allStudents.length) {
            // 更新进度并实时显示当前结果
            if (!cached) {
              renderProgress(index, allStudents.length);
              const topPreview = processed.slice().sort((a,b) => b.rankingScore - a.rankingScore).slice(0, 12);
              topPreview.forEach((s, i) => s.__rankTmp = i + 1);
              renderIncrementalRows(topPreview);
            }
            
            const elapsed = performance.now() - start;
            // 减少延迟，提升响应速度
            const delay = elapsed > 100 ? 10 : 0;
            if(window.__perfFlags && window.__perfFlags.instrumentRanking){
              const dur = (performance.now()-start).toFixed(1);
              dbg(`[perf] ranking batch processed ${batch.length} -> total ${index}/${allStudents.length} in ${dur}ms`);
            }
            setTimeout(processBatch, delay);
          } else {
            // 全部完成
            processed.sort((a, b) => b.rankingScore - a.rankingScore);
            processed.forEach((s, i) => s.__rankTmp = i + 1);
            items = processed;
            container.__lbProgress = false;
            finalizeRankingRender();
          }
        }

        // 将后续渲染封装，供分块结束后调用
        async function finalizeRankingRender(){
          const __finalStart = performance.now();
          try {
            if(!Array.isArray(items) || !items.length){
              container.innerHTML = `<div class="ranking-hero"><div class="ranking-hero-sub">暂无排行榜数据</div></div>`; return;
            }
            // 统一兜底：空或非法分数设为 0
            items.forEach(it=>{ if(!Number.isFinite(it.rankingScore)) it.rankingScore = 0; });

            // === 白名单过滤 + 去重（防已删除 / 重复 / 幽灵学生）===
            try {
              const allowed = new Set(appState.studentsMeta?.keys?.() ? Array.from(appState.studentsMeta.keys()) : []);
              if (allowed.size) {
                const before = items.length;
                const seen = new Set();
                items = items.filter(it => allowed.has(it.name) && !seen.has(it.name) && seen.add(it.name));
                if (before !== items.length) {
                  try { localStorage.removeItem(RANK_CACHE_KEY); localStorage.removeItem('__scoreCache'); } catch(_) {}
                  dbg('[ranking] 过滤已删/重复学生:', before - items.length);
                }
              }
            } catch(e){ dbg('白名单过滤失败(忽略继续):', e); }

            // 排序（确保最终顺序）
            items.sort((a,b)=> b.rankingScore - a.rankingScore);
            const top3 = items.slice(0,3);
            const rest = items.slice(3);

            const titleInfo = (typeof getRankingTitleInfo==='function') ? getRankingTitleInfo() : { title:'排行榜', subtitle:'' };
            const weeklyHintHTML = (typeof rankingMode!=='undefined' && rankingMode === 'weekly' && typeof getActiveLeaderboardDate==='function' && typeof isWorkday==='function' && isWorkday(getActiveLeaderboardDate()))
              ? '<div class="ranking-hero-sub">含今日实时分（如在工作日）</div>' : '';

            const buildScoreText = s => (s.isWeekly ? (Number.isFinite(s.rankingScore)?s.rankingScore.toFixed(1):'-') : (Number.isFinite(s.rankingScore)?s.rankingScore.toFixed(1):'-')) + '分';
            const buildDetailBtn = s => s.isWeekly
                ? `<button class="score-detail-btn" onclick="event.stopPropagation(); (window.showWeeklyScores?showWeeklyScores('${s.name}'):alert('周榜详情未加载'))" title="查看5日分数">?</button>`
                : `<button class="score-detail-btn" onclick="event.stopPropagation(); showScoreDetail('${s.name}')" title="查看评分详情">?</button>`;

            const createTop3Card = (s, rank) => {
              const rankClass = rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : 'rank-3';
              const positionClass = rank === 1 ? ' first-place' : rank === 2 ? ' second-place' : ' third-place';
              return `<div class="top3-card${positionClass}" data-student="${s.name}" onclick="openStudentDetailFromRankingFull('${s.name}')">`+
                `<div class="rank-badge ${rankClass}">${rank}</div>`+
                `<div class="top3-name">${s.name}</div>`+
                `<div class="top3-points">${buildScoreText(s)} ${buildDetailBtn(s)}</div>`+
              `</div>`;
            };

            let top3HTMLBlock = '';
            if(top3.length){
              // 顺序：2,1,3 保持视觉中心突出第一名
              if(top3[1]) top3HTMLBlock += createTop3Card(top3[1],2);
              if(top3[0]) top3HTMLBlock += createTop3Card(top3[0],1);
              if(top3[2]) top3HTMLBlock += createTop3Card(top3[2],3);
            }

            const top3HTML = `<div class="ranking-hero">`+
              `<div class="ranking-title"><h2>${titleInfo.title}</h2><p class="ranking-subtitle">${titleInfo.subtitle||''}</p>${weeklyHintHTML}</div>`+
              `<div class="top3-wrap">${top3HTMLBlock}</div>`+
            `</div>`;

            const rowsHTML = `<div class="ranking-section"><div class="ranking-rows">`+
              rest.map((s,idx)=>{
                const rank = idx + 4;
                return `<div class='ranking-row' data-student='${s.name}' onclick="openStudentDetailFromRankingFull('${s.name}')">`+
                  `<div class='rank-num'>${rank}</div>`+
                  `<div class='row-user'><div class='row-name'>${s.name}</div></div>`+
                  `<div class='row-points'>${buildScoreText(s)} ${buildDetailBtn(s)}</div>`+
                `</div>`;
              }).join('')+
            `</div></div>`;

            const newHTML = top3HTML + rowsHTML;
            // 内容相同则跳过 DOM 更新避免闪烁（哈希或直接字符串比较）
            if (minimalAutoRefresh && container.__lastRankingHtml === newHTML) {
              dbg('排行榜内容未变化，跳过重绘');
              return;
            }
            scheduleDOM(()=>{ container.innerHTML = newHTML; }, 2);
            if(window.__perfFlags && window.__perfFlags.instrumentRanking){ dbg(`[perf] finalizeRankingRender DOM ${(performance.now()-__finalStart).toFixed(1)}ms for ${items.length} students`); }
            // === 排行榜事件委托（防止后续 DOM 局部刷新错位）===
            (function bindRankingDelegation(){
              if (container.__delegated) return; // 只绑定一次
              container.addEventListener('click', e => {
                const card = e.target.closest('.ranking-row, .top3-card');
                if(!card) return;
                const studentName = card.getAttribute('data-student');
                if(!studentName) return;
                if(!appState.studentsMeta?.has?.(studentName)) { console.warn('[ranking] stale click ignored:', studentName); return; }
                openStudentDetailFromRankingFull(studentName);
              });
              container.__delegated = true;
            })();
            container.__lastRankingHtml = newHTML;
            container.__lbProgress = false;
            try { if(typeof saveRankCache==='function' && typeof activeIso!=='undefined'){ saveRankCache(activeIso, top3HTML + rowsHTML, { count: items.length }); } } catch(_){}
            dbg('最终排行榜渲染完成',{ count: items.length });
            // 恢复滚动
            if (keepScroll) {
              try { window.scrollTo({ top: winScrollY, behavior: 'instant' }); } catch(_){}
              try { container.scrollTop = containerScrollTop; } catch(_){}
            }
          } catch(e){ dbg('finalizeRankingRender error', e); scheduleDOM(()=>{ container.innerHTML = `<div class='ranking-hero'><div class='ranking-hero-sub'>渲染出错：${e.message}</div></div>`; },1); }
        }

        // 启动分块计算（等待预热完成或超时后开始）
        Promise.race([
          prefetchPromise,
          new Promise(resolve => setTimeout(resolve, 500)) // 最多等待500ms
        ]).finally(() => {
          processBatch();
        });
        // 等待异步完成后，后续代码会在 finalizeRankingRender 中继续。
        // 注意：下面依赖 items 的代码会在异步完成时再次运行（通过 finalizeRankingRender），因此此处先提前 return，避免继续执行旧同步路径。
        return; // 终止当前同步分支，等待异步渲染完成
      }

      dbg('处理后的 items:', { itemsCount: items.length });

      if (items.length === 0) {
        dbg('items 为空，显示无数据提示');
        container.innerHTML = `
          <div class="ranking-hero">
            <div class="ranking-hero-sub">暂无排行榜数据</div>
          </div>`;
        return;
      }

      // 生成 Top3
      const top3 = items.slice(0, 3);
      const rest = items.slice(3);

      // 动态生成标题
      const titleInfo = getRankingTitleInfo();
      const weeklyHintHTML = (rankingMode === 'weekly' && isWorkday(getActiveLeaderboardDate()))
        ? '<div class="ranking-hero-sub">含今日实时分（如在工作日）</div>'
        : '';
      
  const top3HTML = `
        <div class="ranking-hero">
          <div class="ranking-title">
            <h2>${titleInfo.title}</h2>
            <p class="ranking-subtitle">${titleInfo.subtitle}</p>
            ${weeklyHintHTML}
          </div>
          <div class="top3-wrap">
            ${top3.length > 0 ? (() => {
              const createCard = (s, rank) => {
                let initials;
                try {
                  initials = utils.getStudentInitials(s.name);
                } catch (e) {
                  dbg('getStudentInitials 出错:', s.name, e);
                  initials = s.name.charAt(0) || '?';
                }
                const rankClass = rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : 'rank-3';
                const positionClass = rank === 1 ? ' first-place' : rank === 2 ? ' second-place' : ' third-place';
                const scoreText = s.isWeekly 
                  ? `${Number.isFinite(s.rankingScore)?s.rankingScore.toFixed(1):'-'}分`
                  : `${Number.isFinite(s.rankingScore)?s.rankingScore.toFixed(1):'-'}分`;
                const detailBtn = s.isWeekly
                  ? `<button class="score-detail-btn" onclick="event.stopPropagation(); showWeeklyScores('${s.name}')" title="查看5日分数">?</button>`
                  : `<button class="score-detail-btn" onclick="event.stopPropagation(); showScoreDetail('${s.name}')" title="查看评分详情">?</button>`;
                return `
                  <div class="top3-card${positionClass}" onclick="openStudentDetailFromRankingFull('${s.name}')">
                    <div class="rank-badge ${rankClass}">${rank}</div>
                    <div class="top3-name">${s.name}</div>
                    <div class="top3-points">
                      ${scoreText}
                      ${detailBtn}
                    </div>
                  </div>
                `;
              };
              
              // 按照布局顺序：第二名、第一名、第三名
              let html = '';
              if (top3[1]) html += createCard(top3[1], 2); // 第二名在左侧
              if (top3[0]) html += createCard(top3[0], 1); // 第一名在中间
              if (top3[2]) html += createCard(top3[2], 3); // 第三名在右侧
              return html;
            })() : ''}
          </div>
        </div>`;

      const rowsHTML = `
        <div class="ranking-section">
          <div class="ranking-rows">
            ${rest.map((s, idx) => {
              const rank = idx + 4;
              let initials;
              try {
                initials = utils.getStudentInitials(s.name);
              } catch (e) {
                dbg('getStudentInitials 出错 (rest):', s.name, e);
                initials = s.name.charAt(0) || '?';
              }
              const scoreText = s.isWeekly 
                ? `${Number.isFinite(s.rankingScore)?s.rankingScore.toFixed(1):'-'}分`
                : `${Number.isFinite(s.rankingScore)?s.rankingScore.toFixed(1):'-'}分`;
              const detailBtn = s.isWeekly
                ? `<button class="score-detail-btn" onclick="event.stopPropagation(); showWeeklyScores('${s.name}')" title="查看5日分数">?</button>`
                : `<button class="score-detail-btn" onclick="event.stopPropagation(); showScoreDetail('${s.name}')" title="查看评分详情">?</button>`;
              return `
                <div class="ranking-row" onclick="openStudentDetailFromRankingFull('${s.name}')">
                  <div class="rank-num">${rank}</div>
                  <div class="row-user">
                    <div class="row-name">${s.name}</div>
                  </div>
                  <div class="row-points">
                    ${scoreText}
                    ${detailBtn}
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        </div>`;

      container.innerHTML = top3HTML + rowsHTML;
      try {
        // 若分块模式完成后会再走这里，保存缓存
        if(typeof saveRankCache === 'function' && typeof activeIso !== 'undefined'){
          saveRankCache(activeIso, top3HTML + rowsHTML, { count: items.length });
        }
      } catch(_){}
      
      // 添加全局函数供HTML调用
      window.loadMoreRankings = () => {
        // 这里可以实现懒加载逻辑
        console.log('加载更多排名...');
      };
      
      dbg('HTML 已设置到容器，最终 HTML 长度:', (top3HTML + rowsHTML).length);

      // 将方法挂载到全局，供按钮使用
      window.showWeeklyScores = function(studentName) {
        try {
          const map = window.__weeklyDetailMap || {};
          const entry = map[studentName];
          const datesIso = (entry && entry.datesIso) || window.__weeklyDatesIso || [];
          const datesLabel = (entry && entry.datesLabel) || window.__weeklyDatesLabel || [];
          const scores = (entry && entry.scores) || [];
          // 构建列表内容
          const todayIso = utils.toIsoDate(getActiveLeaderboardDate());
          const rows = datesIso.map((iso, i) => {
            const lab = datesLabel[i] || iso;
            const sc = (scores[i] != null ? Number(scores[i]).toFixed(1) : '0.0');
            const todayMark = (iso === todayIso) ? ' <span style="color: var(--brand-600); font-weight: 600;">(今日)</span>' : '';
            return `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px dashed var(--border-weak);">
              <div style="color: var(--text-2);">${lab}${todayMark}</div>
              <div style="font-weight:600;">${sc} 分</div>
            </div>`;
          }).join('');
          const avg = scores.length ? (scores.reduce((a,b)=>a+Number(b||0),0)/scores.length) : 0;
          const header = `<div style="margin-bottom:10px; color: var(--text-3);">最近5个工作日（0分填充${isWorkday(getActiveLeaderboardDate()) ? '，含今日实时分' : ''}）</div>`;
          const content = `${header}${rows}<div style="margin-top:10px; text-align:right; color: var(--text-2);">5日平均：<b>${avg.toFixed(1)} 分</b></div>`;
          createScoreDetailModal(content, `${studentName} 的5日分数`);
        } catch (e) {
          console.warn('showWeeklyScores error:', e);
        }
      };
      dbg('容器样式:', getComputedStyle(container).display, getComputedStyle(container).visibility);
      dbg('容器父级 ranking 状态:', document.getElementById('rankingView'), document.getElementById('rankingView')?.hidden);

      // 自动同步当日排行榜到数据库（异步执行，不阻塞界面）
      if (items.length > 0 && !items[0].isWeekly) {
        syncTodayLeaderboard().catch(e => console.warn('完整排行榜自动同步失败:', e));
      }
    }

    // 更新排行榜标签页状态
    function updateRankingTabs() {
      const dailyTab = document.getElementById('dailyRankingTab');
      const weeklyTab = document.getElementById('weeklyRankingTab');
      
      if (dailyTab && weeklyTab) {
        dailyTab.classList.toggle('active', rankingMode === 'daily');
        weeklyTab.classList.toggle('active', rankingMode === 'weekly');
      }
    }

    // 切换排行榜模式
    async function switchRankingMode(mode) {
      if (rankingMode === mode) return;
      const container = document.getElementById('rankingFullList');
      // 记录当前内容到缓存（若有内容且非骨架）
      if (container && container.children.length > 0 && !container.querySelector('.ranking-item--skeleton')) {
        rankingModeHtmlCache[rankingMode] = { html: container.innerHTML, ts: Date.now() };
      }
      rankingMode = mode;
      dbg('切换排行榜模式至:', mode);

      // 如果目标模式已经有缓存，直接无闪烁切换并异步后台刷新
      const cached = rankingModeHtmlCache[mode];
      if (cached && cached.html) {
        container.innerHTML = cached.html;
        container.classList.add(RANKING_FADE_CLASS);
        setTimeout(()=>container.classList.remove(RANKING_FADE_CLASS), 320);
        // 后台刷新（不显示骨架）
        renderRankingFull({ silent: true, skipSkeleton: true, modeForce: mode }).catch(()=>{});
        return;
      }
      // 没缓存：先保留旧内容（不清空），加半透明过渡提示再加载
      if (container) {
        container.style.opacity = '0.4';
      }
      await renderRankingFull({ modeForce: mode });
      if (container) {
        container.style.opacity = '';
        container.classList.add(RANKING_FADE_CLASS);
        setTimeout(()=>container.classList.remove(RANKING_FADE_CLASS), 320);
      }
    }

  // 获取排行榜标题信息
    function getRankingTitleInfo() {
      if (rankingMode === 'weekly') {
    // 使用活跃排行榜日期口径
    const refDate = getActiveLeaderboardDate();
    const endWorkday = nearestWorkdayOnOrBefore(refDate);
    const workdayDates = getLastNWorkdayDates(endWorkday, 5);
    const startDate = workdayDates[0];
    const endDate = workdayDates[workdayDates.length - 1];
        
        const formatDate = (date) => {
          return `${date.getMonth() + 1}/${date.getDate()}`;
        };
        
        return {
          title: '周榜排行',
          subtitle: `${formatDate(startDate)} - ${formatDate(endDate)}`
        };
      } else {
        const activeDate = getActiveLeaderboardDate();
        const formatDate = (date) => {
          return `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
        };
        
        return {
          title: '日榜排行',
          subtitle: formatDate(activeDate)
        };
      }
    }

    function openStudentDetailFromRankingFull(studentName) {
      // 防御：若学生已被删除或白名单无此人，忽略点击
      if (!appState.studentsMeta?.has?.(studentName)) {
        console.warn('openStudentDetailFromRankingFull: stale/invalid student', studentName);
        return;
      }
      
      console.log('从完整排行榜进入学生详情:', studentName);
      console.log('当前 uiState.rankingOrigin:', uiState.rankingOrigin);
      
      uiState.previousView = 'ranking'; // 详情返回优先回到排行榜
      uiState.view = 'detail';
      uiState.selectedStudent = studentName;
      // 保持 rankingOrigin 不变，以备异常情况使用
      
      console.log('更新后的 uiState:', uiState);
      updateViews();
    }

    // 显示学生评分详情
  async function showScoreDetail(studentName) {
      const activeDate = getActiveLeaderboardDate();
  const slotsMin = getLeaderboardSlotsMinutes(studentName, activeDate);
  const intervalsMs = getLeaderboardPracticeIntervalsMs(studentName, activeDate);
      const dayStartMs = toDayStart(activeDate);
      const weekday0to6 = activeDate.getDay();
      
      // 若当日无任何练琴区间：不计分（各维度置0、总分显示为“-”），避免出现残留的历史加分
      const noPracticeToday = !intervalsMs || intervalsMs.length === 0;
  let d1, d2, d3res, totalScore, totalScoreDisplay;
      if (noPracticeToday) {
        d1 = { score: 0, breakdown: { noPractice: true } };
        d2 = { score: 0, breakdown: { noPractice: true } };
        d3res = { score: 0, breakdown: { noPractice: true } };
        totalScore = 0;
        totalScoreDisplay = '-';
      } else {
        // 计算三个维度的详细分数（D3 改为云端历史数据口径）
        d1 = computeDim1Score(slotsMin, intervalsMs, dayStartMs);
        d2 = computeDim2Score(slotsMin, intervalsMs, dayStartMs, weekday0to6);
        d3res = await computeDim3ScoreCloud(
          utils.normalizeStudentName(studentName),
          activeDate,
          d1.score + d2.score
        );
        let totalRaw = d1.score + d2.score + d3res.score;
        if (d1.breakdown && d1.breakdown.gotFullBonus) {
          totalRaw += (d1.breakdown.fullBonusAward || 0);
        }
        
        // 管理员调分
        const adminAdjustment = getAdminScoreAdjustment(studentName);
        if (adminAdjustment !== 0) {
          totalRaw += adminAdjustment;
        }
        
        totalScore = totalRaw;
        totalScoreDisplay = totalRaw.toFixed(1);
      }
      
      // 创建进度条
      function createProgressBar(score, maxScore, className) {
        const percentage = Math.min((score / maxScore) * 100, 100);
        return `
          <div class="score-bar">
            <div class="score-fill ${className}" style="width: ${percentage}%"></div>
          </div>
        `;
      }
      
      // 状态评估
      const getD1Status = () => {
        if (d1.score >= 35) return { text: '出勤优秀', color: '#2e7d32' };
        if (d1.score >= 25) return { text: '基本达标', color: '#ef6c00' };
        return { text: '需要改进', color: '#d32f2f' };
      };
      
      const getD2Status = () => {
        if (d2.score >= 35) return { text: '质量优秀', color: '#2e7d32' };
        if (d2.score >= 25) return { text: '质量良好', color: '#ef6c00' };
        return { text: '需优化', color: '#d32f2f' };
      };
      
      const getD3Status = () => {
        if (d3res.score >= 15) return { text: '成长优秀', color: '#2e7d32' };
        if (d3res.score >= 10) return { text: '稳步成长', color: '#ef6c00' };
        return { text: '待激活', color: '#888' };
      };
      
      const d1Status = getD1Status();
      const d2Status = getD2Status();
      const d3Status = getD3Status();

      // 小工具：分钟转 08:30 格式
      const mmToHHMM = (m) => `${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}`;
      const fmt = (n, d=1) => (Number.isFinite(n) ? (+n).toFixed(d) : '-');

      // D1 明细列表
      const d1List = (d1.breakdown?.slots || []).map(s => {
        const time = `${mmToHHMM(s.start)}-${mmToHHMM(s.end)}`;
        const parts = [];
        const isOngoing = s.status === '进行中';
        if (isOngoing) {
          // 进行中：展示实时进度与迟到，不展示未完成/缺席扣分（扣分只在段结束后确定）
          const evalDur = s.durMin || 0; // 评估窗口长度（firstStart->当前）
            const practiced = Math.min(evalDur, s.overlapMin || 0);
          const coveragePct = fmt(s.coverage,1);
          let line = `${time} · 进行中（覆盖${coveragePct}% / 已练${fmt(practiced,1)}分`;
          if (s.lateMin > 0) line += ` / 迟到${s.lateMin}分`;
          line += '）';
          parts.push(line);
        } else {
          parts.push(`${time} · ${s.status}（覆盖${fmt(s.coverage,1)}%）`);
          if (s.missMin > 0 && s.incompletePenalty > 0) parts.push(`未完成${fmt(s.missMin,1)}分钟 → 扣${fmt(s.incompletePenalty,2)}分`);
          if (s.absentPenalty > 0) parts.push(`缺席 → 扣${fmt(s.absentPenalty,2)}分`);
          if (s.lateMin > 0 || s.latePenalty > 0) parts.push(`迟到${s.lateMin}分 → 扣${fmt(s.latePenalty,2)}分`);
        }
        return `<li>${parts.join('；')}</li>`;
      }).join('');

      const d1Summary = (() => {
        const b = d1.breakdown || {};
        const items = [];
        if (b.incompletePenalty > 0) items.push(`未完成扣分：${fmt(b.incompletePenalty,2)}`);
        if (b.absent > 0) items.push(`缺席${b.absent}段，共扣：${fmt(b.absentPenalty,2)}`);
        if (b.latePenalty > 0) items.push(`迟到合计扣分：${fmt(b.latePenalty,2)}`);
  if (b.gotFullBonus) items.push(`满勤加成将在总分生效：+${fmt(b.fullBonusAward||0,0)}`);
        if (items.length === 0) items.push('无扣分项');
        return items.join(' / ');
      })();

      // D2 明细列表
      const d2List = (d2.breakdown?.intervals || []).map(iv => {
        const time = `${mmToHHMM(iv.startMin)}-${mmToHHMM(iv.endMin)}（${iv.lengthMin}分）`;
        const parts = [time];
        if (iv.longPenalty > 0) parts.push(`超长${Math.max(0, iv.longOverMin)}分 → 扣${fmt(iv.longPenalty,2)}`);
        if (iv.shortPenalty > 0) parts.push(`短时差${iv.shortDeficitMin}分 → 扣${fmt(iv.shortPenalty,2)}`);
        if (iv.appliedTail && iv.tailPenalty > 0) parts.push(`拖尾${iv.tailMin}分 → 扣${fmt(iv.tailPenalty,2)}`);
        if (!iv.appliedTail && iv.lowPenalty > 0) parts.push(`低效窗口${iv.lowOverlapMin}分 → 扣${fmt(iv.lowPenalty,2)}`);
        const details = parts.length > 1 ? parts.slice(1).join('；') : '无扣分项';
        return `<li>${parts[0]}：${details}</li>`;
      }).join('');

      const d2Summary = (() => {
        const b = d2.breakdown || {};
        const items = [];
        if (b.longPenalty > 0) items.push(`超长：${fmt(b.longPenalty,2)}`);
        if (b.shortPenalty > 0) items.push(`短时：${fmt(b.shortPenalty,2)}`);
        if (b.tailPenalty > 0) items.push(`拖尾：${fmt(b.tailPenalty,2)}`);
        if (b.windowPenalty > 0) items.push(`低效：${fmt(b.windowPenalty,2)}`);
        if (items.length === 0) items.push('无扣分项');
        return items.join(' / ');
      })();

      // D3 明细
      const d3b = d3res.breakdown || {};
  // NOTE: 之前 rankPoints/progressPoints 用 fmt(...,0) 导致 1.5 → 2 进位，
  // 与总分（保留内部 0.5 粒度）不一致，出现合计多 0.5 的错觉；改为一位小数保持可加性。
  const d3List = `
    <li>昨日排名：${d3b.yesterdayRank ? `第${d3b.yesterdayRank}名` : '无'} → +${fmt(d3b.rankPoints,1)}分</li>
  <li>周进步：${(()=>{const pd=d3b.progressDetail; if(!pd) return '—'; const r=pd.rawRatioAvg; const cls=(r==null)?'delta-zero':(r>0?'delta-pos':(r<0?'delta-neg':'delta-zero')); const capped=(pd.appliedRatio!=null && Math.abs((pd.appliedRatio - pd.ratio)||0)>=0.1); return `均 ${fmt(pd.avgPrev,2)} → ${fmt(pd.avgCur,2)}（<span class=\"delta ${cls}\">${r??'-'}%</span>${capped?`，计分${fmt(pd.appliedRatio,1)}%`:''}${pd.gatedByActiveDays?`；数据不足（近${pd.curActiveDays||0}/${pd.prevActiveDays||0} 有效天，需≥${pd.minActiveDaysRequired||0}）`:''}`; })()}） → +${fmt(d3b.progressPoints,1)}分
    ${Array.isArray(d3b.progressDetail?.curDays) && Array.isArray(d3b.progressDetail?.prevDays)
      ? (()=>{ const pd=d3b.progressDetail; const W=pd.curDays.length||5; const maxVal=Math.max(10,...pd.curDays,...pd.prevDays); const scale=v=> (maxVal? ( (1 - v/maxVal)*34 ).toFixed(2):34); const step=140/Math.max(1,W-1); const buildPath=(arr)=> arr.map((v,i)=> `${i===0?'M':'L'}${(i*step).toFixed(2)},${scale(v)}`).join(' '); const curP=buildPath(pd.curDays); const prevP=buildPath(pd.prevDays); return `<div class=\"score-sub\">`+
        `<svg class=\"sparkline\" viewBox=\"0 0 140 34\" preserveAspectRatio=\"none\">`+
        `<path class=\"spark-prev\" d=\"${prevP}\" />`+
        `<path class=\"spark-cur\" d=\"${curP}\" />`+
        `</svg>`+
        `近5天：${pd.curDays.map(v=>fmt(v,1)).join(', ')} | 合 ${fmt(pd.cur7Total,1)} (均 ${fmt(pd.avgCur,2)})<br/>`+
        `前5天：${pd.prevDays.map(v=>fmt(v,1)).join(', ')} | 合 ${fmt(pd.prev7Total,1)} (均 ${fmt(pd.avgPrev,2)})`+
        `</div>`; })()
      : ''}
  </li>
  <li>稳定性：标准差 ${fmt(d3b.consistencyStd,2)} → +${fmt(d3b.consistencyPoints,1)}分</li>
    ${d3b.antiBonusPoints ? `<li>公平性奖励：+${fmt(d3b.antiBonusPoints,1)}分</li>` : ''}
    ${d3b.freshnessMultiplier ? `<li>反霸榜：乘数 ×${fmt(d3b.freshnessMultiplier,2)}${d3b.antiNote?`（${d3b.antiNote}）`:''}</li>` : ''}
  `;

      const totalBonusLine = (d1.breakdown && d1.breakdown.gotFullBonus)
        ? `<div class="score-sub">总分加成：满勤 +${fmt(d1.breakdown.fullBonusAward||0,0)}</div>`
        : '';
      
      // 管理员调整信息
      const adminAdjustment = getAdminScoreAdjustment(studentName);
      const adminAdjustmentDetails = getAdminScoreAdjustmentDetails(studentName);
      const adminAdjustmentLine = adminAdjustment !== 0 
        ? `<div class="score-sub" style="color:#cbd5e1;border-left:2px solid #cbd5e1;padding-left:8px;margin-top:8px;font-weight:500;">
             <span style="display:inline-block;min-width:72px;">管理员调整：</span><span>${adminAdjustment > 0 ? '+' : ''}${adminAdjustment.toFixed(1)}分</span>
             ${adminAdjustmentDetails && adminAdjustmentDetails.reason ? `<br><span style="font-size:11px;opacity:.7;">说明：${adminAdjustmentDetails.reason}</span>` : ''}
           </div>`
        : '';
      
      const content = `
        <div class="lb-section">
          <div class="lb-card lb-card--gradient" style="background:linear-gradient(135deg,#667eea,#764ba2);border:none;">
            <div class="lb-kv"><strong>${studentName}</strong><span>442 综合评分详情</span></div>
            <div style="margin-top:8px;font-size:30px;font-weight:800;">${totalScoreDisplay}</div>
            <div style="opacity:.9;font-size:11px;">总分 / 100</div>
            ${totalBonusLine}
            ${adminAdjustmentLine}
          </div>
          <div style="margin-top:6px;color:#64748b;font-size:12px;">提示：当日无练琴则不计分。</div>
        </div>

        <div class="lb-section">
          <div class="lb-card lb-card--d1">
            <div class="lb-kv"><h4 style="margin:0;">📅 维度一：出勤完成度 (40分)</h4><strong>${d1.score.toFixed(1)}分</strong></div>
            ${createProgressBar(d1.score, 40, 'd1')}
            <div class="lb-kv" style="margin-top:4px;"><span>${d1Status.text}</span><span style="color:#64748b;">概览：${d1Summary}</span></div>
            <details class="lb-details" style="margin-top:6px;">
              <summary>展开明细 <span style="margin-left:6px;font-size:11px;color:#334155;background:#e2e8f0;border-radius:10px;padding:2px 6px;white-space:nowrap;">实时统计，未开始时段不计分</span></summary>
              <ul class="lb-list">${d1List || '<li>无时段记录</li>'}</ul>
            </details>
          </div>
        </div>

        <div class="lb-section">
          <div class="lb-card lb-card--d2">
            <div class="lb-kv"><h4 style="margin:0;">⚡ 维度二：练琴质量 (40分)</h4><strong>${d2.score.toFixed(1)}分</strong></div>
            ${createProgressBar(d2.score, 40, 'd2')}
            <div class="lb-kv" style="margin-top:4px;"><span>${d2Status.text}</span><span style="color:#64748b;">概览：${d2Summary}</span></div>
            <details class="lb-details" style="margin-top:6px;">
              <summary>展开明细</summary>
              <ul class="lb-list">${d2List || '<li>无练习区间</li>'}</ul>
            </details>
          </div>
        </div>

        <div class="lb-section">
          <div class="lb-card lb-card--d3">
            <div class="lb-kv"><h4 style="margin:0;">🏆 维度三：历史表现 (20分)</h4><strong>${d3res.score.toFixed(1)}分</strong></div>
            ${createProgressBar(d3res.score, 20, 'd3')}
            <div class="lb-kv" style="margin-top:4px;"><span>${d3Status.text}</span></div>
            <details class="lb-details" style="margin-top:6px;">
              <summary>展开明细</summary>
              <ul class="lb-list">${d3List}</ul>
            </details>
          </div>
        </div>

        <div class="lb-section">
          <div class="lb-card">
            <h4>💡 计算公式</h4>
            <p>总分 = D1×40% + D2×40% + D3×20%${(d1.breakdown && d1.breakdown.gotFullBonus)?' + 满勤加成':''}${adminAdjustment !== 0 ? ' + 管理员调整' : ''} = ${d1.score.toFixed(1)} + ${d2.score.toFixed(1)} + ${d3res.score.toFixed(1)}${(d1.breakdown && d1.breakdown.gotFullBonus)?` + ${(d1.breakdown.fullBonusAward||0)}`:''}${adminAdjustment !== 0 ? ` ${adminAdjustment > 0 ? '+' : ''}${adminAdjustment.toFixed(1)}` : ''} = <strong>${totalScore.toFixed(1)}</strong></p>
          </div>
        </div>
      `;
      
      createScoreDetailModal(content, studentName);
    }
    
    // 创建评分详情模态框
    function createScoreDetailModal(content, title) {
      // 移除现有模态框
      const existing = document.querySelector('.score-detail-modal, .lb-modal');
      if (existing) {
        existing.remove();
      }
      
      const modal = document.createElement('div');
      modal.className = 'lb-modal';
      modal.innerHTML = `
        <div class="lb-dialog">
          <div class="lb-dialog__header">
            <div class="lb-dialog__title">${title || '详情'}</div>
            <button class="lb-dialog__close" onclick="closeScoreDetailModal()" aria-label="关闭">&times;</button>
          </div>
          <div class="lb-dialog__body">
            ${content}
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // 显示动画
      requestAnimationFrame(() => {
        modal.classList.add('show');
      });
      
      // 点击背景关闭
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeScoreDetailModal();
        }
      });
      
      // ESC键关闭
      const handleEsc = (e) => {
        if (e.key === 'Escape') {
          closeScoreDetailModal();
          document.removeEventListener('keydown', handleEsc);
        }
      };
      document.addEventListener('keydown', handleEsc);
    }
    
    // 关闭评分详情模态框
    function closeScoreDetailModal() {
  const modal = document.querySelector('.lb-modal');
      if (modal) {
        modal.classList.remove('show');
        setTimeout(() => {
          modal.remove();
        }, 200);
      }
    }

    // ===== 排行规则详情（复刻旧系统样式与文案） =====
    function showLeaderboardRuleDoc() {
      ensureLBExtraStyles();
      const content = `
        <div class="lb-section">
          <div class="lb-card lb-card--gradient" style="background:linear-gradient(135deg,#0ea5e9,#6366f1);border:none;">
            <h4 style="margin:0 0 4px;font-size:18px;">442 测评体系</h4>
            <p style="opacity:.95;">练琴质量综合评价模型 · 结构化 · 可解释 · 可持续激励 · 权重 40:40:20</p>
          </div>
        </div>

        <div class="lb-section">
          <div class="lb-section__title">一、核心理念 <span>Why 442?</span></div>
          <div class="lb-grid lb-grid--4">
            <div class="lb-card"><h4>🎯 客观性</h4><p>时间区间 + 覆盖率 + 有效分钟代替主观打分</p></div>
            <div class="lb-card"><h4>⚖️ 均衡性</h4><p>出勤完成 / 质量效率 / 成长动力 三维并重</p></div>
            <div class="lb-card"><h4>🔄 正循环</h4><p>奖励稳定投入与进步，而非极端刷时长</p></div>
            <div class="lb-card"><h4>💎 透明化</h4><p>所有扣分加成都有来源，长期稳定进步</p></div>
          </div>
        </div>

        <div class="lb-section">
          <div class="lb-grid lb-grid--1">
            <div class="lb-card">
              <h4>📅 维度1 出勤完成 40%</h4>
              <ul class="lb-list">
                <li>按覆盖率连续计分；缺席=0分</li>
                <li>迟到宽限5分钟（宽限内不扣分）</li>
                <li>满勤加成：3/4/≥5 时间段 +1/+2/+3（在总分阶段叠加）</li>
              </ul>
            </div>
            <div class="lb-card">
              <h4>⚡ 维度2 质量效率 40%</h4>
              <ul class="lb-list">
                <li>单段30~125分钟最佳</li>
                <li>过短/过长递减</li>
                <li>低效时间段折减</li>
              </ul>
            </div>
            <div class="lb-card">
              <h4>🏆 维度3 成长加成 20%</h4>
              <ul class="lb-list">
                <li>昨日排名：第1=3分 → 第10=1分 线性计算加分</li>
                <li>周进步：近5工作日vs 前5工作日，提升封顶50% 按提升比例加0~6分</li>
                <li>稳定性：有效日标准差 加0→3分</li>
                <li>反霸榜：连续登顶递减乘子；距上次登顶≥2日 +1 公平性奖励</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="lb-section">
          <div class="lb-card">
            <h4>📐 计算方法</h4>
            <p>总分 = 维度1×0.4 + 维度2×0.4 + 维度3×0.2；排序：总分 → 维度1 → 维度2 → 维度3 → 姓名。</p>
          </div>
        </div>

        <div class="lb-section">
          <div class="lb-grid lb-grid--2">
            <div class="lb-card">
              <h4>⚠️ 低效时段</h4>
              <ul class="lb-list">
                <li>具体窗口（仅工作日）：<br/>周一/二/四/五：12:10–12:40、18:10–18:40；周三：12:10–13:20、18:40–19:10</li>
                <li>周末无低效窗口</li>
                <li>若练习区间与低效窗口重叠：按重叠分钟 × 每分钟扣分（有单段上限）</li>
                <li>同一练习区间若触发拖尾扣分，则不再叠加低效扣分（拖尾优先）</li>
              </ul>
            </div>
            <div class="lb-card">
              <h4>🛡️ 反霸榜</h4>
              <ul class="lb-list">
                <li>连续登顶≥3工作日：逐日衰减</li>
                <li>≥5工作日：额外强衰减</li>
                <li>距上次登顶≥2工作日：公平性奖励</li>
              </ul>
            </div>
          </div>
        </div>
      `;
      createScoreDetailModal(content, '排行规则详情');
    }

    function ensureLBExtraStyles(){
      if(document.getElementById('lb-detail-extra-styles')) return;
      const style=document.createElement('style');
      style.id='lb-detail-extra-styles';
      style.textContent=`/* 评分详情 & 442 说明扩展样式 */
      .lb442-doc .metric-card{background:#ffffff;border:1px solid var(--border-color,#e2e8f0);border-radius:12px;padding:14px 16px;box-shadow:0 2px 6px rgba(0,0,0,.06);transition:.25s;}
      .lb442-doc .metric-card:hover{box-shadow:0 6px 18px -4px rgba(0,0,0,.18);} 
      .lb442-doc .metric-card h4{margin:0 0 6px;font-size:15px;font-weight:600;display:flex;align-items:center;gap:6px;}
      .lb442-doc .metric-card ul{margin:6px 0 0;padding-left:18px;font-size:12px;line-height:1.6;}
      .lb442-doc .formula-box{background:#ffffff;color:#1e293b;border:1px solid #e2e8f0;padding:10px 12px;border-radius:10px;font-size:13px;font-weight:600;}
      .lb442-doc .lb442-section{position:relative;}
      .lb442-doc .lb442-head{margin:0 0 18px;padding:0;border:none;}
      .lb442-doc .lb-head-card{background:linear-gradient(135deg,#0d47a1,#1976d2 55%,#42a5f5);border:1px solid rgba(255,255,255,.25);border-radius:18px;padding:26px 24px 22px;position:relative;overflow:hidden;color:#fff;box-shadow:0 10px 28px -8px rgba(13,71,161,.55),0 4px 16px -4px rgba(0,0,0,.35);} 
      .lb442-doc .lb-head-card:before{content:"";position:absolute;width:420px;height:420px;top:-160px;right:-120px;background:radial-gradient(circle at center,rgba(255,255,255,.35),transparent 60%);filter:blur(8px);opacity:.55;}
      .lb442-doc .lb-head-card h2{margin:0;font-size:30px;font-weight:800;letter-spacing:.5px;line-height:1.15;background:linear-gradient(90deg,#fff,#e3f2fd);-webkit-background-clip:text;-webkit-text-fill-color:transparent;position:relative;}
      .lb442-doc .lb-head-card .lb442-sub{margin:10px 0 14px;font-size:13px;line-height:1.55;max-width:600px;color:rgba(255,255,255,.9);} 
      .lb442-doc .lb-head-card .lb442-tagline{display:inline-flex;align-items:center;gap:6px;font-size:11px;font-weight:600;letter-spacing:1px;padding:6px 14px;border-radius:30px;background:rgba(255,255,255,.15);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.35);} 
      .lb442-doc .scard{background:linear-gradient(145deg,#e8f4fd,#f0f9ff);border:1px solid rgba(25,118,210,.25);border-radius:16px;padding:18px 18px 16px;margin:0 0 16px;position:relative;overflow:hidden;box-shadow:0 4px 14px -4px rgba(25,118,210,.25),0 2px 6px rgba(0,0,0,.06);}
      .lb442-doc .core-concept{background:linear-gradient(135deg,#f8fafc,#f1f5f9);border:1px solid rgba(71,85,105,.15);border-radius:16px;padding:16px;margin:0 0 16px;box-shadow:0 3px 12px -2px rgba(71,85,105,.15);} 
      .lb442-doc .core-concept h3{margin:0 0 14px;font-size:16px;font-weight:600;color:#1e293b;display:flex;align-items:center;gap:8px;}
      .lb442-doc .core-concept h3 span{font-size:13px;color:#1976d2;font-weight:500;background:rgba(25,118,210,.15);padding:4px 10px;border-radius:12px;letter-spacing:.3px;}
      .lb442-doc .concept-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:10px;}
      .lb442-doc .concept-card{display:flex;align-items:flex-start;gap:8px;background:rgba(255,255,255,.8);border:1px solid rgba(71,85,105,.12);border-radius:10px;padding:10px 12px;}
      .lb442-doc .cc-icon{font-size:18px;line-height:1;margin-top:1px;}
      .lb442-doc .cc-content h4{margin:0 0 4px;font-size:13px;font-weight:600;color:#1e293b;line-height:1.2;}
      .lb442-doc .cc-content p{margin:0;font-size:11px;line-height:1.4;color:#64748b;}
      .lb442-doc .scard h3{margin:0 0 10px;font-size:18px;font-weight:700;display:flex;align-items:center;gap:10px;line-height:1.25;position:relative;padding-left:10px;}
      .lb442-doc .scard h3:before{content:"";position:absolute;left:0;top:4px;bottom:4px;width:4px;border-radius:4px;background:linear-gradient(180deg,#1976d2,#42a5f5);} 
      .lb442-doc .scard h3 span{font-size:11px;font-weight:600;color:#1976d2;background:rgba(25,118,210,.18);padding:2px 8px;border-radius:20px;letter-spacing:.5px;}
      .lb442-doc .examples{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:14px;margin-top:10px;}
      .lb442-doc .examples .ex{background:linear-gradient(150deg,#fef3c7,#fef9e7);border:1px solid rgba(245,158,11,.3);padding:12px 12px 10px;border-radius:12px;font-size:12px;line-height:1.55;}
      .lb442-doc .examples .ex .tag{display:inline-flex;align-items:center;font-size:10px;font-weight:600;padding:3px 8px;border-radius:20px;letter-spacing:.5px;margin-bottom:6px;}
      .lb442-doc .examples .ex .tag.ok{background:rgba(16,185,129,.2);color:#047857;}
      .lb442-doc .examples .ex .tag.warn{background:rgba(245,158,11,.25);color:#b45309;}
      .lb442-doc .examples .ex .tag.info{background:rgba(59,130,246,.25);color:#1d4ed8;}
      `;
      document.head.appendChild(style);
    }

    // 渲染学生详情页面
  async function renderStudentDetail(studentName) {
      const student = appState.students.get(studentName);
      if (!student) return;

      const meta = appState.studentsMeta.get(studentName) || {};
      
      // 更新基本信息
      document.getElementById('detailTitle').textContent = `${studentName} 详情`;
      const studentNameEl = document.getElementById('studentName');
      studentNameEl.textContent = studentName;
      
      // 管理员模式：在姓名旁边添加调分按钮和显示当前调整
      const existingAdminBtn = studentNameEl.parentElement.querySelector('.admin-detail-btn');
      const existingAdminInfo = studentNameEl.parentElement.querySelector('.admin-adjustment-info');
      if (existingAdminBtn) existingAdminBtn.remove();
      if (existingAdminInfo) existingAdminInfo.remove();
      
      if (adminMode) {
        const adminBtn = document.createElement('button');
        adminBtn.className = 'admin-detail-btn';
        adminBtn.innerHTML = '⚙️ 调分';
        adminBtn.title = '管理员：调整分数';
        adminBtn.style.cssText = `
          margin-left: 12px; padding: 4px 8px; border: none; border-radius: 6px;
          background: linear-gradient(135deg, #ef4444, #dc2626); color: white; font-size: 12px;
          cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
        `;
        adminBtn.onmouseover = () => {
          adminBtn.style.transform = 'scale(1.05)';
          adminBtn.style.boxShadow = '0 4px 8px rgba(239, 68, 68, 0.4)';
        };
        adminBtn.onmouseout = () => {
          adminBtn.style.transform = 'scale(1)';
          adminBtn.style.boxShadow = '0 2px 4px rgba(239, 68, 68, 0.3)';
        };
        adminBtn.onclick = () => openAdminScoreDialog(studentName);
        
        studentNameEl.parentElement.appendChild(adminBtn);
        
        // 显示当前调分状态
        const currentAdjustment = getAdminScoreAdjustment(studentName);
        if (currentAdjustment !== 0) {
          const adminInfo = document.createElement('div');
          adminInfo.className = 'admin-adjustment-info';
          adminInfo.style.cssText = `
            margin-left: 12px; padding: 2px 6px; border-radius: 4px; font-size: 11px;
            background: ${currentAdjustment > 0 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)'};
            color: ${currentAdjustment > 0 ? '#059669' : '#dc2626'};
            border: 1px solid ${currentAdjustment > 0 ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)'};
          `;
          adminInfo.textContent = `${currentAdjustment > 0 ? '+' : ''}${currentAdjustment.toFixed(1)}分`;
          adminInfo.title = '当前管理员调整分数';
          
          studentNameEl.parentElement.appendChild(adminInfo);
        }
      }
      
      document.getElementById('studentGrade').textContent = meta.grade || '未知年级';
      document.getElementById('studentMajor').textContent = meta.major || '未知专业';

      // 更新当前状态
      updateCurrentStatus(student);
      
      // 更新今日时间轴
      updateTodayTimeline(studentName);
      
      // 更新历史七天总结
      updateWeekHistory(studentName);

      // 更新442评分趋势图
      render442TrendChart('#trendChart', studentName);

      // 计算并显示今日 442 分（仅工作日；周末隐藏）
      const badgeEl = document.getElementById('todayScoreBadge');
      const valEl = document.getElementById('todayScoreValue');
      const btn = document.getElementById('todayScoreDetailBtn');
      const activeDate = getActiveLeaderboardDate();
      if (!isWorkday(activeDate)) {
        if (badgeEl) badgeEl.style.display = 'none';
        if (valEl) valEl.textContent = '--';
        if (btn) btn.onclick = null;
      } else {
        try {
          const score = await computeScore442(student);
          if (valEl) valEl.textContent = Number.isFinite(score?.total) ? Math.round(score.total) : '--';
          if (badgeEl) badgeEl.style.display = 'inline-flex';
          if (btn) btn.onclick = () => { try { showScoreDetail(studentName); } catch {} };
        } catch(e) {
          if (valEl) valEl.textContent = '--';
          if (badgeEl) badgeEl.style.display = 'none';
        }
      }
      // 绑定“查看周时段”按钮（不受周末影响）
      const weekBtn = document.getElementById('viewWeekSlotsBtn');
      if (weekBtn) weekBtn.onclick = () => showWeekSlots(studentName);
      
      // 绑定刷新时间轴按钮
  // 删除手动刷新按钮（自动实时更新即可）
    }

    // 展示学生每周1-5的练琴时间段（模态框）
    function showWeekSlots(studentName) {
  const norm = utils.normalizeStudentName(studentName);
  dbg(`[周时段弹窗] 原始姓名='${studentName}' 标准化='${norm}'`);
  const timeMap = utils.getStudentTimeSlots(studentName) || {};
      // 将 weekday(1..7) 映射到名称，仅显示工作日 1-5
      const days = [
        { w: 1, label: '周一' },
        { w: 2, label: '周二' },
        { w: 3, label: '周三' },
        { w: 4, label: '周四' },
        { w: 5, label: '周五' }
      ];

      const toMin = (slot) => {
        if (typeof slot?.start === 'number' && typeof slot?.end === 'number') return slot;
        const s = utils.parseTimeSlot(slot?.start_time || slot?.start);
        const e = utils.parseTimeSlot(slot?.end_time || slot?.end);
        return { start: s, end: e };
      };
      const mm = (m) => Number.isFinite(m) ? `${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}` : '--:--';
      const fmtSlot = (slot) => `${mm(slot.start)} - ${mm(slot.end)}（${utils.formatDuration(slot.end - slot.start)}）`;

      const sections = days.map(d => {
        const raw = Array.isArray(timeMap[d.w]) ? timeMap[d.w] : [];
        const slots = raw.map(toMin).filter(s => Number.isFinite(s.start) && Number.isFinite(s.end) && s.end > s.start)
                          .sort((a,b) => a.start - b.start);
        dbg(`[周时段弹窗] ${studentName} ${d.label}: 原始${raw.length}，有效${slots.length}`);
        const list = slots.length
          ? slots.map(s => `<li>${fmtSlot(s)}</li>`).join('')
          : '<li class="text-muted">未配置</li>';
        return `
          <div class="lb-section">
            <div class="lb-section__title">${d.label} <span>${slots.length ? `${slots.length} 段` : '无'}</span></div>
            <div class="lb-card">
              <ul class="lb-list">${list}</ul>
            </div>
          </div>`;
      }).join('');

  const totalSlots = days.reduce((sum,d)=> sum + ((timeMap[d.w]?.length)||0), 0);
  const hasAny = totalSlots > 0;
      const headerCard = `
        <div class="lb-section">
          <div class="lb-card lb-card--gradient" style="background:linear-gradient(135deg,#22c55e,#16a34a);border:none;">
            <div class="lb-kv"><strong>${studentName}</strong><span>工作日练琴时间段</span></div>
            <div style="margin-top:6px;font-size:12px;opacity:.9;">${hasAny ? `以下为周一到周五的配置时段（共 ${totalSlots} 段）` : '未配置个性化时段，系统将使用默认统计窗口'}</div>
          </div>
        </div>`;

      createScoreDetailModal(headerCard + sections, '每周练琴时段');
    }

    // 显示今日总计时间的详细说明
    function showTodayTotalExplanation(studentName) {
      try {
        const today = new Date();
        const dayData = calculateDayData(studentName, today);
        const totalMinutes = dayData.in + dayData.out;
        
        // 获取今天的原始练琴会话
        const baseLogs = Array.isArray(appState.practiceLogsNormalized) ? appState.practiceLogsNormalized : (appState.practiceLogs || []);
        const todayKey = utils.getDateKey(today);
        const todayLogs = baseLogs.filter(log => {
          if (!log.timestamp || !log.action) return false;
          const logStudentName = log.student_name || log.student || log.studentName;
          return logStudentName === studentName && utils.getDateKey(new Date(log.timestamp)) === todayKey;
        });
        
        if (todayLogs.length === 0) {
          const content = `
            <div class="lb-section">
              <div class="lb-card lb-card--gradient" style="background:linear-gradient(135deg,#0ea5e9,#6366f1);border:none;">
                <div class="lb-kv"><strong>${studentName}</strong><span>今日练琴时间计算说明</span></div>
                <div style="margin-top:8px;font-size:14px;opacity:.9;">今日暂无练琴记录</div>
              </div>
            </div>
          `;
          createScoreDetailModal(content, '今日时间计算说明');
          return;
        }
        
        // 构建原始会话
        const sessions = buildPracticeSessions(deduplicateLogs(todayLogs), studentName);
        
        // 获取有效窗口信息
        const dayWindow = getEffectiveDayWindow(today) || { start: 0, end: (21*60+30) };
        const weekday = utils.getWeekday(today);
        const isWeekend = weekday === 6 || weekday === 7;
        
        // 计算各种时间段
        let rawTotalMinutes = 0;
        let windowClippedMinutes = 0;
        let breakDeductedMinutes = totalMinutes; // 最终统计的时间就是扣除休息时间后的
        
  const sessionDetails = []; // （已弃用仅用于保留统计变量，明细不再展示）
        const dayStart = new Date(today); 
        dayStart.setHours(0,0,0,0); 
        const dayStartMs = dayStart.getTime();
        const windowStartMs = dayStartMs + dayWindow.start*60*1000;
        const windowEndMs = dayStartMs + dayWindow.end*60*1000;
        
        for (const session of sessions) {
          const rawStartMs = new Date(session.start).getTime();
          const rawEndMs = session.end ? new Date(session.end).getTime() : Date.now();
          const rawDuration = Math.max(0, Math.round((rawEndMs - rawStartMs) / 60000));
          rawTotalMinutes += rawDuration;
          
          // 窗口裁剪
          const clampStart = Math.max(rawStartMs, windowStartMs);
          const clampEnd = Math.min(rawEndMs, windowEndMs);
          const windowDuration = clampEnd > clampStart ? Math.round((clampEnd - clampStart) / 60000) : 0;
          windowClippedMinutes += windowDuration;
          
          const startTime = new Date(rawStartMs).toLocaleTimeString('zh-CN', {hour:'2-digit', minute:'2-digit'});
          const endTime = session.end ? new Date(rawEndMs).toLocaleTimeString('zh-CN', {hour:'2-digit', minute:'2-digit'}) : '进行中';
          
          sessionDetails.push({
            timeRange: `${startTime} - ${endTime}`,
            rawDuration: rawDuration,
            windowDuration: windowDuration,
            room: session.room || '未知',
            isOngoing: !session.end
          });
        }
        
        // 计算被扣除的时间
        const windowDeducted = rawTotalMinutes - windowClippedMinutes;
        const breakDeducted = windowClippedMinutes - breakDeductedMinutes;
        
        // 构建详细说明
        const windowInfo = isWeekend ? '周末无统计窗口限制' : 
          `统计窗口：${Math.floor(dayWindow.start/60).toString().padStart(2,'0')}:${(dayWindow.start%60).toString().padStart(2,'0')} - ${Math.floor(dayWindow.end/60).toString().padStart(2,'0')}:${(dayWindow.end%60).toString().padStart(2,'0')}`;
        
        const breakInfo = isWeekend ? '周末无休息时间扣除' :
          (weekday === 3 ? '休息时间：12:10-13:20, 18:40-19:10' : '休息时间：12:10-12:40, 18:10-18:40');
        
  // 已移除会话明细列表展示（时间轴已提供），保留计算逻辑以保证后续扩展可用。
        
        const content = `
          <div class="lb-section">
            <div class="lb-card lb-card--gradient" style="background:linear-gradient(135deg,#0ea5e9,#6366f1);border:none;">
              <div class="lb-kv"><strong>${studentName}</strong><span>今日练琴时间计算说明</span></div>
              <div style="margin-top:8px;font-size:30px;font-weight:800;">${utils.formatDuration(totalMinutes)}</div>
              <div style="opacity:.9;font-size:12px;">最终统计时间</div>
            </div>
          </div>

          <div class="lb-section">
            <div class="lb-card">
              <h4>📊 计算过程</h4>
              <div class="calc-box">
                <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                  <span>原始时长：</span>
                  <strong>${utils.formatDuration(rawTotalMinutes)}</strong>
                </div>
                ${windowDeducted > 0 ? `
                  <div style="display:flex; justify-content:space-between; margin-bottom:8px; color:#ef4444;">
                    <span>减去窗口外：</span>
                    <strong>-${utils.formatDuration(windowDeducted)}</strong>
                  </div>
                ` : ''}
                ${breakDeducted > 0 ? `
                  <div style="display:flex; justify-content:space-between; margin-bottom:8px; color:#ef4444;">
                    <span>减去休息时间：</span>
                    <strong>-${utils.formatDuration(breakDeducted)}</strong>
                  </div>
                ` : ''}
                <hr class="calc-sep">
                <div style="display:flex; justify-content:space-between; font-weight:600; font-size:16px; color:#059669;">
                  <span>最终统计：</span>
                  <strong>${utils.formatDuration(totalMinutes)}</strong>
                </div>
              </div>
            </div>
          </div>

          ${!isWeekend ? `
          <div class="lb-section">
            <div class="lb-card">
              ${(() => {
                const isWed = weekday === 3;
                const breaks = isWed ? BREAK_SCHEDULE.wed : BREAK_SCHEDULE.monTueThuFri;
                
                // 识别类型：通过跨度时长/时间位置简单映射
                function classify(b){
                  const dur = b.end - b.start; // 分钟
                  const s = b.start;
                  if (dur >= 60 && s >= (12*60) && s < (13*60+30)) return isWed ? '午餐+午间音乐会' : '午餐';
                  if (dur >= 30 && s >= (18*60) && s < (19*60+30)) return '晚餐';
                  if (dur >= 15) return '大课间';
                  return '小课间';
                }
                
                // 将会话转为分钟区间（裁剪到统计窗口）
                const dayStart = new Date(today); dayStart.setHours(0,0,0,0);
                const toMin = ms => Math.floor((ms - dayStart.getTime())/60000);
                const sessionIntervals = sessions.map(s=>{
                  const st = toMin(new Date(s.start).getTime());
                  const et = toMin((s.end? new Date(s.end).getTime(): Date.now()));
                  return {start: Math.max(st, dayWindow.start), end: Math.min(et, dayWindow.end)};
                }).filter(iv=> iv.end>iv.start);
                
                // 计算与每个 break 的重叠
                const overlapped = breaks.map(b=>{
                  const ov = sessionIntervals.reduce((sum,iv)=>{
                    const os = Math.max(iv.start, b.start);
                    const oe = Math.min(iv.end, b.end);
                    return sum + (oe>os? (oe-os):0);
                  },0);
                  return { ...b, overlap: ov };
                }).filter(b=> b.overlap>0);
                
                const totalBreakTime = overlapped.reduce((s,b)=> s + b.overlap,0);
                
                if(!overlapped.length){
                  return `<h4>实际剔除时间 0分钟</h4>
                    <div class="break-summary">
                      <div class="break-total">今日实际未与练琴重叠的休息段，无需扣除</div>
                      <div class="break-hint">说明：只有与练琴会话时间重叠的休息分钟才会被剔除。</div>
                    </div>`;
                }
                
                const rows = overlapped.map(b=>{
                  const start = `${String(Math.floor(b.start/60)).padStart(2,'0')}:${String(b.start%60).padStart(2,'0')}`;
                  const end = `${String(Math.floor(b.end/60)).padStart(2,'0')}:${String(b.end%60).padStart(2,'0')}`;
                  const type = classify(b);
                  return `<li class=\"break-row\"><span class=\"br-time\">${start} - ${end}</span><span class=\"br-type ${type.includes('午餐')?'br-meal': type==='晚餐'?'br-dinner': type==='大课间'?'br-large':'br-small'}\">${type}</span><span class=\"br-dur\">${b.overlap}分</span></li>`;
                }).join('');
                
                return `<h4>实际剔除时间 ${utils.formatDuration(totalBreakTime)}</h4>
                  <div class="break-summary">
                    <ul class="break-list">${rows}</ul>
                    <div class="break-hint">说明：仅列出与练琴重叠的休息段。${isWed ? '（周三午餐合并午间音乐会）' : ''}</div>
                  </div>`;
              })()}
            </div>
          </div>
          ` : ''}

          <!-- 会话明细区块已移除：时间轴已覆盖该信息 -->

          <div class="lb-section">
            <div class="lb-card">
              <h4>📝 统计规则</h4>
              <div style="font-size:13px; line-height:1.8; color:#666;">
                <p>• 统计时间：07:30-21:30</p>
                <p>• 自动扣除所有休息时间</p>
                <p>• 多次进出房间累计计算</p>
              </div>
            </div>
          </div>
        `;
        
        createScoreDetailModal(content, '今日时间计算说明');
        
      } catch (e) {
        console.error('显示今日总计说明失败:', e);
        const content = `
          <div class="lb-section">
            <div class="lb-card">
              <h4>❌ 计算说明加载失败</h4>
              <p>无法获取详细的时间计算信息，可能是数据异常。</p>
            </div>
          </div>
        `;
        createScoreDetailModal(content, '计算说明');
      }
    }

    // 更新当前状态信息
    function updateCurrentStatus(student) {
      const currentStartTime = document.getElementById('currentStartTime');
      const currentDuration = document.getElementById('currentDuration');
      const todayTotal = document.getElementById('todayTotal');
      const currentRoom = document.getElementById('currentRoom');

      // 当前练琴开始时间
      if (student.currentStatus !== 'offline' && student.currentStartTime) {
        currentStartTime.textContent = utils.formatTime(student.currentStartTime);
      } else {
        currentStartTime.textContent = '--';
      }

      // 当前时长（这次练琴的时长）
      if (student.currentStatus !== 'offline' && student.currentStartTime) {
        const now = new Date();
        const currentSessionMinutes = Math.round((now - student.currentStartTime) / (1000 * 60));
        currentDuration.textContent = utils.formatDuration(Math.max(0, currentSessionMinutes));
      } else {
        currentDuration.textContent = '--';
      }

      // 当前琴房
      currentRoom.textContent = student.currentRoom || '--';

      // 今日总计 - 使用与七天总结相同的计算逻辑
      const todayData = calculateDayData(student.name, new Date());
      const totalMinutes = todayData.in + todayData.out;
      todayTotal.textContent = utils.formatDuration(totalMinutes);
      
      // 绑定今日总计说明按钮
      const todayTotalHelpBtn = document.getElementById('todayTotalHelpBtn');
      if (todayTotalHelpBtn) {
        todayTotalHelpBtn.onclick = () => showTodayTotalExplanation(student.name);
      }
    }

    // 去重日志：专门针对 assign/clear 操作去重
    function deduplicateLogs(logs) {
      const result = [];
      const seen = new Set(); // 记录已处理的时间戳+动作组合
      
      // 按时间排序
      const sortedLogs = [...logs].sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
      
      for(const log of sortedLogs) {
        // 只处理有 action 和 timestamp 的日志
        if(!log.action || !log.timestamp) continue;
        
        const action = log.action.toLowerCase();
        // 只处理 assign/clear 或 enter/exit 操作
        if(!['assign', 'clear', 'enter', 'exit'].includes(action)) continue;
        
        const timestamp = log.timestamp;
        const key = `${timestamp}-${action}`;
        
        if(!seen.has(key)) {
          seen.add(key);
          result.push(log);
          dbg(`保留日志: ${timestamp} - ${action}`);
        } else {
          dbg(`跳过重复日志: ${timestamp} - ${action}`);
        }
      }
      
      return result;
    }

    // 更新今日时间轴
    function updateTodayTimeline(studentName) {
      const container = document.getElementById('todayTimeline');
  const __perfStart = performance.now();
      const baseLogs = Array.isArray(appState.practiceLogsNormalized) ? appState.practiceLogsNormalized : (appState.practiceLogs||[]);
      const studentLogs = baseLogs.filter(log => {
        const logStudentName = log.student_name || log.student || log.studentName;
        return logStudentName === studentName;
      });

      const today = new Date();
      const todayKey = utils.getDateKey(today);
      
      // 筛选今日日志并去重（只使用 timestamp）
      const rawTodayLogs = studentLogs.filter(log => {
        return log.timestamp && utils.getDateKey(new Date(log.timestamp)) === todayKey;
      });
      
      const todayLogs = deduplicateLogs(rawTodayLogs);

      if (todayLogs.length === 0) {
        scheduleDOM(()=>{ container.innerHTML = '<div class="timeline-empty">今日暂无练琴记录</div>'; });
        if(window.DEBUG || (window.__perfFlags && window.__perfFlags.instrumentRanking)) {
          const dur = (performance.now()-__perfStart).toFixed(1);
          dbg(`[perf] updateTodayTimeline(empty) ${dur}ms`);
        }
        return;
      }

      // 调试信息：显示日志处理情况
      dbg(`=== 学生 ${studentName} 时间轴构建 ===`);
      dbg(`原始日志: ${rawTodayLogs.length} 条`);
      rawTodayLogs.forEach(log => {
        dbg(`  - ${log.timestamp} | ${log.action} | ${log.room_name || log.room || 'N/A'}`);
      });
      
      dbg(`去重后日志: ${todayLogs.length} 条`);
      if(rawTodayLogs.length !== todayLogs.length) {
        dbg('✓ 发现并移除了重复日志');
      }

      // 构建练琴会话
  const sessions = buildPracticeSessions(todayLogs, studentName);
      
      dbg(`最终会话: ${sessions.length} 个`);
      sessions.forEach((session, index) => {
        const start = new Date(session.start).toLocaleTimeString('zh-CN', {hour:'2-digit', minute:'2-digit'});
        const end = session.end ? new Date(session.end).toLocaleTimeString('zh-CN', {hour:'2-digit', minute:'2-digit'}) : '进行中';
        const duration = session.end ? Math.round((new Date(session.end) - new Date(session.start)) / 60000) : '?';
        dbg(`  会话 ${index + 1}: ${start} - ${end} (${duration}分钟, 房间: ${session.room || '未知'})`);
      });
      dbg(`=== 时间轴构建完成 ===`);
      
      // 添加额外的重复检查
      if(sessions.length > 0) {
        const duplicateCheck = new Set();
        let hasDuplicates = false;
        sessions.forEach(session => {
          const sessionKey = `${session.start}-${session.end}`;
          if(duplicateCheck.has(sessionKey)) {
            hasDuplicates = true;
            dbg(`⚠️  检测到重复会话: ${sessionKey}`);
          }
          duplicateCheck.add(sessionKey);
        });
        if(!hasDuplicates) {
          dbg(`✓ 会话去重检查通过，无重复记录`);
        }
      }
      
      // 如果没有有效会话，显示空状态
      if(!sessions || sessions.length === 0) {
        scheduleDOM(()=>{ container.innerHTML = '<div class="timeline-empty">今日暂无练琴记录</div>'; });
        if(window.DEBUG || (window.__perfFlags && window.__perfFlags.instrumentRanking)) {
          const dur = (performance.now()-__perfStart).toFixed(1);
          dbg(`[perf] updateTodayTimeline(noSessions) ${dur}ms`);
        }
        return;
      }
      
      let html = '';
      const renderedSessions = new Set(); // 用于防止重复渲染相同的会话
      let validSessionCount = 0;
      const CHUNK_THRESHOLD = 80; // 超过此阈值采用分块渲染
      const CHUNK_SIZE = 25;
      const items = [];
      
      sessions.forEach((session, index) => {
        // 生成会话的唯一标识符（基于时间，忽略房间避免房间变化导致的重复）
        const sessionId = `${session.start}-${session.end || 'ongoing'}`;
        if(renderedSessions.has(sessionId)) {
          dbg(`跳过重复会话 ${index + 1}: ${sessionId}`);
          return; // 跳过重复的会话
        }
        renderedSessions.add(sessionId);
        
        // 统一以当天有效窗口的时间范围裁剪会话（包含开始与结束）
        const sessionStartDate = new Date(session.start);
        const dayWindow = getEffectiveDayWindow(sessionStartDate) || { start: 0, end: (21*60+30) }; // 兜底
        const dayBase = new Date(sessionStartDate); dayBase.setHours(0,0,0,0);
        const windowStartMs = dayBase.getTime() + (dayWindow.start||0)*60*1000;
        const windowEndMs = dayBase.getTime() + (dayWindow.end)*60*1000;
        const nowMs = Date.now();
        const rawStartMs = new Date(session.start).getTime();
        
        // 对于正在进行的会话，使用当前时间作为结束时间
        const isOngoing = !session.end;
        const rawEndMs = session.end ? new Date(session.end).getTime() : nowMs;
        
        const effStartMs = Math.min(windowEndMs, Math.max(rawStartMs, windowStartMs));
        const effEndMs = Math.min(windowEndMs, rawEndMs);
        
        if(effEndMs <= effStartMs){ return; } // 过滤被完全裁掉的会话或无效会话
        
        const startTime = new Date(effStartMs).toLocaleTimeString('zh-CN', { hour:'2-digit', minute:'2-digit' });
        const endTime = isOngoing ? '进行中' : new Date(effEndMs).toLocaleTimeString('zh-CN', { hour:'2-digit', minute:'2-digit' });
        const duration = Math.max(0, Math.round((effEndMs - effStartMs)/60000));
        
        // 对于正在进行的会话，即使时长很短也要显示
        if(!isOngoing && duration < 1) return;
        
        const isInSchedule = isSessionInSchedule(session, studentName);
        const scheduleClass = isInSchedule ? 'in-schedule' : 'out-schedule';
        const ongoingClass = isOngoing ? 'ongoing' : '';
        
        const markup = `
          <div class=\"timeline-item ${scheduleClass}\" 
               data-session-id=\"${sessionId}\" 
               data-session-index=\"${validSessionCount + 1}\"
               data-start-time=\"${session.start}\"
               data-is-ongoing=\"${isOngoing}\">
            <div class=\"timeline-time\">
              ${startTime} - ${isOngoing ? '进行中' : endTime}
            </div>
            <div class=\"timeline-duration ${isOngoing ? 'live-duration' : ''}\" 
                 data-start-timestamp=\"${effStartMs}\">
              ${utils.formatDuration(duration)}${isOngoing ? '⏱️' : ''}
            </div>
            ${session.room ? `<div class=\\"timeline-room\\">${session.room}</div>` : ''}
          </div>`;
        items.push(markup);
        html += markup;
        
        validSessionCount++;
        dbg(`渲染会话 ${validSessionCount}: ${startTime} - ${endTime} (${duration}分钟)${isOngoing ? ' [正在进行]' : ''}`);
      });

      const finalizeBind = () => {
        const ongoingCount = sessions.filter(s => !s.end).length;
        dbg(`时间轴渲染完成: 显示 ${validSessionCount} 个会话${ongoingCount > 0 ? `，其中 ${ongoingCount} 个进行中` : ''}`);
        startLiveTimelineUpdate(container);
        const timelineItems = container.querySelectorAll('.timeline-item');
        timelineItems.forEach(item => {
          item.addEventListener('click', (e) => {
            e.stopPropagation();
            item.classList.toggle('selected');
          });
        });
      };

  if(validSessionCount === 0) {
        scheduleDOM(()=>{ container.innerHTML = '<div class="timeline-empty">今日暂无有效练琴记录</div>'; });
        return;
      }

      if(validSessionCount > CHUNK_THRESHOLD) {
  container.innerHTML = '';
        let idx = 0;
        const appendChunk = () => {
          const slice = items.slice(idx, idx + CHUNK_SIZE).join('');
            if(slice) {
              scheduleDOM(()=>{ container.insertAdjacentHTML('beforeend', slice); });
              idx += CHUNK_SIZE;
              if(idx < items.length) {
                requestAnimationFrame(appendChunk);
              } else {
    requestAnimationFrame(()=> { finalizeBind(); if(window.DEBUG || (window.__perfFlags && window.__perfFlags.instrumentRanking)) { dbg(`[perf] updateTodayTimeline(chunked ${validSessionCount}) ${(performance.now()-__perfStart).toFixed(1)}ms`); } });
              }
            }
        };
        requestAnimationFrame(appendChunk);
      } else {
  scheduleDOM(()=>{ container.innerHTML = html; finalizeBind(); if(window.DEBUG || (window.__perfFlags && window.__perfFlags.instrumentRanking)) { dbg(`[perf] updateTodayTimeline(${validSessionCount}) ${(performance.now()-__perfStart).toFixed(1)}ms`); } });
      }
    }

    // 实时更新正在进行的时间轴会话
    let timelineUpdateInterval = null;
    
    function startLiveTimelineUpdate(container) {
      // 清除之前的定时器
      if(timelineUpdateInterval) {
        clearInterval(timelineUpdateInterval);
      }
      
      timelineUpdateInterval = setInterval(() => {
        const ongoingItems = container.querySelectorAll('.timeline-item.ongoing');
        if(ongoingItems.length === 0) {
          // 没有正在进行的会话，停止更新
          clearInterval(timelineUpdateInterval);
          timelineUpdateInterval = null;
          dbg('没有正在进行的会话，停止实时更新');
          return;
        }
        
        const now = Date.now();
        let updateCount = 0;
        ongoingItems.forEach(item => {
          const startTimestamp = parseInt(item.dataset.startTimestamp);
          if(Number.isFinite(startTimestamp)) {
            const durationMs = now - startTimestamp;
            const durationMinutes = Math.max(0, Math.round(durationMs / 60000));
            
            const durationEl = item.querySelector('.live-duration');
            if(durationEl) {
              const currentText = durationEl.textContent.replace('⏱️', '').trim();
              const newText = utils.formatDuration(durationMinutes);
              
              // 只有时长改变时才更新DOM
              if(currentText !== newText) {
                durationEl.textContent = `${newText}⏱️`;
                updateCount++;
              }
            }
          }
        });
        
        if(updateCount > 0) {
          dbg(`更新了 ${updateCount} 个正在进行的会话时长`);
        }
      }, 15000); // 每15秒更新一次，提高实时性
      
      dbg('启动时间轴实时更新');
    }
    
    function stopLiveTimelineUpdate() {
      if(timelineUpdateInterval) {
        clearInterval(timelineUpdateInterval);
        timelineUpdateInterval = null;
        dbg('停止时间轴实时更新');
      }
    }

    // 构建练琴会话 - 强制只使用 assign/clear 配对模式
  function buildPracticeSessions(logs, studentName) {
      if(!Array.isArray(logs) || !logs.length) return [];
      
      // 只使用 assign/clear 配对模式，忽略 session_start/session_end
      const sessions=[]; 
      let current=null; 
      
      // 按时间排序，只处理有 action 和 timestamp 的日志
      const actionLogs = logs.filter(log => log.action && log.timestamp)
                            .sort((a,b)=> new Date(a.timestamp) - new Date(b.timestamp));
      
      dbg(`学生 ${studentName} 有效操作日志: ${actionLogs.length} 条`);
      
      for(const log of actionLogs){
        const act = (log.action || '').toLowerCase();
        const isEnter = act === 'enter' || act === 'assign';
        const isExit = act === 'exit' || act === 'clear';
        
        dbg(`处理日志: ${log.timestamp} - ${act} - 房间: ${log.room_name || log.room || 'N/A'}`);
        
        if(isEnter){
          // 如果有未结束的会话，先结束它（设置结束时间为新assign的时间）
          if(current){ 
            current.end = log.timestamp; // 将前一段时间的结束时间设为新assign的时间
            dbg(`自动结束未完成会话: ${current.start} - ${current.end} (因为新的 ${act} 操作)`);
            sessions.push(current); 
          }
          current = { 
            start: log.timestamp, 
            end: null, 
            room: log.room_name || log.room || log.roomName || '' 
          };
          dbg(`开始新会话: ${log.timestamp}`);
        } else if(isExit && current){
          current.end = log.timestamp; 
          dbg(`结束会话: ${current.start} - ${current.end}`);
          sessions.push(current); 
          current = null;
        } else if(isExit && !current) {
          // 有 clear/exit 但没有对应的 assign/enter，可能是数据不完整
          dbg(`警告: 发现孤立的 ${act} 操作，没有对应的开始操作`);
        }
      }
      
      // 如果还有未结束的会话，保留它（正在进行中）
      if(current) {
        dbg(`保留进行中的会话: ${current.start}`);
        sessions.push(current);
      }
      
      dbg(`学生 ${studentName} 最终会话数量: ${sessions.length}`);
      return deduplicateSessions(sessions);
    }
    
    // 会话去重函数：专门针对 assign/clear 模式的去重
    function deduplicateSessions(sessions) {
      if(!sessions || sessions.length <= 1) return sessions;
      
      // 按开始时间排序
      const sorted = [...sessions].sort((a,b) => new Date(a.start) - new Date(b.start));
      const merged = [];
      
      for(const session of sorted) {
        if(!merged.length) {
          merged.push({...session}); // 创建副本避免引用问题
          continue;
        }
        
        const lastSession = merged[merged.length - 1];
        const lastEnd = lastSession.end ? new Date(lastSession.end) : null;
        const currentStart = new Date(session.start);
        
        // 只有在两个会话时间完全重叠时才合并（防止真正的多次练琴被错误合并）
        if(lastEnd && Math.abs(currentStart - lastEnd) <= 30000) { // 30秒内认为是连续的
          dbg(`合并相邻会话: ${lastSession.start} 和 ${session.start}`);
          // 延长结束时间
          if(session.end) {
            lastSession.end = session.end;
          }
          // 如果新会话有房间信息而旧会话没有，则更新房间信息
          if(session.room && !lastSession.room) {
            lastSession.room = session.room;
          }
        } else {
          merged.push({...session}); // 创建副本
        }
      }
      
      dbg(`会话去重: ${sessions.length} -> ${merged.length}`);
      return merged;
    }

    // 检查会话是否在规定时间段内
    function isSessionInSchedule(session, studentName) {
      const timeSlots = appState.timeSlots.get(studentName);
      if (!timeSlots) return false;

      const sessionDate = new Date(session.start);
      const weekday = utils.getWeekday(sessionDate);
      const daySlots = timeSlots[weekday];
      
      if (!daySlots || daySlots.length === 0) return false;

      const sessionStartMinutes = utils.minutesFromDayStart(sessionDate);
      const sessionEndMinutes = session.end 
        ? utils.minutesFromDayStart(new Date(session.end))
        : sessionStartMinutes + 1; // 如果会话还在进行中，假设至少1分钟

      // 转换时间段为分钟格式
      const windows = daySlots.map(slot => {
        let start, end;
        if (typeof slot.start === 'number' && typeof slot.end === 'number') {
          start = slot.start; end = slot.end;
        } else {
          start = utils.parseTimeSlot(slot.start_time || slot.start);
          end = utils.parseTimeSlot(slot.end_time || slot.end);
        }
        return { start, end };
      }).filter(w => Number.isFinite(w.start) && Number.isFinite(w.end));

      // 使用与splitByTimeWindows相同的逻辑来判断会话是否在时间段内
      const sessionInterval = { start: sessionStartMinutes, end: sessionEndMinutes };
      const { inTime, outTime } = splitByTimeWindows([sessionInterval], windows);
      
      // 如果会话中在时间段内的时间占大部分(>50%)，则认为是段内练琴
      const totalTime = sessionEndMinutes - sessionStartMinutes;
      return totalTime > 0 && (inTime / totalTime) > 0.5;
    }

    // 更新历史七天总结
    async function updateWeekHistory(studentName) {
      console.log('updateWeekHistory called for:', studentName);
      // 计算七天数据（优先使用后端备份）
      const weekData = await calculateWeekData(studentName);
      console.log('weekData:', weekData);

      // 渲染条形图
      renderWeekChart(weekData.dailyData);
    }

    // 计算七天数据
    async function calculateWeekData(studentName) {
      const dailyData = [];
      const today = new Date();
      let totalIn = 0;
      let totalOut = 0;

      // 预拉取后端 7 天汇总（已按 08:00-21:30 和休息时间计算）
      const days = [];
      for (let i = 6; i >= 0; i--) {
        const d = new Date(today);
        d.setDate(d.getDate() - i);
        days.push(d);
      }
      let backendMap = new Map();
      try {
        backendMap = await fetchDailyPracticeSummaries(studentName, days[0], days[days.length - 1]);
      } catch (e) { console.warn('fetchDailyPracticeSummaries failed, fallback to local:', e); }

      for (let i = 6; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const iso = utils.toIsoDate(date);

        let total = backendMap.get(iso);
        let inMin = 0, outMin = 0;
        if (typeof total !== 'number') {
          // 回退：本地按 21:30 有效窗口 + 休息时间计算
          const dayData = calculateDayData(studentName, date);
          inMin = dayData.in; outMin = dayData.out; total = inMin + outMin;
        } else {
          // 后端已提供总分钟（不区分 in/out），按 out 存储以兼容现有渲染
          inMin = 0; outMin = total;
        }

        dailyData.push({
          date,
          label: i === 0 ? '今天' : date.getMonth() + 1 + '/' + date.getDate(),
          inMinutes: inMin,
          outMinutes: outMin,
          total
        });

        totalIn += inMin;
        totalOut += outMin;
      }

      return { dailyData, totalIn, totalOut };
    }

    // 计算单日数据
  function calculateDayData(studentName, date) {
  // 统一：使用 assign/clear 配对模式构建会话
  const dateKey = getStatsDayKey(date);
  const baseLogs = Array.isArray(appState.practiceLogsNormalized) ? appState.practiceLogsNormalized : (appState.practiceLogs||[]);
  if(!baseLogs.length) return { in:0, out:0 };
  const dayLogs = baseLogs.filter(l=>{
    // 按 timestamp 所在自然日过滤，只处理有 action 的日志
    if(!l.timestamp || !l.action) return false; 
    const tsDate=new Date(l.timestamp); 
    return getStatsDayKey(tsDate)===dateKey && (l.student_name===studentName);
  });
  if(!dayLogs.length) return { in:0, out:0 };

  // 使用 assign/clear 配对构建会话，然后按当天窗口裁剪
  let sessions = buildPracticeSessions(dayLogs, studentName);
  if(!sessions.length) return { in:0, out:0 };

  const dayWindow = getEffectiveDayWindow(date) || { start:0, end: (21*60+30) };
  const dayStart = new Date(date); dayStart.setHours(0,0,0,0); const dayStartMs=dayStart.getTime();
  const windowStartMs = dayStartMs + dayWindow.start*60*1000;
  const windowEndMs = dayStartMs + dayWindow.end*60*1000;

  // 转为分钟区间并裁剪
  const intervals = sessions.map(s=>{
    const rawStartMs = new Date(s.start).getTime();
    const rawEndMs = s.end ? new Date(s.end).getTime() : Date.now();
    // 只保留与当天窗口有交集的部分
    const clampStart = Math.max(rawStartMs, windowStartMs);
    const clampEnd = Math.min(rawEndMs, windowEndMs);
    if(clampEnd <= clampStart) return null;
    return { start: utils.minutesFromDayStart(new Date(clampStart)), end: utils.minutesFromDayStart(new Date(clampEnd)) };
  }).filter(Boolean);
  if(!intervals.length) return { in:0, out:0 };

  const weekday = utils.getWeekday(date); // 1..7
  let total;
  if(weekday===6 || weekday===7){
    total = intervals.reduce((sum,iv)=> sum + (iv.end-iv.start),0);
  } else {
    const breaks = weekday===3 ? BREAK_SCHEDULE.wed : BREAK_SCHEDULE.monTueThuFri;
    const afterBreaks = subtractBreaks(intervals, breaks);
    total = afterBreaks.reduce((sum,iv)=> sum + (iv.end-iv.start),0);
  }
  return { in:0, out: total };
    }

    // 渲染周练琴条形图
  function renderWeekChart(dailyData) {
      console.log('renderWeekChart called with:', dailyData);
      const container = document.getElementById('weekChart');
      console.log('weekChart container:', container);
      if (!container) {
        console.error('weekChart container not found!');
        return;
      }
      
      const maxTotal = Math.max(...dailyData.map(d => (d.total ?? (d.inMinutes + d.outMinutes))), 1);
      console.log('maxTotal:', maxTotal);

      let html = '';
      dailyData.forEach((day, idx) => {
        const total = day.total ?? (day.inMinutes + day.outMinutes);
        const heightPercent = (total / maxTotal) * 100;
        const totalHours = total > 0 ? utils.formatDurationShort(total) : '';
        const dateKey = utils.getDateKey(day.date);
        const isToday = idx === dailyData.length - 1; // 最后一根柱为“今天”
        html += `
          <div class="chart-bar" 
               data-date="${dateKey}" 
               data-total="${total}" 
               data-istoday="${isToday}">
            <div class="bar-container">
              <div class="bar-fill" style="height: ${heightPercent}%"></div>
              <div class="bar-value">${totalHours}</div>
              <div class="bar-tooltip" role="tooltip">${day.label} · 总计 ${total} 分钟</div>
            </div>
            <div class="bar-label">${day.label}</div>
          </div>
        `;
      });

  scheduleDOM(()=>{ container.innerHTML = html; });

      // 交互：悬停显示 tooltip，点击可触发查看详细日数据（当前进入当天详情的最小交互示例：仅闪烁效果或复算刷新）
      // 事件绑定推迟到下一帧，避免与批量 DOM 写竞争
      requestAnimationFrame(()=>{
        const bars = container.querySelectorAll('.chart-bar');
        bars.forEach(bar => {
          bar.addEventListener('mouseenter', () => bar.classList.add('show-tooltip'));
          bar.addEventListener('mouseleave', () => bar.classList.remove('show-tooltip'));
          bar.addEventListener('click', () => {
            bar.classList.toggle('show-tooltip');
            const isToday = bar.dataset.istoday === 'true';
            if (isToday && uiState.view === 'detail' && uiState.selectedStudent) {
              updateWeekHistory(uiState.selectedStudent);
            }
          });
        });
      });
    }

    // 实时刷新：详情页打开时，每分钟刷新“今天”柱状图以跟随进行中的会话
    let weekChartTimer = null;
    function startWeekChartAutoRefresh() {
      if (weekChartTimer) return;
      weekChartTimer = setInterval(() => {
        if (uiState.view === 'detail' && uiState.selectedStudent) {
          updateWeekHistory(uiState.selectedStudent);
          // 保持时间轴与柱状图一致（含21:30截断）
          updateTodayTimeline(uiState.selectedStudent);
        }
      }, 60 * 1000); // 每分钟刷新一次
    }
    function stopWeekChartAutoRefresh() {
      if (weekChartTimer) {
        clearInterval(weekChartTimer);
        weekChartTimer = null;
      }
    }

    // 实时更新当前时长
    let currentDurationTimer = null;
    function startCurrentDurationUpdate() {
      if (currentDurationTimer) return;
      currentDurationTimer = setInterval(() => {
        if (uiState.view === 'detail' && uiState.selectedStudent) {
          const student = appState.students.get(uiState.selectedStudent);
          if (student && student.currentStatus !== 'offline' && student.currentStartTime) {
            const now = new Date();
            const win = getEffectiveDayWindow(now);
            const minutesNow = utils.minutesFromDayStart(now);
            const sameDay = student.currentStartTime.getFullYear()===now.getFullYear() && student.currentStartTime.getMonth()===now.getMonth() && student.currentStartTime.getDate()===now.getDate();
            const startMin = utils.minutesFromDayStart(student.currentStartTime);
            const active = sameDay && minutesNow>=win.start && minutesNow<=win.end && startMin>=win.start && startMin<=win.end;
            const currentDurationEl = document.getElementById('currentDuration');
            const currentStartTimeEl = document.getElementById('currentStartTime');
            if(active){
              const currentSessionMinutes = Math.round((now - student.currentStartTime) / (1000 * 60));
              currentDurationEl.textContent = utils.formatDuration(Math.max(0, currentSessionMinutes));
            }else{
              // 失效：重置显示
              currentDurationEl.textContent='--';
              currentStartTimeEl.textContent='--';
              student.currentStatus='offline';
              student.currentStartTime=null;
            }
          }
        }
      }, 30 * 1000); // 每30秒更新一次
    }
    function stopCurrentDurationUpdate() {
      if (currentDurationTimer) {
        clearInterval(currentDurationTimer);
        currentDurationTimer = null;
      }
    }

    // ==== 442排行榜功能 ====
    // 参考 index-4 的 442 评分规则，精简实现维度1/2（各40分），维度3暂置 0（后续可接历史数据）
  const LB442_PARAMS = {
      dim1: { // 段内完成 + 迟到/缺席 扣分 => 0~40
  coverageCompleteThreshold: 0.6, // 兼容保留（不再用于得分阈值，改为按时间覆盖比例计分）
        absentThreshold: 0.1, // 仅用于说明，精简版缺席判定为完全 0 覆盖
        graceMinutes: 5,
  minSlotsForFullBonus: 3, // 满勤奖励触发的最少时段数（≥3 段）
        P_incomplete: 40,
        pLate: 0.4,
        lateCap: 20,
        pAbsent: 15,
        fullBonus: 3
  },
      dim2: { // 质量效率扣分 => 0~40
        longStartMin: 125, // 超过125分钟开始扣分（120分钟+5分钟缓冲期）
        longCapExtraMin: 120,
        pLong: 0.25,
        pWindow: 0.3,
        windowCapPerSession: 18,
        shortThreshold: 30,
        pShort: 0.5,
        tail: { p: 0.4, grace: 15, capMinutes: 30 }
      },
      dim3: { // 成长加成与反霸榜（20分权重槽位）
        // 周进步与稳定性配置
        progress: {
          maxRatio: 0.5,       // 相对提升上限（50%→满6分）
          denomFloor: 80,      // 小分母防护
          minPrevTotal: 40,    // 前窗口总分基线（5 工作日窗口）
          minActiveDaysPerWindow: 3, // 数据充足门槛：近/前各5个工作日内，有效天数≥3
          windowSize: 5        // 工作日窗口（原7改5）
        },
        freshness: {
          // 今日活跃度（适用排行榜窗口）：
          // 1) 在当日排行榜窗口（工作日：周三 08:00-19:10；周一/二/四/五 08:00-18:40）内累计练琴时长
          //    > minTodayDurationHours 小时（周末无窗口，计 0）
          // 2) 且今日 D1+D2 ≥ minTodayD12
          minTodayDurationHours: 3,
          minTodayD12: 78
        },
        antiDomination: {
          decayAfterDays: 3,     // 连续登顶>=3个工作日开始衰减
          maxConsecutiveDays: 5, // >=5个工作日登顶，额外强衰减
          decayRate: 0.85,       // 每超出一天乘以该系数
          breakPeriod: 2         // 距离上次登顶>=2个工作日，给一点新鲜奖励
        },
        freshBreakBonus: 1       // 新鲜奖励基础分（非乘子）
      }
    };

    function toDayStart(date) {
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
      return d.getTime();
    }

    function mergeIntervalsMs(arr) {
      if (!arr || !arr.length) return [];
      const sorted = arr.slice().sort((a, b) => a.start - b.start);
      const res = [];
      let cur = { ...sorted[0] };
      for (let i = 1; i < sorted.length; i++) {
        const x = sorted[i];
        if (x.start <= cur.end) {
          cur.end = Math.max(cur.end, x.end);
        } else {
          res.push(cur);
          cur = { ...x };
        }
      }
      res.push(cur);
      return res;
    }

    // 低效窗口（按星期）：
    // 一/二/四/五 => 12:10-12:40, 18:10-18:40；三 => 12:10-13:20, 18:40-19:10；其余为空
    function getDailyLowEffWindowsByWeekday(weekday0to6) {
      if ([1, 2, 4, 5].includes(weekday0to6)) {
        // Mon/Tue/Thu/Fri: 12:10–12:40, 18:10–18:40
        return [
          { startMin: 12*60 + 10, endMin: 12*60 + 40 },
          { startMin: 18*60 + 10, endMin: 18*60 + 40 }
        ];
      }
      if (weekday0to6 === 3) {
        // Wed: 12:10–13:20, 18:40–19:10
        return [
          { startMin: 12*60 + 10, endMin: 13*60 + 20 },
          { startMin: 18*60 + 40, endMin: 19*60 + 10 }
        ];
      }
      return [];
    }

    // 维度1：段内完成 + 迟到/缺席（slots 以分钟表示，intervalsMs 为当天毫秒区间）
    function computeDim1Score(slotsMin, intervalsMs, dayStartMs) {
      const p = LB442_PARAMS.dim1;
      if (!slotsMin || !slotsMin.length) {
        return { score: 0, breakdown: { slots: [], completed: 0, totalSlots: 0, absent: 0, latePenalty: 0, incompletePenalty: 0, absentPenalty: 0, fullBonus: 0, raw: 0 } };
      }
      // 预合并练习区间
      const merged = mergeIntervalsMs(intervalsMs);
      let completed = 0, absent = 0, latePenalty = 0;
      let totalDurMin = 0, totalOverlapMin = 0;
      const slotsDetail = [];

      // 以“当前时间”决定计分窗口：
      // - 已结束时段（slot.end <= nowMin）：全额计入，可能记为缺席
      // - 进行中时段（slot.start < nowMin < slot.end）：仅计入已到当前时刻的部分，不记缺席
      // - 未开始时段（nowMin <= slot.start）：不计入任何扣分/覆盖
      const nowMin = Math.floor((Date.now() - dayStartMs) / 60000);
      let includedSlots = 0;
      let allSlotsEnded = true;

      for (const slot of slotsMin) {
        const slotStartMs = dayStartMs + slot.start * 60 * 1000;
        const slotEndMs = dayStartMs + slot.end * 60 * 1000;
        const slotStartMin = slot.start;
        const slotEndMin = slot.end;

        // 决定是否计入以及计入到哪一刻
        if (nowMin <= slotStartMin) {
          // 未开始：跳过，不纳入本次计分
          allSlotsEnded = false;
          continue;
        }

        const effectiveEndMs = (nowMin >= slotEndMin) ? slotEndMs : (dayStartMs + nowMin * 60000);
        if (nowMin < slotEndMin) allSlotsEnded = false; // 仍有进行中

        // 仅将“起练后”的时间窗计入未完成计算
        // 1) 找到首个进入时刻 firstStartMs（若未进入则为 null）
        let firstStartMs = null;
        let overlapAfterStartMin = 0; // 仅统计 firstStart 之后的覆盖分钟
        for (const iv of merged) {
          if (iv.end <= slotStartMs) continue;
          if (iv.start >= effectiveEndMs) break;
          const st = Math.max(iv.start, slotStartMs);
          const ed = Math.min(iv.end, effectiveEndMs);
          if (ed > st) {
            if (firstStartMs === null) firstStartMs = st;
            const adjSt = Math.max(st, firstStartMs);
            if (ed > adjSt) overlapAfterStartMin += (ed - adjSt) / 60000;
          }
        }

        // 2) 评估窗：从 firstStart 到 effectiveEnd（未开始则评估窗为 0）
        const evalDurMin = firstStartMs ? ((effectiveEndMs - firstStartMs) / 60000) : 0;
        if (evalDurMin <= 0 && !(nowMin >= slotEndMin)) {
          // 未开始或尚未有效进入且未结束：跳过本段（不计迟到/未完成/缺席）
          continue;
        }

        includedSlots++;
        totalDurMin += Math.max(0, evalDurMin);

  // coverageEval: 起练后评估窗覆盖率；ongoing 时我们展示整体进度 = 已练 / 段总时长
  const coverageEval = evalDurMin > 0 ? (overlapAfterStartMin / evalDurMin) : 0;
  let status = '未完成'; // 结束前默认视为未完成，后面区分进行中

        // 迟到扣分：首入时间相对段开始的延迟（减去宽限）
        let lateMin = 0, thisLatePenalty = 0;
        if (firstStartMs) {
          lateMin = Math.max(0, Math.floor((firstStartMs - slotStartMs) / 60000 - p.graceMinutes));
          if (lateMin > 0) {
            thisLatePenalty = lateMin * p.pLate;
            latePenalty += thisLatePenalty;
          }
        }

        const ended = nowMin >= slotEndMin;
        if (ended) {
          if (!firstStartMs) {
            // 已结束且从未进入 → 缺席
            absent++;
            status = '缺席';
          } else if (evalDurMin > 0 && overlapAfterStartMin >= evalDurMin - 1e-6) {
            // 起练后覆盖满至段尾 → 完成
            completed++;
            status = '完成';
          } else {
            status = '未完成';
          }
        } else {
          // 进行中：不记缺席，状态标记为“进行中”以便前端展示覆盖进度
          status = '进行中';
        }

        let displayCoveragePct;
        if (status === '进行中') {
          const totalSlotDur = slotEndMin - slotStartMin; // 总分钟
          const practicedOverall = overlapAfterStartMin; // 已练分钟（从 firstStart 起）
          const overallPct = totalSlotDur > 0 ? (practicedOverall / totalSlotDur) : 0;
          displayCoveragePct = +(overallPct * 100).toFixed(1);
        } else {
          displayCoveragePct = +((coverageEval) * 100).toFixed(1);
        }
        slotsDetail.push({
          start: slot.start,
          end: slot.end,
          durMin: +Math.max(0, evalDurMin).toFixed(1), // 进行中：当前评估窗长度
          overlapMin: +overlapAfterStartMin.toFixed(1),
          coverage: displayCoveragePct,
          status,
          lateMin,
          latePenalty: +thisLatePenalty.toFixed(2)
        });
      }

      latePenalty = Math.min(latePenalty, p.lateCap);

  // 若当前尚无任何已开始的时段，则本次不产生未完成/缺席/迟到扣分
  // 这里 totalDurMin、overlapMin 均以“起练后评估窗”为口径
  let coverageRate = 0, incompletePenalty = 0, absentPenalty = 0;
  const totalOverlapAfterStartMin = slotsDetail.reduce((sum, s) => sum + (Number.isFinite(s.overlapMin) ? s.overlapMin : 0), 0);
  coverageRate = totalDurMin > 0 ? (totalOverlapAfterStartMin / totalDurMin) : 0;
  // 覆盖率接近 100% 时容差处理，避免浮点误差导致 0.01 的未完成扣分
  // 覆盖率接近 100% 时容差处理（避免日志秒级缝隙导致 0.01~0.05 分微扣）
  // 提升容差：0.0005 -> 0.002 (0.2%)，典型 40 分满分下最大可忽略缺口约 0.08 分原始值 * 40% = 0.032 实际得分影响（仍比迟到/缺席量级小很多）
  const EPS_COVERAGE = 2e-3; // 0.2%
  let microGapSuppressed = false;
  if (coverageRate > 1 - EPS_COVERAGE) { coverageRate = 1; microGapSuppressed = true; }
      if (totalDurMin > 0) {
        incompletePenalty = (1 - coverageRate) * p.P_incomplete;
        absentPenalty = absent * p.pAbsent;
      } else {
        incompletePenalty = 0;
        absentPenalty = 0;
        latePenalty = 0;
      }

      let raw = 100 - incompletePenalty - latePenalty - absentPenalty;

      // 若“纳入计分的时段”全部缺席（极端情况），则 raw 归零
      if (includedSlots > 0 && absent === includedSlots) {
        raw = 0;
      }

      // 为每个时段分配未完成扣分份额（按缺失分钟数占比），并标注缺席扣分
      const totalMissingMin = slotsDetail.reduce((sum, s) => sum + Math.max(0, (s.durMin || 0) - (s.overlapMin || 0)), 0);
      for (const s of slotsDetail) {
        const miss = Math.max(0, (s.durMin || 0) - (s.overlapMin || 0));
        const incShare = totalMissingMin > 0 ? miss / totalMissingMin * incompletePenalty : 0;
        const ended = nowMin >= s.end;
        const isAbsent = ended && (s.overlapMin || 0) === 0;
        s.missMin = +miss.toFixed(1);
        s.incompletePenalty = +incShare.toFixed(2);
        s.absentPenalty = isAbsent ? +p.pAbsent.toFixed(2) : 0;
      }

      // 满勤标记：仅在“当日所有时段均已结束且无迟到/缺席且覆盖率100%”时触发（不直接加到 D1 分，转移到总分层面）
      const slotCountIncluded = includedSlots;
      const gotFullBonus = (allSlotsEnded && slotCountIncluded >= (p.minSlotsForFullBonus || 1) && coverageRate === 1 && latePenalty === 0 && absent === 0);
      // 动态满勤加成：3段+1，4段+2，≥5段+3
      let fullBonusAward = 0;
      if (gotFullBonus) {
        if (slotCountIncluded >= 5) fullBonusAward = 3;
        else if (slotCountIncluded === 4) fullBonusAward = 2;
        else if (slotCountIncluded === 3) fullBonusAward = 1;
      }

      raw = Math.max(0, Math.min(raw, 100));
      const score = +(((raw) / 100) * 40).toFixed(2);
  return { score, breakdown: {
        slots: slotsDetail,
        completed,
        totalSlots: slotCountIncluded,
        absent,
        latePenalty: +latePenalty.toFixed(2),
        incompletePenalty: +incompletePenalty.toFixed(2),
        absentPenalty: +absentPenalty.toFixed(2),
  fullBonus: fullBonusAward, // 展示与总分层面使用的动态加成
  gotFullBonus,
  fullBonusAward,
        raw: +raw.toFixed(2),
  coverageRate: +coverageRate.toFixed(4),
  microGapSuppressed
      } };
    }

    // 维度2：质量效率（长时/低效窗口/短时/拖尾）
    function computeDim2Score(slotsMin, intervalsMs, dayStartMs, weekday0to6) {
      const p = LB442_PARAMS.dim2;
      if (!intervalsMs || !intervalsMs.length) {
        return { score: 0, breakdown: { intervals: [], longPenalty: 0, windowPenalty: 0, shortPenalty: 0, tailPenalty: 0, totalPenalty: 0, raw: 100 } };
      }
      const merged = mergeIntervalsMs(intervalsMs);
      const lowWins = getDailyLowEffWindowsByWeekday(weekday0to6);
  // 排行榜窗口结束分钟（用于截止截断短勤不扣分）
  const winEndMin = ([1,2,4,5].includes(weekday0to6)) ? (18*60+40) : (weekday0to6===3 ? (19*60+10) : null);
      // 预处理时段，增加 nextStart 以支持“进入下一个时段后不算拖尾”规则
      const slotsSorted = (slotsMin || []).slice().sort((a,b)=>a.start-b.start).map(s=>({start:s.start,end:s.end}));
      for (let i=0;i<slotsSorted.length;i++) {
        slotsSorted[i].nextStart = (i+1 < slotsSorted.length) ? slotsSorted[i+1].start : Infinity;
      }
      
      let longPenalty = 0, windowPenalty = 0, shortPenalty = 0, tailPenalty = 0;
      const intervalDetail = [];
      
      for (const iv of merged) {
        const startMin = Math.floor((iv.start - dayStartMs) / 60000);
        const endMin = Math.floor((iv.end - dayStartMs) / 60000);
        if (endMin <= startMin) continue;
        const L = endMin - startMin;
        
        // 1. 超长扣分（总是应用）
        let thisLongPenalty = 0;
        if (L > p.longStartMin) {
          const over = Math.min(L - p.longStartMin, p.longCapExtraMin);
          thisLongPenalty = over * p.pLong;
          longPenalty += thisLongPenalty;
        }
        
        // 2. 短时扣分（1-30分钟才扣分，避免误触记录被过度扣分）
        let thisShortPenalty = 0;
        if (L < p.shortThreshold && L > 1) {
          // 截止截断保护：若该区间恰好在排行榜截止时间结束，则视为被窗口截断，不算短时扣分
          const atCutoff = (winEndMin != null && endMin === winEndMin);
          if (!atCutoff) {
            thisShortPenalty = (p.shortThreshold - L) * p.pShort;
            shortPenalty += thisShortPenalty;
          }
        }
        
        // 3. 低效窗口 vs 拖尾扣分：只应用其中之一（优先拖尾）
        let appliedTailPenalty = false;
        let thisTailPenalty = 0, thisWindowPenalty = 0, overlapLow = 0, tailMin = 0;
        
        // 检查是否有拖尾扣分（规则：超过某时段结束 + grace 且该延伸部分未进入下一时段开始之前）
        for (const sl of slotsSorted) {
          const se = sl.end;
          // 必须跨过该段结束 + grace
          if (!(startMin < se && endMin > se + p.tail.grace)) continue;
          // 若进入了任意后续计划段（区间与后续段有 >=1 分钟重叠），则视为“衔接下一段”而非拖尾
          let overlapsNextSlot = false;
          for (const next of slotsSorted) {
            if (next.start <= se) continue; // 只看后面的
            // 如果练习区间的后半部分进入了 next.start 之后（至少1分钟）
            if (endMin > next.start && startMin < next.end) { overlapsNextSlot = true; break; }
          }
          if (overlapsNextSlot) continue; // 连续跨段练习，不算拖尾
          // 仍需保持“下一段开始太近”不算拖尾（原有规则）
            if (sl.nextStart <= se + p.tail.grace) continue;
          const tailRegionEnd = Math.min(endMin, sl.nextStart);
          const rawTail = tailRegionEnd - (se + p.tail.grace);
          if (rawTail > 0) {
            const tail = Math.min(rawTail, p.tail.capMinutes);
            tailMin = tail;
            thisTailPenalty = tail * p.tail.p;
            tailPenalty += thisTailPenalty;
            appliedTailPenalty = true;
            break;
          }
        }
        
        // 如果没有拖尾扣分，才检查低效窗口扣分
        if (!appliedTailPenalty) {
          overlapLow = 0;
          for (const w of lowWins) {
            if (endMin <= w.startMin || startMin >= w.endMin) continue;
            overlapLow += Math.min(endMin, w.endMin) - Math.max(startMin, w.startMin);
          }
          if (overlapLow > 0) {
            thisWindowPenalty = Math.min(overlapLow * p.pWindow, p.windowCapPerSession);
            windowPenalty += thisWindowPenalty;
          }
        }

        intervalDetail.push({
          startMin, endMin, lengthMin: L,
          longOverMin: Math.max(0, L - p.longStartMin), longPenalty: +thisLongPenalty.toFixed(2),
          shortDeficitMin: L < p.shortThreshold ? (p.shortThreshold - L) : 0, shortPenalty: +thisShortPenalty.toFixed(2),
          lowOverlapMin: overlapLow, lowPenalty: +thisWindowPenalty.toFixed(2),
          tailMin, tailPenalty: +thisTailPenalty.toFixed(2),
          appliedTail: appliedTailPenalty,
          intervalPenalty: +(thisLongPenalty + thisShortPenalty + (appliedTailPenalty ? thisTailPenalty : thisWindowPenalty)).toFixed(2)
        });
      }
      
      const totalPenalty = longPenalty + windowPenalty + shortPenalty + tailPenalty;
      let raw = 100 - totalPenalty;
      raw = Math.max(0, Math.min(raw, 100));
      const score = +((raw / 100) * 40).toFixed(2);
      return { score, breakdown: {
        intervals: intervalDetail,
        longPenalty: +longPenalty.toFixed(2),
        windowPenalty: +windowPenalty.toFixed(2),
        shortPenalty: +shortPenalty.toFixed(2),
        tailPenalty: +tailPenalty.toFixed(2),
        totalPenalty: +totalPenalty.toFixed(2),
        raw: +raw.toFixed(2)
      } };
    }

    function getTodaySlotsMinutes(studentName, today) {
      const weekday1to7 = utils.getWeekday(today); // 1..7，周一=1，周日=7
      const ts = appState.timeSlots.get(studentName);
      const list = (ts && ts[weekday1to7]) ? ts[weekday1to7] : [];
      // 现有结构：[{start_time, end_time}]（字符串 HH:MM）或 {start, end}（分钟）
      return (list || []).map(s => {
        const startRaw = (s.start !== undefined) ? s.start : (s.start_time || s.start);
        const endRaw = (s.end !== undefined) ? s.end : (s.end_time || s.end);
        const start = (typeof startRaw === 'number') ? startRaw : utils.parseTimeSlot(startRaw);
        const end = (typeof endRaw === 'number') ? endRaw : utils.parseTimeSlot(endRaw);
        return { start, end };
      }).filter(x => Number.isFinite(x.start) && Number.isFinite(x.end) && x.end > x.start);
    }

    function getTodayPracticeIntervalsMs(studentName, today) {
      const dateKey = utils.getDateKey(today);
      const logs = (appState.practiceLogs || []).filter(log => {
        const nm = log.student_name || log.student || log.studentName;
        if (nm !== studentName) return false;
        const dKey = utils.getDateKey(new Date(log.timestamp));
        return dKey === dateKey;
      }).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

      const intervals = [];
      let curStart = null;
      logs.forEach(log => {
        const action = String(log.action || '').toLowerCase();
        const isEnter = action === 'enter' || action === 'assign';
        const isExit = action === 'exit' || action === 'clear';
        if (isEnter) {
          if (curStart == null) curStart = new Date(log.timestamp).getTime();
        } else if (isExit) {
          if (curStart != null) {
            const end = new Date(log.timestamp).getTime();
            if (end > curStart) intervals.push({ start: curStart, end });
            curStart = null;
          }
        }
      });
      if (curStart != null) {
        const now = Date.now();
        if (now > curStart) intervals.push({ start: curStart, end: now });
      }
      return intervals;
    }

    // === 排行榜专用窗口与裁剪 ===
    // 周1/2/4/5: 08:00-18:40  (共10小时40分)
    // 周3      : 08:00-19:10  (共11小时10分)
    // 其余(周六日)不参与排行榜
    function getLeaderboardWindow(date){
      const wd = date.getDay(); // 0=Sun 1=Mon ... 6=Sat
      if (wd === 3) { // 周三
        return { startMin: 8*60, endMin: 19*60 + 10 };
      }
      if ([1,2,4,5].includes(wd)) {
        return { startMin: 8*60, endMin: 18*60 + 40 };
      }
      return null; // 周末或周日/周六不参与
    }

    function clipIntervalMsToWindow(iv, dayStartMs, win){
      const ws = dayStartMs + win.startMin*60000;
      const we = dayStartMs + win.endMin*60000;
      const s = Math.max(iv.start, ws);
      const e = Math.min(iv.end, we);
      if (e - s > 0) return { start: s, end: e };
      return null;
    }

    // 裁剪 slots 分段到排行榜窗口（只保留重叠部分）
    function getLeaderboardSlotsMinutes(studentName, date){
      const win = getLeaderboardWindow(date);
      if (!win) return [];
      const orig = getTodaySlotsMinutes(studentName, date) || [];
      return orig.map(s => {
        const st = Math.max(s.start, win.startMin);
        const ed = Math.min(s.end, win.endMin);
        return { start: st, end: ed };
      }).filter(s => s.end > s.start);
    }

    // 裁剪练习区间到排行榜窗口
    function getLeaderboardPracticeIntervalsMs(studentName, date){
      const win = getLeaderboardWindow(date);
      if(!win) return [];
      const base = getTodayPracticeIntervalsMs(studentName, date) || [];
      const dayStartMs = toDayStart(date);
      const out = [];
      for (const iv of base){
        const clipped = clipIntervalMsToWindow(iv, dayStartMs, win);
        if (clipped) out.push(clipped);
      }
      return out;
    }

    function getActiveLeaderboardDate() {
      const now = new Date();
      // 排行榜日界定：07:30 之前仍归前一天，其余属于当天
      const minutesSinceMidnight = now.getHours() * 60 + now.getMinutes();
      if (minutesSinceMidnight < 7*60 + 30) {
        return new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
      }
      return new Date(now.getFullYear(), now.getMonth(), now.getDate());
    }

    async function ensureDailyLeaderboard(date){
      const key = formatDateKey(date);
      if(appState.dailyLeaderboards.has(key)) return appState.dailyLeaderboards.get(key);
      // 尝试从后端读取备份
  const backend = await fetchDailyLeaderboardMap(date);
      if (backend) { appState.dailyLeaderboards.set(key, backend); return backend; }
      // 回退：本地现算
      const map = new Map();
      const arr = Array.from(appState.students.values()).map(stu => {
        const dayStartMs = toDayStart(date);
        const slotsMin = getLeaderboardSlotsMinutes(stu.name, date);
        const intervalsMs = getLeaderboardPracticeIntervalsMs(stu.name, date);
        const d1 = computeDim1Score(slotsMin, intervalsMs, dayStartMs);
        const d2 = computeDim2Score(slotsMin, intervalsMs, dayStartMs, date.getDay());
        return { name: stu.name, score: d1.score + d2.score };
      }).sort((a, b) => b.score - a.score);
      arr.forEach((x, idx) => map.set(x.name, idx + 1));
      appState.dailyLeaderboards.set(key, map);
      return map;
    }

    async function buildPrevDayRankingMap(date) {
      return await ensureDailyLeaderboard(date);
    }

    // ==== 反霸榜辅助：简易历史缓存（仅工作日向后追溯最多14天） ====
    const __rankTopCache = new Map(); // key: dateKey => [top1Name]

    function formatDateKey(d){
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

    function isWorkday(d){
      const wd = d.getDay();
      return wd>=1 && wd<=5;
    }

    // 工作日辅助
    function nearestWorkdayOnOrBefore(date){
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      while(!isWorkday(d)) d.setDate(d.getDate()-1);
      return d;
    }
    function previousWorkday(date){
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate()-1);
      return nearestWorkdayOnOrBefore(d);
    }
    function getLastNWorkdayDates(endDate, n){
      const arr=[]; let d = nearestWorkdayOnOrBefore(endDate);
      while(arr.length < n){ if(isWorkday(d)) arr.push(new Date(d.getFullYear(), d.getMonth(), d.getDate())); d.setDate(d.getDate()-1); }
      return arr.reverse();
    }

    function getTopNameForDate(date){
      const key = formatDateKey(date);
      if(__rankTopCache.has(key)) return __rankTopCache.get(key);
      // 计算该日所有学生的 D1+D2 分，取 Top1
      const arr = Array.from(appState.students.values()).map(stu => {
        const dayStartMs = toDayStart(date);
        const slotsMin = getLeaderboardSlotsMinutes(stu.name, date);
        const intervalsMs = getLeaderboardPracticeIntervalsMs(stu.name, date);
        const d1 = computeDim1Score(slotsMin, intervalsMs, dayStartMs);
        const d2 = computeDim2Score(slotsMin, intervalsMs, dayStartMs, date.getDay());
        return { name: stu.name, score: d1.score + d2.score };
      }).sort((a,b)=>b.score-a.score);
      const top = arr[0]?.name || null;
      __rankTopCache.set(key, top);
      return top;
    }

    function getConsecutiveTopWorkdaysUpTo(date, studentName){
      // 从给定日期向前按工作日统计连续登顶数
      let cnt = 0;
      let d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      for(let i=0;i<14;i++){
        if(!isWorkday(d)) { d.setDate(d.getDate()-1); continue; }
        const top = getTopNameForDate(d);
        if(top === studentName){ cnt++; } else { break; }
        d.setDate(d.getDate()-1);
      }
      return cnt;
    }

    function getWorkdaysSinceLastTop(date, studentName){
      // 从前一工作日起向前找上次登顶的工作日距离
      let days = 0;
      let d = new Date(date.getFullYear(), date.getMonth(), date.getDate()-1);
      for(let i=0;i<30;i++){
        if(!isWorkday(d)) { d.setDate(d.getDate()-1); continue; }
        const top = getTopNameForDate(d);
        if(top === studentName) return days; // 找到
        days++;
        d.setDate(d.getDate()-1);
      }
      return days; // 没找到则认为很久未登顶
    }
    function getDailyD12Score(studentName, date) {
      // 计算指定日期的 D1+D2 总分
      try {
        const dayStartMs = toDayStart(date);
        const weekday0to6 = date.getDay();
  const slotsMin = getLeaderboardSlotsMinutes(studentName, date);
  const intervalsMs = getLeaderboardPracticeIntervalsMs(studentName, date);
        const d1 = computeDim1Score(slotsMin, intervalsMs, dayStartMs);
        const d2 = computeDim2Score(slotsMin, intervalsMs, dayStartMs, weekday0to6);
        return d1.score + d2.score;
      } catch { return 0; }
    }

    function getLastNDaysD12Scores(studentName, endDate, n) {
      const out = [];
      for (let i = n - 1; i >= 0; i--) {
        const d = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate() - i);
        out.push(getDailyD12Score(studentName, d));
      }
      return out;
    }

        // 逐名次细化排名加分：
        // 1名=3分, 10名=1分, 2-9名线性插值: score = 3 - (rank-1)*( (3-1)/(10-1) ) = 3 - (rank-1)*(2/9)
        // rank <=0 或 非数字返回 0；rank>10 → 0。
        // 可根据需要改为非线性（例如幂次或对数），先保持线性确保总区间与原上限一致。
        function computeRankPoints(rank){
          if(!Number.isFinite(rank) || rank<=0) return 0;
          if(rank===1) return 3;
          if(rank>=10) return rank===10 ? 1 : 0;
          const val = 3 - (rank-1)*(2/9); // rank in [1,10]
          // 保留到 2 位，避免浮点噪声
          return +val.toFixed(2);
        }

        // 连续化稳定性分：std=0 -> 3 分；std>=15 -> 0 分；中间线性衰减。
        // 原离散阈值: <=3(3分),<=5(2),<=10(1),<=15(0.5),>15(0)
        // 新公式更平滑：score = 3 * max(0, 1 - std/15)
        // 保留两位再输出（展示层仍可一位）。
        function computeConsistencyPoints(std){
          if(!Number.isFinite(std) || std<0) return 0;
          const val = 3 * Math.max(0, 1 - std/15);
          return +val.toFixed(2);
        }

  function computeDim3Score(studentName, activeDate, todayD12, prevDayRankMap) {
      // sFresh：仅“今日活跃度”分；antiBonus：反霸榜的公平性奖励，独立于今日活跃度
      let sRank = 0, sProgress = 0, sConsistency = 0, sFresh = 0, antiBonus = 0;
      // 周末不计算维度三（完全禁用），返回标记，后续总分计算会被周末早退逻辑拦截
      if (!isWorkday(activeDate)) {
        return { score: 0, breakdown: { weekend: true, disabled: true } };
      }
  // 昨日排行：改为逐名次细化（1名=3分，10名=1分，中间线性插值；>10名=0）
  const pr = prevDayRankMap?.get(studentName);
  sRank = computeRankPoints(pr);
      
  // 周进步：近7个工作日 vs 前7个工作日（排除周六周日），最多6分，上限50%提升
  const endWorkday = nearestWorkdayOnOrBefore(activeDate);
  const WN = p3.progress.windowSize || 5;
  const curDates = getLastNWorkdayDates(endWorkday, WN);
  const cur7 = curDates.map(d => getDailyD12Score(studentName, d));
  const prevWindowEnd = previousWorkday(curDates[0]);
  const prevDates = getLastNWorkdayDates(prevWindowEnd, WN);
  const prev7 = prevDates.map(d => getDailyD12Score(studentName, d));
  // 历史参考仅统计“有练琴的工作日”（>0分的天），无练琴天不纳入参考
  const sum = a => a.reduce((x, y) => x + y, 0);
  const curActiveArr = cur7.filter(v => v > 0);
  const prevActiveArr = prev7.filter(v => v > 0);
  const sCur = sum(curActiveArr), sPrev = sum(prevActiveArr);
      // 小分母/基线保护：前周极低时不计或以下限分母计算提升占比
      let appliedProgressRatio = 0;
      const p3 = LB442_PARAMS.dim3;
      // 数据充足门槛：两个窗口各自有效天数（>0分）要达到阈值
  const curActiveDays = curActiveArr.length;
  const prevActiveDays = prevActiveArr.length;
      const passActiveDaysGate = (curActiveDays >= p3.progress.minActiveDaysPerWindow) && (prevActiveDays >= p3.progress.minActiveDaysPerWindow);
      if (passActiveDaysGate && sPrev >= p3.progress.minPrevTotal && sCur > sPrev) {
        const W = p3.progress.windowSize || 5;
        const avgCur = sCur / W;
        const avgPrev = sPrev / W;
        const denomAvg = Math.max(avgPrev, p3.progress.denomFloor / W);
        const rawRatio = (avgCur - avgPrev) / denomAvg; // 0 ~ ~
        appliedProgressRatio = Math.min(p3.progress.maxRatio, Math.max(0, rawRatio));
        const ratioPct = appliedProgressRatio / p3.progress.maxRatio;
        sProgress = Math.min(6, +(ratioPct * 6).toFixed(2));
      }
      
  // 稳定性：仅基于“有效工作日”（>0分）计算标准差
      const activeDays = curActiveArr.length;
      let std = 0;
      if (activeDays > 0) {
        const mean = sCur / activeDays;
        const variance = curActiveArr.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / activeDays;
        std = Math.sqrt(variance);
      } else {
        std = 0;
      }
      // 最低活跃门槛：近7个“有效工作日”≥3 或 有效总分≥40，否则不授予稳定性分
      const passStabilityGate = (activeDays >= 3) || (sCur >= 40);
      if (passStabilityGate) {
        sConsistency = computeConsistencyPoints(std);
      } else {
        sConsistency = 0;
      }
      
  // 删除“今日活跃度”加分（历史规则调整，D3 不再包含当日活跃度）

      // 反霸榜机制（基于工作日 Top1 连续天数与距上次登顶天数）
      // 反霸榜（乘子与公平性奖励）
      // 乘子仅作用基础分（不含公平性奖励）；公平性奖励不受乘子影响
      // 注：大多数未近期登顶者会获得 +freshBreakBonus 的常驻鼓励，用于抑制单人长期垄断带来的相对劣势
      const p3_anti = LB442_PARAMS.dim3;
      let freshnessMultiplier = 1;
      let antiNote = null;
      try {
  const prevWorkday = previousWorkday(activeDate);
        const consec = getConsecutiveTopWorkdaysUpTo(prevWorkday, studentName);
        const daysSince = getWorkdaysSinceLastTop(activeDate, studentName);
        if (consec >= p3_anti.antiDomination.decayAfterDays) {
          const excess = consec - p3_anti.antiDomination.decayAfterDays;
          freshnessMultiplier = Math.pow(p3_anti.antiDomination.decayRate, Math.max(0, excess));
          if (consec >= p3_anti.antiDomination.maxConsecutiveDays) {
            freshnessMultiplier *= 0.5; // 额外强衰减
          }
          antiNote = `连续登顶${consec}个工作日，应用衰减×${freshnessMultiplier.toFixed(2)}`;
        } else if (daysSince >= p3_anti.antiDomination.breakPeriod) {
          // 给未近期登顶者轻微公平性奖励（不计入今日活跃度）
          antiBonus += p3_anti.freshBreakBonus;
          antiNote = `距上次登顶${daysSince}个工作日，获得公平性奖励+${p3_anti.freshBreakBonus}`;
        }
      } catch (e) { /* 忽略反霸榜异常 */ }

  let totalBase = sRank + sProgress + sConsistency;
      let total = totalBase * freshnessMultiplier + antiBonus;
      total = Math.max(0, Math.min(20, total));
      return {
        score: total,
        breakdown: {
          yesterdayRank: pr ?? null,
          rankPoints: sRank,
          progressPoints: sProgress,
          // ratioDisplay 用原始分母 sPrev 便于理解；ratioApplied 用防护后的分母用于计分
          progressDetail: {
            cur7Total: sCur,
            prev7Total: sPrev,
            curDays: cur7, // 近窗口逐日分
            prevDays: prev7, // 前窗口逐日分
            avgCur: +( (sCur / (p3.progress.windowSize||5)) .toFixed(2) ),
            avgPrev: +( (sPrev / (p3.progress.windowSize||5)) .toFixed(2) ),
            rawRatioAvg: (sPrev>0 ? +(((sCur/(p3.progress.windowSize||5)) - (sPrev/(p3.progress.windowSize||5))) / (sPrev/(p3.progress.windowSize||5)) * 100).toFixed(1) : null),
            ratio: (sPrev > 0 ? +(((sCur/ (p3.progress.windowSize||5)) - (sPrev/(p3.progress.windowSize||5))) / Math.max(sPrev/(p3.progress.windowSize||5), p3.progress.denomFloor/(p3.progress.windowSize||5)) * 100).toFixed(1) : null),
            appliedRatio: +(appliedProgressRatio * 100).toFixed(1), // 基于窗口平均
            curActiveDays,
            prevActiveDays,
            minActiveDaysRequired: p3.progress.minActiveDaysPerWindow,
            gatedByActiveDays: !(curActiveDays >= p3.progress.minActiveDaysPerWindow && prevActiveDays >= p3.progress.minActiveDaysPerWindow)
          },
          consistencyPoints: sConsistency,
          consistencyStd: +std.toFixed(2),
          // freshPoints: 已移除
          antiBonusPoints: antiBonus,
          freshnessMultiplier: +freshnessMultiplier.toFixed(2),
          antiNote: antiNote
        }
      };
    }

    // ===== 云端 D3 计算：轻量缓存与批量辅助 =====
    const __cloudD3 = {
      perDateIntervals: new Map(), // isoDate -> Map(student_key -> intervals)
      prevTopByActiveIso: new Map(), // activeIso -> Map(dateIso -> top student_key)
      prevDayRankMap: new Map(), // prevIso -> Map(student_key -> rank)
      corsBlocked: false,
      d12CacheByDate: new Map() // isoDate -> Map(student_key -> d1+d2)
    };

    async function __prefetchD12ForWindows(studentKeys, dates){
      const isoDates = Array.from(new Set(dates.map(d=>utils.toIsoDate(d))));
      const needDates = isoDates.filter(iso=>!__cloudD3.d12CacheByDate.has(iso));
      if(!needDates.length) return;
      // 分日期批量获取所有学生的 d1/d2
      try{
        for(const iso of needDates){
          const { data, error } = await supabaseClient
            .from('leaderboard_daily')
            .select('student_key,d1,d2')
            .eq('date', iso);
          const m = new Map();
          if(!error && Array.isArray(data)){
            for(const r of data){
              const key = utils.normalizeStudentName(r.student_key);
              m.set(key, (Number(r.d1)||0) + (Number(r.d2)||0));
            }
          }
          __cloudD3.d12CacheByDate.set(iso, m);
        }
      }catch{}
    }

    async function __getPerStudentIntervalsForDateCached(date){
      const iso = utils.toIsoDate(date);
      if(__cloudD3.perDateIntervals.has(iso)) return __cloudD3.perDateIntervals.get(iso);
      try{
        const map = await __fetchPracticeIntervalsByStudentForDate(supabaseClient, date);
        __cloudD3.perDateIntervals.set(iso, map);
        return map;
      }catch(e){
        __cloudD3.corsBlocked = true; // 遇到 CORS/加载失败后，本会话内不再反复尝试
        return new Map();
      }
    }

    async function __getPrevDayRankMapCached(prevDate){
      const iso = utils.toIsoDate(prevDate);
      if(__cloudD3.prevDayRankMap.has(iso)) return __cloudD3.prevDayRankMap.get(iso);
      const m = new Map();
      try{
        const { data, error } = await supabaseClient
          .from('leaderboard_daily')
          .select('student_key,rank')
          .eq('date', iso);
        if(!error && Array.isArray(data)){
          for(const r of data){ if(typeof r.rank === 'number') m.set(utils.normalizeStudentName(r.student_key), r.rank); }
        }
      }catch{}
      __cloudD3.prevDayRankMap.set(iso, m);
      return m;
    }

    async function __getPrevTopByDateCached(activeDate){
      const activeIso = utils.toIsoDate(activeDate);
      if(__cloudD3.prevTopByActiveIso.has(activeIso)) return __cloudD3.prevTopByActiveIso.get(activeIso);
      // 收集近 30 个工作日（从前一工作日开始）
      const datesScan = [];
      let d = previousWorkday(activeDate);
      for(let i=0;i<60 && datesScan.length<30;i++){
        if(isWorkday(d)) datesScan.push(utils.toIsoDate(d));
        d = previousWorkday(d);
      }
      const topByDate = new Map();
      try{
        if(datesScan.length){
          const { data, error } = await supabaseClient
            .from('leaderboard_daily')
            .select('date,student_key')
            .in('date', datesScan)
            .eq('rank', 1);
          if(!error && Array.isArray(data)){
            for(const r of data){ topByDate.set(r.date, utils.normalizeStudentName(r.student_key)); }
          }
        }
      }catch{}
      __cloudD3.prevTopByActiveIso.set(activeIso, topByDate);
      return topByDate;
    }

    // ===== 基于云端历史数据的 D3 计算（统一入口） =====
    async function computeDim3ScoreCloud(studentName, activeDate, todayD12) {
      const p3 = LB442_PARAMS.dim3;
      const key = utils.normalizeStudentName(studentName);
      // 周末不计算维度三
      if (!isWorkday(activeDate)) {
        return { score: 0, breakdown: { weekend: true, disabled: true } };
      }

      // 1) 昨日排名（来自 leaderboard_daily）
      const prevDay = previousWorkday(activeDate);
      let yesterdayRank = null;
      const prevMapAll = await __getPrevDayRankMapCached(prevDay);
      if(prevMapAll && prevMapAll.size){ yesterdayRank = prevMapAll.get(key) ?? null; }
      let sRank = 0;
  sRank = computeRankPoints(yesterdayRank);

      // 2) 周进步与稳定性：近7个工作日 vs 前7个工作日，基于 leaderboard_daily 的 d1+d2
      const endWorkday = nearestWorkdayOnOrBefore(activeDate);
  const WN = p3.progress.windowSize || 5;
  const curDates = getLastNWorkdayDates(endWorkday, WN);
      const prevWindowEnd = previousWorkday(curDates[0]);
  const prevDates = getLastNWorkdayDates(prevWindowEnd, WN);
      const allDates = [...curDates, ...prevDates];
      // 先尝试从缓存取，不足再补齐
      await __prefetchD12ForWindows([key], allDates);
      const getD12 = (d) => {
        const iso = utils.toIsoDate(d);
        const map = __cloudD3.d12CacheByDate.get(iso);
        return map ? (map.get(key) || 0) : 0;
      };
      const cur7 = curDates.map(getD12);
      const prev7 = prevDates.map(getD12);
      const sum = a => a.reduce((x, y) => x + y, 0);
      const curActiveArr = cur7.filter(v => v > 0);
      const prevActiveArr = prev7.filter(v => v > 0);
      const sCur = sum(curActiveArr), sPrev = sum(prevActiveArr);
      const curActiveDays = curActiveArr.length;
      const prevActiveDays = prevActiveArr.length;
      let sProgress = 0, appliedProgressRatio = 0;
      const passActiveDaysGate = (curActiveDays >= p3.progress.minActiveDaysPerWindow) && (prevActiveDays >= p3.progress.minActiveDaysPerWindow);
      if (passActiveDaysGate && sPrev >= p3.progress.minPrevTotal && sCur > sPrev) {
        const W = p3.progress.windowSize || 5;
        const avgCur = sCur / W;
        const avgPrev = sPrev / W;
        const denomAvg = Math.max(avgPrev, p3.progress.denomFloor / W);
        appliedProgressRatio = Math.min(p3.progress.maxRatio, Math.max(0, (avgCur - avgPrev) / denomAvg));
        const ratioPct = appliedProgressRatio / p3.progress.maxRatio;
        sProgress = Math.min(6, +(ratioPct * 6).toFixed(2));
      }
      // 稳定性
      let sConsistency = 0; let std = 0;
      if (curActiveArr.length > 0) {
        const mean = sCur / curActiveArr.length;
        const variance = curActiveArr.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / curActiveArr.length;
        std = Math.sqrt(variance);
      }
      const passStabilityGate = (curActiveArr.length >= 3) || (sCur >= 40);
      if (passStabilityGate) {
        sConsistency = computeConsistencyPoints(std);
      }

  // 3) 今日活跃度加分已移除（维度三不再包含）

      // 4) 反霸榜（用 leaderboard_daily 的 rank=1 记录判断登顶情况）
      let antiBonus = 0; let freshnessMultiplier = 1; let antiNote = null;
      try {
        const topByDate = await __getPrevTopByDateCached(activeDate);
        // 连续登顶数（从前一工作日开始向前）
        let consec = 0;
        let d = previousWorkday(activeDate);
        for (let i = 0; i < 14; i++) {
          const iso = utils.toIsoDate(d);
          if (topByDate.get(iso) === key) { consec++; d = previousWorkday(d); } else { break; }
        }
        // 距上次登顶的工作日数
        let daysSince = 0;
        let dd = previousWorkday(activeDate);
        for (let i = 0; i < 30; i++) {
          const iso = utils.toIsoDate(dd);
          if (topByDate.get(iso) === key) break;
          daysSince++;
          dd = previousWorkday(dd);
        }
        const anti = p3.antiDomination;
        if (consec >= anti.decayAfterDays) {
          const excess = consec - anti.decayAfterDays;
          freshnessMultiplier = Math.pow(anti.decayRate, Math.max(0, excess));
          if (consec >= anti.maxConsecutiveDays) {
            freshnessMultiplier *= 0.5;
          }
          antiNote = `连续登顶${consec}个工作日，应用衰减×${freshnessMultiplier.toFixed(2)}`;
        } else if (daysSince >= anti.breakPeriod) {
          antiBonus += p3.freshBreakBonus;
          antiNote = `距上次登顶${daysSince}个工作日，获得公平性奖励+${p3.freshBreakBonus}`;
        }
      } catch {}

  const totalBase = sRank + sProgress + sConsistency;
      let total = totalBase * freshnessMultiplier + antiBonus;
      total = Math.max(0, Math.min(20, total));
      return {
        score: total,
        breakdown: {
          yesterdayRank,
          rankPoints: sRank,
          progressPoints: sProgress,
          progressDetail: {
            cur7Total: sCur,
            prev7Total: sPrev,
            curDays: cur7,
            prevDays: prev7,
            avgCur: +( (sCur / (p3.progress.windowSize||5)) .toFixed(2) ),
            avgPrev: +( (sPrev / (p3.progress.windowSize||5)) .toFixed(2) ),
            rawRatioAvg: (sPrev>0 ? +(((sCur/(p3.progress.windowSize||5)) - (sPrev/(p3.progress.windowSize||5))) / (sPrev/(p3.progress.windowSize||5)) * 100).toFixed(1) : null),
            ratio: (sPrev > 0 ? +(((sCur/ (p3.progress.windowSize||5)) - (sPrev/(p3.progress.windowSize||5))) / Math.max(sPrev/(p3.progress.windowSize||5), p3.progress.denomFloor/(p3.progress.windowSize||5)) * 100).toFixed(1) : null),
            appliedRatio: +(appliedProgressRatio * 100).toFixed(1),
            curActiveDays,
            prevActiveDays,
            minActiveDaysRequired: p3.progress.minActiveDaysPerWindow,
            gatedByActiveDays: !(curActiveDays >= p3.progress.minActiveDaysPerWindow && prevActiveDays >= p3.progress.minActiveDaysPerWindow)
          },
          consistencyPoints: sConsistency,
          consistencyStd: +std.toFixed(2),
          // freshPoints: 已移除
          antiBonusPoints: antiBonus,
          freshnessMultiplier: +freshnessMultiplier.toFixed(2),
          antiNote
        }
      };
    }

  async function computeScore442(student) {
      const activeDate = getActiveLeaderboardDate();
      const dayStartMs = toDayStart(activeDate);
      const weekday0to6 = activeDate.getDay();
      // 周末不计算 442 分，返回空结果用于前端隐藏
      if (!isWorkday(activeDate)) {
        return { total: null, d1: null, d2: null, d3: null, weekend: true };
      }
  const slotsMin = getLeaderboardSlotsMinutes(student.name, activeDate);
  const intervalsMs = getLeaderboardPracticeIntervalsMs(student.name, activeDate);
      // 当天无任何练琴记录：排行榜不显示分数
      if (!intervalsMs || intervalsMs.length === 0) {
        return { total: null, d1: null, d2: null, d3: null, noPractice: true };
      }
      const d1 = computeDim1Score(slotsMin, intervalsMs, dayStartMs);
      const d2 = computeDim2Score(slotsMin, intervalsMs, dayStartMs, weekday0to6);
  const d3 = await computeDim3ScoreCloud(utils.normalizeStudentName(student.name), activeDate, d1.score + d2.score);
  let total = d1.score + d2.score + d3.score;
  // 方案D：满勤加分移动到总分层面（动态：3→+1，4→+2，≥5→+3）
  if (d1.breakdown && d1.breakdown.gotFullBonus) {
    total += (d1.breakdown.fullBonusAward || 0);
  }
  
  // 管理员调分
  const adminAdjustment = getAdminScoreAdjustment(student.name);
  if (adminAdjustment !== 0) {
    total += adminAdjustment;
  }
  
  total = +(Math.max(0, Math.min(100, total))).toFixed(2);
  const bonus = (d1.breakdown && d1.breakdown.gotFullBonus) ? (d1.breakdown.fullBonusAward || 0) : 0;
  
  return { 
    total, 
    d1: d1.score, 
    d2: d2.score, 
    d3: d3.score, 
    bonus: bonus,
    adminAdjustment: adminAdjustment
  };
    }

  async function updateRanking() {
      const rankingList = document.getElementById('rankingList');
      if (!rankingList) return;
      // 保障：若有某些学生仍残留在缓存但不在 student_database，提前过滤
      if(appState && appState.students instanceof Map && appState.studentsMeta instanceof Map){
        for(const k of Array.from(appState.students.keys())){
          if(!appState.studentsMeta.has(utils.normalizeStudentName(k))){
            appState.students.delete(k);
            if(window.__scoreCache) window.__scoreCache.delete(k);
          }
        }
      }
      
      // 缓存检查：确保与日排行榜一致性
      const now = Date.now();
      const currentActiveDate = getActiveLeaderboardDate();
      const currentActiveIso = utils.toIsoDate(currentActiveDate);
      
      // 检查本地存储缓存是否存在且有效
      const localCache = (() => {
        try {
          const raw = localStorage.getItem('rank_cache_v2');
          if (!raw) return null;
          const obj = JSON.parse(raw);
          if (obj && obj.date === currentActiveIso && now - obj.ts < 300000) {
            return obj;
          }
        } catch(_) {}
        return null;
      })();
      
      // 如果本地缓存有效，优先使用；否则检查内存缓存
      if (localCache) {
        dbg('首页排行榜使用本地缓存，确保与日排行榜一致');
        // 从本地缓存提取数据而非直接返回（保持计算逻辑一致）
      } else if (rankingDataCache && (now - lastRankingUpdateTime) < RANKING_CACHE_DURATION) {
        // 如果缓存存在但某个学生的管理员调分已变化（内存对象被修改），需要重新计算。
        // 简单策略：比较 topStudents 中的调分是否与当前 getAdminScoreAdjustment 返回一致。
        const stale = rankingDataCache.topStudents && rankingDataCache.topStudents.some(stu => {
          const curAdj = getAdminScoreAdjustment(stu.name) || 0;
          const cachedAdj = (stu.__442 && typeof stu.__442.adminAdjustment==='number') ? stu.__442.adminAdjustment : 0;
          return curAdj !== cachedAdj; // 发现任一差异则视为过期
        });
        if (!stale) {
          dbg('使用内存缓存的排行榜数据');
          return;
        } else {
          dbg('管理员调分变化导致首页小榜缓存失效，重新计算');
        }
      }
      
      const t0 = performance.now();
      // 骨架屏（首次或未填充时）
      if (!rankingList.__filled) {
        const skeletonRows = Array.from({length:3}).map((_,i)=>`<div class=\"ranking-item ranking-item--skeleton\">\n  <div class=\"ranking-position\">${i+1}</div>\n  <div class=\"ranking-student-info\">\n    <div class=\"ranking-student-name sk-bar\" style=\"width:${40+Math.random()*40}%\"></div>\n    <div class=\"ranking-student-meta sk-bar\" style=\"width:${30+Math.random()*30}%\"></div>\n  </div>\n  <div class=\"ranking-score\">\n    <div class=\"ranking-score-value sk-bar\" style=\"width:50px;height:16px\"></div>\n    <div class=\"ranking-score-label sk-bar\" style=\"width:36px;height:10px\"></div>\n  </div>\n</div>`).join('');
        rankingList.innerHTML = skeletonRows;
      }

  // 周末不展示排行榜，显示说明（使用当前选中的排行榜日期）
  const __today = getActiveLeaderboardDate();
  if (!isWorkday(__today)) {
        rankingList.innerHTML = `
          <div class="ranking-hero" style="margin:0 0 8px;">
            <div class="ranking-hero-sub">周末（周六/周日）不展示排行榜；工作日排行榜窗口：周一/二/四/五 08:00–18:40，周三 08:00–19:10；维度三历史评分参考不包含周六周日，且排除当日无练琴的工作日；当日无练琴则不计分。</div>
          </div>
        `;
        return;
      }

      // 获取所有学生数据并计算排行榜分数（签名缓存）
      if (!window.__scoreCache) window.__scoreCache = new Map();
      const cache = window.__scoreCache;
      const activeDate = getActiveLeaderboardDate();
      const students = [];
      for (const student of Array.from(appState.students.values())) {
        const intervalsMs = getLeaderboardPracticeIntervalsMs(student.name, activeDate);
        const lastLogTs = intervalsMs && intervalsMs.length ? intervalsMs[intervalsMs.length-1].end : 0;
        const slots = getLeaderboardSlotsMinutes(student.name, activeDate) || [];
        const slotSig = slots.map(s=>s.start+'-'+s.end).join('|');
        let practicedMin = 0; if (intervalsMs) { for (const iv of intervalsMs) practicedMin += (iv.end-iv.start)/60000; }
  // 将管理员调分纳入签名（若调整变更即强制重新计算）
  const adminAdj = getAdminScoreAdjustment(student.name) || 0;
  const sig = `${lastLogTs}|${slotSig}|${Math.floor(practicedMin)}|adj:${adminAdj}`;
        let s;
        const c = cache.get(student.name);
        if (c && c.sig === sig) { s = c.s; }
        else {
          s = await computeScore442(student);
          cache.set(student.name, {sig, s});
        }
        students.push({...student, rankingScore: s.total, __442: s});
      }

      // 过滤无有效分数(null/undefined/NaN) 的学生，避免空数据乱跳
      const scoredStudents = students.filter(s=> typeof s.rankingScore === 'number' && !isNaN(s.rankingScore));
      // 若全部无分，直接显示占位
      if(!scoredStudents.length){
        rankingList.innerHTML = `
          <div style="text-align: center; padding: 32px; color: #656d76;">
            <div style="margin-bottom: 8px; font-size:32px;">📊</div>
            <div>今日暂无可计算的排行榜数据</div>
            <div style="margin-top:6px;font-size:12px;opacity:.8;">(没有有效练琴记录或全部被排除)</div>
          </div>`;
        rankingDataCache = { students, topStudents: [], timestamp: now };
        lastRankingUpdateTime = now;
        rankingList.__filled = true;
        return;
      }
      // 按分数排序
      scoredStudents.sort((a, b) => b.rankingScore - a.rankingScore);
      // 只显示前3名
      const topStudents = scoredStudents.slice(0, 3);

      // 生成排行榜HTML
      rankingList.innerHTML = topStudents.map((student, index) => {
        const position = index + 1;
        const meta = appState.studentsMeta.get(student.name) || {};
        const score = student.rankingScore;
        const clickable = (typeof score === 'number' && !isNaN(score));
        return `
          <div class="ranking-item${!clickable?' ranking-item-disabled':''}" ${clickable?`onclick="openStudentDetailFromRanking('${student.name}')"`:''}>
            <div class="ranking-position rank-${position}">${position}</div>
            <div class="ranking-student-info">
              <div class="ranking-student-name">${student.name}</div>
              <div class="ranking-student-meta">${meta.major || '未知专业'} · ${meta.grade || '未知年级'}</div>
            </div>
            <div class="ranking-score">
              <div class="ranking-score-value">${score != null ? score.toFixed(1) : '-'}</div>
              <div class="ranking-score-label">总分</div>
            </div>
          </div>
        `;
      }).join('');

      // 如果没有数据，显示占位内容
      if (topStudents.length === 0) {
        rankingList.innerHTML = `
          <div style="text-align: center; padding: 32px; color: #656d76;">
            <div style="margin-bottom: 8px;">📊</div>
            <div>暂无排行榜数据</div>
          </div>
        `;
      }

      // 自动同步当日排行榜到数据库（异步执行，不阻塞界面）
      if (students.length > 0) {
        syncTodayLeaderboard().catch(e => console.warn('自动同步排行榜失败:', e));
      }
      
      // 更新缓存并同步到本地存储
      rankingDataCache = { students, topStudents, timestamp: now };
      lastRankingUpdateTime = now;
      
      dbg('首页排行榜更新完成（缓存由日排行榜统一管理）');
      
      rankingList.__filled = true;
      const t1 = performance.now();
      dbg('updateRanking ms=', +(t1-t0).toFixed(1));
    }

    // 从排行榜打开学生详情
    function openStudentDetailFromRanking(studentName) {
      console.log('从首页小排行榜进入学生详情:', studentName);
      
      // 从首页小榜进入详情：标记返回到首页
      uiState.previousView = 'home';
      uiState.view = 'detail';
      uiState.selectedStudent = studentName;
      
      console.log('更新后的 uiState:', uiState);
      updateViews();
    }

    function getFilteredStudents() {
      let students = Array.from(appState.students.values());
      
      // 按搜索查询过滤
      if (appState.searchQuery) {
        const query = appState.searchQuery.toLowerCase();
        students = students.filter(student => {
          const meta = appState.studentsMeta.get(student.name) || {};
          return student.name.toLowerCase().includes(query) ||
                 (meta.major && meta.major.toLowerCase().includes(query)) ||
                 (meta.grade && meta.grade.toLowerCase().includes(query));
        });
      }
      
      // 按筛选条件过滤
      switch (appState.currentFilter) {
        case 'practicing':
          students = students.filter(s => s.currentStatus !== 'offline');
          break;
        case 'active-today':
          students = students.filter(s => s.isPresent);
          break;
        case 'violin':
          students = students.filter(s => {
            const meta = appState.studentsMeta.get(s.name) || {};
            return meta.major && meta.major.includes('小提琴');
          });
          break;
        case 'piano':
          students = students.filter(s => {
            const meta = appState.studentsMeta.get(s.name) || {};
            return meta.major && meta.major.includes('钢琴');
          });
          break;
        case 'other':
          students = students.filter(s => {
            const meta = appState.studentsMeta.get(s.name) || {};
            return meta.major && !meta.major.includes('小提琴') && !meta.major.includes('钢琴');
          });
          break;
      }
      
      // 排序：正在练琴的优先，然后按今日总时长降序
      students.sort((a, b) => {
        if (a.currentStatus !== 'offline' && b.currentStatus === 'offline') return -1;
        if (a.currentStatus === 'offline' && b.currentStatus !== 'offline') return 1;
        return (b.todayMinutes.in + b.todayMinutes.out) - (a.todayMinutes.in + a.todayMinutes.out);
      });
      
      return students;
    }

    function createStudentCard(student) {
      const meta = appState.studentsMeta.get(student.name) || {};
      const initials = utils.getStudentInitials(student.name);
      
      const statusInfo = getStatusInfo(student);
      const badges = generateBadges(student);
      
      return `
        <div class="student-card" data-student-name="${student.name}">
          <div class="student-header">
            <div class="student-info">
              <div class="student-avatar">${initials}</div>
              <div class="student-details">
                <h3>${student.name}</h3>
                <div class="student-meta">${meta.major || '未知专业'} · ${meta.grade || '未知年级'}</div>
              </div>
            </div>
            <div class="student-status ${statusInfo.class}">
              <span class="material-icons">${statusInfo.icon}</span>
              ${statusInfo.text}
            </div>
          </div>
          
          <div class="student-body">
            <div class="progress-section">
              <div class="progress-header">
                <span class="progress-label">今日完成度</span>
                <span class="progress-value">${student.achievementRate}%</span>
              </div>
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${Math.min(100, student.achievementRate)}%"></div>
              </div>
            </div>
            
            <div class="stats-grid">
              <div class="stat-item">
                <div class="stat-item-value">${utils.formatDuration(student.todayMinutes.in)}</div>
                <div class="stat-item-label">今日段内时长</div>
              </div>
              <div class="stat-item">
                <div class="stat-item-value">${utils.formatDuration(student.todayMinutes.out)}</div>
                <div class="stat-item-label">今日段外时长</div>
              </div>
              <div class="stat-item">
                <div class="stat-item-value">${student.weekStreak}</div>
                <div class="stat-item-label">连续天数</div>
              </div>
              <div class="stat-item">
                <div class="stat-item-value">${student.totalSessions}</div>
                <div class="stat-item-label">本周练习次数</div>
              </div>
            </div>
            
            <div class="achievement-badges">
              ${badges.join('')}
            </div>
          </div>
        </div>
      `;
    }

    function getStatusInfo(student) {
      switch (student.currentStatus) {
        case 'practicing-in':
          return {
            class: 'practicing-in',
            icon: 'music_note',
            text: '正在练琴（段内）'
          };
        case 'practicing-out':
          return {
            class: 'practicing-out',
            icon: 'music_note',
            text: '正在练琴（段外）'
          };
        default:
          return {
            class: 'offline',
            icon: 'pause_circle',
            text: '未在练琴'
          };
      }
    }

    function generateBadges(student) {
      const badges = [];
      
      if (student.weekStreak >= 7) {
        badges.push('<span class="badge streak">本周全勤</span>');
      } else if (student.weekStreak >= 3) {
        badges.push('<span class="badge streak">连续练习</span>');
      }
      
      if (student.achievementRate >= 100) {
        badges.push('<span class="badge target">目标达成</span>');
      } else if (student.achievementRate >= 80) {
        badges.push('<span class="badge target">接近目标</span>');
      }
      
      const weekTotal = student.weekMinutes.in + student.weekMinutes.out;
      const todayTotal = student.todayMinutes.in + student.todayMinutes.out;
      if (weekTotal > 0 && todayTotal > weekTotal / 7 * 1.5) {
        badges.push('<span class="badge improvement">今日超常</span>');
      }
      
      return badges;
    }

    function openStudentModal(studentName) {
      const student = appState.students.get(studentName);
      if (!student) return;
      
      const meta = appState.studentsMeta.get(studentName) || {};
      
      document.getElementById('modalTitle').textContent = `${studentName} 的练琴数据`;
      
      const modalContent = `
        <div style="margin-bottom: 24px;">
          <h3 style="margin-bottom: 12px; color: var(--on-surface-variant);">基本信息</h3>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">
            <div><strong>专业：</strong>${meta.major || '未知'}</div>
            <div><strong>年级：</strong>${meta.grade || '未知'}</div>
            <div><strong>学籍号：</strong><span style="opacity:.6">（字段已下线）</span></div>
          </div>
        </div>
        
        <div style="margin-bottom: 24px;">
          <h3 style="margin-bottom: 12px; color: var(--on-surface-variant);">当前状态</h3>
          <div style="padding: 16px; background: #f8f9fa; border-radius: 8px;">
            ${generateCurrentStatusHTML(student)}
          </div>
        </div>
        
        <div style="margin-bottom: 24px;">
          <h3 style="margin-bottom: 12px; color: var(--on-surface-variant);">今日练习统计</h3>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px;">
            <div style="text-align: center; padding: 16px; background: #f8f9fa; border-radius: 8px;">
              <div style="font-size: 24px; font-weight: 700; color: var(--primary); margin-bottom: 8px;">
                ${utils.formatDuration(student.todayMinutes.in)}
              </div>
              <div style="color: var(--on-surface-variant);">段内练习时长</div>
            </div>
            <div style="text-align: center; padding: 16px; background: #f8f9fa; border-radius: 8px;">
              <div style="font-size: 24px; font-weight: 700; color: var(--warning); margin-bottom: 8px;">
                ${utils.formatDuration(student.todayMinutes.out)}
              </div>
              <div style="color: var(--on-surface-variant);">段外练习时长</div>
            </div>
          </div>
        </div>
        
        <div style="margin-bottom: 24px;">
          <h3 style="margin-bottom: 12px; color: var(--on-surface-variant);">本周数据</h3>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px;">
            <div style="text-align: center; padding: 16px; background: #f8f9fa; border-radius: 8px;">
              <div style="font-size: 20px; font-weight: 700; color: var(--primary); margin-bottom: 8px;">
                ${utils.formatDuration(student.weekMinutes.in)}
              </div>
              <div style="color: var(--on-surface-variant);">本周段内总时长</div>
            </div>
            <div style="text-align: center; padding: 16px; background: #f8f9fa; border-radius: 8px;">
              <div style="font-size: 20px; font-weight: 700; color: var(--warning); margin-bottom: 8px;">
                ${utils.formatDuration(student.weekMinutes.out)}
              </div>
              <div style="color: var(--on-surface-variant);">本周段外总时长</div>
            </div>
          </div>
        </div>
        
        <div>
          <h3 style="margin-bottom: 12px; color: var(--on-surface-variant);">成就徽章</h3>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            ${generateBadges(student).join('')}
          </div>
        </div>
      `;
      
      document.getElementById('modalContent').innerHTML = modalContent;
      document.getElementById('modalOverlay').style.display = 'flex';
    }

    function generateCurrentStatusHTML(student) {
      if (student.currentStatus === 'offline') {
        return '<div style="color: var(--on-surface-variant);">当前未在练琴</div>';
      }
      
      const statusText = student.currentStatus === 'practicing-in' ? '时间段内练琴' : '时间段外练琴';
      const roomText = student.currentRoom ? ` · ${student.currentRoom}` : '';
      const timeText = student.currentStartTime ? ` · 开始于 ${utils.formatTime(student.currentStartTime)}` : '';
      
      return `
        <div style="display: flex; align-items: center; gap: 12px;">
          <span class="material-icons" style="color: var(--${student.currentStatus === 'practicing-in' ? 'success' : 'warning'});">music_note</span>
          <div>
            <div style="font-weight: 500;">${statusText}</div>
            <div style="color: var(--on-surface-variant); font-size: 14px;">${roomText}${timeText}</div>
          </div>
        </div>
      `;
    }

    function closeModal() {
      document.getElementById('modalOverlay').style.display = 'none';
    }

    // ==== 事件监听器 ====
    function setupEventListeners() {
      // 搜索功能
      const searchInput = document.getElementById('searchInput');
      searchInput.addEventListener('input', (e) => {
        appState.searchQuery = e.target.value.trim();
        renderStudentCards();
      });
      
      // 筛选功能
      document.querySelectorAll('.filter-chip').forEach(chip => {
        chip.addEventListener('click', () => {
          document.querySelector('.filter-chip.active')?.classList.remove('active');
          chip.classList.add('active');
          appState.currentFilter = chip.dataset.filter;
          renderStudentCards();
        });
      });
      
      // 模态框关闭
      document.getElementById('modalOverlay').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          closeModal();
        }
      });
    }

    // ==== 实时更新优化 ====
    
    // 页面可见性管理 - 提前定义，避免未初始化错误
    let isPageVisible = !document.hidden;
    let lastVisibilityChange = Date.now();
    
    // 连接状态管理
    let realtimeReconnectAttempts = 0;
    let realtimeReconnectTimer = null;
    const MAX_RECONNECT_ATTEMPTS = 5;
    
    // WebSocket心跳检测系统
    class RealtimeHealthMonitor {
      constructor() {
        this.heartbeatInterval = null;
        this.heartbeatFrequency = 30000; // 默认30秒心跳
        this.lastHeartbeat = Date.now();
        this.connectionQuality = 'good'; // good | fair | poor
        this.pingHistory = []; // 记录ping延迟历史
        this.maxPingHistory = 10;
        this.isMonitoring = false;
        this.heartbeatTimeout = null;
        this.failedHeartbeats = 0;
        this.maxFailedHeartbeats = 3;
      }
      
      startMonitoring() {
        if (this.isMonitoring) return;
        this.isMonitoring = true;
        this.scheduleHeartbeat();
        dbg('心跳监控已启动');
      }
      
      stopMonitoring() {
        this.isMonitoring = false;
        if (this.heartbeatInterval) {
          clearInterval(this.heartbeatInterval);
          this.heartbeatInterval = null;
        }
        if (this.heartbeatTimeout) {
          clearTimeout(this.heartbeatTimeout);
          this.heartbeatTimeout = null;
        }
        dbg('心跳监控已停止');
      }
      
      scheduleHeartbeat() {
        if (!this.isMonitoring) return;
        
        this.heartbeatInterval = setInterval(() => {
          this.performHeartbeat();
        }, this.heartbeatFrequency);
      }
      
      async performHeartbeat() {
        if (!realtimeChannel || !isPageVisible) return;
        
        const startTime = Date.now();
        
        try {
          // 使用简单的presence事件作为心跳
          const heartbeatPromise = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              reject(new Error('心跳超时'));
            }, 10000); // 10秒超时
            
            // 发送心跳并监听响应
            realtimeChannel.track({ 
              heartbeat: true, 
              timestamp: startTime,
              client_id: 'practice-tracker-' + Math.random().toString(36).substr(2, 9)
            });
            
            // 监听一次性的presence事件响应
            const unsubscribe = realtimeChannel.on('presence', { event: 'sync' }, () => {
              clearTimeout(timeout);
              unsubscribe();
              resolve();
            });
          });
          
          await heartbeatPromise;
          
          const pingTime = Date.now() - startTime;
          this.recordPing(pingTime);
          this.lastHeartbeat = Date.now();
          this.failedHeartbeats = 0;
          
          dbg(`心跳成功: ${pingTime}ms, 连接质量: ${this.connectionQuality}`);
          
        } catch (error) {
          this.failedHeartbeats++;
          dbg(`心跳失败 (${this.failedHeartbeats}/${this.maxFailedHeartbeats}): ${error.message}`);
          
          if (this.failedHeartbeats >= this.maxFailedHeartbeats) {
            dbg('连续心跳失败，触发重连');
            this.onConnectionUnhealthy();
          }
        }
      }
      
      recordPing(pingTime) {
        this.pingHistory.push(pingTime);
        if (this.pingHistory.length > this.maxPingHistory) {
          this.pingHistory.shift();
        }
        
        // 计算连接质量
        const avgPing = this.pingHistory.reduce((a, b) => a + b, 0) / this.pingHistory.length;
        
        if (avgPing < 200) {
          this.connectionQuality = 'good';
          this.heartbeatFrequency = 30000; // 30秒
        } else if (avgPing < 1000) {
          this.connectionQuality = 'fair';
          this.heartbeatFrequency = 20000; // 20秒
        } else {
          this.connectionQuality = 'poor';
          this.heartbeatFrequency = 15000; // 15秒，更频繁检测
        }
      }
      
      onConnectionUnhealthy() {
        dbg('检测到连接不健康，尝试重连');
        this.stopMonitoring();
        setConnectionStatus('syncing', '连接异常，重连中...');
        // 延迟调用以确保函数已定义
        setTimeout(() => {
          if (typeof attemptRealtimeReconnect === 'function') {
            attemptRealtimeReconnect();
          }
        }, 100);
      }
      
      getStatus() {
        const timeSinceLastHeartbeat = Date.now() - this.lastHeartbeat;
        return {
          quality: this.connectionQuality,
          lastHeartbeat: this.lastHeartbeat,
          timeSinceLastHeartbeat,
          avgPing: this.pingHistory.length > 0 ? 
            Math.round(this.pingHistory.reduce((a, b) => a + b, 0) / this.pingHistory.length) : 0,
          isHealthy: this.failedHeartbeats < this.maxFailedHeartbeats && timeSinceLastHeartbeat < 60000
        };
      }
    }
    
    // 创建心跳监控实例
    const healthMonitor = new RealtimeHealthMonitor();
    
    // 智能节流：不同类型数据使用不同的同步策略
    const realtimeThrottlers = {
      rooms: throttle(() => {
        dbg('同步: 房间状态变更');
        fetchDataWithDiff('rooms');
      }, 2000), // 2秒节流，房间状态更重要
      
      logs: throttle(() => {
        dbg('同步: 练琴记录变更');
        fetchDataWithDiff('practice_logs');
      }, 8000), // 8秒节流，练琴记录可以稍微延迟
      
      metadata: throttle(() => {
        dbg('同步: 学生信息/时段变更');
        fetchDataWithDiff(['student_database', 'student_time_slots']);
      }, 10000), // 10秒节流，元数据变更频率低
    };
    
    // 性能监控
    let updateCounter = 0;
    let lastUpdateLog = 0;
    
    // 页面可见性监听
    document.addEventListener('visibilitychange', () => {
      isPageVisible = !document.hidden;
      lastVisibilityChange = Date.now();
      
      // 动态调整缓存时间
      RANKING_CACHE_DURATION = isPageVisible ? 30000 : 120000;
      
      if (isPageVisible) {
        dbg('页面重新可见，检查连接状态');
        // 页面重新可见时，适度延迟后检查连接
        setTimeout(() => {
          if (realtimeChannel && !isConnected) {
            dbg('页面可见但连接断开，尝试重连');
            attemptRealtimeReconnect();
          }
        }, 1000);
      } else {
        dbg('页面隐藏，降低更新频率');
      }
    });
    
    // 智能重连机制
    function attemptRealtimeReconnect() {
      if (realtimeReconnectTimer) return; // 避免重复重连
      
      realtimeReconnectAttempts++;
      if (realtimeReconnectAttempts > MAX_RECONNECT_ATTEMPTS) {
        dbg('重连次数超限，停止自动重连');
        setConnectionStatus('offline', '连接失败');
        return;
      }
      
      const delay = Math.min(30000, 2000 * Math.pow(2, realtimeReconnectAttempts - 1));
      dbg(`第${realtimeReconnectAttempts}次重连尝试，${delay/1000}秒后开始...`);
      
      realtimeReconnectTimer = setTimeout(() => {
        realtimeReconnectTimer = null;
        setupRealtime();
      }, delay);
    }
    
    function setupRealtime() {
      if (!isConnected) return;
      
      // 清理现有连接
      if (realtimeChannel) {
        realtimeChannel.unsubscribe();
        realtimeChannel = null;
      }
      
      realtimeChannel = supabaseClient.channel('practice-tracker-optimized')
        .on('postgres_changes', { 
          event: '*', 
          schema: 'public', 
          table: 'rooms' 
        }, (payload) => {
          updateCounter++;
          const now = Date.now();
          if (now - lastUpdateLog > 15000) { // 每15秒记录一次频率
            dbg(`实时更新频率: ${updateCounter} 次/15s`);
            updateCounter = 0;
            lastUpdateLog = now;
          }
          
          // 页面隐藏时降低同步频率
          if (!isPageVisible && (now - lastVisibilityChange) < 30000) {
            dbg('页面隐藏中，跳过房间更新');
            return;
          }
          
          realtimeThrottlers.rooms();
        })
        .on('postgres_changes', { 
          event: '*', 
          schema: 'public', 
          table: 'practice_logs' 
        }, (payload) => {
          // 页面隐藏时，练琴记录同步延迟更长
          if (!isPageVisible) {
            dbg('页面隐藏中，延迟练琴记录同步');
            setTimeout(() => {
              if (isPageVisible) realtimeThrottlers.logs();
            }, 30000);
            return;
          }
          
          realtimeThrottlers.logs();
        })
        .on('postgres_changes', { 
          event: '*', 
          schema: 'public', 
          table: 'student_database' 
        }, () => {
          realtimeThrottlers.metadata();
        })
        .on('postgres_changes', { 
          event: '*', 
          schema: 'public', 
          table: 'student_time_slots' 
        }, () => {
          realtimeThrottlers.metadata();
        })
        .subscribe(status => {
          dbg(`Realtime连接状态: ${status}`);
          
          if (status === 'SUBSCRIBED') {
            setConnectionStatus('online', '实时连接');
            realtimeReconnectAttempts = 0; // 重置重连计数
            
            if (realtimeReconnectTimer) {
              clearTimeout(realtimeReconnectTimer);
              realtimeReconnectTimer = null;
            }
            
            // 连接成功后启动心跳监控
            healthMonitor.startMonitoring();
            
            // 更新连接状态显示，包含连接质量信息
            setTimeout(() => {
              const healthStatus = healthMonitor.getStatus();
              const qualityText = healthStatus.quality === 'good' ? '优秀' : 
                                healthStatus.quality === 'fair' ? '良好' : '较差';
              setConnectionStatus('online', `实时连接 (${qualityText})`);
            }, 2000); // 等待2秒后显示连接质量
            
          } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status === 'CLOSED') {
            setConnectionStatus('syncing', '连接中...');
            
            // 停止心跳监控
            healthMonitor.stopMonitoring();
            
            // 智能重连：检查页面状态和网络状况
            if (isPageVisible && navigator.onLine) {
              setTimeout(() => attemptRealtimeReconnect(), 1000);
            } else {
              dbg('页面隐藏或网络离线，暂停重连');
            }
          }
        });
    }    // ==== 应用初始化 ====
    async function initializeApp() {
      dbg('=== 应用初始化开始 ===');
      const startTime = performance.now();
      
      // 立即显示基础界面
      updateViews();
      setupHomeInteractions();
      
  // （已删除）初始化iOS滑动返回手势调用
      
      try {
        // 显示加载状态
        setConnectionStatus('connecting', '正在连接...');
        
        // 不再依赖顶部交互
        dbg('初始化 Supabase...');
        const connected = await initializeSupabase();
        dbg('Supabase 连接结果:', connected);
        
        if (connected) {
          setConnectionStatus('syncing', '加载数据...');
          dbg('开始获取数据...');
          await fetchAllData();
          dbg('加载管理员调分数据...');
          try {
            await loadAdminScoresFromCloud();
          } catch (error) {
            dbg('管理员调分数据加载失败，将使用本地数据:', error);
          }
          dbg('设置实时监听...');
          setupRealtime();
          dbg('启动定时同步...');
          startDailySyncScheduler();
          setConnectionStatus('online', '已连接');
        } else {
          setConnectionStatus('offline', '连接失败');
        }
        
        const endTime = performance.now();
        dbg(`应用初始化完成，耗时: ${(endTime - startTime).toFixed(2)}ms`);
      } catch (error) {
        console.error('应用初始化失败:', error);
        setConnectionStatus('offline', '初始化失败');
      }
    }

    // 启动应用
    document.addEventListener('DOMContentLoaded', initializeApp);

    // 全局函数供HTML调用
    window.closeModal = closeModal;
    window.openStudentDetail = openStudentDetail;
  window.openRankingView = openRankingView;
  window.openStudentDetailFromRankingFull = openStudentDetailFromRankingFull;

    // ========== 当日排行榜自动同步功能 ==========
    
    // 安全检查：验证日期是否允许同步
    function isSafeDateForSync(dateString) {
      const today = new Date();
      const todayISO = utils.toIsoDate(today);
      
      // 只允许同步今天或昨天的数据（考虑时区和延迟情况）
      const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
      const yesterdayISO = utils.toIsoDate(yesterday);
      
      return dateString === todayISO || dateString === yesterdayISO;
    }

    async function syncTodayLeaderboard(targetDate = null) {
      try {
        if (!supabaseClient) {
          console.warn('Supabase 未初始化，无法同步排行榜');
          return false;
        }

        const activeDate = targetDate || getActiveLeaderboardDate();
        if (!isWorkday(activeDate)) {
          console.log('周末不同步排行榜');
          return true;
        }

        const iso = utils.toIsoDate(activeDate);
        
        // 安全检查：确保只同步允许的日期
        if (!isSafeDateForSync(iso)) {
          console.warn(`🚫 安全限制：只能同步今天或昨天的数据，拒绝同步日期 ${iso}`);
          return false;
        }
        
        console.log(`开始同步日期 ${iso} 的排行榜数据...`);
        const dayStartMs = toDayStart(activeDate);
        const weekday0to6 = activeDate.getDay();
        
        // 获取所有有时间表的学生
        const allStudents = Array.from(appState.students.values());
        if (!allStudents.length) {
          console.warn('没有学生数据，跳过同步');
          return false;
        }

        const rows = [];
        const validScores = [];

        // 为每个学生计算分数
        for (const student of allStudents) {
          try {
            const key = utils.normalizeStudentName(student.name);
            const slotsMin = getLeaderboardSlotsMinutes(student.name, activeDate);
            const intervalsMs = getLeaderboardPracticeIntervalsMs(student.name, activeDate);

            if (!intervalsMs || intervalsMs.length === 0) {
              // 当天无练琴：写入 no_practice 标记
              rows.push({
                date: iso,
                student_key: key,
                d1: 0,
                d2: 0,
                d3: 0,
                total: 0,
                rule_version: RULE_VERSION,
                window: __leaderboardWindowJSON(weekday0to6),
                no_practice: true,
                updated_at: new Date().toISOString()
              });
              continue;
            }

            // 计算各维度分数
            const d1 = computeDim1Score(slotsMin, intervalsMs, dayStartMs);
            const d2 = computeDim2Score(slotsMin, intervalsMs, dayStartMs, weekday0to6);
            const d3 = await computeDim3ScoreCloud(key, activeDate, d1.score + d2.score);
            let totalScoreRaw = d1.score + d2.score + d3.score;
            if (d1.breakdown && d1.breakdown.gotFullBonus) {
              totalScoreRaw += (d1.breakdown.fullBonusAward || 0); // 动态满勤加分
            }
            const totalScore = +(Math.max(0, Math.min(100, totalScoreRaw))).toFixed(2);

            const row = {
              date: iso,
              student_key: key,
              d1: d1.score || 0,
              d2: d2.score || 0,
              d3: d3.score || 0,
              total: totalScore,
              rule_version: RULE_VERSION,
              window: __leaderboardWindowJSON(weekday0to6),
              no_practice: false,
              updated_at: new Date().toISOString()
            };

            rows.push(row);
            if (totalScore > 0) validScores.push(row);
          } catch (e) {
            console.error(`计算学生 ${student.name} 分数失败:`, e);
          }
        }

        // 计算排名（仅 total > 0 的参与排名）
        validScores.sort((a, b) => b.total - a.total);
        let rank = 1;
        for (let i = 0; i < validScores.length; i++) {
          if (i > 0 && validScores[i].total < validScores[i - 1].total) {
            rank = i + 1;
          }
          validScores[i].rank = rank;
        }

        // 将排名写回所有行
        const keyToRank = new Map(validScores.map(r => [r.student_key, r.rank]));
        rows.forEach(r => {
          if (keyToRank.has(r.student_key)) {
            r.rank = keyToRank.get(r.student_key);
          }
        });

        // 批量同步到数据库（带安全检查）
        const BATCH = 200;
        let successCount = 0;
        
        // 二次安全检查：确保所有记录都是指定日期
        const filteredRows = rows.filter(row => {
          if (row.date !== iso) {
            console.error(`安全警告：发现异常日期记录 ${row.date}，预期 ${iso}，已过滤`);
            return false;
          }
          return true;
        });
        
        if (filteredRows.length !== rows.length) {
          console.warn(`过滤了 ${rows.length - filteredRows.length} 条异常日期记录`);
        }
        
        for (let i = 0; i < filteredRows.length; i += BATCH) {
          const slice = filteredRows.slice(i, i + BATCH);
          
          // 使用更安全的 upsert：明确指定冲突解决和约束条件
          const { error } = await supabaseClient
            .from('leaderboard_daily')
            .upsert(slice, { 
              onConflict: 'date,student_key',
              ignoreDuplicates: false // 确保更新现有记录而不是忽略
            });
          
          if (error) {
            console.error(`同步排行榜失败 (批次 ${Math.floor(i/BATCH) + 1}):`, error);
          } else {
            successCount += slice.length;
          }
        }

        const syncSummary = {
          date: iso,
          totalRecords: filteredRows.length,
          successCount,
          failedCount: filteredRows.length - successCount,
          validRankings: validScores.length,
          timestamp: new Date().toISOString()
        };
        
        console.log(`✅ ${iso} 排行榜同步完成:`, syncSummary);
        console.log(`📊 数据详情: ${successCount}/${filteredRows.length} 条记录成功, ${validScores.length} 人有效排名`);
        
        // 记录同步到本地存储（可选，用于调试）
        try {
          // 安全写入：QuotaExceededError 时自动裁剪并降级
          function safeSetSyncLog(summary){
            let logArr = [];
            try { logArr = JSON.parse(localStorage.getItem('leaderboard_sync_log')||'[]'); } catch { logArr = []; }
            logArr.push(summary);
            // 只留最近 14 条（时间跨度仍限定 7 天）
            const cutoff = Date.now() - 7*24*60*60*1000;
            logArr = logArr.filter(x => { const t=Date.parse(x.timestamp||''); return !isNaN(t) && t>cutoff; });
            if (logArr.length>14) logArr = logArr.slice(logArr.length-14);
            const data = JSON.stringify(logArr);
            try {
              localStorage.setItem('leaderboard_sync_log', data);
            } catch(err){
              if (err && err.name === 'QuotaExceededError') {
                // 尝试再压缩：丢弃最旧 50% 再写一次
                logArr = logArr.slice(Math.floor(logArr.length/2));
                try { localStorage.setItem('leaderboard_sync_log', JSON.stringify(logArr)); }
                catch(inner){ console.warn('同步日志记录失败(二次):', inner); }
              } else {
                console.warn('同步日志记录失败(写入):', err);
              }
            }
          }
          safeSetSyncLog(syncSummary);
        } catch (e) {
          console.warn('同步日志记录失败:', e);
        }
        
        return true;
      } catch (e) {
        console.error('同步当日排行榜失败:', e);
        return false;
      }
    }

    // 手动同步今日排行榜
    async function manualSyncTodayLeaderboard() {
      try {
        if (!ENABLE_MANUAL_SYNC) {
          console.warn('手动同步已被禁用（ENABLE_MANUAL_SYNC=false）');
          try { showToast('手动同步已禁用'); } catch {}
          return;
        }
        const activeDate = getActiveLeaderboardDate();
        const iso = utils.toIsoDate(activeDate);
        
        // 确认同步的是今天的数据
        const confirmed = confirm(`确认同步 ${iso} 的排行榜数据到云端？\n\n注意：这只会影响指定日期的数据，不会修改历史记录。`);
        if (!confirmed) {
          showToast('同步已取消');
          return;
        }
        
        showToast('开始同步今日排行榜...');
        const success = await syncTodayLeaderboard();
        if (success) {
          showToast(`${iso} 排行榜同步成功！`);
        } else {
          showToast('今日排行榜同步失败，请检查控制台');
        }
      } catch (e) {
        showToast('同步失败: ' + (e?.message || e));
        console.error('手动同步失败:', e);
      }
    }

    // 定时同步机制优化
    let dailySyncTimer = null;
    let syncRetryCount = 0;
    const MAX_SYNC_RETRIES = 3;

    function startDailySyncScheduler() {
      // 清除之前的定时器
      if (dailySyncTimer) {
        clearTimeout(dailySyncTimer);
        dailySyncTimer = null;
      }

      function scheduleNextSync() {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        
        // 优化：只在工作日进行自动同步，且检查页面活跃度
        const isWorkday = now.getDay() >= 1 && now.getDay() <= 5;
        
        // 设置每天晚上 22:00 自动同步
        const syncTime = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 22, 0, 0);
        
        // 如果当前时间已经过了今天的同步时间，则安排明天的同步
        if (now >= syncTime) {
          syncTime.setDate(syncTime.getDate() + 1);
        }
        
        // 如果是周末，跳到下周一
        while (syncTime.getDay() === 0 || syncTime.getDay() === 6) {
          syncTime.setDate(syncTime.getDate() + 1);
        }

        const msUntilSync = syncTime.getTime() - now.getTime();
        console.log(`下次自动同步: ${syncTime.toLocaleString()}, 距离 ${Math.round(msUntilSync / 1000 / 60)} 分钟${!isWorkday ? ' (跳过周末)' : ''}`);

        dailySyncTimer = setTimeout(async () => {
          // 检查页面是否活跃和网络状态
          if (!navigator.onLine) {
            console.log('网络离线，延迟同步');
            setTimeout(() => scheduleNextSync(), 300000); // 5分钟后重试
            return;
          }
          
          // 页面长时间隐藏时跳过同步
          if (!isPageVisible && (Date.now() - lastVisibilityChange) > 3600000) { // 1小时
            console.log('页面长时间隐藏，跳过同步');
            scheduleNextSync();
            return;
          }
          
          try {
            const syncDate = new Date();
            const iso = utils.toIsoDate(syncDate);
            console.log(`开始定时同步 ${iso} 排行榜...`);
            
            const success = await syncTodayLeaderboard();
            console.log(`定时同步 ${iso} ${success ? '成功' : '失败'}`);
            
            if (success) {
              console.log(`✅ ${iso} 排行榜已成功备份到云端`);
              syncRetryCount = 0; // 重置重试计数
            } else {
              throw new Error('同步返回失败状态');
            }
          } catch (e) {
            console.error('定时同步出错:', e);
            syncRetryCount++;
            
            // 失败重试机制
            if (syncRetryCount <= MAX_SYNC_RETRIES) {
              const retryDelay = 300000 * syncRetryCount; // 5分钟 * 重试次数
              console.log(`同步失败，${retryDelay/60000}分钟后重试 (${syncRetryCount}/${MAX_SYNC_RETRIES})`);
              setTimeout(() => scheduleNextSync(), retryDelay);
              return;
            } else {
              console.error('同步重试次数已达上限，放弃本次同步');
              syncRetryCount = 0;
            }
          }
          
          // 安排下一次同步
          scheduleNextSync();
        }, msUntilSync);
      }

      scheduleNextSync();
    }

    // 停止定时同步
    function stopDailySyncScheduler() {
      if (dailySyncTimer) {
        clearTimeout(dailySyncTimer);
        dailySyncTimer = null;
        console.log('定时同步已停止');
      }
    }

    // 查看同步历史（调试用）
    function getSyncHistory() {
      try {
        const syncLog = JSON.parse(localStorage.getItem('leaderboard_sync_log') || '[]');
        console.table(syncLog);
        return syncLog;
      } catch (e) {
        console.error('获取同步历史失败:', e);
        return [];
      }
    }

    // 清除同步历史
    function clearSyncHistory() {
      try {
        localStorage.removeItem('leaderboard_sync_log');
        console.log('同步历史已清除');
        return true;
      } catch (e) {
        console.error('清除同步历史失败:', e);
        return false;
      }
    }

  // ========== Admin 按钮移除 ==========
  // 按需求移除“重算历史442”和“同步今日”两个浮动按钮，不再注入任何管理端按钮。
  // 保留 recalcAllLeaderboardHistory442 与 syncTodayLeaderboard 供后台/开发者手动调用。

    async function recalcAllLeaderboardHistory442(){
      const startedAt = Date.now();
      try{ showToast('开始重算历史 4-4-2…'); }catch{}
      if(!supabaseClient){
        throw new Error('Supabase 未初始化，无法写回 leaderboard_daily');
      }

      // 1) 取“已有数据历史”的日期集合：来自 leaderboard_daily
      let dates = await __fetchAllLeaderboardDates(supabaseClient);
      // 回退：若 leaderboard_daily 为空，则从 practice_logs 提取历史日期集合
      if(!dates.length){
        dates = await __fetchAllDatesFromPracticeLogs(supabaseClient);
        if(!dates.length){ throw new Error('practice_logs 中也没有可重算的日期'); }
      }

      // 2) 学生键集合：来自 leaderboard_daily 现有键或本地 timeSlots
      let studentKeys = await __fetchAllLeaderboardStudentKeys(supabaseClient);
      if(!studentKeys.length){
        try{ studentKeys = Array.from(appState.timeSlots.keys()); }catch{}
      }
      // 回退：仍为空则从 practice_logs 提取学生集合
      if(!studentKeys.length){
        studentKeys = await __fetchAllStudentKeysFromPracticeLogs(supabaseClient);
      }
      if(!studentKeys.length){ throw new Error('未找到任何 student_key'); }

      // 预取每个日期的“昨日排行映射”（供 D3 使用）
      const rankCache = new Map(); // isoDate -> Map(student_key -> rank)
      for(const d of dates){
        const prev = previousWorkday(new Date(d));
        const map = await __fetchRankMapForDate(supabaseClient, utils.toIsoDate(prev));
        if(map) rankCache.set(utils.toIsoDate(prev), map);
      }

      // d12 缓存：isoDate -> Map(student_key -> d1+d2)
      const d12Cache = new Map();

      // 主循环：逐日重算
      const BATCH = 200;
      let total = 0, failed = 0;
      for(let i=0;i<dates.length;i++){
        const iso = dates[i];
        const date = new Date(iso+'T00:00:00');
        if(!isWorkday(date)) { // 周末直接跳过（无排行榜窗口）
          continue;
        }
        const dayStartMs = toDayStart(date);
        const weekday0to6 = date.getDay();
        const prevKey = utils.toIsoDate(previousWorkday(date));
        let prevMap = rankCache.get(prevKey) || await __fetchRankMapForDate(supabaseClient, prevKey) || null;
        if(!prevMap || prevMap.size === 0){
          // 用 d12 缓存构造前一工作日的名次映射（当 leaderboard_daily 尚未有历史时）
          prevMap = __buildRankMapFromD12(prevKey, d12Cache, studentKeys);
        }

        // 为当日一次性拉取全体练琴日志并构建每人区间（避免逐人查询）
        const intervalsByStudent = await __fetchPracticeIntervalsByStudentForDate(supabaseClient, date);

        // 准备当日 d12 缓存容器
        if(!d12Cache.has(iso)) d12Cache.set(iso, new Map());
        const d12TodayMap = d12Cache.get(iso);

        const rows = [];
        const studentKeysNorm = studentKeys.map(k=>utils.normalizeStudentName(k));
        for(let idx=0; idx<studentKeys.length; idx++){
          const key = studentKeys[idx];
          try{
            const name = utils.normalizeStudentName(key);
            const slotsMin = getLeaderboardSlotsMinutes(name, date);
            // 历史重算：优先使用数据库日志构建的区间
            const intervalsMs = intervalsByStudent.get(name) || [];
            if(!intervalsMs.length){
              // 当天无练琴：写入 no_practice 标记与 0 分
              rows.push({ date: iso, student_key: key, d1: 0, d2: 0, d3: 0, total: 0, rule_version: RULE_VERSION, window: __leaderboardWindowJSON(weekday0to6), no_practice: true, updated_at: new Date().toISOString() });
              continue;
            }
            const d1res = computeDim1Score(slotsMin, intervalsMs, dayStartMs);
            const d1 = d1res.score || 0;
            const d2 = computeDim2Score(slotsMin, intervalsMs, dayStartMs, weekday0to6).score || 0;
            // 更新 d12 缓存（供 D3 历史窗口、反霸榜计算使用）
            d12TodayMap.set(name, (d1 + d2));
            // 历史 D3：基于 d12 缓存计算（不依赖 appState.practiceLogs）
            const d3 = __computeDim3Historical(name, date, d1 + d2, prevMap || new Map(), d12Cache, studentKeysNorm).score || 0;
            let totalScoreRaw = d1 + d2 + d3;
            if (d1res.breakdown && d1res.breakdown.gotFullBonus) {
              totalScoreRaw += (d1res.breakdown.fullBonusAward || 0);
            }
            const totalScore = +(Math.max(0, Math.min(100, totalScoreRaw))).toFixed(2);
            rows.push({
              date: iso, student_key: key,
              d1, d2, d3, total: totalScore,
              rule_version: RULE_VERSION,
              window: __leaderboardWindowJSON(weekday0to6),
              no_practice: false,
              updated_at: new Date().toISOString()
            });
          }catch(e){ failed++; }
        }

        // 计算当日排名（仅 total > 0 的行参与排名；并列同名次）
        const withScore = rows.filter(r => (r.total ?? 0) > 0).sort((a,b)=> (b.total - a.total));
        let rank = 1;
        for(let j=0;j<withScore.length;j++){
          if(j>0 && withScore[j].total < withScore[j-1].total) rank = j+1;
          withScore[j].rank = rank;
        }
        // 将计算出的 rank 写回 rows 中对应项
        const keyToRank = new Map(withScore.map(r=>[`${r.student_key}`, r.rank]));
        rows.forEach(r => { if(keyToRank.has(`${r.student_key}`)) r.rank = keyToRank.get(`${r.student_key}`); });

        // 批量 upsert 到 leaderboard_daily
        for(let p=0;p<rows.length;p+=BATCH){
          const slice = rows.slice(p, p+BATCH);
          const { error } = await supabaseClient.from('leaderboard_daily').upsert(slice, { onConflict: 'date,student_key' });
          if(error){ failed += slice.length; console.error('upsert error', iso, error); }
          else total += slice.length;
        }
        try{ showToast(`${iso} 完成：有练琴 ${withScore.length} 人 · 本日写入 ${rows.length} 条 · 累计 ${total} · 错误 ${failed}`); }catch{}
      }
      const secs = ((Date.now()-startedAt)/1000).toFixed(1);
      try{ showToast(`完成：${total} 条，错误 ${failed}，耗时 ${secs}s`); }catch{}
    }

    // ===== 获取学生442评分历史数据 =====
    async function fetchStudent442History(studentKey, days = 14) {
      if (!supabaseClient) {
        console.warn('Supabase 未初始化，无法获取历史数据');
        return [];
      }
      
      try {
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - days);
        
        const startISO = utils.toIsoDate(startDate);
        const endISO = utils.toIsoDate(endDate);
        
        const { data, error } = await supabaseClient
          .from('leaderboard_daily')
          .select('date, d1, d2, d3, total, rank, no_practice')
          .eq('student_key', studentKey)
          .gte('date', startISO)
          .lte('date', endISO)
          .order('date', { ascending: true });
          
        if (error) {
          console.error('获取学生历史数据失败:', error);
          return [];
        }
        
        return data || [];
      } catch (e) {
        console.error('fetchStudent442History 异常:', e);
        return [];
      }
    }

    // ===== 渲染442评分趋势图 =====
  async function render442TrendChart(containerSelector, studentName) {
      const container = document.querySelector(containerSelector);
      if (!container) {
        console.warn('趋势图容器未找到:', containerSelector);
        return;
      }

      try {
        // 获取历史数据
        const studentKey = utils.normalizeStudentName(studentName);
        const historyData = await fetchStudent442History(studentKey, 14);
        
        // 获取当天实时数据（使用排行榜窗口期逻辑）
        const today = getActiveLeaderboardDate();
        const todayISO = utils.toIsoDate(today);
        let todayScore = null;
        
        if (isWorkday(today)) {
          const student = appState.students.get(studentName);
          if (student) {
            const scoreResult = await computeScore442(student);
            if (scoreResult && scoreResult.total !== null) {
              todayScore = {
                date: todayISO,
                total: scoreResult.total,
                d1: scoreResult.d1,
                d2: scoreResult.d2,
                d3: scoreResult.d3,
                isToday: true
              };
            }
          }
        }

        // 合并历史数据和当天数据
        const allData = [...historyData];
        if (todayScore && !historyData.some(d => d.date === todayISO)) {
          allData.push(todayScore);
        }

        // 过滤掉周末和无练琴的数据，并规范数值类型
        const validData = allData.filter(d => {
          const date = new Date(d.date);
          return isWorkday(date) && !d.no_practice && d.total > 0;
        }).map(d => ({
          date: d.date,
          total: Number(d.total),
          rank: d.rank,
          isToday: !!d.isToday
        }));

        if (validData.length === 0) {
          container.innerHTML = '<div class="trend-empty">暂无有效的评分数据</div>';
          return;
        }

        // 绘制图表
        renderTrendSVG(container, validData);
        
      } catch (e) {
        console.error('渲染442趋势图失败:', e);
        container.innerHTML = '<div class="trend-empty">数据加载失败</div>';
      }
    }

    // ===== SVG趋势图绘制 =====
    function renderTrendSVG(container, data) {
      const containerWidth = container.clientWidth || container.getBoundingClientRect().width || 600;
      const height = 200;
      const margin = { top: 20, right: 20, bottom: 40, left: 40 };
      // 动态宽度：让点与点之间更大间距
      const MIN_GAP = 54; // 每个点的最小水平间距（像素）
      const desiredWidth = data.length > 1 
        ? Math.max(containerWidth, margin.left + margin.right + (data.length - 1) * MIN_GAP)
        : containerWidth;
      const width = desiredWidth;
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;
      const parseISODate = (s) => new Date(`${s}T00:00:00`);

      // 创建SVG
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'trend-chart');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

      // 数据处理 - 修复单点数据的范围计算
  const scores = data.map(d => d.total).filter(Number.isFinite);
  const maxScore = Math.max(...scores, 100);
  let minScore = Math.max(Math.min(...scores) - 5, 0);
  let scoreRange = maxScore - minScore;
  
  // 处理单点数据或所有数据相同的情况
  if (scoreRange === 0 || data.length === 1) {
    const centerScore = scores[0] || 50;
    minScore = Math.max(centerScore - 10, 0);
    scoreRange = Math.min(centerScore + 10, 100) - minScore;
    if (scoreRange === 0) scoreRange = 20; // 最小范围
  }

      // 坐标计算函数 - 修复单点数据的边界问题
      const getX = (index) => {
        if (data.length === 1) {
          // 单个数据点时，居中显示
          return margin.left + chartWidth / 2;
        }
        return margin.left + (index / (data.length - 1)) * chartWidth;
      };
      const getY = (score) => {
        if (scoreRange === 0) {
          // 单个数据点且无变化时，居中显示
          return margin.top + chartHeight / 2;
        }
        return margin.top + (1 - (score - minScore) / scoreRange) * chartHeight;
      };

      // 绘制网格线
      const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      for (let i = 0; i <= 4; i++) {
        const y = margin.top + (i / 4) * chartHeight;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('class', 'trend-grid-line');
        line.setAttribute('x1', margin.left);
        line.setAttribute('y1', y);
        line.setAttribute('x2', margin.left + chartWidth);
        line.setAttribute('y2', y);
        gridGroup.appendChild(line);

        // Y轴标签
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('class', 'trend-value-label');
        label.setAttribute('x', margin.left - 5);
        label.setAttribute('y', y);
        label.setAttribute('text-anchor', 'end');
        label.setAttribute('dominant-baseline', 'middle');
        const labelValue = minScore + (4-i) * scoreRange / 4;
        label.textContent = Math.round(labelValue).toString();
        gridGroup.appendChild(label);
      }
      svg.appendChild(gridGroup);

      // 绘制坐标轴
      const axisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      xAxis.setAttribute('class', 'trend-axis');
      xAxis.setAttribute('x1', margin.left);
      xAxis.setAttribute('y1', margin.top + chartHeight);
      xAxis.setAttribute('x2', margin.left + chartWidth);
      xAxis.setAttribute('y2', margin.top + chartHeight);
      axisGroup.appendChild(xAxis);

      const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      yAxis.setAttribute('class', 'trend-axis');
      yAxis.setAttribute('x1', margin.left);
      yAxis.setAttribute('y1', margin.top);
      yAxis.setAttribute('x2', margin.left);
      yAxis.setAttribute('y2', margin.top + chartHeight);
      axisGroup.appendChild(yAxis);
      svg.appendChild(axisGroup);

      // 绘制趋势线
      if (data.length > 1) {
        const pathData = data.map((d, i) => {
          const x = getX(i);
          const y = getY(d.total);
          return i === 0 ? `M ${x} ${y}` : `L ${x} ${y}`;
        }).join(' ');

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', 'trend-line');
        path.setAttribute('d', pathData);
        svg.appendChild(path);
      }

      // 绘制数据点和标签
      const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      data.forEach((d, i) => {
        const x = getX(i);
        const y = getY(d.total);
        
        // 数据点
        const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        point.setAttribute('class', `trend-point ${d.isToday ? 'today' : ''}`);
        point.setAttribute('cx', x);
        point.setAttribute('cy', y);
        point.setAttribute('r', d.isToday ? '5' : '4'); // 今日数据点稍大一些
        point.setAttribute('data-date', d.date);
        point.setAttribute('data-score', d.total.toFixed(1));
        
        // 鼠标事件
        point.addEventListener('mouseenter', (e) => {
          showTrendTooltip(e, d);
          // 放大圆点
          e.target.setAttribute('r', d.isToday ? '7' : '6');
        });
        point.addEventListener('mouseleave', (e) => {
          hideTrendTooltip(e);
          // 恢复圆点大小
          e.target.setAttribute('r', d.isToday ? '5' : '4');
        });
        
        pointsGroup.appendChild(point);
        
        // 调试：确保圆点已创建
        dbg(`趋势图数据点 ${i + 1}: 位置(${x.toFixed(1)}, ${y.toFixed(1)}), 半径=${point.getAttribute('r')}, 分数=${d.total}`);

        // 迷你标签：上下两行（分数 / 名次）并进行避线与边缘防裁剪
        const mini = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        mini.setAttribute('class', `trend-point-mini ${d.isToday ? 'today' : ''}`);
        // 根据局部斜率决定标签放在点的上方还是下方，避免被趋势线遮挡
        const prevY = (i > 0) ? getY(data[i-1].total) : null;
        const nextY = (i < data.length-1) ? getY(data[i+1].total) : null;
        // 计算局部平均斜率（正值向下走）
        const slope = (() => {
          const parts = [];
          if (prevY !== null) parts.push(y - prevY);
          if (nextY !== null) parts.push(nextY - y);
          if (!parts.length) return 0;
          return parts.reduce((a,b)=>a+b,0)/parts.length;
        })();
        // 当线往下走（slope>0）时将标签放在点的上方；往上走则放在下方
  const baseDy = slope > 0 ? -12 : 16; // 下方需要更大间距给副标题
  
  // 处理单点数据的特殊情况
  let xClamped, textAnchor;
  if (data.length === 1) {
    // 单个数据点时，标签居中对齐
    xClamped = x;
    textAnchor = 'middle';
  } else {
    // 多点数据时，首尾点做水平偏移，避免碰到左右边界
    const edgePad = 10;
    xClamped = Math.max(margin.left + edgePad, Math.min(margin.left + chartWidth - edgePad, x));
    // 对首尾点设置不同对齐，进一步避免裁剪
    if (i === 0) textAnchor = 'start';
    else if (i === data.length - 1) textAnchor = 'end';
    else textAnchor = 'middle';
  }
  
  mini.setAttribute('text-anchor', textAnchor);
  
  const yRaw = y + baseDy;
  const yTop = margin.top + 10; // 顶部留白
  const yBottom = margin.top + chartHeight - 14; // 底部留白给 X 轴
  const yClamped = Math.max(yTop, Math.min(yBottom, yRaw));
  mini.setAttribute('x', xClamped);
  mini.setAttribute('y', yClamped);
        
        const t1 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
        t1.setAttribute('x', xClamped);
        t1.setAttribute('dy', 0);
        t1.textContent = `${d.total.toFixed(0)}分`;
        mini.appendChild(t1);
        
        if (d.rank && Number(d.rank) > 0) {
          const t2 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
          t2.setAttribute('class', 'sub');
          t2.setAttribute('x', xClamped);
          t2.setAttribute('dy', 11);
          t2.textContent = `No.${Number(d.rank)}`;
          mini.appendChild(t2);
        }
        pointsGroup.appendChild(mini);

        // X轴日期标签（只显示部分，避免拥挤）
        if (data.length === 1 || i % Math.max(1, Math.floor(data.length / 6)) === 0 || i === data.length - 1) {
          const dateLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          dateLabel.setAttribute('class', 'trend-label');
          
          // 处理单点数据的日期标签位置
          let xLabel;
          if (data.length === 1) {
            xLabel = x; // 单点时居中显示
            dateLabel.setAttribute('text-anchor', 'middle');
          } else {
            // 多点数据时，日期标签同样做边缘防裁剪
            xLabel = Math.max(margin.left + 10, Math.min(margin.left + chartWidth - 10, x));
            if (i === 0) dateLabel.setAttribute('text-anchor', 'start');
            else if (i === data.length - 1) dateLabel.setAttribute('text-anchor', 'end');
            else dateLabel.setAttribute('text-anchor', 'middle');
          }
          
          dateLabel.setAttribute('x', xLabel);
          dateLabel.setAttribute('y', margin.top + chartHeight + 15);
          const dt = parseISODate(d.date);
          // 使用合法的本地化格式选项，避免 RangeError
          const dateStr = dt.toLocaleDateString('zh-CN', { month: 'numeric', day: 'numeric' });
          dateLabel.textContent = dateStr.replace(/\//g, '/');
          pointsGroup.appendChild(dateLabel);
        }
      });
      svg.appendChild(pointsGroup);

      // 清空容器并添加SVG
      container.innerHTML = '';
      container.appendChild(svg);

      // 创建tooltip
      const tooltip = document.createElement('div');
      tooltip.className = 'trend-tooltip';
      container.appendChild(tooltip);
      container._tooltip = tooltip;
      
      // 调试：图表渲染完成
      dbg(`442趋势图渲染完成: ${data.length} 个数据点，SVG尺寸 ${width}x${height}`);
      dbg('所有数据点:', data.map((d, i) => `${i+1}. ${d.date}: ${d.total}分${d.isToday ? ' (今日)' : ''}`));
    }

    // ===== 趋势图交互 =====
    function showTrendTooltip(event, data) {
      const container = event.target.closest('.trend-container');
      if (!container || !container._tooltip) return;

      const tooltip = container._tooltip;
      const date = new Date(`${data.date}T00:00:00`).toLocaleDateString('zh-CN', { 
        month: 'long', 
        day: 'numeric',
        weekday: 'short'
      });
      
      tooltip.innerHTML = `
        <div><strong>${date}${data.isToday ? ' (今日)' : ''}</strong></div>
        <div>总分: ${data.total.toFixed(1)}分</div>
        ${data.rank ? `<div>排名: 第${data.rank}名</div>` : ''}
      `;
      
      const rect = event.target.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      
      tooltip.style.left = `${rect.left - containerRect.left - tooltip.offsetWidth / 2}px`;
      tooltip.style.top = `${rect.top - containerRect.top - tooltip.offsetHeight - 8}px`;
      tooltip.classList.add('show');
    }

    function hideTrendTooltip(event) {
      const container = event.target.closest('.trend-container');
      if (!container || !container._tooltip) return;
      
      container._tooltip.classList.remove('show');
    }

    // ===== 辅助：读取历史范围与 rank =====
    async function __fetchAllLeaderboardDates(sb){
      const out = new Set();
      const page = 2000;
      for(let from=0; from<100000; from+=page){
        const to = from + page - 1;
        const { data, error } = await sb.from('leaderboard_daily').select('date').order('date', { ascending: true }).range(from, to);
        if(error) { console.warn('fetch dates error', error); break; }
        if(!data?.length) break;
        for(const r of data){ out.add(r.date); }
        if(data.length < page) break;
      }
      return Array.from(out).sort();
    }

    async function __fetchAllLeaderboardStudentKeys(sb){
      const out = new Set();
      const page = 2000;
      for(let from=0; from<100000; from+=page){
        const to = from + page - 1;
        const { data, error } = await sb.from('leaderboard_daily').select('student_key').order('student_key', { ascending: true }).range(from, to);
        if(error) { console.warn('fetch student keys error', error); break; }
        if(!data?.length) break;
        for(const r of data){ out.add(r.student_key); }
        if(data.length < page) break;
      }
      return Array.from(out).sort();
    }

    async function __fetchRankMapForDate(sb, isoDate){
      try{
        const { data, error } = await sb.from('leaderboard_daily').select('student_key, rank').eq('date', isoDate);
        if(error) return null;
        const m = new Map();
        for(const r of (data||[])){
          if(typeof r.rank === 'number') m.set(r.student_key, r.rank);
        }
        return m;
      }catch{ return null; }
    }

    // ===== 辅助：历史重算专用（从 DB 拉取日志并构建区间 + 历史 D3） =====
    async function __fetchAllDatesFromPracticeLogs(sb){
      // 扫描 practice_logs，提取日期集合（分页以避免上限）
      const out = new Set();
      const page = 2000;
      for(let from=0; from<100000; from+=page){
        const to = from + page - 1;
        const { data, error } = await sb
          .from('practice_logs')
          .select('timestamp')
          .order('timestamp', { ascending: true })
          .range(from, to);
        if(error){ console.warn('fetch practice_logs dates error', error); break; }
        if(!data?.length) break;
        for(const r of data){
          const d = new Date(r.timestamp);
          const iso = utils.toIsoDate(d);
          out.add(iso);
        }
        if(data.length < page) break;
      }
      // 只保留工作日，并排序
      const arr = Array.from(out).sort();
      return arr.filter(iso => isWorkday(new Date(iso+'T00:00:00')));
    }

    async function __fetchAllStudentKeysFromPracticeLogs(sb){
      const out = new Set();
      const page = 2000;
      for(let from=0; from<100000; from+=page){
        const to = from + page - 1;
        const { data, error } = await sb
          .from('practice_logs')
          .select('student_name, student, studentName')
          .order('timestamp', { ascending: true })
          .range(from, to);
        if(error){ console.warn('fetch practice_logs students error', error); break; }
        if(!data?.length) break;
        for(const r of data){
          const nmRaw = r.student_name || r.student || r.studentName || '';
          const nm = utils.normalizeStudentName(nmRaw);
          if(nm) out.add(nm);
        }
        if(data.length < page) break;
      }
      return Array.from(out).sort();
    }

    function __buildRankMapFromD12(isoDate, d12Cache, studentKeys){
      const m = new Map();
      const d12Map = d12Cache.get(isoDate);
      if(!d12Map) return m;
      // 根据 d12 值降序排序并赋排名（同分并列处理：相同分可赋相同 rank，也可稳定排序；这里采用稳定排名）
      const list = [];
      for(const name of studentKeys){
        const v = d12Map.get(name);
        if(v != null) list.push({ name, v });
      }
      list.sort((a,b)=> b.v - a.v);
      let rank = 1;
      for(let i=0;i<list.length;i++){
        if(i>0 && list[i].v < list[i-1].v) rank = i+1;
        m.set(list[i].name, rank);
      }
      return m;
    }
    async function __fetchPracticeIntervalsByStudentForDate(sb, date){
      const start = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      const end = new Date(date.getFullYear(), date.getMonth(), date.getDate()+1);
      const { data, error } = await sb
        .from('practice_logs')
        .select('student_name, student, action, timestamp, session_start, session_end, start_time, end_time, actual_start_time, end_reason, room_name')
        .gte('timestamp', start.toISOString())
        .lt('timestamp', end.toISOString())
        .order('timestamp', { ascending: true });
      if(error){ console.warn('fetch logs error', error); return new Map(); }
      const byName = new Map(); // normName -> array of logs
      for(const row of (data||[])){
        const nmRaw = row.student_name || row.student || row.studentName || '';
        const nm = utils.normalizeStudentName(nmRaw);
        if(!nm) continue;
        if(!byName.has(nm)) byName.set(nm, []);
        byName.get(nm).push(row);
      }
      const win = getLeaderboardWindow(date);
      if(!win) return new Map();
      const dayStartMs = toDayStart(date);
      const res = new Map(); // normName -> [ {start,end} in ms clipped to window ]
      for(const [nm, logs] of byName.entries()){
        const intervals = __buildIntervalsFromLogs(logs);
        // 裁剪到排行榜窗口
        const clipped = [];
        for(const iv of intervals){
          const c = clipIntervalMsToWindow(iv, dayStartMs, win);
          if(c) clipped.push(c);
        }
        // 合并重叠区间，减少重复
        const merged = mergeIntervalsMs(clipped);
        res.set(nm, merged);
      }
      return res;
    }

    function __buildIntervalsFromLogs(logs){
      const arr = (logs||[]).slice().sort((a,b)=> new Date(a.timestamp) - new Date(b.timestamp));
      const out = [];
      const used = new Set(); // 使用过的日志（基于引用索引）

      // Pass A：优先使用 session_start + (timestamp 或 session_end) 直接构造，避免只有 clear 时丢失
      for(let i=0;i<arr.length;i++){
        const row = arr[i];
        const sessStartStr = row.session_start || row.actual_start_time || row.start_time;
        const sessEndStr = row.session_end || row.end_time; // 可选
        const tsStr = row.timestamp;
        const hasStart = !!sessStartStr;
        const hasEnd = !!(sessEndStr || tsStr);
        const action = String(row.action||'').toLowerCase();
        const isExitLike = action === 'clear' || action === 'exit';
        // clear/exit 且具备 session_start 与 终点（timestamp 或 session_end），可直接构造
        if(hasStart && hasEnd && (isExitLike || action === 'renew')){
          const s = new Date(sessStartStr).getTime();
          const e = new Date(sessEndStr || tsStr).getTime();
          if(Number.isFinite(s) && Number.isFinite(e) && e > s){
            out.push({ start: s, end: e });
            used.add(i);
          }
        }
      }

      // Pass B：对剩余日志用 assign/enter 与 clear/exit 配对（兜底）
      let curStart = null;
      for(let i=0;i<arr.length;i++){
        if(used.has(i)) continue;
        const log = arr[i];
        const action = String(log.action||'').toLowerCase();
        const isEnter = action === 'enter' || action === 'assign';
        const isExit = action === 'exit' || action === 'clear';
        if(isEnter){ if(curStart == null) curStart = new Date(log.timestamp).getTime(); }
        else if(isExit){
          if(curStart != null){
            const end = new Date(log.timestamp).getTime();
            if(end > curStart) out.push({ start: curStart, end });
            curStart = null;
          }
        }
      }

      // 合并相邻或重叠，先排序
      out.sort((a,b)=> a.start - b.start);
      const merged = [];
      for(const iv of out){
        if(!merged.length || iv.start > merged[merged.length-1].end){ merged.push({ ...iv }); }
        else { merged[merged.length-1].end = Math.max(merged[merged.length-1].end, iv.end); }
      }
      return merged;
    }

    function __computeDim3Historical(studentName, activeDate, todayD12, prevDayRankMap, d12Cache, studentKeys){
      if (!isWorkday(activeDate)) {
        return { score: 0, breakdown: { weekend: true, disabled: true } };
      }
  // 1) 昨日排行加分（已细化为逐名次线性插值：1名=3分→10名=1分，其余=0）
      let sRank = 0, sProgress = 0, sConsistency = 0, sFresh = 0, antiBonus = 0;
      const pr = prevDayRankMap?.get?.(studentName);
  sRank = computeRankPoints(pr);

      // 2) 进步与稳定：基于 d12 缓存（近7工作日 vs 前7工作日，仅统计 >0 的有效日）
      const endWorkday = nearestWorkdayOnOrBefore(activeDate);
  const WN = p3.progress.windowSize || 5;
  const curDates = getLastNWorkdayDates(endWorkday, WN);
      const prevWindowEnd = previousWorkday(curDates[0]);
  const prevDates = getLastNWorkdayDates(prevWindowEnd, WN);
      const getD12 = (d) => {
        const k = utils.toIsoDate(d);
        const m = d12Cache.get(k);
        const v = m?.get?.(studentName) ?? 0;
        return Number.isFinite(v) ? v : 0;
      };
      const cur7 = curDates.map(getD12);
      const prev7 = prevDates.map(getD12);
      const curActiveArr = cur7.filter(v => v > 0);
      const prevActiveArr = prev7.filter(v => v > 0);
      const sum = a => a.reduce((x,y)=>x+y,0);
      const sCur = sum(curActiveArr), sPrev = sum(prevActiveArr);
      const p3 = LB442_PARAMS.dim3;
      const curActiveDays = curActiveArr.length;
      const prevActiveDays = prevActiveArr.length;
      const passActiveDaysGate = (curActiveDays >= p3.progress.minActiveDaysPerWindow) && (prevActiveDays >= p3.progress.minActiveDaysPerWindow);
      if (passActiveDaysGate && sPrev >= p3.progress.minPrevTotal && sCur > sPrev) {
        const W = p3.progress.windowSize || 5;
        const avgCur = sCur / W;
        const avgPrev = sPrev / W;
        const denomAvg = Math.max(avgPrev, p3.progress.denomFloor / W);
        const appliedProgressRatio = Math.min(p3.progress.maxRatio, Math.max(0, (avgCur - avgPrev) / denomAvg));
        const ratioPct = appliedProgressRatio / p3.progress.maxRatio;
        sProgress = Math.min(6, +(ratioPct * 6).toFixed(2));
      }
      // 稳定性：仅基于有效工作日的标准差
      if (curActiveDays > 0) {
        const mean = sCur / curActiveDays;
        const variance = curActiveArr.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / curActiveDays;
        const std = Math.sqrt(variance);
        const passStabilityGate = (curActiveDays >= 3) || (sCur >= 40);
        if (passStabilityGate) {
          sConsistency = computeConsistencyPoints(std);
        }
      }

      // 3) 今日活跃度仅对“今天”生效，历史回算时记 0（computeDim3Score 原逻辑亦如此）
      // sFresh = 0;

      // 4) 反霸榜机制：基于 d12Cache 推导“某日登顶者”（以 D1+D2 排名）
      const prevWork = previousWorkday(activeDate);
      const consec = __getConsecutiveTopWorkdaysUpToFromD12(prevWork, studentName, d12Cache, studentKeys);
      const daysSince = __getWorkdaysSinceLastTopFromD12(activeDate, studentName, d12Cache, studentKeys);
      let freshnessMultiplier = 1;
      if (consec >= p3.antiDomination.decayAfterDays) {
        const excess = consec - p3.antiDomination.decayAfterDays;
        freshnessMultiplier = Math.pow(p3.antiDomination.decayRate, Math.max(0, excess));
        if (consec >= p3.antiDomination.maxConsecutiveDays) {
          freshnessMultiplier *= 0.5;
        }
      } else if (daysSince != null && daysSince >= p3.antiDomination.breakPeriod) {
        antiBonus = p3.antiDomination.freshBreakBonus;
      }

      // 汇总：基础为 rank + progress + consistency，再乘 freshnessMultiplier，并加 antiBonus
      const base = sRank + sProgress + sConsistency;
      let score = Math.round(base * freshnessMultiplier + antiBonus);
      score = Math.max(0, Math.min(score, 20));
      return { score, breakdown: { sRank, sProgress, sConsistency, sFresh, antiBonus, freshnessMultiplier } };
    }

    function __getTopNameForDateFromD12(date, d12Cache, studentKeys){
      const iso = utils.toIsoDate(date);
      const m = d12Cache.get(iso);
      if(!m) return null;
      let bestName = null, best = -Infinity;
      for(const name of studentKeys){
        const v = m.get(name);
        if(v == null) continue;
        if(v > best){ best = v; bestName = name; }
      }
      return bestName;
    }

    function __getConsecutiveTopWorkdaysUpToFromD12(date, studentName, d12Cache, studentKeys){
      let cnt = 0;
      let d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      for(let i=0;i<14;i++){
        if(!isWorkday(d)) { d.setDate(d.getDate()-1); continue; }
        const top = __getTopNameForDateFromD12(d, d12Cache, studentKeys);
        if(top === studentName){ cnt++; } else { break; }
        d.setDate(d.getDate()-1);
      }
      return cnt;
    }

    function __getWorkdaysSinceLastTopFromD12(date, studentName, d12Cache, studentKeys){
      let days = 0;
      let d = new Date(date.getFullYear(), date.getMonth(), date.getDate()-1);
      for(let i=0;i<30;i++){
        if(!isWorkday(d)) { d.setDate(d.getDate()-1); continue; }
        const top = __getTopNameForDateFromD12(d, d12Cache, studentKeys);
        if(top === studentName) return days;
        days++;
        d.setDate(d.getDate()-1);
      }
      return null; // 未找到
    }

    function __leaderboardWindowJSON(weekday){
      if([1,2,4,5].includes(weekday)) return { start: '08:00', end: '18:40' };
      if(weekday===3) return { start: '08:00', end: '19:10' };
      return null;
    }
    
    // 添加连接质量调试面板
    function createConnectionDebugPanel() {
      const panel = document.createElement('div');
      panel.id = 'connectionDebugPanel';
      panel.style.cssText = `
        position: fixed;
        top: 60px;
        right: 10px;
        width: 280px;
        background: rgba(255,255,255,0.95);
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 12px;
        font-size: 12px;
        z-index: 1000;
        display: none;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        font-family: 'SF Pro Text', system-ui, sans-serif;
      `;
      
      panel.innerHTML = `
        <div style="font-weight: 600; margin-bottom: 8px; color: #333;">连接质量监控</div>
        <div id="debugConnectionStatus">状态: 检测中...</div>
        <div id="debugHeartbeat">心跳: --</div>
        <div id="debugPing">延迟: --</div>
        <div id="debugDataVersions">数据版本: --</div>
        <div style="margin-top: 8px; font-size: 11px; color: #666;">
          <button onclick="healthMonitor.performHeartbeat()" style="padding:2px 6px;font-size:11px;">手动心跳</button>
          <button onclick="fetchDataWithDiff(['rooms'])" style="padding:2px 6px;font-size:11px;margin-left:4px;">测试同步</button>
        </div>
      `;
      
      document.body.appendChild(panel);
      
      // 定期更新调试信息
      setInterval(() => {
        if (panel.style.display === 'none') return;
        
        const status = healthMonitor.getStatus();
        const statusElement = document.getElementById('debugConnectionStatus');
        const heartbeatElement = document.getElementById('debugHeartbeat');
        const pingElement = document.getElementById('debugPing');
        const versionsElement = document.getElementById('debugDataVersions');
        
        if (statusElement) {
          const healthIcon = status.isHealthy ? '🟢' : '🔴';
          const qualityColor = status.quality === 'good' ? '#22c55e' : 
                              status.quality === 'fair' ? '#f59e0b' : '#ef4444';
          statusElement.innerHTML = `状态: ${healthIcon} <span style="color:${qualityColor}">${status.quality}</span>`;
        }
        
        if (heartbeatElement) {
          const timeSince = Math.round(status.timeSinceLastHeartbeat / 1000);
          heartbeatElement.textContent = `心跳: ${timeSince}s前`;
        }
        
        if (pingElement) {
          pingElement.textContent = `延迟: ${status.avgPing}ms (平均)`;
        }
        
        if (versionsElement) {
          const versions = Object.entries(dataVersions)
            .map(([table, info]) => `${table}: ${info.count}条`)
            .join(', ');
          versionsElement.textContent = `数据: ${versions}`;
        }
      }, 2000);
    }
    
    // 添加键盘快捷键显示调试面板
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'D') {
        const panel = document.getElementById('connectionDebugPanel');
        if (!panel) {
          createConnectionDebugPanel();
        } else {
          panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        e.preventDefault();
      }
    });
    
    // 初始化防抖函数（在所有函数定义后）
    debouncedUpdateRanking = createSmartDebounce(updateRanking, 2000, 10000);
    debouncedRenderHomeBins = createSmartDebounce(renderHomeBins, 500, 5000);
    
    // 加载所有脚本后启动应用
    initializeApp();
  </script>
</body>
</html>

  <!-- 轻量提示容器 -->
  <div id="lbToast" class="lb-toast" role="status" aria-live="polite" aria-atomic="true" hidden></div>
