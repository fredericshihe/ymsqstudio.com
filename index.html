<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1.0" />
	<title>青岛耶胡迪梅纽因学校 琴房管理系统 · 全新</title>
	<style>
		:root {
			--bg:#0e1116; --bg-alt:#161b22; --surface:#1f252d; --surface-alt:#242b35; --outline:#2f3844; --outline-hover:#3d4957; --divider:#212a33;
			--accent:#4c8dff; --accent-hover:#6aa1ff; --danger:#ff5f56; --warn:#ffb347; --ok:#3fbf6b; --text:#e6ecf3; --text-dim:#9aa7b4; --focus:0 0 0 2px rgba(76,141,255,.45);
			--radius-sm:6px; --radius:12px; --radius-lg:18px; --transition:.18s cubic-bezier(.4,0,.2,1);
			--card-min-h:150px; --grid-gap:16px; --shadow:0 4px 14px -6px rgba(0,0,0,.55);
			font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,'Noto Sans',sans-serif; color:var(--text);
		}

	.sl-btn {
		display:inline-flex;
		align-items:center;
		justify-content:center;
		padding:8px 14px;
		font-size:13px;
		font-weight:600;
		line-height:1;
		text-align:center;
		border:1px solid;
		border-radius:6px;
		cursor:pointer;
		transition:all 0.2s ease;
		text-decoration:none;
		white-space:nowrap;
		letter-spacing:.3px;
		min-height:32px;
	}

		.sl-btn:hover {
			transform: translateY(-1px);
			box-shadow: 0 2px 6px rgba(0,0,0,0.1);
		}

		.sl-btn:active {
			transform: translateY(0);
			box-shadow: 0 1px 3px rgba(0,0,0,0.1);
		}

		.sl-btn:disabled {
			opacity: 0.6;
			cursor: not-allowed;
			transform: none !important;
			box-shadow: none !important;
		}

		/* 主要按钮 - 蓝色 */
		.sl-btn-primary {
			background: #2563eb;
			border-color: #1d4ed8;
			color: #ffffff;
		}

		.sl-btn-primary:hover {
			background: #1d4ed8;
			border-color: #1e40af;
		}

		/* 成功按钮 - 绿色 */
		.sl-btn-success {
			background: #16a34a;
			border-color: #15803d;
			color: #ffffff;
		}

		.sl-btn-success:hover {
			background: #15803d;
			border-color: #166534;
		}

		/* 危险按钮 - 红色 */
		.sl-btn-danger {
			background: #dc2626;
			border-color: #b91c1c;
			color: #ffffff;
		}

		.sl-btn-danger:hover {
			background: #b91c1c;
			border-color: #991b1b;
		}

		/* 次要按钮 - 灰色 */
		.sl-btn-secondary {
			background: #f1f5f9;
			border-color: #cbd5e1;
			color: #475569;
		}

		.sl-btn-secondary:hover {
			background: #e2e8f0;
			border-color: #94a3b8;
			color: #334155;
		}

		/* 强调按钮 - 深灰色 */
		.sl-btn-accent {
			background: #475569;
			border-color: #334155;
			color: #ffffff;
		}

		.sl-btn-accent:hover {
			background: #334155;
			border-color: #1e293b;
		}

		/* 轮廓按钮 - 透明背景 */
		.sl-btn-outline {
			background: transparent;
			border-color: #64748b;
			color: #475569;
		}

		.sl-btn-outline:hover {
			background: #f8fafc;
			border-color: #475569;
			color: #334155;
		}

		/* 小型按钮 */
		.sl-btn-sm {
			padding: 6px 10px;
			font-size: 12px;
			min-height: 28px;
		}

		/* 迷你按钮（用于列表项） */
		.sl-btn-mini {
			padding: 4px 8px;
			font-size: 11px;
			font-weight: 500;
			min-height: 24px;
			border-radius: 4px;
		}

		/* 输入框样式 */
		.sl-input {
			padding: 8px 12px;
			border: 1px solid #cbd5e1;
			border-radius: 6px;
			color: #1a1a1a;
			background: #ffffff;
			font-size: 13px;
			transition: all 0.2s ease;
		}

		.sl-input:focus {
			outline: none;
			border-color: #2563eb;
			box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
		}

		.sl-input::placeholder {
			color: #9ca3af;
		}

		/* 警告样式按钮 */
		.sl-btn-warning {
			background: #f59e0b;
			border-color: #d97706;
			color: #ffffff;
		}

		.sl-btn-warning:hover {
			background: #d97706;
			border-color: #b45309;
		}

		/* 学生库特定样式调整 */
		#studentLibraryPanel .sl-btn {
			font-weight: 500;
			letter-spacing: 0.2px;
		}

		#studentLibraryPanel .sl-btn:focus {
			outline: none;
			box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.5);
		}

		/* 学生列表行样式 */
		.sl-row {
			transition: all 0.2s ease;
			position: relative;
			z-index: 1;
		}

		.sl-row:hover {
			background: #f8fafc !important;
			border-color: #cbd5e1 !important;
			transform: translateY(-1px);
			box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			z-index: 10;
		}

		/* 按钮组间距优化 */
		.sl-row .sl-btn + .sl-btn {
			margin-left: 4px;
		}
		* {box-sizing:border-box;}
		body {margin:0; background:linear-gradient(180deg,#0d1014,#11161d); min-height:100vh; display:flex; flex-direction:column;}
		header {padding:18px 26px 10px; display:flex; flex-wrap:wrap; align-items:flex-start; gap:16px;}
		header h1 {margin:0;font-size:20px;font-weight:600;letter-spacing:.5px;background:linear-gradient(90deg,#91bdff,#c3daff);background-clip:text;-webkit-background-clip:text;color:transparent;}
		header .subtitle {margin:0 0 0 4px;font-size:14px;font-weight:400;color:var(--text-dim);letter-spacing:.3px;align-self:flex-end;padding-bottom:2px;}
		.toolbar {display:flex;flex-wrap:wrap;align-items:center;gap:10px;margin-left:auto;}
		.sync-status {display:flex;align-items:center;gap:6px;font-size:12px;color:var(--text-dim);padding:6px 10px;border-radius:var(--radius-sm);background:var(--surface-alt);}
		.sync-dot {width:8px;height:8px;border-radius:50%;background:var(--text-dim);transition:var(--transition);}
		.sync-dot.connected {background:var(--ok);box-shadow:0 0 0 2px rgba(34,197,94,.3);}
		.sync-dot.error {background:var(--danger);box-shadow:0 0 0 2px rgba(239,68,68,.3);}
		.sync-dot.connecting {background:var(--warn);animation:pulse 1.5s infinite;}
		@keyframes pulse {0%,100%{opacity:1}50%{opacity:.5}}
		button {cursor:pointer; border:1px solid var(--outline); background:var(--surface-alt); color:var(--text-dim); padding:8px 14px; font-size:13px; border-radius:var(--radius-sm); display:inline-flex; gap:6px; align-items:center; line-height:1; transition:var(--transition);}
		button:hover {border-color:var(--outline-hover); color:var(--text);} button.primary {background:var(--accent); border-color:var(--accent); color:#fff;} button.primary:hover{background:var(--accent-hover);} button.danger{background:var(--danger);border-color:var(--danger);color:#fff;} button.danger:hover{filter:brightness(1.08);} button.ghost{background:transparent;}
		input[type=text],input[type=search]{background:var(--surface);border:1px solid var(--outline);border-radius:var(--radius-sm);padding:8px 12px;color:var(--text);font-size:13px;min-width:200px;}
		input:focus{outline:none; box-shadow:var(--focus); border-color:var(--accent);} select {background:var(--surface); border:1px solid var(--outline); color:var(--text); padding:7px 10px; border-radius:var(--radius-sm); font-size:13px;} select:focus{outline:none; box-shadow:var(--focus); border-color:var(--accent);} 
		main {flex:1; display:flex; padding:0 26px 36px; gap:26px; align-items:flex-start;}
		.panel {background:var(--surface); border:1px solid var(--outline); border-radius:var(--radius-lg); padding:18px 18px 20px; width:100%; display:flex; flex-direction:column; gap:18px; box-shadow:var(--shadow); position:relative;}
		/* 旧浮动编辑按钮样式已移除；编辑按钮现在与楼层过滤同行显示 */
		.panel-header {display:flex; align-items:center; gap:14px;}
		.panel-header h2 {margin:0;font-size:16px;font-weight:600;letter-spacing:.5px;color:var(--text);} .panel-header .badge{background:var(--surface-alt);padding:4px 8px;font-size:11px;border-radius:var(--radius-sm);color:var(--text-dim);} 
		.divider{height:1px;background:var(--divider);margin:0;}
		.filters {display:flex;flex-wrap:wrap;gap:8px;}
		.filters button {padding:6px 12px;font-size:12px;border-radius:999px;background:var(--surface-alt);} .filters button[data-active='1']{background:var(--accent);color:#fff;border-color:var(--accent);} .filters button:hover{border-color:var(--outline-hover);} 
		.grid {display:grid; gap:var(--grid-gap); grid-template-columns:repeat(auto-fill,minmax(180px,1fr));}
		@media (min-width:1250px){ .grid{grid-template-columns:repeat(5,1fr);} }
		.room-card {position:relative; background:linear-gradient(150deg,#232b35,#1b2129); border:1px solid var(--outline); border-radius:var(--radius); padding:12px 12px 10px; display:flex; flex-direction:column; gap:6px; min-height:var(--card-min-h); cursor:pointer; transition:var(--transition); overflow:hidden;}
		.room-card:hover {border-color:var(--outline-hover); transform:translateY(-3px);} 
		.room-card[data-status='occupied']{
			background:linear-gradient(135deg,#2a4158 0%,#1d3245 40%,#16252f 100%); 
			border:1px solid #4a90e2; 
			box-shadow:
				0 0 0 1px rgba(74,144,226,0.4),
				0 2px 12px rgba(74,144,226,0.15),
				0 6px 25px rgba(74,144,226,0.08),
				inset 0 1px 0 rgba(255,255,255,0.05);
			position:relative;
		}
		.room-card[data-status='occupied']:hover{
			border-color:#5fa3ff;
			box-shadow:
				0 0 0 1px rgba(95,163,255,0.5),
				0 3px 16px rgba(74,144,226,0.25),
				0 8px 35px rgba(74,144,226,0.12),
				inset 0 1px 0 rgba(255,255,255,0.08);
			transform:translateY(-4px);
		}

		.room-card[data-status='preparing']{background:linear-gradient(160deg,#3d2a19,#2a1e0f); border:2px solid #f39c12; box-shadow:0 0 15px rgba(243,156,18,0.3); animation:preparing-pulse 2s infinite;} 
		.room-card[data-status='overtime']{
			background:linear-gradient(135deg,#4a2728 0%,#3d1f20 40%,#2a1415 100%); 
			border:1px solid #ff4757; 
			box-shadow:
				0 0 0 1px rgba(255,71,87,0.4),
				0 2px 12px rgba(255,71,87,0.15),
				0 6px 25px rgba(255,71,87,0.08),
				inset 0 1px 0 rgba(255,255,255,0.05);
		}
		.room-card[data-status='overtime']:hover{
			border-color:#ff6b7a;
			box-shadow:
				0 0 0 1px rgba(255,107,122,0.5),
				0 3px 16px rgba(255,71,87,0.25),
				0 8px 35px rgba(255,71,87,0.12),
				inset 0 1px 0 rgba(255,255,255,0.08);
			transform:translateY(-4px);
		}
		.room-card[data-status='empty']{background:linear-gradient(160deg,#1e242c,#181d23);} 
		.room-card[data-status='syncing']{background:linear-gradient(160deg,#1f2a3d,#1a2234); border-color:#4a90e2;} 
		.room-card.pending-operation{position:relative; pointer-events:none;} 
		.room-card.pending-operation::before{content:''; position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(74,144,226,0.1); border:2px solid #4a90e2; border-radius:var(--radius); z-index:10; animation:pulse-border 1.5s infinite;}
		
		/* 编辑模式样式 */
		.edit-mode-btn{padding:6px 12px;font-size:12px;background:var(--accent);color:#fff;border-color:var(--accent);}
		.edit-mode-btn.active{background:var(--ok);border-color:var(--ok);}
		.clear-all-btn{
			padding:6px 14px;
			font-size:12px;
			background:#dc3545;
			color:#fff;
			border:1px solid #dc3545;
			border-radius:4px;
			cursor:pointer;
			transition:all 0.25s ease;
			font-weight:600;
			letter-spacing:0.3px;
		}
		.clear-all-btn:hover{
			background:#c82333;
			border-color:#c82333;
			transform:translateY(-2px);
			box-shadow:0 4px 12px rgba(220,53,69,0.3);
		}
		.clear-all-btn:active{
			transform:translateY(0);
			box-shadow:0 2px 6px rgba(220,53,69,0.2);
		}
		.room-card.edit-mode{position:relative;pointer-events:auto;overflow:visible;}
		.room-card.edit-mode .delete-btn{
			position:absolute;top:-8px;right:-8px;width:20px;height:20px;
			border-radius:50%;background:#ff4757;border:2px solid #fff;
			color:#fff;font-size:14px;font-weight:bold;cursor:pointer;
			display:flex;align-items:center;justify-content:center;
			z-index:15;transition:var(--transition);
		}
		.room-card.edit-mode .delete-btn:hover{background:#ff3742;transform:scale(1.1);}
		.room-card.edit-mode .edit-row{
			display:flex;align-items:center;gap:8px;margin-bottom:6px;
		}
		.room-card.edit-mode .room-name.compact{
			flex:1;min-width:0;border:1px dashed var(--outline);
			padding:4px 6px;border-radius:4px;cursor:text;
		}
		.room-card.edit-mode .piano-type-selector{
			flex-shrink:0;min-width:80px;padding:4px 6px;
			background:var(--surface);border:1px solid var(--outline);
			border-radius:4px;font-size:12px;color:var(--text);
			cursor:pointer;outline:none;transition:var(--transition);
		}
		.room-card.edit-mode .piano-type-selector:hover,
		.room-card.edit-mode .piano-type-selector:focus{
			border-color:var(--accent);background:rgba(76,141,255,0.05);
		}
		.room-card.edit-mode .room-name{border:1px dashed var(--outline);padding:4px 6px;border-radius:4px;cursor:text;}
		.room-card.edit-mode .remark{border:1px dashed var(--outline);padding:4px 6px;border-radius:4px;cursor:text;min-height:24px;}
		.room-card.edit-mode .room-name:hover,.room-card.edit-mode .remark:hover{border-color:var(--accent);background:rgba(76,141,255,0.05);}
		.room-card.edit-mode .room-name.compact:hover{border-color:var(--accent);background:rgba(76,141,255,0.05);}
		.add-room-btn{
			background: linear-gradient(135deg, var(--ok) 0%, #2ecc71 100%);
			color: #fff;
			border: 1px solid var(--ok);
			margin-left: 8px;
			font-size: 12px;
			padding: 6px 12px;
			border-radius: 6px;
			font-weight: 600;
			display: inline-flex;
			align-items: center;
			gap: 4px;
			box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
			transition: all 0.2s ease;
		}
		.add-room-btn:hover{
			background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
			border-color: #2ecc71;
			transform: translateY(-1px);
			box-shadow: 0 4px 8px rgba(76, 175, 80, 0.4);
		}
		.add-room-btn:active {
			transform: translateY(0);
			box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
		}
		
		/* === 新增琴房模态框专用样式 === */
		.add-room-modal .modal-header {
			background: linear-gradient(135deg, var(--surface-alt) 0%, #2c3e50 100%);
			border-bottom: 1px solid var(--outline);
		}
		.add-room-modal .modal-header h3 {
			color: var(--text);
			display: flex;
			align-items: center;
			gap: 8px;
		}
		.add-room-modal .modal-header h3::before {
			content: "🎹";
			font-size: 18px;
		}
		.add-room-modal .form-grid {
			display: grid;
			gap: 18px;
		}
		.add-room-modal .form-field {
			display: flex;
			flex-direction: column;
			gap: 6px;
		}
		.add-room-modal .form-field label {
			font-size: 13px;
			font-weight: 600;
			color: var(--text);
			display: flex;
			align-items: center;
			gap: 6px;
		}
		.add-room-modal .form-field label .required {
			color: var(--danger);
			font-weight: bold;
		}
		.add-room-modal .form-field label .icon {
			font-size: 14px;
			opacity: 0.7;
		}
		.add-room-modal input,
		.add-room-modal select,
		.add-room-modal textarea {
			font-size: 14px;
			padding: 10px 12px;
			border: 1px solid var(--outline);
			border-radius: 8px;
			background: var(--surface);
			color: var(--text);
			transition: all 0.2s ease;
		}
		.add-room-modal input:focus,
		.add-room-modal select:focus,
		.add-room-modal textarea:focus {
			outline: none;
			border-color: var(--accent);
			box-shadow: 0 0 0 3px rgba(76, 141, 255, 0.1);
			background: var(--surface-alt);
		}
		.add-room-modal textarea {
			resize: vertical;
			min-height: 60px;
			font-family: inherit;
			line-height: 1.4;
		}
		.add-room-modal .piano-type-display {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 8px;
			margin-top: 4px;
		}
		.add-room-modal .piano-type-option {
			padding: 8px 12px;
			border: 1px solid var(--outline);
			border-radius: 6px;
			background: var(--surface-alt);
			color: var(--text-dim);
			text-align: center;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.2s ease;
		}
		.add-room-modal .piano-type-option:hover {
			border-color: var(--accent);
			background: var(--accent-fade, rgba(76, 141, 255, 0.1));
		}
		.add-room-modal .piano-type-option.selected {
			background: var(--accent);
			color: #fff;
			border-color: var(--accent);
			font-weight: 600;
		}
		.add-room-modal .modal-footer {
			background: var(--surface-alt);
			border-top: 1px solid var(--outline);
			padding: 16px 20px;
		}
		.add-room-modal .modal-footer button {
			padding: 10px 20px;
			font-size: 14px;
			font-weight: 600;
			border-radius: 8px;
			transition: all 0.2s ease;
		}
		.add-room-modal .form-field.error input,
		.add-room-modal .form-field.error select,
		.add-room-modal .form-field.error textarea {
			border-color: var(--danger);
			background: rgba(255, 77, 77, 0.05);
		}
		.add-room-modal .form-field.error label {
			color: var(--danger);
		}
		.add-room-modal .error-message {
			color: var(--danger);
			font-size: 12px;
			margin-top: 4px;
			display: flex;
			align-items: center;
			gap: 4px;
		}
		.add-room-modal .error-message::before {
			content: "⚠️";
			font-size: 10px;
		}
		.floor-filter-edit{position:relative;}
		.floor-filter-edit .add-floor-btn{
			position:absolute;right:-30px;top:50%;transform:translateY(-50%);
			width:24px;height:24px;border-radius:50%;background:var(--ok);
			color:#fff;font-size:16px;cursor:pointer;border:none;
			display:flex;align-items:center;justify-content:center;
		}
		.editable-input{
			background:var(--surface);border:1px solid var(--accent);
			border-radius:4px;padding:4px 6px;font-size:inherit;
			color:var(--text);width:100%;outline:none;
		}
		
		@keyframes pulse-border { 0%, 100% { border-color: #4a90e2; opacity: 0.8; } 50% { border-color: #7fb1ff; opacity: 1; } }
		@keyframes preparing-pulse { 0%, 100% { border-color: #f39c12; box-shadow: 0 0 15px rgba(243,156,18,0.3); } 50% { border-color: #e67e22; box-shadow: 0 0 25px rgba(243,156,18,0.5), 0 0 35px rgba(243,156,18,0.2); } } 
		.room-name {font-size:15px;font-weight:600;letter-spacing:.5px; display:flex;align-items:center; gap:6px; color:var(--text);} .pill {font-size:10px;padding:2px 6px;border-radius:6px;background:var(--surface-alt);color:var(--text-dim); font-weight:500; letter-spacing:.3px;transition:var(--transition);}
		.pill-grand {background:linear-gradient(135deg,#3b82f6,#1e40af);color:#fff;box-shadow:0 1px 3px rgba(59,130,246,0.3);}
		.pill-upright {background:linear-gradient(135deg,#10b981,#059669);color:#fff;box-shadow:0 1px 3px rgba(16,185,129,0.3);}
		.pill-other {background:linear-gradient(135deg,#8b5cf6,#7c3aed);color:#fff;box-shadow:0 1px 3px rgba(139,92,246,0.3);}
		.room-card:hover .pill-grand {box-shadow:0 2px 6px rgba(59,130,246,0.5);}
		.room-card:hover .pill-upright {box-shadow:0 2px 6px rgba(16,185,129,0.5);}
		.room-card:hover .pill-other {box-shadow:0 2px 6px rgba(139,92,246,0.5);}
		.remark {font-size:11px;color:var(--text-dim); line-height:1.3; max-height:30px; overflow:hidden;text-overflow:ellipsis;}
		.occupant-line {display:flex;align-items:center; gap:6px; font-size:13px; font-weight:500; color:#fff; margin-top:2px; white-space:nowrap;overflow:hidden;}
		.dot {width:8px;height:8px;border-radius:50%;background:var(--accent);box-shadow:0 0 0 3px rgba(76,141,255,.25);} 
		.status-row {margin-top:auto; display:flex; align-items:center; justify-content:space-between; gap:8px;}
		.chip {font-size:11px; padding:3px 8px; border-radius:8px; background:var(--surface-alt); color:var(--text-dim); font-weight:500; letter-spacing:.3px; line-height:1;}
		.chip.accent{color:var(--accent);} .chip.warn{color:var(--warn);} .chip.good{color:var(--ok);} .chip.danger{color:var(--danger);} 
		.chip.preparing{background:linear-gradient(135deg,#f39c12,#e67e22); color:#fff; font-weight:600; text-shadow:0 1px 2px rgba(0,0,0,0.3); box-shadow:0 2px 8px rgba(243,156,18,0.4); animation:chip-glow 2s infinite; position:relative;}
		.chip.preparing::before{content:'⚡'; margin-right:3px; animation:preparing-icon 1.5s infinite;}
		@keyframes chip-glow { 0%, 100% { box-shadow: 0 2px 8px rgba(243,156,18,0.4); } 50% { box-shadow: 0 2px 15px rgba(243,156,18,0.7), 0 0 20px rgba(243,156,18,0.3); } }
		@keyframes preparing-icon { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } } 
		.actions {display:flex;gap:4px;} .actions button {padding:4px 7px; font-size:11px; background:var(--surface-alt);} .actions button.primary{background:var(--accent);color:#fff;border-color:var(--accent);} .actions button.primary:hover{background:var(--accent-hover);} .actions button.danger{background:var(--danger);border-color:var(--danger);} 
		/* === 可读性增强覆盖样式 === */
		.room-card{color:#dbe5ef;}
		.room-card .room-name{font-weight:600; letter-spacing:.5px; color:#ffffff; text-shadow:0 1px 2px rgba(0,0,0,.4);} 
		.room-card .occupant-line span:last-child{font-weight:600; color:#fff;}
		
		/* === 空闲状态重新设计 - 根据钢琴类型显示不同颜色 === */
		/* 默认空闲状态（其他类型） - 紫色，与分割线保持一致 */
		.room-card.empty{
			background:linear-gradient(135deg, #241530 0%, #322038 35%, #1c1625 100%);
			border:1px solid #604d85; 
			box-shadow:
				0 0 0 1px rgba(120,50,160,0.25),
				0 2px 12px -2px rgba(0,0,0,0.65),
				0 6px 22px -8px rgba(0,0,0,0.7),
				inset 0 0 0 1px rgba(255,255,255,0.03),
				inset 0 4px 18px -6px rgba(130,70,180,0.08);
			filter:saturate(.88) brightness(.85);
		}
		.room-card.empty:hover{
			border-color:#7a65a8;
			background:linear-gradient(135deg, #322038 0%, #3d2a45 35%, #241a30 100%);
			box-shadow:
				0 0 0 1px rgba(140,60,180,0.35),
				0 6px 18px -6px rgba(0,0,0,0.7),
				0 10px 38px -12px rgba(0,0,0,0.65),
				inset 0 1px 0 rgba(255,255,255,0.06),
				inset 0 4px 22px -8px rgba(130,70,180,0.12);
			transform:translateY(-3px);
		}
		
		/* 三角钢琴空闲状态 - 蓝色 */
		.room-card.empty[data-grand="1"]{
			background:linear-gradient(135deg, #152030 0%, #202f38 35%, #141c25 100%);
			border:1px solid #4d6085;
			box-shadow:
				0 0 0 1px rgba(76,135,215,0.25),
				0 2px 12px -2px rgba(0,0,0,0.65),
				0 6px 22px -8px rgba(0,0,0,0.7),
				inset 0 0 0 1px rgba(255,255,255,0.03),
				inset 0 4px 18px -6px rgba(76,135,215,0.08);
		}
		.room-card.empty[data-grand="1"]:hover{
			border-color:#6078c8;
			background:linear-gradient(135deg, #202f38 0%, #2a3845 35%, #181f30 100%);
			box-shadow:
				0 0 0 1px rgba(76,135,215,0.35),
				0 6px 18px -6px rgba(0,0,0,0.7),
				0 10px 38px -12px rgba(0,0,0,0.65),
				inset 0 1px 0 rgba(255,255,255,0.06),
				inset 0 4px 22px -8px rgba(76,135,215,0.12);
		}
		
		/* 立式钢琴空闲状态 - 绿色 */
		.room-card.empty[data-grand="0"]{
			background:linear-gradient(135deg, #153025 0%, #203830 35%, #141c1a 100%);
			border:1px solid #2aa876;
			box-shadow:
				0 0 0 1px rgba(42,168,118,0.25),
				0 2px 12px -2px rgba(0,0,0,0.65),
				0 6px 22px -8px rgba(0,0,0,0.7),
				inset 0 0 0 1px rgba(255,255,255,0.03),
				inset 0 4px 18px -6px rgba(42,168,118,0.08);
		}
		.room-card.empty[data-grand="0"]:hover{
			border-color:#3ec490;
			background:linear-gradient(135deg, #203830 0%, #2a4538 35%, #181f25 100%);
			box-shadow:
				0 0 0 1px rgba(42,168,118,0.35),
				0 6px 18px -6px rgba(0,0,0,0.7),
				0 10px 38px -12px rgba(0,0,0,0.65),
				inset 0 1px 0 rgba(255,255,255,0.06),
				inset 0 4px 22px -8px rgba(42,168,118,0.12);
		} 
		/* 空闲熄灭 chip 样式 */
		.chip-dim[data-empty="1"]{
			background:linear-gradient(135deg,rgba(70,90,80,0.25),rgba(40,55,48,0.18));
			color:#d9e7dd; 
			font-weight:500;
			letter-spacing:.4px;
			border:1px solid rgba(120,170,150,0.25);
			box-shadow:0 1px 2px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.02);
			text-shadow:0 1px 2px rgba(0,0,0,0.45);
			filter:brightness(.95) saturate(.9);
		}
		.room-card.empty .status-row .chip-dim[data-empty="1"]:hover{background:linear-gradient(135deg,rgba(90,115,100,0.3),rgba(50,70,60,0.25));}
		/* 空闲状态文字增强 */
		.room-card.empty .room-name{
			color:#f2f7f5; 
			text-shadow:0 1px 3px rgba(0,0,0,0.55);
			font-weight:650;
			letter-spacing:.6px;
		}
		.room-card.empty .remark{
			color:#b7c9c0; 
			opacity:.85;
		} 
		.room-card.empty .occupant-line{display:none;}
		/* 与占用亮起对应：占用房保持鲜艳；空闲提升亮度 */
		.room-card[data-status='occupied']{filter:saturate(1.05) brightness(1.03);} 
		.room-card[data-status='empty']{filter:saturate(1.1) brightness(1.1);} 
		.room-card[data-status='empty']:hover{filter:saturate(1.15) brightness(1.15);} 
		.room-card .status-row .chip{filter:brightness(1.05);} 
		.room-card[data-status='overtime'] .chip.danger{background:rgba(255,77,77,0.18); box-shadow:0 0 0 1px rgba(255,77,77,0.35);} 
		.room-card[data-status='preparing'] .chip.preparing{background:rgba(243,156,18,0.15); color:#ffb347;} 
		.room-card .actions button{filter:brightness(1.1);} 
		.room-card:hover .actions button.primary{box-shadow:0 0 0 1px rgba(0,140,255,0.4);} 
		/* 更亮的文本与辅助说明 */
		body{--text:#d9e2ec; --text-dim:#90a4b8;}
		/* 移除空闲卡片的透明度设置，让其保持正常可见度 */
		.meta-bar {display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
		.meta-stat {font-size:12px; color:var(--text-dim); display:flex; gap:4px; align-items:center;}
		.searchbox {position:relative;}
		.searchbox input {min-width:260px; padding-left:34px;}
		.searchbox svg {position:absolute; top:50%; left:10px; width:16px; height:16px; transform:translateY(-50%); stroke:var(--text-dim);} 
		.inline-search-results{position:absolute; top:100%; left:0; margin-top:6px; width:480px; max-width:70vw; background:var(--surface); border:1px solid var(--outline); border-radius:14px; box-shadow:0 8px 28px -10px rgba(0,0,0,.4); padding:10px 0; display:flex; flex-direction:column; max-height:420px; overflow:auto; z-index:60; backdrop-filter:blur(6px);} 
		.inline-search-results .group-title{font-size:11px; font-weight:600; color:var(--text-dim); padding:4px 14px 6px; letter-spacing:.5px;}
		.inline-search-results .result-item{padding:8px 14px; display:flex; justify-content:space-between; gap:12px; line-height:1.2; cursor:pointer; font-size:13px; border-left:3px solid transparent; transition:var(--transition);} 
		.inline-search-results .result-item:hover{background:var(--surface-alt); border-left-color:var(--accent);}
		.inline-search-results .result-item .meta{font-size:11px; color:var(--text-dim);} 
		.inline-search-results .result-item .occ-info{margin-left:6px; font-size:11px; padding:2px 6px; border-radius:10px; background:var(--surface-alt); display:inline-flex; align-items:center; gap:4px; font-weight:500;}
		.inline-search-results .result-item .occ-info .icon{font-size:12px;}
		.inline-search-results .result-item .occ-info.preparing{background:#ffe9c8;color:#a45b00;}
		.inline-search-results .result-item .occ-info.occupied{background:#d8eefc;color:#0a5b85;}
		.inline-search-results .result-item .occ-info.overtime{background:#ffe0e0;color:#b40000;}
		.inline-search-results .result-item .occ-info .dur{opacity:.8;}
		.inline-search-results .empty{padding:20px 16px; text-align:center; font-size:12px; color:var(--text-dim);} 
		.inline-search-results .result-item.room{--icon:"🎹";} 
		.inline-search-results .highlight{color:var(--accent); font-weight:600;}
		/* ==== 类型分隔线 ==== */
		.room-type-separator{grid-column:1/-1;display:flex;align-items:center;gap:14px;margin:14px 2px 6px;position:relative;}
		.room-type-separator .line{flex:1;height:1px;background:linear-gradient(90deg,transparent,var(--outline),transparent);}
		.room-type-separator .label{font-size:11px;letter-spacing:1px;font-weight:600;color:var(--text-dim);text-transform:uppercase;padding:4px 10px;border:1px solid var(--outline);border-radius:30px;background:var(--surface-alt);backdrop-filter:blur(4px);}
		.room-type-separator.grand .label{color:#60a5ff;border-color:#3d5e82;background:linear-gradient(120deg,rgba(30,50,70,.35),rgba(20,30,40,.4));}
		.room-type-separator.upright .label{color:#34d399;border-color:#245f45;background:linear-gradient(120deg,rgba(24,60,48,.35),rgba(18,32,26,.4));}
		.room-type-separator.other .label{color:#c084fc;border-color:#553a7a;background:linear-gradient(120deg,rgba(55,35,80,.35),rgba(35,25,50,.4));}
		/* ===== 标题体系 ===== */
		.app-title{display:flex;flex-direction:column;gap:6px;margin-bottom:8px;}
		.title-line{display:flex;align-items:baseline;flex-wrap:wrap;gap:10px;}
		.title-line.main{font-size:22px;font-weight:600;letter-spacing:.5px;}
		.title-line.main .brand{background:linear-gradient(120deg,#cfd9e5,#ffffff);background-clip:text;-webkit-background-clip:text;color:transparent;font-weight:700;filter:drop-shadow(0 2px 6px rgba(0,0,0,.25));}
		.title-line.main .divider{color:var(--text-dim);font-weight:400;opacity:.6;}
		.title-line.main .module{color:var(--accent);font-weight:600;position:relative;}
		.title-line.main .module:after{content:"";position:absolute;left:0;bottom:-4px;width:100%;height:2px;background:linear-gradient(90deg,var(--accent),transparent);opacity:.5;border-radius:2px;}
		.title-line.sub{font-size:11px;font-weight:500;letter-spacing:.8px;color:var(--text-dim);text-transform:uppercase;gap:6px;}
		.tag{padding:2px 8px;border-radius:20px;display:inline-flex;align-items:center;gap:4px;font-size:10px;line-height:1.2;letter-spacing:.5px;font-weight:600;position:relative;}
		.tag.beta{background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff;box-shadow:0 2px 8px -2px rgba(99,102,241,.5);}
		.tag.env{background:linear-gradient(135deg,#0ea5e9,#3b82f6);color:#fff;}
		@media (max-width:720px){
			.title-line.main{font-size:18px;}
			.title-line.sub{font-size:10px;}
		}
		header h1, header h2.subtitle{display:none !important;}
		.side {width:340px; display:flex; flex-direction:column; gap:24px;}
		.section-title {font-size:13px;font-weight:600;color:var(--text-dim);letter-spacing:.5px;margin:0 0 8px;}
		.import-box {background:var(--surface);border:1px dashed var(--outline); border-radius:var(--radius); padding:14px; display:flex; flex-direction:column; gap:10px;}
		.import-box input {width:100%;}
		.list-small {max-height:220px; overflow:auto; font-size:12px; line-height:1.4; background:var(--surface-alt); padding:8px 10px; border:1px solid var(--outline); border-radius:var(--radius-sm);} .list-small code{font-size:11px;}
		.toast {position:fixed; bottom:24px; right:24px; background:#222c36; color:#fff; padding:10px 16px; border-radius:10px; font-size:13px; box-shadow:0 6px 18px -8px #000; display:flex; gap:10px; align-items:center; animation:fadeIn .3s;} @keyframes fadeIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}
		.modal-backdrop {position:fixed; inset:0; background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; z-index:100;}
		.modal {background:var(--surface); border:1px solid var(--outline); width:480px; max-width:92%; border-radius:18px; display:flex; flex-direction:column; overflow:hidden; box-shadow:0 12px 40px -16px rgba(0,0,0,.7);} .modal-header{padding:16px 20px; display:flex; align-items:center; justify-content:space-between; background:var(--surface-alt);} .modal-header h3{margin:0;font-size:15px;font-weight:600;} .modal-body{padding:16px 20px; display:flex; flex-direction:column; gap:14px; max-height:60vh; overflow:auto;} .modal-footer{padding:14px 20px; display:flex; gap:10px; justify-content:flex-end; background:var(--surface-alt);} 
		/* 放大学生选择弹窗：在特定 backdrop 下作用，避免影响新增房间弹窗 */
		#studentModalBackdrop .modal { width:760px; max-width:94%; border-radius:22px; }
		#studentModalBackdrop .modal-header{ padding:22px 28px 18px; }
		#studentModalBackdrop .modal-header h3{ font-size:19px; letter-spacing:.6px; font-weight:650; }
		#studentModalBackdrop .modal-body{ padding:10px 28px 24px; gap:18px; max-height:68vh; }
		#studentModalBackdrop .modal-footer{ padding:18px 28px 22px; }
		#studentModalBackdrop input#studentSearch{ font-size:16px; padding:14px 16px; border-radius:14px; }
		#studentModalBackdrop .student-list{ --item-gap:10px; display:flex; flex-direction:column; gap:var(--item-gap); font-size:15px; line-height:1.5; }
		#studentModalBackdrop .student-list .stu-item{ padding:10px 14px 11px; font-size:15px; border-radius:12px; }
		#studentModalBackdrop .student-list .stu-item strong{ font-size:15px; font-weight:600; }
		#studentModalBackdrop .student-list .stu-item small{ font-size:12px; opacity:.85; }
		#studentModalBackdrop button{ font-size:14px; }
		#studentModalBackdrop .ghost{ font-size:14px; }
		/* ==== 学生占用显示增强 ==== */
		#studentModalBackdrop .student-list .student-item{display:flex; align-items:center; flex-wrap:wrap; gap:14px; background:linear-gradient(145deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.05);} 
		#studentModalBackdrop .student-list .student-item{justify-content:space-between;}
		#studentModalBackdrop .student-list .student-item .stu-name{flex:0 0 auto; min-width:100px; font-weight:600; letter-spacing:.4px;}
		#studentModalBackdrop .student-list .student-item .col-left{display:flex; align-items:center; gap:12px; flex:1 1 auto; min-width:320px;}
		#studentModalBackdrop .student-list .student-item .col-right{display:flex; align-items:center; gap:14px; justify-content:flex-end; flex:0 0 auto; min-width:240px;}
		#studentModalBackdrop .student-list .student-item .col-right .state-tag{margin-left:2px;}
		/* 禁用旧 info-col 布局（若残留） */
		#studentModalBackdrop .student-list .student-item .info-col{display:none !important;}
		/* 紧凑模式：在较窄屏幕自动回退为横向单行 */
		@media (max-width:900px){
			#studentModalBackdrop .student-list .student-item{flex-direction:column; align-items:flex-start; gap:10px;}
			#studentModalBackdrop .student-list .student-item .col-left{flex-wrap:wrap; min-width:auto;}
			#studentModalBackdrop .student-list .student-item .col-right{width:100%; justify-content:flex-start; flex-wrap:wrap;}
		}
		#studentModalBackdrop .student-list .student-item:hover{background:linear-gradient(145deg,rgba(255,255,255,0.06),rgba(255,255,255,0.03)); border-color:rgba(255,255,255,0.15);} 
		#studentModalBackdrop .student-list .student-item.kb-selected{border-color:var(--accent); box-shadow:0 0 0 1px var(--accent), 0 4px 14px -4px rgba(0,123,255,0.35);} 
		/* 已移除纵向结构，保持兼容 */
		#studentModalBackdrop .student-list .student-item .stu-line-main{display:contents;}
		#studentModalBackdrop .student-list .student-item .stu-name{font-weight:600; letter-spacing:.4px;}
		#studentModalBackdrop .student-list .student-item .stu-line-sub{display:contents;}
		#studentModalBackdrop .student-list .student-item .tag.major{background:rgba(59,130,246,0.12); color:#7fb3ff;}
		#studentModalBackdrop .student-list .student-item .tag.grade{background:rgba(120,160,255,0.12); color:#b0c8ff;}
		#studentModalBackdrop .student-list .student-item .room-tag{padding:2px 8px; font-size:11px; border-radius:20px; background:linear-gradient(135deg,#2d3e52,#1e2a38); color:#aad4ff; letter-spacing:.4px; position:relative; top:-1px; box-shadow:0 1px 3px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,0.05);} 
		#studentModalBackdrop .student-list .student-item .room-tag::before{content:'房'; font-size:10px; margin-right:4px; opacity:.8;}
		#studentModalBackdrop .student-list .student-item .state-tag{padding:2px 8px; font-size:11px; border-radius:16px; background:rgba(255,255,255,0.07); color:#d2dee8; letter-spacing:.4px; font-weight:500; box-shadow:0 1px 2px rgba(0,0,0,.4);}
		#studentModalBackdrop .student-list .student-item .state-tag.st-preparing{background:linear-gradient(135deg,#f39c12,#e67e22); color:#fff; font-weight:600;}
		#studentModalBackdrop .student-list .student-item .state-tag.st-occupied{background:linear-gradient(135deg,#0052d4,#4364f7); color:#fff; font-weight:600;}
		#studentModalBackdrop .student-list .student-item .state-tag.st-overtime{background:linear-gradient(135deg,#ff4d4d,#c62828); color:#fff; font-weight:600;}
		#studentModalBackdrop .student-list .student-item .state-tag.st-empty{background:rgba(255,255,255,0.12); color:#bcd;}
		/* 键盘高亮/hover 提升层次 */
		#studentModalBackdrop .student-list .stu-item.hover, 
		#studentModalBackdrop .student-list .stu-item:focus-visible{ outline:2px solid var(--accent); outline-offset:1px; }
		/* 响应式保护 */
		@media (max-width:900px){
			#studentModalBackdrop .modal{ width:94%; }
			#studentModalBackdrop .modal-body{ max-height:70vh; }
		}
		.student-list {display:flex; flex-direction:column; gap:6px;} .student-item{background:var(--surface-alt); padding:6px 10px; border:1px solid var(--outline); border-radius:8px; cursor:pointer; display:flex; justify-content:space-between; align-items:center; font-size:13px; transition:var(--transition);} .student-item:hover{border-color:var(--accent); color:var(--text);} .student-item .tag{font-size:11px; color:var(--text-dim);} .student-item.disabled{opacity:.45;pointer-events:none;} .student-item.kb-selected{border-color:var(--accent); background:var(--accent-fade,#2d6cdf22);} .student-item.kb-selected span:first-child{font-weight:600;}
		.muted{color:var(--text-dim);} .danger{color:var(--danger);} .warn{color:var(--warn);} .accent{color:var(--accent);} 
		footer {padding:18px 26px 34px; font-size:11px; text-align:center; color:var(--text-dim);} a{color:var(--accent); text-decoration:none;} a:hover{text-decoration:underline;}
	</style>
</head>
<body>
	<header>
		<div class="app-title">
			<div class="title-line main" aria-label="青岛耶胡迪梅纽因学校 琴房管理系统">
				<span class="brand">青岛耶胡迪梅纽因学校</span>
				<span class="divider">·</span>
				<span class="module">琴房管理系统</span>
			</div>
			<div class="title-line sub">
				<span class="tag beta">v2</span>
				<span class="tag env">实时同步启用</span>
			</div>
		</div>
		<div class="searchbox">
			<svg fill="none" stroke-width="2" stroke="currentColor" viewBox="0 0 24 24"><circle cx="11" cy="11" r="7"/><path d="M21 21l-4.35-4.35"/></svg>
			<input id="globalSearch" type="search" placeholder="搜索学生 / 琴房 (支持拼音首字母)" />
			<div id="inlineSearchResults" class="inline-search-results" style="display:none;"></div>
		</div>
		<div class="toolbar">
			<div class="sync-status" id="syncStatus">
				<div class="sync-dot" id="syncDot"></div>
				<span id="syncText">离线</span>
			</div>
			<!-- 已移除导入学生 (改由学生库 CSV) -->
			<button id="btnSyncToCloud" class="ghost">同步到云端</button>
			<button id="btnReconnect" class="ghost" style="display: none;">重新连接</button>
			<button id="btnToggleSlotCheck" class="ghost" title="切换登记时段检测">时段检测: 开</button>
			<!-- 已移除刷新按钮 -->
			<!-- 已移除考勤时间段入口 (改由学生库内导入导出 + 需要时可重新添加) -->
		</div>
	</header>
	<main>
		<div class="panel" id="panelRooms">
			<div class="panel-header">
				<h2>琴房列表</h2>
				<div class="badge" id="statUsage">加载中...</div>
			</div>
			<div class="meta-bar">
				<div class="filters" id="floorFilters"></div>
				<div class="filters" id="typeFilters"></div>
				<div style="margin-left:auto;display:flex;align-items:center;gap:10px;">
					<button id="btnClearAllRooms" class="clear-all-btn" title="一键清空所有琴房">清空全部</button>
					<button id="btnEditRooms" class="edit-mode-btn" title="编辑琴房" style="padding:6px 14px;">编辑</button>
					<button id="btnCheckConsistency" class="consistency-check-btn" title="检查数据一致性" style="padding:6px 14px;margin-left:8px;background:#17a2b8;color:white;border:none;border-radius:4px;font-size:12px;">检查一致性</button>
				</div>
				<div class="meta-stat" id="metaCounts"></div>
			</div>
			<hr class="divider"/>
			<div class="grid" id="roomGrid"></div>
		</div>
		<div class="side">

			<div>
				<p class="section-title">运行状态</p>
				<div class="list-small" id="runtimeInfo"></div>
			</div>
			<div style="margin-top:22px;">
				<p class="section-title" style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:nowrap;">
					<span style="white-space:nowrap;">重要提醒</span>
					<span style="display:flex;gap:8px;flex-wrap:nowrap;align-items:center;white-space:nowrap;">
						<span class="alert-filters" style="display:flex;gap:4px;flex-wrap:nowrap;">
							<button class="alert-filter-btn act" data-filter="all">全部</button>
							<button class="alert-filter-btn" data-filter="absent">缺勤</button>
							<button class="alert-filter-btn" data-filter="anomaly">异常</button>
						</span>
						<button id="ignoreAllBtn" class="alert-ignore-all-btn" title="忽略当前筛选条件下的所有提醒">一键忽略</button>
					</span>
				</p>
				<div id="alertList" class="list-small alert-empty" style="max-height:680px;overflow:auto;display:flex;flex-direction:column;gap:10px;"></div>
			</div>
		</div>
	</main>
	<footer>© 2025 青岛耶胡迪梅纽因学校 琴房管理系统 · Demo 版本 · <a href="https://supabase.com" target="_blank" rel="noopener">Supabase</a></footer>

	<!-- 学生库管理面板（抽屉） -->
	<div id="studentLibraryPanel" style="position:fixed;top:0;right:0;bottom:0;width:420px;max-width:100%;background:#ffffff;box-shadow:-4px 0 18px -4px rgba(0,0,0,.15);border-left:1px solid #e2e8f0;z-index:3100;display:none;flex-direction:column;font-size:13px;color:#1a1a1a;">
		<div style="padding:14px 16px;border-bottom:1px solid #e2e8f0;display:flex;align-items:center;gap:10px;position:relative;z-index:20;background:#ffffff;">
			<h3 style="margin:0;font-size:16px;font-weight:600;flex:1;display:flex;align-items:center;gap:6px;color:#1a1a1a;">学生库 <span id="slTotal" style="font-size:11px;font-weight:500;color:#64748b;">--</span></h3>
			<button id="slCloseBtn" class="sl-btn sl-btn-secondary sl-btn-sm">关闭</button>
		</div>
		<div style="padding:10px 14px;display:flex;flex-direction:column;gap:10px;flex:1;min-height:0;">
			<div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
				<input id="slSearch" placeholder="搜索姓名 / 拼音" class="sl-input" style="flex:1;min-width:160px;" />
				<button id="slAddBtn" class="sl-btn sl-btn-primary">新增学生</button>
				<button id="slOpenBTMBtn" class="sl-btn sl-btn-accent">批量时间段</button>
			</div>
			<div id="slAddForm" style="display:none;gap:8px;flex-wrap:wrap;background:#f8fafc;border:1px solid #e2e8f0;padding:12px;border-radius:8px;">
				<input id="slName" placeholder="姓名*" class="sl-input" style="flex:1;min-width:120px;" />
				<input id="slGrade" placeholder="年级" class="sl-input" style="flex:1;min-width:100px;" />
				<input id="slMajor" placeholder="专业" class="sl-input" style="flex:1;min-width:100px;" />
				<div style="display:flex;gap:8px;width:100%;justify-content:flex-end;margin-top:6px;">
					<button id="slCancelAdd" class="sl-btn sl-btn-secondary">取消</button>
					<button id="slSubmitAdd" class="sl-btn sl-btn-success">保存</button>
				</div>
			</div>
			<div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
				<div style="margin-left:auto;display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
					<button id="slExportCsvSlotsBtn" class="sl-btn sl-btn-outline sl-btn-sm">导出学生库</button>
					<button id="slImportCsvSlotsBtn" class="sl-btn sl-btn-outline sl-btn-sm">导入学生库</button>
					<input type="file" id="slImportCsvSlotsFile" accept=".csv,text/csv" style="display:none;" />
				</div>
			</div>
			<div id="slList" style="flex:1;min-height:0;overflow:auto;display:flex;flex-direction:column;gap:6px;"></div>
		</div>
	</div>

	<!-- 批量时间段管理 Modal -->
	<!-- 提升 z-index 到高于学生库面板(学生库=3100)，防止被遮挡 -->
	<div id="bulkTimeManagerModal" style="display:none;position:fixed;inset:0;z-index:3600;background:rgba(0,0,0,.55);backdrop-filter:blur(4px);">
		<div class="btm-wrapper">
			<div class="btm-header">
				<div class="btm-title">批量时间段管理</div>
				<div class="btm-actions">
					<button class="btm-btn btm-secondary" id="btmPrevBtn">上一位</button>
					<button class="btm-btn btm-secondary" id="btmNextBtn">下一位</button>
					<button class="btm-btn btm-danger" id="btmClearAllBtn">清空全部</button>
					<button class="btm-btn btm-primary" id="btmSaveBtn">保存</button>
					<button class="btm-btn btm-secondary" id="btmCloseBtn">关闭</button>
				</div>
			</div>
			<div class="btm-body">
				<div class="btm-left">
					<div class="btm-student-bar" style="display:flex;gap:12px;align-items:center;margin-bottom:10px;flex-wrap:wrap;">
						<select id="btmStudentSelect" class="btm-select" style="min-width:220px;"></select>
						<input id="btmSearchInput" placeholder="搜索姓名 / 拼音" class="btm-select" style="flex:1;min-width:180px;" />
					</div>
					<div id="btmStudentInfo" class="btm-stu-info"></div>
					<div class="btm-legend">
						<span>单击选择/取消</span>
						<span>灰色 = 休息/午餐</span>
						<span>保存写入 student_time_slots</span>
					</div>
					<div class="btm-table-wrap">
						<table class="btm-table">
							<thead>
								<tr><th class="btm-time-col">时间</th><th>周一</th><th>周二</th><th>周三</th><th>周四</th><th>周五</th></tr>
							</thead>
							<tbody id="btmTbody"></tbody>
						</table>
					</div>
				</div>
				<div class="btm-right">
					<div class="btm-summary-title">当前学生选中节次</div>
					<div id="btmSelectedList" class="btm-selected-list"></div>
					<div class="btm-note">说明：保存覆盖该学生本周(周一-周五)既有时间段。</div>
				</div>
			</div>
		</div>
	</div>

	<!-- 学生选择 Modal -->
	<div class="modal-backdrop" id="studentModalBackdrop" style="display:none;">
		<div class="modal" role="dialog" aria-modal="true" aria-labelledby="studentModalTitle">
			<div class="modal-header">
				<h3 id="studentModalTitle">选择学生</h3>
				<button id="btnCloseStudentModal" class="ghost" style="padding:4px 8px;">✕</button>
			</div>
			<div class="modal-body">
				<input id="studentSearch" type="text" placeholder="按姓名 / 拼音首字母 / 专业过滤" />
				<div class="student-list" id="studentList"></div>
			</div>
			<div class="modal-footer">
				<button id="btnStudentModalCancel" class="ghost">取消</button>
			</div>
		</div>
	</div>

	<!-- 新增房间 Modal -->
	<div class="modal-backdrop" id="addRoomModalBackdrop" style="display:none;">
		<div class="modal add-room-modal" role="dialog" aria-modal="true" aria-labelledby="addRoomModalTitle">
			<div class="modal-header">
				<h3 id="addRoomModalTitle">新增琴房</h3>
				<button id="btnCloseAddRoomModal" class="ghost" style="padding:4px 8px;">✕</button>
			</div>
			<div class="modal-body">
				<div class="form-grid">
					<div class="form-field">
						<label>
							<span class="icon">🏷️</span>
							房间名称
							<span class="required">*</span>
						</label>
						<input id="addRoomName" type="text" placeholder="例如：101、琴房A" />
					</div>
					<div class="form-field">
						<label>
							<span class="icon">📍</span>
							位置
						</label>
						<input id="addRoomLocation" type="text" placeholder="例如：1楼、音乐楼二层" />
					</div>
					<div class="form-field">
						<label>
							<span class="icon">🎼</span>
							钢琴类型
						</label>
						<div class="piano-type-display">
							<div class="piano-type-option" data-type="立式">立式钢琴</div>
							<div class="piano-type-option selected" data-type="三角">三角钢琴</div>
							<div class="piano-type-option" data-type="其他">其他</div>
						</div>
						<select id="addRoomPianoType" style="display:none;">
							<option value="立式">立式</option>
							<option value="三角">三角</option>
							<option value="其他">其他</option>
						</select>
					</div>
					<div class="form-field">
						<label>
							<span class="icon">📝</span>
							备注
						</label>
						<textarea id="addRoomRemark" placeholder="可选：设备说明、使用注意事项等"></textarea>
					</div>
				</div>
			</div>
			<div class="modal-footer">
				<button id="btnAddRoomCancel" class="ghost">取消</button>
				<button id="btnAddRoomConfirm" class="primary">创建琴房</button>
			</div>
		</div>
	</div>

	<!-- Toast 容器 -->
	<div id="toastContainer" style="position:fixed;pointer-events:none;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:flex-end;gap:10px;padding:0 24px 24px;z-index:500;"></div>

	<script>
	/*************************************************
	 * 数据层 & 状态模型
	 *************************************************/
	const SUPABASE_URL = 'https://waesizzoqodntrlvrwhw.supabase.co';
	const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndhZXNpenpvcW9kbnRybHZyd2h3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc4MjIyOTYsImV4cCI6MjA3MzM5ODI5Nn0.kE5gSV68q1nLo4z2IqgwqfTBVqNOJw5qs08f6r0SQH0';
	let supabaseClient = null;
	let supabaseReady = false; // 内部标志
	// 统一对外暴露，供 StudentLibrary / 其它模块检测
	Object.defineProperty(window,'supabaseReady',{ get(){ return supabaseReady; }, set(v){ supabaseReady=!!v; if(v){ try{ if(window.__retryStudentLibraryPending) window.__retryStudentLibraryPending(); }catch(_){ } } }});
	let realtimeChannel = null;

	// 请求频率限制器
	class RequestThrottler {
		constructor() {
			this.requests = new Map(); // 存储每种请求类型的最后执行时间
			this.minimumIntervals = {
				heartbeat: 60000,        // 心跳最短1分钟间隔
				reconcile: 30000,        // 状态同步最短30秒间隔
				roomUpdate: 1000,        // 房间更新最短1秒间隔
				studentUpdate: 2000,     // 学生更新最短2秒间隔
				syncToCloud: 10000       // 云端同步最短10秒间隔
			};
		}
		
		canExecute(requestType, identifier = '') {
			const key = `${requestType}_${identifier}`;
			const now = Date.now();
			const lastTime = this.requests.get(key) || 0;
			const minInterval = this.minimumIntervals[requestType] || 5000;
			
			if (now - lastTime >= minInterval) {
				this.requests.set(key, now);
				return true;
			}
			
			logInfo(`请求被限流: ${requestType} ${identifier}, 还需等待 ${Math.round((minInterval - (now - lastTime))/1000)}秒`);
			return false;
		}
		
		reset(requestType, identifier = '') {
			const key = `${requestType}_${identifier}`;
			this.requests.delete(key);
		}
	}
	
	// 全局请求限流器
	const requestThrottler = new RequestThrottler();

	// 全局定时器管理器
	class TimerManager {
		constructor() {
			this.timers = new Map();
		}
		
		setInterval(name, callback, interval) {
			this.clearTimer(name);
			const id = setInterval(callback, interval);
			this.timers.set(name, { id, type: 'interval' });
			return id;
		}
		
		setTimeout(name, callback, delay) {
			this.clearTimer(name);
			const id = setTimeout(() => {
				this.timers.delete(name);
				callback();
			}, delay);
			this.timers.set(name, { id, type: 'timeout' });
			return id;
		}
		
		clearTimer(name) {
			const timer = this.timers.get(name);
			if (timer) {
				if (timer.type === 'interval') {
					clearInterval(timer.id);
				} else {
					clearTimeout(timer.id);
				}
				this.timers.delete(name);
			}
		}
		
		clearAllTimers() {
			for (const [name, timer] of this.timers) {
				if (timer.type === 'interval') {
					clearInterval(timer.id);
				} else {
					clearTimeout(timer.id);
				}
			}
			this.timers.clear();
			logInfo('已清理所有定时器');
		}
	}
	
	// 全局定时器管理器实例
	const timerManager = new TimerManager();
	
	// 🕐 服务器时间同步系统
	class ServerTimeSync {
		constructor() {
			this.serverTimeOffset = 0; // 服务器时间 - 本地时间的偏移量(ms)
			this.lastSyncTime = 0;
			this.syncInterval = 5 * 60 * 1000; // 每5分钟同步一次
			this.isInitialized = false;
			this.syncInProgress = false;
		}
		
		// 初始化时间同步
		async init() {
			if (this.isInitialized) return;
			
			// 先设置默认值，确保系统可以工作
			this.serverTimeOffset = 0;
			this.isInitialized = true;
			
			try {
				// 异步进行首次同步
				await this.syncWithServer();
				this.startPeriodicSync();
			} catch (error) {
				logWarn('服务器时间同步初始化失败，使用本地时间:', error.message);
				// 即使同步失败，也启动定期同步尝试
				this.startPeriodicSync();
			}
		}
		
		// 与服务器同步时间
		async syncWithServer() {
			if (this.syncInProgress || !supabaseClient) return;
			this.syncInProgress = true;
			try {
				// 简化策略：由于无法获取真实服务器时间戳，仅做连通性检测
				// 实际时间偏移保持为0，避免异常的巨大偏移值
				const t0 = performance.now();
				const { data, error } = await supabaseClient
					.from('rooms')
					.select('name')
					.limit(1);
				const t1 = performance.now();
				
				if (error) {
					this.failCount = (this.failCount||0) + 1;
					logWarn('[TimeSync] 连接测试失败，保留旧偏移 (failCount=' + this.failCount + ')');
					return;
				}
				
				// 成功连接，但不计算时间偏移（避免不准确的估算）
				this.rtt = t1 - t0;
				this.lastSyncTime = Date.now();
				this.failCount = 0;
				
				// 检查是否存在异常的巨大偏移值，如果有则重置为0
				const oldOffset = this.serverTimeOffset || 0;
				if (Math.abs(oldOffset) > 24 * 60 * 60 * 1000) { // 超过24小时
					logWarn('[TimeSync] 检测到异常偏移值，重置为0');
					this.serverTimeOffset = 0;
				}
				
			} catch (e) {
				logWarn('[TimeSync] 同步异常: ' + e.message);
			} finally {
				this.syncInProgress = false;
			}
		}
		
		// 启动定期同步
		startPeriodicSync() {
			timerManager.setInterval('serverTimeSync', () => {
				this.syncWithServer();
			}, this.syncInterval);
		}
		
		// 获取服务器同步的当前时间
		now() {
			return Date.now() + this.serverTimeOffset;
		}

		// 诊断状态
		getStatus(){
			return {
				offset: Math.round(this.serverTimeOffset||0),
				lastSync: this.lastSyncTime ? (Date.now()-this.lastSyncTime)+'ms ago' : 'never',
				inProgress: !!this.syncInProgress,
				rtt: Math.round(this.rtt||0),
				failCount: this.failCount||0
			};
		}
		
		// 检查是否需要重新同步
		shouldResync() {
			return (Date.now() - this.lastSyncTime) > this.syncInterval * 2; // 超过2个同步周期
		}
		
		// 手动触发同步
		async manualSync() {
			logInfo('手动触发时间同步...');
			await this.syncWithServer();
		}
	}
	
	// 全局时间同步器
	const serverTimeSync = new ServerTimeSync();
	
	// 🗄️ 计时器状态持久化系统
	class TimerPersistence {
		constructor() {
			this.storageKey = 'yms_timer_states';
			this.maxAge = 24 * 60 * 60 * 1000; // 24小时过期
		}
		
		// 保存计时器状态
		saveTimerStates() {
			const occupiedRooms = Store.rooms.filter(r => r.occupant_student_name && r.registerTime);
			const timerStates = occupiedRooms.map(room => ({
				roomName: room.name,
				occupant_student_name: room.occupant_student_name,
				registerTime: room.registerTime,
				version: room.version,
				savedAt: getServerSyncedTime()
			}));
			
			const data = {
				states: timerStates,
				timestamp: getServerSyncedTime()
			};
			
			try {
				localStorage.setItem(this.storageKey, JSON.stringify(data));
			} catch (e) {
				logWarn('保存计时器状态失败:', e.message);
			}
		}
		
		// 恢复计时器状态
		restoreTimerStates() {
			try {
				const stored = localStorage.getItem(this.storageKey);
				if (!stored) return [];
				
				const data = JSON.parse(stored);
				const now = getServerSyncedTime();
				
				// 检查数据是否过期
				if (now - data.timestamp > this.maxAge) {
					localStorage.removeItem(this.storageKey);
					return [];
				}
				
				return data.states || [];
			} catch (e) {
				logWarn('恢复计时器状态失败:', e.message);
				localStorage.removeItem(this.storageKey);
				return [];
			}
		}
		
		// 清理过期状态
		cleanup() {
			localStorage.removeItem(this.storageKey);
		}
		
		// 同步状态到云端
		async syncStatesToCloud() {
			const occupiedRooms = Store.rooms.filter(r => r.occupant_student_name && r.registerTime);
			if (occupiedRooms.length === 0) return;
			
			try {
				const updates = occupiedRooms.map(room => ({
					name: room.name,
					occupant_student_name: room.occupant_student_name,
					register_time: new Date(room.registerTime).toISOString(),
					version: room.version
				}));
				
				// 批量更新到云端
				for (const update of updates) {
					await supabaseClient
						.from('rooms')
						.upsert(update);
				}
				
				logInfo(`已同步${updates.length}个房间的计时状态到云端`);
			} catch (error) {
				logWarn('同步计时状态到云端失败:', error.message);
			}
		}
	}
	
	// 全局计时器持久化管理器
	const timerPersistence = new TimerPersistence();
	
	// 恢复房间计时器状态
	async function restoreRoomTimerStates() {
		const savedStates = timerPersistence.restoreTimerStates();
		if (savedStates.length === 0) {
			logInfo('无计时器状态需要恢复');
			return;
		}
		
		// 🔧 恢复前进行数据一致性验证
		logInfo('计时器状态恢复前进行数据一致性检查...');
		let validStates = [];
		
		for (const state of savedStates) {
			// 验证该房间在数据库中是否确实被占用
			try {
				const dbRoom = await supabaseClient
					.from('rooms')
					.select('name, occupant_student_name, register_time')
					.eq('name', state.roomName)
					.single();
				
				if (dbRoom.data && dbRoom.data.occupant_student_name) {
					// 数据库确认房间被占用，状态有效
					validStates.push(state);
				} else {
					// 数据库显示房间为空，缓存状态无效
					logWarn(`[TimerRestore] 房间 ${state.roomName} 缓存显示占用但数据库为空，跳过恢复`);
				}
			} catch (error) {
				// 查询失败，保守起见跳过该状态
				logWarn(`[TimerRestore] 验证房间 ${state.roomName} 状态失败:`, error.message);
			}
		}
		
		if (validStates.length < savedStates.length) {
			const invalidCount = savedStates.length - validStates.length;
			logWarn(`[TimerRestore] 发现 ${invalidCount} 个无效缓存状态，已过滤`);
			toast(`过滤了 ${invalidCount} 个过期的房间状态`, 'warn');
		}
		
		let restoredCount = 0;
		const now = getServerSyncedTime();
		
		validStates.forEach(state => {
			const room = Store.byName.get(state.roomName);
			if (!room) {
				logWarn(`恢复计时器状态失败：房间 ${state.roomName} 不存在`);
				return;
			}
			
			// 检查状态是否仍然有效（避免恢复过期状态）
			const ageHours = (now - state.registerTime) / (1000 * 60 * 60);
			if (ageHours > 12) { // 超过12小时的状态不恢复
				logWarn(`跳过过期计时器状态：${state.roomName} (${ageHours.toFixed(1)}小时前)`);
				return;
			}
			
			// 只有当前房间是空闲状态时才恢复
			if (!room.occupant_student_name) {
				room.occupant_student_name = state.occupant_student_name || state.occupant;
				room.registerTime = state.registerTime;
				room.version = state.version;
				restoredCount++;
				logInfo(`恢复计时器状态：${state.roomName} -> ${state.occupant_student_name || state.occupant}`);
			}
		});
		
		if (restoredCount > 0) {
			logInfo(`成功恢复 ${restoredCount} 个房间的计时器状态`);
			
			// 异步同步状态到云端
			setTimeout(() => {
				timerPersistence.syncStatesToCloud();
			}, 2000);
		}
	}
	
	// 获取服务器同步的时间（供全局使用）
	function getServerSyncedTime() {
		try {
			// 简化逻辑：直接返回本地时间，避免时间同步问题
			return Date.now();
		} catch (error) {
			logWarn('获取同步时间失败，使用本地时间:', error.message);
			return Date.now();
		}
	}
	
	// 🕐 全局计时器更新系统
	function updateAllRoomTimers() {
		const now = getServerSyncedTime();
		let needsFullRerender = [];
		
		// 批量处理所有占用的房间
		Store.rooms.forEach(room => {
			if (!room.occupant_student_name || !room.registerTime) return;
			
			const roomCard = document.querySelector(`[data-room="${CSS.escape(room.name)}"]`);
			if (!roomCard) return;
			
			const chip = roomCard.querySelector('.chip');
			if (!chip) return;
			
			const currentStatus = roomCard.dataset.status;
			const newStatusInfo = statusInfo(room);
			
			// 如果状态发生改变（preparing -> occupied -> overtime），需要完整重渲染
			if (currentStatus !== newStatusInfo.state) {
				needsFullRerender.push(room.name);
				return;
			}
			
			// 状态相同，只更新文本内容
			if (chip.textContent !== newStatusInfo.chip) {
				chip.textContent = newStatusInfo.chip;
			}
		});
		
		// 批量重渲染需要状态更新的房间
		needsFullRerender.forEach(roomName => {
			renderRoomCard(roomName);
		});
		
		// 性能监控：如果需要重渲染的房间过多，记录警告
		if (needsFullRerender.length > 5) {
			logWarn(`计时器更新触发了${needsFullRerender.length}个房间的完整重渲染`);
		}
		
		// 🔍 定期验证registerTime字段一致性
		if (consistencyValidator) {
			consistencyValidator.validateRegisterTimeConsistency();
		}
	}
	
	// 页面卸载时清理所有定时器
	window.addEventListener('beforeunload', () => {
		timerManager.clearAllTimers();
		
		// 清理其他可能的定时器
		if (window.__heartbeatInterval) clearInterval(window.__heartbeatInterval);
		if (window.__periodicStateCheckInterval) clearInterval(window.__periodicStateCheckInterval);
		if (window.__operationTimeoutInterval) clearInterval(window.__operationTimeoutInterval);
		if (window.__roomsRealtimeReconnectTimer) clearTimeout(window.__roomsRealtimeReconnectTimer);
		if (window.__studentsRealtimeReconnectTimer) clearTimeout(window.__studentsRealtimeReconnectTimer);
		
		// 清理realtime连接
		if (realtimeChannel) {
			try { supabaseClient?.removeChannel(realtimeChannel); } catch(e) {}
		}
		if (window.studentRealtimeChannel) {
			try { supabaseClient?.removeChannel(window.studentRealtimeChannel); } catch(e) {}
		}
	});

	// Realtime连接监控和自动修复
	class RealtimeMonitor {
		constructor() {
			this.lastActivity = Date.now();
			this.healthCheckInterval = null;
			this.connectionIssues = 0;
			this.maxConnectionIssues = 3;
			this.isReconnecting = false;
			this.lastReconnectAttempt = 0;
			this.reconnectCooldown = 10000; // 10秒冷却时间
			this.pageHidden = false;
			this.pageHiddenTime = null;
			this.backgroundTimeoutId = null;
			this.closedEvents = []; // 记录 CLOSED 事件的时间
			this.maxClosedEvents = 3; // 5分钟内最多允许3次 CLOSED
			this.closedEventWindow = 300000; // 5分钟时间窗口
			this.silentMode = false; // 静默模式标记
			this.originalLogFunctions = null; // 原始日志函数的备份
			
			// 监听页面可见性变化
			this.initVisibilityHandling();
		}
		
		start() {
			if (this.healthCheckInterval) return;
			
			this.healthCheckInterval = timerManager.setInterval('realtimeHealth', () => {
				this.checkHealth();
			}, 300000); // 每5分钟检查一次连接健康状态
		}
		
		recordActivity() {
			this.lastActivity = Date.now();
			window.__lastRealtimeActivity = this.lastActivity; // 暴露给全局使用
			this.connectionIssues = 0; // 重置连接问题计数
		}
		
		checkHealth() {
			// 页面隐藏时暂停健康检查
			if (this.pageHidden) {
				return;
			}
			
			const now = Date.now();
			const timeSinceActivity = now - this.lastActivity;
			const timeSinceVisibilityChange = window.__lastVisibilityChange ? now - window.__lastVisibilityChange : 0;
			
			// 如果刚从后台切换回来不久，给连接一些恢复时间
			if (timeSinceVisibilityChange < 30000) { // 30秒内
				logInfo(`页面刚切换回前台 (${Math.round(timeSinceVisibilityChange/1000)}秒前)，跳过健康检查`);
				return;
			}
			
			// 在增强模式下使用更短的超时时间，普通模式下使用更长的超时时间
			const timeoutThreshold = syncEnhancer.isInEnhancedMode() ? 300000 : 600000; // 5分钟 vs 10分钟
			
			if (timeSinceActivity > timeoutThreshold) {
				// 检查是否已在重连中
				if (this.isReconnecting) {
					logInfo(`Realtime健康检查：重连进行中 (${Math.round(timeSinceActivity/60000)}分钟无活动)`);
					return;
				}
				
				// 检查是否已有重连在进行中，避免重复触发
				if (window.__roomsRealtimeReconnectTimer || window.__studentsRealtimeReconnectTimer) {
					logInfo(`Realtime健康检查：重连计时器已运行 (${Math.round(timeSinceActivity/60000)}分钟无活动)`);
					return;
				}
				
				// 先进行连接状态检查
				const connectionHealthy = this.performConnectionStateCheck();
				if (connectionHealthy) {
					logInfo('连接状态检查通过，重置健康检查');
					this.recordActivity();
					return;
				}
				
				this.connectionIssues++;
				const minutes = Math.round(timeSinceActivity/60000);
				logWarn(`Realtime连接健康检查失败 #${this.connectionIssues}: ${minutes}分钟无活动`);
				
				// 在增强模式下更快触发重连，但增加更多检查
				const maxIssues = syncEnhancer.isInEnhancedMode() ? 2 : this.maxConnectionIssues;
				if (this.connectionIssues >= maxIssues) {
					logWarn('Realtime连接疑似断开，尝试重新连接');
					this.forceReconnectWithCooldown();
				}
			} else {
				// 连接正常，重置问题计数
				if (this.connectionIssues > 0) {
					logInfo(`Realtime连接恢复正常，重置问题计数 (之前${this.connectionIssues}次)`);
					this.connectionIssues = 0;
				}
			}
		}
		
		async forceReconnectWithCooldown() {
			const now = Date.now();
			
			// 检查冷却时间
			if (now - this.lastReconnectAttempt < this.reconnectCooldown) {
				logInfo(`Realtime重连冷却中，剩余${Math.round((this.reconnectCooldown - (now - this.lastReconnectAttempt))/1000)}秒`);
				return;
			}
			
			// 检查是否已在重连中
			if (this.isReconnecting) {
				logInfo('Realtime重连已在进行中，跳过');
				return;
			}
			
			this.lastReconnectAttempt = now;
			await this.forceReconnect();
		}

		async forceReconnect() {
			if (this.isReconnecting) {
				logInfo('Realtime重连已在进行中，跳过重复操作');
				return;
			}
			
			this.isReconnecting = true;
			
			try {
				logInfo('开始Realtime强制重连...');
				
				// 重置连接状态
				window.__roomsRealtimeInit = false;
				window.__roomsRealtimeReconnecting = false;
				window.__roomsRealtimeAttempts = 0;
				window.__studentsRealtimeAttempts = 0;
				
				// 清理现有连接
				if (realtimeChannel) {
					try { 
						logInfo('清理现有房间实时连接');
						supabaseClient?.removeChannel(realtimeChannel); 
						realtimeChannel = null;
					} catch(e) {
						logWarn('清理房间连接失败:', e.message);
					}
				}
				if (window.studentRealtimeChannel) {
					try { 
						logInfo('清理现有学生实时连接');
						supabaseClient?.removeChannel(window.studentRealtimeChannel); 
						window.studentRealtimeChannel = null;
					} catch(e) {
						logWarn('清理学生连接失败:', e.message);
					}
				}
				
				// 等待一段时间让连接完全清理
				await new Promise(resolve => setTimeout(resolve, 2000));
				
				// 重新建立连接
				await setupRealtime();
				
				this.connectionIssues = 0;
				this.recordActivity();
				
				logInfo('Realtime连接重新建立成功');
				toast('实时连接已恢复', 'success');
				
			} catch (error) {
				logErr('强制重连失败:', error.message);
				toast('实时连接恢复失败', 'error');
				
				// 重连失败后，延迟再次尝试
				setTimeout(() => {
					if (!this.pageHidden) {
						this.forceReconnectWithCooldown();
					}
				}, 30000); // 30秒后再次尝试
				
			} finally {
				this.isReconnecting = false;
			}
		}
		
		initVisibilityHandling() {
			// 监听页面可见性变化
			document.addEventListener('visibilitychange', () => {
				window.__lastVisibilityChange = Date.now();
				
				if (document.hidden) {
					this.pageHidden = true;
					this.pageHiddenTime = Date.now();
					
					// 🔇 进入静默模式，减少后台日志
					this.enterSilentMode();
					
					logInfo('页面切换到后台，进入静默模式');
					
					// 清理重连计时器，避免后台重连
					this.clearReconnectTimers();
					
					// 设置后台超时检查
					this.backgroundTimeoutId = setTimeout(() => {
						if (this.pageHidden) {
							console.debug('页面后台时间过长，主动断开连接以节省资源');
							this.cleanupConnectionsForBackground();
						}
					}, 900000); // 15分钟后主动清理连接（延长时间）
					
				} else {
					// 🔊 退出静默模式，恢复正常日志
					this.exitSilentMode();
					
					this.pageHidden = false;
					const hiddenDuration = Date.now() - (this.pageHiddenTime || Date.now());
					
					// 只有长时间后台才记录日志
					if (hiddenDuration > 300000) { // 超过5分钟才记录
						logInfo(`页面切换到前台，后台时长: ${Math.round(hiddenDuration/60000)}分钟`);
					}
					
					// 清理后台超时检查
					if (this.backgroundTimeoutId) {
						clearTimeout(this.backgroundTimeoutId);
						this.backgroundTimeoutId = null;
					}
					
					// 页面回到前台时，检查连接状态
					setTimeout(() => {
						this.handlePageVisible(hiddenDuration);
					}, 3000); // 延迟3秒，等待连接稳定
				}
			});
		}
		
		handlePageVisible(hiddenDuration = 0) {
			const now = Date.now();
			const timeSinceActivity = now - this.lastActivity;
			
			// 🔧 页面切换回前台时进行数据一致性验证（仅在长时间后台且有必要时）
			if (hiddenDuration > 300000 && DataConsistencyValidator) { // 后台超过5分钟才验证
				// 检查是否需要验证（避免频繁验证）
				const lastValidation = window.__lastConsistencyCheck || 0;
				const timeSinceLastCheck = Date.now() - lastValidation;
				
				if (timeSinceLastCheck > 300000) { // 距离上次验证超过5分钟
					setTimeout(async () => {
						try {
							logInfo(`[PageVisible] 页面后台 ${Math.round(hiddenDuration/60000)} 分钟，进行数据一致性验证`);
							const validation = await DataConsistencyValidator.validateOnPageLoad();
							if (validation.issues > 0) {
								logWarn(`[PageVisible] 发现 ${validation.issues} 个数据一致性问题，已自动修复`);
								toast(`页面恢复时修复了 ${validation.issues} 个数据问题`, 'warn');
							}
							// 记录验证时间
							window.__lastConsistencyCheck = Date.now();
						} catch (error) {
							logErr('[PageVisible] 数据一致性验证失败:', error.message);
						}
					}, 8000); // 延迟8秒执行，避免与连接重建冲突
				}
			}
			
			// 根据后台时长决定重连策略
			if (hiddenDuration > 600000) { // 超过10分钟
				logInfo(`页面后台超过10分钟 (${Math.round(hiddenDuration/60000)}分钟)，强制重建连接`);
				this.forceFullReconnect();
			} else if (hiddenDuration > 300000 || timeSinceActivity > 300000) { // 超过5分钟
				logInfo(`页面切换回前台，检测到${Math.round(Math.max(hiddenDuration, timeSinceActivity)/60000)}分钟无活动，主动重连`);
				this.forceReconnectWithCooldown();
			} else {
				// 检查连接健康状态
				this.checkConnectionHealth();
				// 重置活动时间，避免误报
				this.recordActivity();
			}
			
			// 同步最新数据状态（在连接重建后进行）
			setTimeout(() => {
				this.syncDataAfterReturn(hiddenDuration);
			}, 3000); // 等待连接稳定后再同步数据
		}
		
		clearReconnectTimers() {
			// 清理房间重连计时器
			if (window.__roomsRealtimeReconnectTimer) {
				clearTimeout(window.__roomsRealtimeReconnectTimer);
				window.__roomsRealtimeReconnectTimer = null;
				logInfo('已清理房间重连计时器');
			}
			
			// 清理学生重连计时器
			if (window.__studentsRealtimeReconnectTimer) {
				clearTimeout(window.__studentsRealtimeReconnectTimer);
				window.__studentsRealtimeReconnectTimer = null;
				logInfo('已清理学生重连计时器');
			}
		}
		
		cleanupConnectionsForBackground() {
			logInfo('执行后台连接清理...');
			
			try {
				// 优雅地关闭现有连接
				if (window.supabase && window.supabase.realtime) {
					window.supabase.realtime.disconnect();
					logInfo('已断开Supabase Realtime连接');
				}
				
				// 重置连接状态标志
				window.__roomsRealtimeInit = false;
				window.__studentsRealtimeInit = false;
				window.__roomsRealtimeReconnecting = false;
				window.__studentsRealtimeReconnecting = false;
				
				// 清理所有重连计时器
				this.clearReconnectTimers();
				
			} catch (error) {
				logErr('后台连接清理失败:', error.message);
			}
		}
		
		async forceFullReconnect() {
			logInfo('执行完整连接重建...');
			
			try {
				// 先清理现有连接
				this.cleanupConnectionsForBackground();
				
				// 等待一段时间让清理完成
				await new Promise(resolve => setTimeout(resolve, 3000));
				
				// 重新初始化连接
				await this.initializeConnections();
				
				logInfo('完整连接重建完成');
				toast('实时连接已重新建立', 'success');
				
			} catch (error) {
				logErr('完整连接重建失败:', error.message);
				toast('连接重建失败，请刷新页面', 'error');
			}
		}
		
		async initializeConnections() {
			try {
				// 重置连接管理器状态
				if (window.ConnectionManager && window.ConnectionManager.resetAllConnections) {
					window.ConnectionManager.resetAllConnections(true);
				}
				
				// 等待状态重置完成
				await new Promise(resolve => setTimeout(resolve, 1000));
				
				// 重新初始化房间连接
				if (window.initRoomsRealtimeUpdates && typeof window.initRoomsRealtimeUpdates === 'function') {
					logInfo('重新初始化房间连接...');
					await window.initRoomsRealtimeUpdates();
				}
				
				// 重新初始化学生连接
				if (window.initStudentsRealtimeUpdates && typeof window.initStudentsRealtimeUpdates === 'function') {
					logInfo('重新初始化学生连接...');
					await window.initStudentsRealtimeUpdates();
				}
				
				// 重新初始化练习提醒连接
				if (window.PracticeAlerts && window.PracticeAlerts.init) {
					logInfo('重新初始化练习提醒连接...');
					window.PracticeAlerts.init();
				}
				
				// 重置活动时间
				this.recordActivity();
				
				logInfo('所有连接重新初始化完成');
				
			} catch (error) {
				logErr('连接初始化失败:', error.message);
				throw error;
			}
		}
		
		checkConnectionHealth() {
			// 检查Supabase连接状态
			if (window.supabase && window.supabase.realtime) {
				const state = window.supabase.realtime.connection?.readyState;
				logInfo(`连接健康检查 - 状态: ${this.getConnectionState(state)}`);
				
				// 如果连接已断开，尝试重连
				if (state === 3) { // CLOSED
					logWarn('检测到连接已断开，尝试重连');
					this.forceReconnectWithCooldown();
				}
			}
		}
		
		getConnectionState(state) {
			const states = {
				0: 'CONNECTING',
				1: 'OPEN', 
				2: 'CLOSING',
				3: 'CLOSED'
			};
			return states[state] || 'UNKNOWN';
		}
		
		performConnectionStateCheck() {
			try {
				// 检查 Supabase 客户端状态
				if (window.supabase && window.supabase.realtime) {
					const connection = window.supabase.realtime.connection;
					if (connection) {
						const state = connection.readyState;
						const stateStr = this.getConnectionState(state);
						logInfo(`Supabase连接状态: ${stateStr} (${state})`);
						
						// 如果连接已断开，返回不健康
						if (state === 3) { // CLOSED
							return false;
						}
						
						// 如果连接正常，检查通道状态
						if (state === 1) { // OPEN
							let channelsHealthy = true;
							
							// 检查房间通道
							if (window.supabase.realtime.channels) {
								const channels = window.supabase.realtime.channels;
								logInfo(`检查到 ${channels.length} 个活跃通道`);
								
								channels.forEach((channel, index) => {
									const channelState = channel.state;
									logInfo(`通道 ${index + 1} 状态: ${channelState}`);
									
									if (channelState === 'errored' || channelState === 'closed') {
										channelsHealthy = false;
									}
								});
							}
							
							return channelsHealthy;
						}
					}
				}
				
				// 额外检查：验证数据更新是否正常
				const lastDataUpdate = window.__lastRealtimeDataUpdate || 0;
				const timeSinceUpdate = Date.now() - lastDataUpdate;
				
				if (lastDataUpdate > 0 && timeSinceUpdate < 600000) { // 10分钟内有数据更新
					logInfo(`最近数据更新: ${Math.round(timeSinceUpdate/60000)}分钟前，连接健康`);
					return true;
				}
				
				logWarn('连接状态检查：无法确认连接健康状态');
				return false;
				
			} catch (error) {
				logErr('连接状态检查失败:', error.message);
				return false;
			}
		}
		
		async syncDataAfterReturn(hiddenDuration) {
			try {
				logInfo(`页面返回后开始数据同步，后台时长: ${Math.round(hiddenDuration/60000)}分钟`);
				
				// 记录同步开始时间
				const syncStartTime = Date.now();
				
				// 根据后台时长选择同步策略
				if (hiddenDuration > 300000) { // 超过5分钟，进行全量同步
					await this.performFullDataSync();
				} else { // 少于5分钟，进行增量同步
					await this.performIncrementalSync(this.pageHiddenTime);
				}
				
				// 同步计时器和准备状态
				await this.syncTimerStates();
				
				// 刷新UI显示
				this.refreshUIAfterSync();
				
				const syncDuration = Date.now() - syncStartTime;
				logInfo(`数据同步完成，耗时: ${syncDuration}ms`);
				
				// 显示同步完成的通知（仅在后台时间较长时显示）
				if (hiddenDuration > 60000) { // 超过1分钟才显示通知
					const minutes = Math.round(hiddenDuration / 60000);
					toast(`数据已同步完成 (后台${minutes}分钟)`, 'success');
				}
				
				// 执行状态验证检查
				setTimeout(() => {
					this.validateSyncedRoomStates();
				}, 1000); // 等待UI更新完成后检查
				
			} catch (error) {
				logErr('页面返回后数据同步失败:', error.message);
			}
		}
		
		async performFullDataSync() {
			logInfo('执行全量数据同步...');
			
			try {
				// 🔄 数据一致性增强：确保获取最新数据
				logInfo('正在从数据库获取最新房间状态...');
				
				// 同步房间数据
				if (window.fetchRooms && typeof window.fetchRooms === 'function') {
					const rooms = await window.fetchRooms();
					if (rooms && rooms.length > 0) {
						// 记录同步前的房间状态
						const beforeSync = {};
						if (window.Store && window.Store.rooms) {
							window.Store.rooms.forEach(room => {
								if (room.occupant_student_name) {
									beforeSync[room.name] = {
										student: room.occupant_student_name,
										registerTime: room.registerTime,
										timeStr: room.registerTime ? new Date(room.registerTime).toLocaleString() : 'null'
									};
								}
							});
						}
						
						// 🔍 检查是否存在"幽灵占用"（数据库已清空但仍显示占用的房间）
						const dbOccupiedRooms = rooms.filter(r => r.occupant_student_name && r.occupant_student_name.trim() !== '');
						logInfo(`数据库中实际占用房间数: ${dbOccupiedRooms.length}`);
						
						if (dbOccupiedRooms.length > 0) {
							logInfo('数据库中占用的房间:', dbOccupiedRooms.map(r => `${r.name}:${r.occupant_student_name}`));
						}
						
						// 更新房间数据到Store
						if (window.Store && window.Store.rooms) {
							window.Store.rooms = rooms;
							
							// 重建索引以确保 byName 映射正确
							if (window.rebuildIndexes && typeof window.rebuildIndexes === 'function') {
								window.rebuildIndexes();
								logInfo('已重建房间索引');
							}
							
							// 记录同步后的房间状态并对比
							const afterSync = {};
							rooms.forEach(room => {
								if (room.occupant_student_name) {
									afterSync[room.name] = {
										student: room.occupant_student_name,
										registerTime: room.registerTime,
										timeStr: room.registerTime ? new Date(room.registerTime).toLocaleString() : 'null'
									};
								}
							});
							
							// 详细对比日志
							logInfo(`房间数据同步对比:`);
							Object.keys(afterSync).forEach(roomName => {
								const before = beforeSync[roomName];
								const after = afterSync[roomName];
								
								if (!before) {
									logInfo(`  新占用: ${roomName} -> ${after.student} @ ${after.timeStr}`);
								} else if (before.registerTime !== after.registerTime) {
									logInfo(`  时间变更: ${roomName} -> ${after.student}`);
									logInfo(`    原时间: ${before.timeStr}`);
									logInfo(`    新时间: ${after.timeStr}`);
								}
							});
							
							logInfo(`已同步 ${rooms.length} 个房间数据，其中占用 ${Object.keys(afterSync).length} 个`);
						}
					}
				}
				
				// 同步学生数据  
				if (window.fetchStudents && typeof window.fetchStudents === 'function') {
					await window.fetchStudents({ forceFullSync: true });
					logInfo('已执行学生数据全量同步');
				}
				
				// 同步练习提醒数据
				if (window.PracticeAlerts && window.PracticeAlerts.refreshFromCloud) {
					await window.PracticeAlerts.refreshFromCloud();
					logInfo('已同步练习提醒数据');
				}
				
			} catch (error) {
				logErr('全量数据同步失败:', error.message);
				throw error;
			}
		}
		
		async performIncrementalSync(since) {
			logInfo('执行增量数据同步...');
			
			try {
				// 增量同步学生数据
				if (window.fetchStudents && typeof window.fetchStudents === 'function' && since) {
					const sinceTime = new Date(since).toISOString();
					await window.fetchStudents({ 
						incremental: true, 
						since: sinceTime 
					});
					logInfo(`已执行学生数据增量同步，从 ${sinceTime} 开始`);
				}
				
				// 房间数据相对较少，直接全量同步
				if (window.fetchRooms && typeof window.fetchRooms === 'function') {
					const rooms = await window.fetchRooms();
					if (rooms && rooms.length > 0) {
						if (window.Store && window.Store.rooms) {
							// 记录占用房间的时间信息
							const occupiedRooms = rooms.filter(r => r.occupant_student_name);
							occupiedRooms.forEach(room => {
								logInfo(`增量同步房间: ${room.name} -> ${room.occupant_student_name}`);
								if (room.registerTime) {
									const timeStr = new Date(room.registerTime).toLocaleString();
									logInfo(`  registerTime: ${room.registerTime} (${timeStr})`);
								} else {
									logInfo(`  registerTime: null`);
								}
							});
							
							window.Store.rooms = rooms;
							
							// 重建索引以确保 byName 映射正确
							if (window.rebuildIndexes && typeof window.rebuildIndexes === 'function') {
								window.rebuildIndexes();
								logInfo('已重建房间索引');
							}
							
							logInfo(`已同步 ${rooms.length} 个房间数据，其中占用 ${occupiedRooms.length} 个`);
						}
					}
				}
				
			} catch (error) {
				logErr('增量数据同步失败:', error.message);
				// 增量同步失败时，尝试全量同步
				logInfo('增量同步失败，回退到全量同步');
				await this.performFullDataSync();
			}
		}
		
		async syncTimerStates() {
			logInfo('同步计时器和准备状态...');
			
			try {
				// 计时器状态由 renderRooms() 中的 statusInfo() 函数自动计算
				// 这里验证并记录所有房间的时间状态
				
				let occupiedRooms = 0;
				let preparingRooms = 0;
				const roomTimerDetails = [];
				
				if (window.Store && window.Store.rooms) {
					window.Store.rooms.forEach(room => {
						if (room.occupant_student_name) {
							occupiedRooms++;
							
							if (room.registerTime) {
								const now = Date.now();
								const elapsed = Math.floor((now - room.registerTime) / 1000);
								const prepEnd = room.registerTime + 60000; // 60秒准备期
								const isPrep = now < prepEnd;
								
								if (isPrep) {
									preparingRooms++;
									const remaining = Math.ceil((prepEnd - now) / 1000);
									roomTimerDetails.push(`${room.name}: 准备中 ${remaining}s (${room.occupant_student_name})`);
								} else {
									const practiceElapsed = Math.floor((now - prepEnd) / 1000);
									roomTimerDetails.push(`${room.name}: 练习中 ${Math.floor(practiceElapsed/60)}:${(practiceElapsed%60).toString().padStart(2,'0')} (${room.occupant_student_name})`);
								}
							} else {
								roomTimerDetails.push(`${room.name}: 无时间记录 (${room.occupant_student_name})`);
							}
						}
					});
				}
				
				logInfo(`计时器状态同步完成 - 占用房间: ${occupiedRooms}, 准备中: ${preparingRooms}`);
				
				// 详细记录每个房间的计时器状态
				if (roomTimerDetails.length > 0) {
					logInfo('房间计时器详情:');
					roomTimerDetails.forEach(detail => logInfo(`  ${detail}`));
				}
				
			} catch (error) {
				logErr('同步计时器状态失败:', error.message);
			}
		}
		
		refreshUIAfterSync() {
			try {
				// 记录同步前的状态以便比较
				const beforeSync = {
					totalRooms: window.Store ? window.Store.rooms.length : 0,
					occupiedRooms: window.Store ? window.Store.rooms.filter(r => r.occupant_student_name).length : 0,
					totalStudents: window.Store ? window.Store.students.length : 0
				};
				
				// 刷新房间显示
				if (window.renderRooms && typeof window.renderRooms === 'function') {
					window.renderRooms();
					logInfo('房间界面已刷新');
				}
				
				// 刷新学生库
				if (window.StudentLibrary && window.StudentLibrary.refresh) {
					window.StudentLibrary.refresh();
					logInfo('学生库已刷新');
				}
				
				// 刷新练习提醒UI
				if (window.PracticeAlerts && window.PracticeAlerts.renderAlerts) {
					window.PracticeAlerts.renderAlerts();
					logInfo('练习提醒界面已刷新');
				}
				
				// 更新统计信息
				if (window.updateUsageStats && typeof window.updateUsageStats === 'function') {
					window.updateUsageStats();
					logInfo('统计信息已更新');
				}
				
				// 强制重启并更新全局计时器
				this.restartGlobalTimer();
				
				// 记录同步后的状态
				const afterSync = {
					totalRooms: window.Store ? window.Store.rooms.length : 0,
					occupiedRooms: window.Store ? window.Store.rooms.filter(r => r.occupant_student_name).length : 0,
					totalStudents: window.Store ? window.Store.students.length : 0
				};
				
				// 输出状态对比
				logInfo(`UI刷新完成 - 房间: ${afterSync.totalRooms} (占用: ${afterSync.occupiedRooms}), 学生: ${afterSync.totalStudents}`);
				
				// 如果有新的占用房间，特别标记
				if (afterSync.occupiedRooms > beforeSync.occupiedRooms) {
					const newOccupations = afterSync.occupiedRooms - beforeSync.occupiedRooms;
					logInfo(`🆕 检测到 ${newOccupations} 个新占用房间`);
				}
				
			} catch (error) {
				logErr('UI刷新失败:', error.message);
			}
		}
		
		restartGlobalTimer() {
			try {
				// 强制停止现有计时器
				if (window.__globalTimerInterval) {
					clearInterval(window.__globalTimerInterval);
					window.__globalTimerInterval = null;
					logInfo('已停止旧的全局计时器');
				}
				
				// 立即执行一次计时器更新以显示最新状态
				if (window.updateAllRoomTimers && typeof window.updateAllRoomTimers === 'function') {
					window.updateAllRoomTimers();
					logInfo('已执行即时计时器更新');
				}
				
				// 重新启动计时器
				if (!document.hidden) {
					window.__globalTimerInterval = setInterval(() => {
						if (window.updateAllRoomTimers && typeof window.updateAllRoomTimers === 'function') {
							window.updateAllRoomTimers();
						}
					}, 1000);
					logInfo('🔄 全局计时器已重新启动');
				}
				
		} catch (error) {
			logErr('重启全局计时器失败:', error.message);
		}
	}
	
	// 调试函数：检查特定房间的状态
	debugRoomStatus(roomName) {
		try {
			const room = window.Store ? window.Store.byName.get(roomName) : null;
			if (!room) {
				logErr(`房间 ${roomName} 不存在于Store中`);
				return;
			}
			
			logInfo(`=== 房间 ${roomName} 状态调试 ===`);
			logInfo(`占用者: ${room.occupant_student_name || '无'}`);
			logInfo(`registerTime: ${room.registerTime || '无'}`);
			
			if (room.registerTime) {
				const timeStr = new Date(room.registerTime).toLocaleString(); 
				logInfo(`注册时间: ${timeStr}`);
				
				const now = Date.now();
				const elapsed = Math.floor((now - room.registerTime) / 1000);
				const prepEnd = room.registerTime + 60000;
				const inPrep = now < prepEnd;
				
				logInfo(`当前时间: ${new Date(now).toLocaleString()}`);
				logInfo(`经过时间: ${elapsed}秒`);
				logInfo(`是否在准备期: ${inPrep}`);
				
				if (inPrep) {
					const remaining = Math.ceil((prepEnd - now) / 1000);
					logInfo(`剩余准备时间: ${remaining}秒`);
				}
			}
			
			const status = statusInfo(room);
			logInfo(`计算状态: ${status.state}`);
			logInfo(`显示文本: ${status.chip}`);
			
			// 检查DOM中的显示
			const roomCard = document.querySelector(`[data-room="${CSS.escape(roomName)}"]`);
			if (roomCard) {
				const chip = roomCard.querySelector('.chip');
				const currentStatus = roomCard.dataset.status;
				logInfo(`DOM状态: ${currentStatus}`);
				logInfo(`DOM显示: ${chip ? chip.textContent : '无chip元素'}`);
			} else {
				logInfo(`DOM: 未找到房间卡片`);
			}
			
		} catch (error) {
			logErr(`调试房间状态失败:`, error.message);
		}
	}
	
	// 验证同步后的房间状态
	validateSyncedRoomStates() {
		try {
			if (!window.Store || !window.Store.rooms) return;
			
			const occupiedRooms = window.Store.rooms.filter(r => r.occupant_student_name);
			logInfo(`=== 同步后状态验证 (${occupiedRooms.length}个占用房间) ===`);
			
			occupiedRooms.forEach(room => {
				const status = statusInfo(room);
				const roomCard = document.querySelector(`[data-room="${CSS.escape(room.name)}"]`);
				const domStatus = roomCard ? roomCard.dataset.status : 'NOT_FOUND';
				const domChip = roomCard ? roomCard.querySelector('.chip')?.textContent : 'NO_CHIP';
				
				logInfo(`${room.name}: ${room.occupant_student_name}`);
				logInfo(`  计算状态: ${status.state} -> ${status.chip}`);
				logInfo(`  DOM状态: ${domStatus} -> ${domChip}`);
				
				if (status.state !== domStatus || status.chip !== domChip) {
					logWarn(`  ⚠️ 状态不匹配，强制重新渲染`);
					renderRoomCard(room.name);
				}
			});
			
		} catch (error) {
			logErr('状态验证失败:', error.message);
		}
	}		// 检查是否频繁出现 CLOSED 事件
		checkClosedEventFrequency() {
			const now = Date.now();
			
			// 清理过期的事件记录
			this.closedEvents = this.closedEvents.filter(time => now - time < this.closedEventWindow);
			
			// 记录新的 CLOSED 事件
			this.closedEvents.push(now);
			
			// 检查是否超过阈值
			if (this.closedEvents.length > this.maxClosedEvents) {
				logWarn(`检测到频繁的 CLOSED 事件 (${this.closedEvents.length}次在${Math.round(this.closedEventWindow/60000)}分钟内)，暂停自动重连`);
				return true; // 需要暂停重连
			}
			
			return false; // 可以继续重连
		}

		stop() {
			if (this.healthCheckInterval) {
				timerManager.clearTimer('realtimeHealth');
				this.healthCheckInterval = null;
			}
			
			// 清理后台超时检查
			if (this.backgroundTimeoutId) {
				clearTimeout(this.backgroundTimeoutId);
				this.backgroundTimeoutId = null;
			}
			
			// 清理所有重连计时器
			this.clearReconnectTimers();
			
			// 退出静默模式
			this.exitSilentMode();
		}
		
		isActive() {
			return !!this.healthCheckInterval;
		}
		
		// 🔇 进入静默模式：页面在后台时减少日志输出
		enterSilentMode() {
			if (this.silentMode) return;
			
			this.silentMode = true;
			
			// 备份原始日志函数
			if (!this.originalLogFunctions) {
				this.originalLogFunctions = {
					logInfo: window.logInfo,
					logWarn: window.logWarn,
					logErr: window.logErr
				};
			}
			
			// 创建静默版本的日志函数
			const createSilentLogger = (level, originalFn) => {
				return (...args) => {
					const message = args.join(' ');
					// 只有严重错误才在后台记录
					if (level === 'ERR' || 
					    (level === 'WARN' && (message.includes('频繁') || message.includes('失败'))) ||
					    (level === 'INFO' && message.includes('重建连接'))) {
						originalFn(...args);
					} else {
						// 其他日志降级到 console.debug
						console.debug(`[${level}]`, ...args);
					}
				};
			};
			
			// 替换全局日志函数
			window.logInfo = createSilentLogger('INFO', this.originalLogFunctions.logInfo);
			window.logWarn = createSilentLogger('WARN', this.originalLogFunctions.logWarn);
			window.logErr = createSilentLogger('ERR', this.originalLogFunctions.logErr);
		}
		
		// 🔊 退出静默模式：恢复正常日志
		exitSilentMode() {
			if (!this.silentMode || !this.originalLogFunctions) return;
			
			this.silentMode = false;
			
			// 恢复原始日志函数
			window.logInfo = this.originalLogFunctions.logInfo;
			window.logWarn = this.originalLogFunctions.logWarn;
			window.logErr = this.originalLogFunctions.logErr;
		}
		
		// 📶 智能重连策略：根据页面状态和网络状况决定是否重连
		shouldAttemptReconnect(errorType = 'UNKNOWN') {
			// 页面隐藏时不重连
			if (this.pageHidden) {
				return false;
			}
			
			// 刚从后台切换回来，给一些缓冲时间
			const timeSinceVisible = Date.now() - (window.__lastVisibilityChange || 0);
			if (timeSinceVisible < 10000) { // 10秒内
				return false;
			}
			
			// 正在重连中，避免重复
			if (this.isReconnecting) {
				return false;
			}
			
			// 频繁的CLOSED事件，暂停重连
			if (errorType === 'CLOSED' && this.checkClosedEventFrequency()) {
				return false;
			}
			
			// 检查网络状态
			if (navigator.onLine === false) {
				console.debug('网络离线，跳过重连');
				return false;
			}
			
			return true;
		}
		
		// ⏱️ 统一的重连延迟计算
		calculateReconnectDelay(attempts, status) {
			let baseDelay = 2000; // 基础延迟2秒
			
			// 页面隐藏时使用更长的延迟
			if (this.pageHidden || this.silentMode) {
				baseDelay = 10000; // 10秒
			}
			
			if (status === 'CLOSED') {
				baseDelay = Math.max(baseDelay, 4000);
				const now = Date.now();
				const lastClosedTime = window.__lastClosedTime || 0;
				if (now - lastClosedTime < 15000) { // 15秒内多次CLOSED
					baseDelay = Math.min(45000, baseDelay * attempts);
				}
				window.__lastClosedTime = now;
			}
			
			const maxDelay = this.pageHidden || this.silentMode ? 360000 : // 隐藏时最长6分钟
							status === 'CLOSED' ? 240000 : 150000; // CLOSED状态允许更长延迟
			
			return Math.min(maxDelay, Math.round(baseDelay * Math.pow(1.4, attempts-1) + Math.random()*1000));
		}
	}
	
	// 全局realtime监控器
	const realtimeMonitor = new RealtimeMonitor();

	// 多设备同步增强器
	class MultiDeviceSyncEnhancer {
		constructor() {
			this.lastOperationTime = 0;
			this.operationWindow = 30000; // 30秒内的操作认为是"活跃期"
			this.enhancedMode = false;
		}
		
		// 记录用户操作，进入增强同步模式
		recordUserOperation() {
			this.lastOperationTime = Date.now();
			if (!this.enhancedMode) {
				this.enterEnhancedMode();
			}
		}
		
		// 进入增强同步模式：主要用于连接监控，不再提高心跳频率
		enterEnhancedMode() {
			this.enhancedMode = true;
			logInfo('进入增强同步模式：增强连接监控');
			
			// 🚫 取消增强模式的高频心跳 - realtime已经足够实时
			// 增强模式现在只影响连接健康检查的频率，不额外发送心跳请求
			
			// 设置退出增强模式的定时器
			setTimeout(() => {
				this.exitEnhancedMode();
			}, this.operationWindow);
		}
		
		// 退出增强模式，恢复正常频率
		exitEnhancedMode() {
			if (!this.enhancedMode) return;
			
			const timeSinceLastOp = Date.now() - this.lastOperationTime;
			if (timeSinceLastOp < this.operationWindow) {
				// 如果还在操作窗口内，延迟退出
				setTimeout(() => this.exitEnhancedMode(), this.operationWindow - timeSinceLastOp);
				return;
			}
			
			this.enhancedMode = false;
			logInfo('退出增强同步模式：恢复正常监控频率');
			
			// 🚫 不再需要恢复心跳频率，因为增强模式不再改变心跳
		}
		

		
		isInEnhancedMode() {
			return this.enhancedMode;
		}
	}
	
	// 全局多设备同步增强器
	const syncEnhancer = new MultiDeviceSyncEnhancer();
	
	// 🔍 多设备同步一致性验证器
	class SyncConsistencyValidator {
		constructor() {
			this.lastValidationTime = 0;
			this.validationInterval = 30000; // 30秒验证一次，减少频率
			this.initializationGracePeriod = 10000; // 页面初始化后10秒内不进行验证
			this.startTime = Date.now(); // 记录创建时间
		}
		
		// 验证registerTime字段的一致性
		validateRegisterTimeConsistency() {
			const now = Date.now();
			
			// 页面初始化期间跳过验证，避免初始化数据不一致的误报
			if (now - this.startTime < this.initializationGracePeriod) {
				return;
			}
			
			if (now - this.lastValidationTime < this.validationInterval) return;
			
			this.lastValidationTime = now;
			let inconsistencies = 0;
			let fixedInconsistencies = 0;
			
			Store.rooms.forEach(room => {
				// 只检查有占用者的房间
				if (!room.occupant_student_name) {
					// 空闲房间应该两个字段都为空，如果不是则静默修复
					if (room.registerTime !== null || room.register_time !== null) {
						room.registerTime = null;
						room.register_time = null;
						fixedInconsistencies++;
					}
					return;
				}
				
				// 检查占用房间的时间字段一致性
				const hasValidRegisterTime = room.registerTime !== null && room.registerTime !== undefined && !isNaN(room.registerTime);
				const hasValidRegisterTimeRaw = room.register_time !== null && room.register_time !== undefined && room.register_time !== '';
				
				// 如果两个字段都有值，检查是否对应
				if (hasValidRegisterTime && hasValidRegisterTimeRaw) {
					const registerTimeFromRaw = toMs(room.register_time);
					const timeDiff = Math.abs(room.registerTime - registerTimeFromRaw);
					
					// 允许最多1秒的误差（数据库精度问题）
					if (timeDiff > 1000) {
						inconsistencies++;
						logWarn(`房间 ${room.name} 时间字段数值不匹配: registerTime=${room.registerTime} (${new Date(room.registerTime).toLocaleString()}), register_time=${room.register_time}`);
						
						// 优先使用registerTime（本地时间戳）
						room.register_time = new Date(room.registerTime).toISOString();
						fixedInconsistencies++;
					}
				}
				// 如果只有一个字段有值，补充另一个字段
				else if (hasValidRegisterTime && !hasValidRegisterTimeRaw) {
					room.register_time = new Date(room.registerTime).toISOString();
					fixedInconsistencies++;
				}
				else if (!hasValidRegisterTime && hasValidRegisterTimeRaw) {
					room.registerTime = toMs(room.register_time);
					fixedInconsistencies++;
				}
				// 如果两个字段都没有有效值，这是异常情况
				else if (!hasValidRegisterTime && !hasValidRegisterTimeRaw) {
					inconsistencies++;
					logWarn(`房间 ${room.name} 有占用者但缺少时间信息: ${room.occupant_student_name}`);
				}
			});
			
			// 只在有真正的不一致问题时才输出日志
			if (inconsistencies > 0) {
				logWarn(`🔧 检测到 ${inconsistencies} 个严重时间字段问题，已自动修复 ${fixedInconsistencies} 个`);
			} else if (fixedInconsistencies > 0 && fixedInconsistencies <= 3) {
				// 少量修复时静默处理，避免刷屏
				console.debug(`🔧 静默修复了 ${fixedInconsistencies} 个时间字段格式问题`);
			} else if (fixedInconsistencies > 3) {
				// 大量修复时才输出警告
				logInfo(`🔧 批量修复了 ${fixedInconsistencies} 个时间字段格式问题`);
			}
			
			// 如果有修复，触发一次计时器更新
			if (fixedInconsistencies > 0 && window.updateAllRoomTimers) {
				window.updateAllRoomTimers();
			}
		}
	}
	
	// 全局一致性验证器
	const consistencyValidator = new SyncConsistencyValidator();
	
	// 初始化数据规范化函数
	function normalizeInitialData() {
		let normalizedCount = 0;
		
		Store.rooms.forEach(room => {
			// 确保空闲房间的时间字段为空
			if (!room.occupant_student_name) {
				if (room.registerTime !== null || room.register_time !== null) {
					room.registerTime = null;
					room.register_time = null;
					normalizedCount++;
				}
			}
			// 确保占用房间的时间字段同步
			else {
				const hasValidRegisterTime = room.registerTime !== null && room.registerTime !== undefined && !isNaN(room.registerTime);
				const hasValidRegisterTimeRaw = room.register_time !== null && room.register_time !== undefined && room.register_time !== '';
				
				if (hasValidRegisterTime && !hasValidRegisterTimeRaw) {
					room.register_time = new Date(room.registerTime).toISOString();
					normalizedCount++;
				} else if (!hasValidRegisterTime && hasValidRegisterTimeRaw) {
					room.registerTime = toMs(room.register_time);
					normalizedCount++;
				}
			}
		});
		
		if (normalizedCount > 0) {
			console.debug(`📋 初始化时规范化了 ${normalizedCount} 个房间的时间字段格式`);
		}
	}

	// 请求统计器
	class RequestStats {
		constructor() {
			this.stats = {
				heartbeat: { count: 0, lastTime: 0 },
				reconcile: { count: 0, lastTime: 0 },
				roomUpdate: { count: 0, lastTime: 0 },
				studentUpdate: { count: 0, lastTime: 0 },
				syncToCloud: { count: 0, lastTime: 0 },
				realtimeEvents: { count: 0, lastTime: 0 }
			};
			this.startTime = Date.now();
		}
		
		record(type) {
			if (this.stats[type]) {
				this.stats[type].count++;
				this.stats[type].lastTime = Date.now();
			}
		}
		
		getReport() {
			const now = Date.now();
			const uptime = Math.round((now - this.startTime) / 1000 / 60); // 分钟
			let report = `\n=== 请求统计报告 (运行时间: ${uptime}分钟) ===\n`;
			
			for (const [type, stat] of Object.entries(this.stats)) {
				const rate = uptime > 0 ? (stat.count / uptime).toFixed(2) : '0.00';
				const lastTime = stat.lastTime > 0 ? `${Math.round((now - stat.lastTime)/1000)}秒前` : '从未';
				report += `${type}: ${stat.count}次 (${rate}/分钟) 最后: ${lastTime}\n`;
			}
			
			return report;
		}
		
		reset() {
			for (const stat of Object.values(this.stats)) {
				stat.count = 0;
				stat.lastTime = 0;
			}
			this.startTime = Date.now();
		}
	}
	
	// 全局请求统计器
	const requestStats = new RequestStats();
	
	// 紧急刹车系统
	class EmergencyBrake {
		constructor() {
			this.engaged = false;
			this.reason = '';
		}
		
		engage(reason) {
			if (!this.engaged) {
				this.engaged = true;
				this.reason = reason;
				logWarn(`紧急刹车激活: ${reason}`);
				updateSyncStatus('error', '紧急模式');
				toast(`⚠️ 系统进入紧急模式: ${reason}`, 'warn');
				
				// 停止所有定时器
				timerManager.clearAllTimers();
				
				// 断开realtime连接以减少服务器压力
				if (realtimeChannel) {
					try { supabaseClient?.removeChannel(realtimeChannel); } catch(e) {}
				}
				if (window.studentRealtimeChannel) {
					try { supabaseClient?.removeChannel(window.studentRealtimeChannel); } catch(e) {}
				}
			}
		}
		
		disengage() {
			if (this.engaged) {
				this.engaged = false;
				this.reason = '';
				logInfo('紧急刹车解除，系统恢复正常');
				updateSyncStatus('disconnected', '正在恢复...');
				toast('系统正在恢复正常模式...', 'info');
				
				// 延迟重新建立连接，避免立即重新触发问题
				setTimeout(async () => {
					try {
						if (supabaseReady) {
							await setupRealtime();
							realtimeMonitor.start();
							updateSyncStatus('connected', '已恢复');
							toast('系统已恢复正常', 'success');
						}
					} catch (error) {
						logErr('系统恢复失败:', error.message);
					}
				}, 30000); // 30秒后恢复
			}
		}
		
		isEngaged() {
			return this.engaged;
		}
	}
	
	// 全局紧急刹车系统
	const emergencyBrake = new EmergencyBrake();
	
	// 暴露到全局供调试使用
	window.debugStats = {
		getReport: () => console.log(requestStats.getReport()),
		reset: () => requestStats.reset(),
		throttler: requestThrottler,
		monitor: realtimeMonitor,
		emergencyBrake: emergencyBrake,
		syncEnhancer: syncEnhancer,
		// 时间同步
		timeSyncStatus: () => serverTimeSync.getStatus(),
		syncTime: () => serverTimeSync.syncWithServer(),
		
		// 紧急停止所有realtime功能
		emergencyStop: (reason = '手动停止') => emergencyBrake.engage(reason),
		
		// 恢复realtime功能
		resume: () => emergencyBrake.disengage(),
		
		// 手动触发增强同步模式
		enhanceSync: () => {
			syncEnhancer.recordUserOperation();
			console.log('已手动触发增强同步模式');
		},
		
		// 检查当前同步状态
		getSyncStatus: () => {
			return {
				enhancedMode: syncEnhancer.isInEnhancedMode(),
				emergencyBrake: emergencyBrake.isEngaged(),
				realtimeActivity: Date.now() - realtimeMonitor.lastActivity
			};
		},
		
		// 手动测试转移功能
		testTransfer: (fromRoom, toRoom, studentName) => {
			transferStudent(fromRoom, toRoom, studentName);
			console.log(`正在测试转移: ${studentName} 从 ${fromRoom} 到 ${toRoom}`);
		},
		
		// 获取详细的Realtime连接状态
		getRealtimeStatus: () => ({
			lastActivity: realtimeMonitor.lastActivity,
			connectionIssues: realtimeMonitor.connectionIssues,
			healthCheckActive: !!realtimeMonitor.healthCheckInterval,
			roomChannelState: realtimeChannel?.state || 'unknown',
			studentChannelState: window.studentRealtimeChannel?.state || 'unknown',
			roomReconnectTimer: !!window.__roomsRealtimeReconnectTimer,
			studentReconnectTimer: !!window.__studentsRealtimeReconnectTimer,
			roomAttempts: window.__roomsRealtimeAttempts || 0,
			studentAttempts: window.__studentsRealtimeAttempts || 0
		}),
		
		// 一键诊断函数
		diagnoseIssues: () => {
			const now = Date.now();
			const diagnostics = {
				timestamp: new Date().toISOString(),
				supabaseReady: !!supabaseClient,
				realtimeChannels: {
					rooms: realtimeChannel ? {
						state: realtimeChannel.state,
						topic: realtimeChannel.topic,
						joinedAt: realtimeChannel.joinedAt
					} : null,
					students: window.studentRealtimeChannel ? {
						state: window.studentRealtimeChannel.state,
						topic: window.studentRealtimeChannel.topic,
						joinedAt: window.studentRealtimeChannel.joinedAt
					} : null
				},
				studentLibrary: {
					count: window.StudentLibrary ? (function() {
						try { return window.StudentLibrary.list().length; } catch(e) { return 'error'; }
					})() : 'not-loaded'
				},
				storeStatus: {
					roomCount: Store.rooms.length,
					studentCount: Store.students.length
				},
				reconnectState: {
					roomReconnecting: window.__roomsRealtimeReconnecting || false,
					lastClosedTime: window.__lastClosedTime || 0,
					lastStudentClosedTime: window.__lastStudentClosedTime || 0
				}
			};
			
			const issues = [];
			const suggestions = [];
			
			if (!diagnostics.supabaseReady) issues.push('Supabase客户端未就绪');
			if (diagnostics.realtimeChannels.rooms?.state !== 'joined') issues.push(`房间通道状态异常: ${diagnostics.realtimeChannels.rooms?.state || 'null'}`);
			if (diagnostics.realtimeChannels.students?.state !== 'joined') issues.push(`学生通道状态异常: ${diagnostics.realtimeChannels.students?.state || 'null'}`);
			if (realtimeMonitor.connectionIssues > 0) issues.push(`连接问题计数: ${realtimeMonitor.connectionIssues}`);
			if (window.__roomsRealtimeAttempts > 5) issues.push(`房间重连次数过多: ${window.__roomsRealtimeAttempts}`);
			if (window.__studentsRealtimeAttempts > 5) issues.push(`学生重连次数过多: ${window.__studentsRealtimeAttempts}`);
			
			const report = {
				timestamp: diagnostics.timestamp,
				issues: issues.length > 0 ? issues : ['无明显问题'],
				suggestions: suggestions,
				fullDiagnostics: diagnostics
			};
			
			if (issues.length > 0) {
				suggestions.push('尝试刷新页面重新建立连接');
				if (diagnostics.reconnectState.roomReconnecting) {
					suggestions.push('房间数据同步正在重连，请等待');
				}
				if (window.__roomsRealtimeAttempts > 10 || window.__studentsRealtimeAttempts > 10) {
					suggestions.push('重连次数过多，建议检查网络连接');
				}
			}
			
			console.log('🔍 Realtime连接诊断报告:', report);
			return report;
		},
		
		// 快速修复常见问题
		quickFix: () => {
			console.log('🔧 执行快速修复...');
			
			// 重置重连计数
			window.__roomsRealtimeAttempts = 0;
			window.__studentsRealtimeAttempts = 0;
			
			// 清除重连计时器
			if (window.__roomsRealtimeReconnectTimer) {
				clearTimeout(window.__roomsRealtimeReconnectTimer);
				window.__roomsRealtimeReconnectTimer = null;
			}
			if (window.__studentsRealtimeReconnectTimer) {
				clearTimeout(window.__studentsRealtimeReconnectTimer);
				window.__studentsRealtimeReconnectTimer = null;
			}
			
			// 重置连接问题计数
			realtimeMonitor.connectionIssues = 0;
			realtimeMonitor.recordActivity();
			
			// 重新同步服务器时间
			if (serverTimeSync.isInitialized) {
				serverTimeSync.manualSync();
			}
			
			// 重新建立连接
			if (supabaseClient) {
				setTimeout(() => {
					try {
						setupRealtime();
						console.log('✅ Realtime连接重新初始化完成');
					} catch(e) {
						console.error('❌ 重新初始化失败:', e);
					}
				}, 1000);
			}
			
			console.log('🔧 快速修复执行完成，请等待连接重建...');
		},
		
		// 获取时间同步状态
		getTimeSyncStatus: () => {
			const now = Date.now();
			const serverTime = getServerSyncedTime();
			return {
				initialized: serverTimeSync.isInitialized,
				serverOffset: serverTimeSync.serverTimeOffset,
				lastSyncTime: serverTimeSync.lastSyncTime > 0 ? new Date(serverTimeSync.lastSyncTime).toLocaleString() : 'Never',
				syncInProgress: serverTimeSync.syncInProgress,
				shouldResync: serverTimeSync.shouldResync(),
				timeSinceLastSync: serverTimeSync.lastSyncTime > 0 ? Math.round((now - serverTimeSync.lastSyncTime) / 1000) + 's' : 'N/A',
				currentServerTime: new Date(serverTime).toLocaleString(),
				currentLocalTime: new Date(now).toLocaleString(),
				timeDifference: Math.round((serverTime - now) / 1000) + 's',
				syncHealth: serverTimeSync.lastSyncTime > 0 && (now - serverTimeSync.lastSyncTime) < 10 * 60 * 1000 ? 'Good' : 'Needs Sync'
			};
		},
		
		// 手动同步时间
		syncTime: async () => {
			console.log('⏰ 开始手动时间同步...');
			try {
				await serverTimeSync.manualSync();
				const status = window.debugStats.getTimeSyncStatus();
				console.log('✅ 时间同步完成:', status);
			} catch (error) {
				console.error('❌ 时间同步失败:', error);
			}
		},
		
		// 测试时间同步准确性
		testTimeSync: () => {
			const local = Date.now();
			const server = getServerSyncedTime();
			const diff = server - local;
			
			console.log('🕐 时间同步测试结果:');
			console.log('本地时间:', new Date(local).toLocaleString());
			console.log('服务器时间:', new Date(server).toLocaleString());
			console.log('时间差:', diff + 'ms (' + Math.round(diff/1000) + 's)');
			
			if (Math.abs(diff) < 5000) {
				console.log('✅ 时间同步正常 (差值 < 5秒)');
			} else if (Math.abs(diff) < 60000) {
				console.log('⚠️ 时间同步有轻微偏差 (差值 < 1分钟)');
			} else {
				console.log('❌ 时间同步偏差较大，建议检查');
			}
			
			return { local, server, difference: diff };
		},
		
		// 计时器状态管理
		getTimerStates: () => {
			const occupiedRooms = Store.rooms.filter(r => r.occupant_student_name && r.registerTime);
			return occupiedRooms.map(r => ({
				room: r.name,
				occupant_student_name: r.occupant_student_name,
				registerTime: new Date(r.registerTime).toLocaleString(),
				elapsed: Math.floor((getServerSyncedTime() - r.registerTime) / 1000),
				status: statusInfo(r).state
			}));
		},
		
		// 保存计时器状态
		saveTimerStates: () => {
			timerPersistence.saveTimerStates();
			console.log('💾 计时器状态已保存');
		},
		
		// 恢复计时器状态
		restoreTimerStates: async () => {
			await restoreRoomTimerStates();
			console.log('🔄 计时器状态恢复尝试完成');
		},
		
		// 清理计时器状态
		clearTimerStates: () => {
			timerPersistence.cleanup();
			console.log('🗑️ 计时器状态已清理');
		}
	};

	// 统一房间模型(已简化): { name, pianoType, location, remark, occupant_student_name, register_time, version, heartbeat_at }
	// 2025-09 字段统一: 仅使用 occupant_student_name；所有旧字段 occupant / student 已废弃，禁止再引用
	const Store = {
		rooms: [], // 活动状态 (rooms 表)
		roomMeta: {}, // 静态（room_database） name->meta
		students: [], // {id,name,major,grade}
		byName: new Map(),
		studentIndex: new Map(),
		floorSet: new Set(),
		filters: { floor:'ALL', type:'ALL' },
		settings: { basePracticeDuration:120, practiceSlotCheckEnabled:true }, // 新增: 练琴时段检测开关
		timer: null,
		lastStats:{},
		pendingAssign:new Map(), // roomName -> {occupant,version,ts}
		localPracticeLogs: [], // 本地练习记录缓存
		editMode: false // 编辑模式状态
	};

	// ========== Guard: 捕获遗留对 rooms?select=created_at 的请求 (防旧缓存脚本) ==========
	(function installCreatedAtGuard(){
		try {
			if(window.__createdAtGuardInstalled) return; window.__createdAtGuardInstalled=true;
			const origFetch = window.fetch;
			window.fetch = function(resource, init){
				try {
					const url = typeof resource==='string'?resource:(resource&&resource.url)||'';
					if(url.includes('/rest/v1/rooms') && /select=([^&]*,)?created_at/.test(url)){
						console.warn('[Guard] 拦截遗留 rooms?select=created_at 请求:', url);
						console.warn('[Guard] 说明仍有旧版本页面或缓存逻辑在运行，请关闭其它标签并强制刷新 (Ctrl+Shift+R)。');
						try{ console.warn('[Guard] 调用堆栈→\n'+(new Error().stack)); }catch(_){ }
					}
				}catch(_){ }
				return origFetch.apply(this, arguments);
			};
		} catch(e){ console.warn('[Guard] 安装 fetch 监控失败', e); }
	})();

	/* 拼音映射 */
	const pinyinMap={'靳':'jin','蓝':'lan','熙':'xi','邓':'deng','涵':'han','周':'zhou','静':'jing','远':'yuan','冯':'feng','瑞':'rui','夕':'xi','吕':'lv','金':'jin','昂':'ang','徐':'xu','涬':'shuang','宸':'chen','窦':'dou','璟':'jing','华':'hua','林':'lin','晏':'yan','熹':'xi','段':'duan','鉴':'jian','叶':'ye','蔚':'wei','刘':'liu','泽':'ze','文':'wen','潘':'pan','瑾':'jin','熠':'yi','李':'li','博':'bo','恩':'en','王':'wang','奕':'yi','然':'ran','韩':'han','昀':'yun','桦':'hua','孔':'kong','璇':'xuan','臧':'zang','昱':'yu','棋':'qi','蔺':'lin','轩':'xuan','宋':'song','梓':'zi','暄':'xuan','田':'tian','子':'zi','萱':'xuan','张':'zhang','依':'yi','陈':'chen','思':'si','彤':'tong','杨':'yang','雨':'yu','桐':'tong','赵':'zhao','欣':'xin','怡':'yi','马':'ma','晨':'chen','曦':'xi','高':'gao','梦':'meng','琪':'qi','郑':'zheng','诗':'shi','吴':'wu','佳':'jia','何':'he','朱':'zhu','心':'xin','语':'yu','胡':'hu','若':'ruo','汐':'xi','许':'xu','瑶':'yao','罗':'luo','雅':'ya','钟':'zhong','嫣':'yan','谢':'xie','苏':'su','琳':'lin','江':'jiang','孙':'sun','袁':'yuan','汪':'wang','曹':'cao','姚':'yao','沈':'shen','卢':'lu','韦':'wei','董':'dong','傅':'fu','程':'cheng','丁':'ding','石':'shi','任':'ren','邹':'zou','龙':'long','史':'shi','方':'fang','夏':'xia','侯':'hou','邱':'qiu','尹':'yin','黎':'li','汤':'tang','易':'yi','常':'chang','武':'wu','乔':'qiao','贺':'he','赖':'lai','龚':'gong','庞':'pang','樊':'fan','兰':'lan','殷':'yin','施':'shi','陶':'tao','翁':'weng','安':'an','倪':'ni','严':'yan','牛':'niu','温':'wen','芦':'lu','季':'ji','俞':'yu','章':'zhang','鲁':'lu','葛':'ge','伍':'wu','申':'shen','尤':'you','毕':'bi','聂':'nie','丛':'cong','焦':'jiao','向':'xiang','柯':'ke','岳':'yue','湘':'xiang','悦':'yue','玮':'wei','管':'guan','哲':'zhe','婷':'ting','释':'shi','言':'yan','祝':'zhu','宝':'bao','彭':'peng','美':'mei','淇':'qi','康':'kang','群':'qun','耿':'geng','幄':'wo','千':'qian','瑜':'yu','又':'you','雯':'wen','俊':'jun','杰':'jie','劲':'jin','豪':'hao','笙':'sheng','权':'quan','薛':'xue','宜':'yi','陆':'lu','曜':'yao','嶙':'lin','馨':'xin','裕':'yu','昕':'xin','沐':'mu','唐':'tang','君':'jun','盛':'sheng','硕':'shuo','晗':'han','如':'ru','牧':'mu','风':'feng','晞':'xi','伊':'yi','清':'qing','妃':'fei','月':'yue','祺':'qi','蒲':'pu','柏':'bai','羽':'yu','冠':'guan','成':'cheng','颜':'yan','亦':'yi','沅':'yuan','承':'cheng','秦':'qin','铂':'bo','筵':'yan','慧':'hui','作':'zuo','翰':'han','上':'shang','之':'zhi','路':'lu','瓒':'zan','著':'zhu','睿':'rui','籽':'zi','丞':'cheng','妍':'yan','栩':'xu','乐':'le','逸':'yi','诚':'cheng','钰':'yu','洁':'jie','媛':'yuan','鋆':'yun','谨':'jin','畅':'chang','茹':'ru','沂':'yi','婉':'wan','荷':'he','洋':'yang','明':'ming','多':'duo','郗':'xi','传':'chuan','平':'ping','世':'shi','元':'yuan','汇':'hui','沙':'sha','皓':'hao','家':'jia','楠':'nan','官':'guan','柘':'zhe','希':'xi','溥':'pu','尚':'shang','凌':'ling','翾':'xuan','姜':'jiang','煊':'xuan','琬':'wan','迪':'di','昍':'xuan','沁':'qin','祎':'yi','珈':'jia','政':'zheng','阳':'yang','以':'yi','骞':'qian','乙':'yi','铮':'zheng','商':'shang','天':'tian','赐':'ci','晟':'sheng','峰':'feng','邵':'shao','颢':'hao','浩':'hao','余':'yu','浡':'bo','瀚':'han','峻':'jun','于':'yu','钲':'zheng','埼':'qi','苏':'su','彦':'yan','炳':'bing','岐':'qi','璠':'fan','白':'bai','咏':'yong','玎':'ding','庄':'zhuang','笛':'di','薪':'xin','米':'mi','琪':'qi','存':'cun','和':'he','笑':'xiao','欧':'ou','翰':'han','喆':'zhe','庭':'ting','彰':'zhang','邰':'tai','蔡':'cai','屹':'yi','潆':'ying','潞':'lu','修':'xiu','冉':'ran','光':'guang','翼':'yi','珺':'jun','闻':'wen','治':'zhi','玥':'yue','婧':'jing','婍':'qi','植':'zhi','寅':'yin','井':'jing','溪':'xi','紫':'zi','航':'hang','显':'xian','翔':'xiang','景':'jing','园':'yuan','羿':'yi','达':'da','正':'zheng','潼':'tong','嘉':'jia','崚':'ling','汉':'han','冼':'xian','昊':'hao','敬':'jing','尔':'er','卓':'zhuo','帅':'shuai','志':'zhi','可':'ke','钧':'jun','鉴':'jian','笙':'sheng','权':'quan','显':'xian','翔':'xiang','晏':'yan','熹':'xi','释':'shi','言':'yan','森':'sen','贤':'xian','柳':'liu','恩':'en','奕':'yi','潼':'tong','嘉':'jia','怡':'yi','金':'jin','昂':'ang','瑾':'jin','熠':'yi','美':'mei','淇':'qi','千':'qian','瑜':'yu','子':'zi','轩':'xuan','志':'zhi','昊':'hao','萱':'xuan','申':'shen','崚':'ling','梓':'zi','康':'kang','岳':'yue','汉':'han','昊':'hao','熹':'xi','又':'you','安':'an','涬':'shuang','宸':'chen','宜':'yi','艺':'yi','卓':'zhuo','然':'ran','蔚':'wei','蓝':'lan','敬':'jing','轩':'xuan','昱':'yu','棋':'qi','尔':'er','涵':'han','雯':'wen','婷':'ting','卓':'zhuo','群':'qun','子':'zi','帅':'shuai','子':'zi','依':'yi','博':'bo','玮':'wei','欣':'xin','怡':'yi','静':'jing','远':'yuan','宝':'bao','怡':'yi','常':'chang','欣':'xin','洋':'yang','婉':'wan','茹':'ru','明':'ming','多':'duo','杰':'jie','欣':'xin','荷':'he','千':'qian','皓':'hao','汇':'hui','泽':'ze','传':'chuan','平':'ping','世':'shi','元':'yuan','冠':'guan','源':'yuan','米':'mi','琪':'qi','单':'dan','若':'ruo','溪':'xi','恩':'en','和':'he','金':'jin','黄':'huang','可':'ke','欣':'xin','孔':'kong','梓':'zi','语':'yu','存':'cun','浩':'hao','嘉':'jia','荷':'he','雨':'yu','笛':'di','子':'zi','轩':'xuan','薪':'xin','瑜':'yu','梓':'zi','宸':'chen','承':'cheng','熹':'xi','子':'zi','墨':'mo','塘':'tang','欣':'xin','妍':'yan','笑':'xiao','欧':'ou','祎':'yi','玥':'yue','婧':'jing','婍':'qi','植':'zhi','元':'yuan','浩':'hao','元':'yuan','梓':'zi','寅':'yin','依':'yi','诺':'nuo','钧':'jun','屹':'yi','博':'bo','闻':'wen','庭':'ting','彰':'zhang','潆':'ying','潞':'lu','熠':'yi','宸':'chen','天':'tian','翼':'yi','治':'zhi','钧':'jun','林':'lin','熠':'yi','梓':'zi','峰':'feng','修':'xiu','冉':'ran','珺':'jun','翰':'han','喆':'zhe','米':'mi','阳':'yang','光':'guang','栩':'xu','乐':'le','安':'an','慧':'hui','冠':'guan','华':'hua','若':'ruo','昕':'xin','雨':'yu','熙':'xi','金':'jin','沂':'yi','以':'yi','诺':'nuo','钰':'yu','沐':'mu','曦':'xi','牧':'mu','风':'feng','欣':'xin','妍':'yan','沅':'yuan','承':'cheng','籽':'zi','丞':'cheng','谨':'jin','畅':'chang','作':'zuo','翰':'han','文':'wen','盛':'sheng','路':'lu','雨':'yu','瓒':'zan','亦':'yi','宸':'chen','逸':'yi','诚':'cheng','子':'zi','清':'qing','柏':'bai','羽':'yu','铂':'bo','筵':'yan','曜':'yao','嶙':'lin','轩':'xuan','子':'zi','茹':'ru','嘉':'jia','君':'jun','洁':'jie','媛':'yuan','月':'yue','祺':'qi','淇':'qi','晗':'han','如':'ru','上':'shang','恩':'en','雅':'ya','晞':'xi','一':'yi','妃':'fei','怡':'yi','文':'wen','魏':'wei','伊':'yi','萱':'xuan','易':'yi','成':'cheng','晟':'sheng','嘉':'jia','家':'jia','硕':'shuo','佳':'jia','馨':'xin','语':'yu','著':'zhu','睿':'rui','诗':'shi','悦':'yue','依':'yi','宸':'chen','子':'zi','鋆':'yun','涵':'han','之':'zhi','裕':'yu','达':'da'};

	function matchPinyin(name, searchTerm) {
		if (!searchTerm) return true;
		const searchLower = searchTerm.toLowerCase().trim();
		const nameLower = name.toLowerCase();
		
		// 直接匹配中文
		if (nameLower.includes(searchLower)) return true;
		
		// 处理空格分隔的多关键词搜索
		const keywords = searchLower.split(/\s+/).filter(k => k.length > 0);
		if (keywords.length > 1) {
			return matchMultipleKeywords(name, keywords);
		}
		
		// 单关键词的拼音匹配逻辑
		const nameChars = name.split('');
		const firstLetters = nameChars.map(char => {
			const py = pinyinMap[char];
			return py ? py.charAt(0) : char.toLowerCase();
		});

		// 💡 启动学生库智能轮询（增量同步 + 兜底机制）
		if(!window.__studentPollingInterval){
			window.__studentPollingInterval = setInterval(async ()=>{
				try{
					if(!window.supabaseReady) return;
					// 若最近5秒已有实时事件，则跳过本次轮询，避免频繁合并
					if(window.__studentUpdateTimestamp && (Date.now()-window.__studentUpdateTimestamp)<5000) return;
					
					if(typeof fetchStudents==='function'){
						const beforeCount = (Store.students||[]).length;
						
						// 使用增量同步（基于上次同步时间）
						const lastSyncTime = window.__studentLastSyncTime;
						const isFirstSync = !lastSyncTime;
						
						if (isFirstSync) {
							// 首次同步使用全量
							await fetchStudents({ forceFullSync: true });
							logInfo('[RT][students][poll] 首次全量同步完成');
						} else {
							// 后续使用增量同步
							await fetchStudents({ 
								incremental: true, 
								since: lastSyncTime 
							});
						}
						
						const afterCount = (Store.students||[]).length;
						if(afterCount!==beforeCount){ 
							logInfo(`[RT][students][poll] 合并后数量变化: ${beforeCount} → ${afterCount}`); 
						}
					}
				}catch(e){ console.warn('[RT][students][poll] 异常', e.message); }
			}, 120000); // 💡 增量同步可以进一步延长到2分钟
		}
		
		// 如果搜索词只有一个字母，只匹配第一个字的首字母
		if (searchLower.length === 1) {
			return firstLetters[0] === searchLower;
		}
		
		// 多字母搜索时的连续首字母匹配
		const firstLettersStr = firstLetters.join('');
		
		// 完整的首字母匹配（如 "彭美岐" -> "pmq"）
		if (firstLettersStr === searchLower) return true;
		
		// 从开头开始的部分匹配（如 "彭美岐" -> "pm"）
		if (firstLettersStr.startsWith(searchLower)) return true;
		
		// 连续子串匹配（如 "彭美岐" -> "mq" 匹配 "美岐"）
		if (searchLower.length >= 2 && firstLettersStr.includes(searchLower)) return true;
		
		return false;
	}

	// 多关键词匹配函数
	function matchMultipleKeywords(name, keywords) {
		const nameLower = name.toLowerCase();
		const nameChars = name.split('');
		const firstLetters = nameChars.map(char => {
			const py = pinyinMap[char];
			return py ? py.charAt(0) : char.toLowerCase();
		});
		const firstLettersStr = firstLetters.join('');
		
		// 每个关键词都必须单独匹配（AND 逻辑）
		const allMatch = keywords.every(keyword => {
			// 直接中文匹配
			if (nameLower.includes(keyword)) return true;
			
			// 单字母首字母匹配
			if (keyword.length === 1) {
				return firstLetters.includes(keyword);
			}
			
			// 多字母连续匹配
			if (keyword.length >= 2) {
				return firstLettersStr.includes(keyword);
			}
			
			return false;
		});
		
		if (allMatch) return true;
		
		// 智能首字母组合匹配
		const isAllSingleLetters = keywords.every(k => k.length === 1);
		if (isAllSingleLetters) {
			return matchSmartKeywords(name, keywords);
		}
		
		// 组合关键词匹配
		return matchCombinedKeywords(name, keywords, firstLetters, nameLower);
	}

	// 组合关键词匹配
	function matchCombinedKeywords(name, keywords, firstLetters, nameLower) {
		for (let i = 0; i < keywords.length; i++) {
			const keyword = keywords[i];
			let matched = false;
			
			if (keyword.length === 1) {
				// 单字母：检查首字母
				matched = firstLetters.includes(keyword);
			} else {
				// 多字母：检查中文或拼音
				matched = nameLower.includes(keyword) || 
						  firstLetters.join('').includes(keyword);
			}
			
			if (!matched) return false;
		}
		
		return true;
	}

	// 智能关键词匹配（支持首字母组合）
	function matchSmartKeywords(name, keywords) {
		const nameChars = name.split('');
		const firstLetters = nameChars.map(char => {
			const py = pinyinMap[char];
			return py ? py.charAt(0) : char.toLowerCase();
		});
		
		// 检查是否存在连续的首字母匹配
		if (keywords.length <= nameChars.length) {
			for (let i = 0; i <= firstLetters.length - keywords.length; i++) {
				let match = true;
				for (let j = 0; j < keywords.length; j++) {
					if (firstLetters[i + j] !== keywords[j]) {
						match = false;
						break;
					}
				}
				if (match) return true;
			}
			
			// 支持非连续但按顺序的首字母匹配
			let keywordIndex = 0;
			for (let i = 0; i < firstLetters.length && keywordIndex < keywords.length; i++) {
				if (firstLetters[i] === keywords[keywordIndex]) {
					keywordIndex++;
				}
			}
			if (keywordIndex === keywords.length) return true;
		}
		
		return false;
	}

	function canonicalizeRoom(r){
		if(!r) return null;
		// 统一：仅 occupant_student_name；其余字段沿用旧前端属性命名（registerTime / heartbeatAt）
		const out = {
			name: r.name,
			pianoType: r.piano_type || r.pianoType || r.pianoKind || '无钢琴',
			location: (r.location||'').trim(),
			remark: r.remark || ''
		};
		if ('occupant_student_name' in r) {
			out.occupant_student_name = r.occupant_student_name || null;
		}
		if ('register_time' in r || 'registerTime' in r) {
			// 优先使用 register_time（数据库字段），如果为空则使用 registerTime（本地字段）
			if (r.register_time !== null && r.register_time !== undefined && r.register_time !== '') {
				out.registerTime = toMs(r.register_time);  
				out.register_time = r.register_time; // 保持两个字段同步
			} else if (r.registerTime !== null && r.registerTime !== undefined) {
				out.registerTime = r.registerTime;
				out.register_time = new Date(r.registerTime).toISOString(); // 保持两个字段同步
			} else {
				out.registerTime = null;
				out.register_time = null; // 确保两个字段都为空
			}
		}
		if ('version' in r) out.version = r.version || 0;
		if ('heartbeat_at' in r || 'heartbeatAt' in r) {
			out.heartbeatAt = r.heartbeat_at ? toMs(r.heartbeat_at) : (r.heartbeatAt||null);
		}
		return out;
	}
	function toMs(v){ if(!v) return null; if(typeof v==='number') return v* (v<2e12?1000:1); return new Date(v).getTime(); }

	/*************************************************
	 * Supabase 适配器
	 *************************************************/
	async function initSupabase(){
		updateSyncStatus('connecting', '连接中...');
		let retryCount = 0;
		const maxRetries = 3;
		
		while (retryCount < maxRetries) {
			try {
				logInfo(`尝试连接 Supabase (第 ${retryCount + 1} 次)`);
				
				// 检查 Supabase 客户端是否已加载
				if(typeof window.supabase !== 'undefined' && window.supabase.createClient){ 
					logInfo('使用全局 supabase 对象');
					supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY); 
				} else if(typeof window.createClient==='function'){ 
					logInfo('使用全局 createClient 函数');
					supabaseClient = window.createClient(SUPABASE_URL, SUPABASE_KEY); 
				} else { 
					logInfo('动态加载 Supabase 脚本');
					await loadSupabaseScript(); 
					if (!window.supabase || !window.supabase.createClient) {
						throw new Error('Supabase 脚本加载失败，全局对象不可用');
					}
					supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY); 
				}
				// 挂载到全局，供 BTM 等模块使用
				window.supabaseClient = supabaseClient;
				
				// 验证客户端对象
				if (!supabaseClient) {
					throw new Error('Supabase 客户端创建失败');
				}
				
				// 测试连接
				logInfo('测试 Supabase 连接...');
				updateSyncStatus('connecting', '测试连接...');
				const { data, error } = await supabaseClient.from('rooms').select('count').limit(1);
				if (error) {
					logWarn('Supabase 连接测试失败:', error.message);
					throw error;
				} else {
					logInfo('Supabase 连接测试成功');
				}
				
				supabaseReady = true; 
				logInfo('Supabase 初始化完成');
				updateSyncStatus('connected', 'Supabase 就绪');
				return; // 成功，退出重试循环
				
			} catch (error) {
				retryCount++;
				logErr(`Supabase 初始化失败 (第 ${retryCount} 次):`, error.message);
				
				if (retryCount >= maxRetries) {
					updateSyncStatus('error', `初始化失败 (${error.message})`);
					// 不抛出错误，改为优雅降级
					logWarn('使用离线模式');
					return;
				}
				
				// 等待后重试
				await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
			}
		}
	}
	function loadSupabaseScript(){
		return new Promise((res,rej)=>{
			// 检查是否已加载
			if(window.supabase && window.supabase.createClient){
				logInfo('Supabase 脚本已存在');
				return res();
			}
			
			const s=document.createElement('script'); 
			s.src='https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js';
			s.crossOrigin = 'anonymous'; 
			s.onload=()=>{
				logInfo('Supabase 脚本加载成功');
				// 等待几毫秒确保全局对象可用
				setTimeout(res, 100);
			}; 
			s.onerror=(e)=>{
				logErr('加载 supabase 脚本失败:', e);
				rej(new Error('加载 supabase 失败'));
			}; 
			document.head.appendChild(s);
		});
	}
	async function fetchRooms(){
		if(!supabaseReady) return [];
		const { data, error } = await supabaseClient.from('rooms').select('name,piano_type,location,remark,occupant_student_name,register_time,version,heartbeat_at,updated_at');
		if(error){ logWarn('加载 rooms 失败', error.message); return []; }
		return data.map(canonicalizeRoom);
	}
	async function fetchRoomMeta(){
		if(!supabaseReady) return {};
		const { data, error } = await supabaseClient.from('room_database').select('*');
		if(error){ logWarn('加载 room_database 失败', error.message); return {}; }
		
		const map={}; 
		const cloudRooms = [];
		
		(data||[]).forEach(r=>{ 
			map[r.name]=r; 
			// 转换为标准格式并加入琴房列表
			cloudRooms.push({
				name: r.name,
				pianoType: r.piano_type || '',
				location: r.location || '',
				remark: r.remark || ''
			});
		}); 
		
		// 自动合并云端琴房数据到本地（跳过云端同步避免递归）
		if (cloudRooms.length > 0) {
			logInfo(`从云端获取到 ${cloudRooms.length} 个琴房，自动合并到本地`);
			await mergeRooms(cloudRooms, { skipCloudSync: true, metaOnly: true });
		}
		
		return map;
	}

	// 按房间名拉取单个静态元数据并合并（仅元数据，不触动占用状态）
	async function fetchRoomMetaByName(name){
		if(!supabaseReady || !name) return;
		try{
			const { data, error } = await supabaseClient.from('room_database').select('*').eq('name', name).limit(1);
			if(error){ logWarn(`加载 room_meta(${name}) 失败`, error.message); return; }
			const r = Array.isArray(data) ? data[0] : data;
			if(!r) return;
			await mergeRooms([{ name: r.name, pianoType: r.piano_type || '', location: r.location || '', remark: r.remark || '' }], { skipCloudSync: true, metaOnly: true });
			logInfo(`已补充房间元数据: ${name}`);
		}catch(e){ logWarn(`加载房间元数据异常(${name})`, e.message); }
	}
	
	// 💡 增量学生库同步 - 支持全量和增量两种模式
	async function fetchStudents(options = {}){
		if(!supabaseReady) return [];
		
		const { 
			incremental = false,  // 是否增量同步
			since = null,         // 增量同步的起始时间
			forceFullSync = false // 强制全量同步
		} = options;
		
		// 💡 先尝试包含updated_at字段，如果失败则降级到基础字段
		let query = supabaseClient.from('student_database').select('id,name,major,grade,updated_at');
		let hasUpdatedAtField = true;
		
		// 增量查询：只获取指定时间之后更新的学生
		if (incremental && since && !forceFullSync && hasUpdatedAtField) {
			query = query.gt('updated_at', since);
			logInfo(`增量获取学生数据，since: ${since}`);
		} else {
			if (incremental && since && !hasUpdatedAtField) {
				logWarn('数据库无updated_at字段，降级为全量同步');
			}
			logInfo('全量获取学生数据');
		}
		
		const { data, error } = await query;
		
		// 如果包含updated_at的查询失败，可能是字段不存在，降级到基础查询
		if (error && error.message && error.message.includes('updated_at')) {
			logWarn('updated_at字段不存在，降级到基础字段查询');
			hasUpdatedAtField = false;
			// 重新构建查询，只包含基础字段
			const fallbackQuery = supabaseClient.from('student_database').select('id,name,major,grade');
			const { data: fallbackData, error: fallbackError } = await fallbackQuery;
			
			if (fallbackError) {
				logWarn('加载学生失败（降级查询）', fallbackError.message);
				return [];
			}
			
			// 没有updated_at字段时，无法精确记录同步时间，使用当前时间
			window.__studentLastSyncTime = new Date().toISOString();
			const students = fallbackData || [];
			logInfo(`降级查询成功，获取到 ${students.length} 个学生（无时间戳）`);
			
			if (students.length > 0) {
				await mergeStudents(students, true);
				try{ if(window.ensureStudentLibraryHydrated){ window.ensureStudentLibraryHydrated({ source:'after-fetchStudents' }); } }catch(_){ }
			}
			
			return students;
		}
		
		if(error){ logWarn('加载学生失败', error.message); return []; }
		
		const students = data || [];
		
		// 记录最新的更新时间，用于下次增量同步
		if (students.length > 0) {
			// 计算最新更新时间（如果有updated_at字段）
			let latestUpdateTime;
			if (hasUpdatedAtField && students.some(s => s.updated_at)) {
				latestUpdateTime = Math.max(...students.map(s => new Date(s.updated_at || 0).getTime()));
				window.__studentLastSyncTime = new Date(latestUpdateTime).toISOString();
			} else {
				// 没有updated_at字段时，使用当前时间
				window.__studentLastSyncTime = new Date().toISOString();
			}
			
			const syncType = incremental && since && !forceFullSync && hasUpdatedAtField ? '增量' : '全量';
			logInfo(`${syncType}获取到 ${students.length} 个学生，最新同步时间: ${window.__studentLastSyncTime}`);
			
			// 统计信息
			if (!window.__studentSyncStats) {
				window.__studentSyncStats = { totalSyncs: 0, incrementalSyncs: 0, totalRecords: 0 };
			}
			window.__studentSyncStats.totalSyncs++;
			if (syncType === '增量') {
				window.__studentSyncStats.incrementalSyncs++;
			}
			window.__studentSyncStats.totalRecords += students.length;
			
			await mergeStudents(students, true); // skipCloudSync = true
			try{ if(window.ensureStudentLibraryHydrated){ window.ensureStudentLibraryHydrated({ source:'after-fetchStudents' }); } }catch(_){ }
		} else if (incremental) {
			logInfo('增量同步：无新变化');
			// 更新同步时间即使没有变化
			window.__studentLastSyncTime = new Date().toISOString();
		}
		
		return students;
	}

	// 💡 房间备注数据库同步函数
	async function syncRoomRemarkToDatabase(roomName, remark) {
		if (!supabaseReady || !supabaseClient) {
			throw new Error('Supabase未就绪');
		}
		
		try {
			logInfo(`🔄 开始同步房间备注到数据库: ${roomName} -> "${remark}"`);
			
			// 更新room_database表中的备注字段
			// 这会自动触发realtime事件，其他设备会收到更新
			const { data, error } = await supabaseClient
				.from('room_database')
				.update({ 
					remark: remark || null,
					updated_at: new Date().toISOString() // 确保有更新时间戳
				})
				.eq('name', roomName)
				.select(); // 添加select()以获取更新后的数据
				
			if (error) {
				throw error;
			}
			
			logInfo(`✅ 房间备注已成功同步到数据库：${roomName} -> "${remark}"`);
			logInfo(`📊 数据库返回:`, data);
			
		} catch (error) {
			logErr(`❌ 房间备注数据库同步失败 ${roomName}:`, error.message);
			throw error;
		}
	}

	// 💡 房间重命名数据库同步函数
	async function syncRoomNameToDatabase(oldName, newName, opts={}) {
		if (!supabaseReady || !supabaseClient) throw new Error('Supabase未就绪');
		const { silent } = opts;
		const ts = ()=>new Date().toISOString();
		// 并发锁
		if(!window.__renameLocks) window.__renameLocks = new Set();
		const lockKey = `rename::${oldName}`;
		if(window.__renameLocks.has(lockKey)){
			throw new Error('重命名进行中, 请稍候');
		}
		window.__renameLocks.add(lockKey);
		try {
			logInfo(`🔄 房间重命名开始(带检查): ${oldName} -> ${newName}`);
			if(oldName===newName) return { skipped:true };
			// 0. 远程可用性检查（避免直接 update 触发 409）
			const { data: existCheck, error: existErr } = await supabaseClient
				.from('room_database')
				.select('name')
				.eq('name', newName)
				.limit(1);
			if(existErr){ throw new Error(`名称检测失败: ${existErr.message}`); }
			if(existCheck && existCheck.length){
				throw new Error('NAME_CONFLICT');
			}
			// 1. 更新 room_database
			const now = ts();
			const { data: metaData, error: metaError } = await supabaseClient
				.from('room_database')
				.update({ name:newName, updated_at: now })
				.eq('name', oldName)
				.select();
			if(metaError){
				// duplicate key 再次兜底识别
				if(/duplicate key/i.test(metaError.message)) throw new Error('NAME_CONFLICT');
				throw new Error(`更新元数据失败:${metaError.message}`);
			}
			// 2. 更新 rooms 表
			const { data: roomsData, error: roomsError } = await supabaseClient
				.from('rooms')
				.update({ name:newName, updated_at: now })
				.eq('name', oldName)
				.select();
			if(roomsError){
				if(/duplicate key/i.test(roomsError.message)){
					// 回滚 room_database 改名 (尝试改回旧名)
					try {
						await supabaseClient.from('room_database').update({ name:oldName, updated_at: ts() }).eq('name', newName);
						logWarn('已尝试回滚元数据表名称');
					}catch(e){ logErr('回滚失败:', e.message); }
					throw new Error('NAME_CONFLICT');
				}
				throw new Error(`更新状态失败:${roomsError.message}`);
			}
			logInfo(`🎉 房间重命名完成(双表) ${oldName} -> ${newName}`);
			return { success:true, meta:metaData, rooms:roomsData };
		} catch (e){
			if(e.message==='NAME_CONFLICT'){
				if(!silent) logWarn(`⚠️ 名称冲突: ${newName}`);
			} else {
				logErr(`❌ 房间重命名失败 ${oldName} -> ${newName}:`, e.message);
			}
			throw e;
		} finally {
			window.__renameLocks.delete(lockKey);
		}
	}

	// 🧪 测试辅助：快速在控制台触发重命名并输出阶段性日志
	if(!window.testRoomRename){
		window.testRoomRename = async function(oldName, newName){
			console.log('[TEST] rename start', oldName, '->', newName);
			try{
				const r = Store.byName.get(oldName);
				if(!r){ console.warn('房间不存在:', oldName); return; }
				await syncRoomNameToDatabase(oldName, newName);
				console.log('[TEST] rename success');
			}catch(e){ console.error('[TEST] rename fail', e.message); }
		};
	}

	// 🧪 测试辅助：快速在控制台触发删除并观测同步
	if(!window.testRoomDeletion){
		window.testRoomDeletion = async function(roomName){
			console.log('[TEST] deletion start', roomName);
			try{
				const r = Store.byName.get(roomName);
				if(!r){ console.warn('房间不存在:', roomName); return; }
				await deleteRoom(roomName);
				console.log('[TEST] deletion success - local removed');
				// 观测其他设备同步（如果在多窗口环境）
				setTimeout(()=>{
					const stillExists = Store.byName.has(roomName);
					console.log('[TEST] deletion check after 2s - still exists:', stillExists);
				}, 2000);
			}catch(e){ console.error('[TEST] deletion fail', e.message); }
		};
	}

	// 🧪 跨窗口删除同步测试
	if(!window.testCrossWindowDeletion){
		window.testCrossWindowDeletion = function(roomName){
			console.log('[CROSS-WINDOW-TEST] 准备跨窗口删除测试:', roomName);
			console.log('📋 测试步骤:');
			console.log('1. 在窗口A执行: testRoomDeletion("' + roomName + '")');
			console.log('2. 在窗口B执行: watchRoomDeletionSync("' + roomName + '")');
			console.log('3. 在窗口B执行: diagnoseDeletionBlocking("' + roomName + '") (如果删除阻塞)');
			
			// 检查当前房间是否存在
			const exists = Store.byName.has(roomName);
			if(!exists){
				console.warn('⚠️ 房间不存在，无法测试删除');
				return;
			}
			
			console.log('✅ 房间存在，可以开始测试');
			console.log('💡 建议先在另一个窗口执行监控，然后回到这个窗口删除');
		};
	}

	// 🧪 增强删除同步监控工具
	if(!window.watchRoomDeletionSync){
		window.watchRoomDeletionSync = function(roomName, seconds=8){
			console.log('[WATCH] 开始监控房间删除同步:', roomName);
			let i=0; const timer=setInterval(()=>{
				i++;
				const inStore = Store.byName.has(roomName);
				const inRooms = Store.rooms.some(r=>r.name===roomName);
				const inMeta = Store.roomMeta && Store.roomMeta[roomName];
				const inDOM = !!document.querySelector(`[data-room="${CSS.escape(roomName)}"]`);
				const deletionMarker = Store.deletionMarkers && Store.deletionMarkers.get(roomName);
				const markerAge = deletionMarker ? Math.round((Date.now() - deletionMarker)/1000) : 0;
				console.log(`[WATCH][${i}s] ${roomName} - Store.byName:${inStore} Store.rooms:${inRooms} meta:${!!inMeta} DOM:${inDOM} delMarker:${markerAge}s`);
				if(i>=seconds) {
					clearInterval(timer);
					const isFullyRemoved = !inStore && !inRooms && !inMeta && !inDOM;
					console.log(`[WATCH] 监控结束 - 完全删除: ${isFullyRemoved}`);
				}
			},1000);
		};
	}

	// 🏗️ 简单房间创建函数 (用于测试)
	if(!window.createTestRoom){
		window.createTestRoom = async function(roomName) {
			console.log(`📝 创建测试房间: ${roomName}`);
			
			const newRoom = {
				name: roomName,
				location: '测试楼层',
				pianoType: '其他',
				remark: '自动测试创建',
				occupant_student_name: null,
				registerTime: null,
				version: 1,
				heartbeatAt: null
			};
			
			// 添加到本地数据
			Store.rooms.push(newRoom);
			Store.byName.set(roomName, newRoom);
			Store.floorSet.add('测试楼层');
			
			// 同步到云端
			if (!Store.settings.offlineMode) {
				await supabaseClient.from('room_database').upsert({
					name: roomName,
					location: '测试楼层',
					piano_type: '其他',
					remark: '自动测试创建'
				});
				
				await supabaseClient.from('rooms').upsert({
					name: roomName,
					occupant_student_name: null,
					register_time: null,
					heartbeat_at: new Date().toISOString(),
					version: 1,
					updated_at: new Date().toISOString()
				});
			}
			
			// 刷新页面显示
			rebuildIndexes();
			rebuildDisplay();
			
			console.log(`✅ 测试房间创建完成: ${roomName}`);
			return roomName;
		};
	}

	// 🧪 快速测试删除同步
	if(!window.quickDeletionTest){
		window.quickDeletionTest = async function() {
			// 创建测试房间
			console.log('🧪 开始快速删除测试...');
			const testName = `测试房间_${Date.now()}`;
			
			try {
				await window.createTestRoom(testName);
				
				// 等待2秒让房间创建完成并同步
				await new Promise(resolve => setTimeout(resolve, 2000));
				
				// 验证房间是否创建成功
				const roomInStore = Store.byName.has(testName);
				console.log(`📊 房间创建验证 - Store中存在: ${roomInStore}`);
				
				if (!roomInStore) {
					console.error('❌ 测试房间创建失败 - Store中未找到');
					return;
				}
				
				// 开始监听删除同步
				window.watchRoomDeletionSync(testName, 15);
				
				// 等待3秒后删除
				setTimeout(async () => {
					console.log(`🗑️ 删除测试房间: ${testName}`);
					
					// 找到房间进行删除
					const room = Store.byName.get(testName);
					if (room) {
						// 模拟点击删除按钮的逻辑
						const roomElement = Array.from(document.querySelectorAll('.room-item'))
							.find(item => item.textContent.includes(testName));
						
						if (roomElement) {
							const roomId = roomElement.getAttribute('data-room-id') || testName;
							await window.deleteRoom(roomId);
						} else {
							console.warn('⚠️ 未找到房间DOM元素，直接调用删除函数');
							await window.deleteRoom(testName);
						}
					}
				}, 3000);
				
			} catch (error) {
				console.error('❌ 快速删除测试失败:', error);
			}
		};
	}

	// 🔌 检查实时连接状态
	if(!window.checkRealtimeStatus){
		window.checkRealtimeStatus = function() {
			console.log('🔌 实时连接状态检查:');
			
			// 检查 Supabase 实时连接
			const supabaseRealtime = window.supabase?.realtime;
			console.log('- Supabase 实时对象:', !!supabaseRealtime);
			
			if(supabaseRealtime) {
				console.log('- 连接状态:', supabaseRealtime.connection?.connectionState);
				console.log('- 通道数量:', supabaseRealtime.channels?.length || 0);
				
				// 检查每个通道
				supabaseRealtime.channels?.forEach((channel, index) => {
					console.log(`- 通道 ${index}:`, {
						topic: channel.topic,
						state: channel.state,
						joinedAt: channel.joinedAt
					});
				});
			}
			
			// 检查我们的实时监控器
			const monitor = window.realtimeMonitor;
			if(monitor) {
				console.log('- 实时监控器活跃:', monitor.isActive());
				console.log('- 最后活动时间:', monitor.lastActivity ? new Date(monitor.lastActivity).toLocaleTimeString() : '无');
			}
			
			// 检查房间订阅状态
			console.log('- 房间表订阅初始化:', !!window.__roomsRealtimeInit);
			console.log('- 房间元数据订阅连接:', !!window.__roomMetaRealtimeConnected);
			
			return {
				supabaseConnected: supabaseRealtime?.connection?.connectionState === 'open',
				channelCount: supabaseRealtime?.channels?.length || 0,
				monitorActive: monitor?.isActive() || false,
				subscriptionsReady: !!window.__roomsRealtimeInit && !!window.__roomMetaRealtimeConnected
			};
		};
	}

	// 🧪 诊断删除阻塞的工具
	if(!window.diagnoseDeletionBlocking){
		window.diagnoseDeletionBlocking = function(roomName){
			console.log('[DIAG] 诊断删除阻塞:', roomName);
			
			// 检查各种可能的阻塞条件
			const inStore = Store.byName.has(roomName);
			const inRooms = Store.rooms.some(r=>r.name===roomName);
			const inMeta = Store.roomMeta && Store.roomMeta[roomName];
			const inDOM = !!document.querySelector(`[data-room="${CSS.escape(roomName)}"]`);
			
			const deletionMarker = Store.deletionMarkers && Store.deletionMarkers.get(roomName);
			const markerAge = deletionMarker ? (Date.now() - deletionMarker) : 0;
			
			const operationLocks = Store.operationLocks ? Array.from(Store.operationLocks).filter(k=>k.includes(roomName)) : [];
			
			const realtimeConnected = window.__roomMetaRealtimeConnected;
			const roomsRealtimeInit = window.__roomsRealtimeInit;
			
			console.log('🔍 诊断结果:');
			console.log('  数据存在:', {inStore, inRooms, inMeta, inDOM});
			console.log('  删除标记:', deletionMarker ? `存在(${Math.round(markerAge/1000)}秒前)` : '无');
			console.log('  操作锁:', operationLocks.length ? operationLocks : '无');
			console.log('  实时连接:', {roomsMeta: realtimeConnected, roomsTable: roomsRealtimeInit});
			
			if(deletionMarker && markerAge < 5000){
				console.warn('⚠️ 删除标记阻塞 - 等待标记过期');
			}
			if(operationLocks.length){
				console.warn('⚠️ 操作锁阻塞:', operationLocks);
			}
			if(!realtimeConnected || !roomsRealtimeInit){
				console.warn('⚠️ 实时连接问题');
			}
		};
	}

	// 💡 房间类型数据库同步函数
	async function syncRoomTypeToDatabase(roomName, pianoType) {
		if (!supabaseReady || !supabaseClient) {
			throw new Error('Supabase未就绪');
		}
		
		try {
			logInfo(`🔄 开始同步房间类型到数据库: ${roomName} -> ${pianoType}`);
			
			// 更新room_database表中的钢琴类型字段
			const { data, error } = await supabaseClient
				.from('room_database')
				.update({ 
					piano_type: pianoType,
					updated_at: new Date().toISOString()
				})
				.eq('name', roomName)
				.select(); // 添加select()以获取更新后的数据
				
			if (error) {
				throw error;
			}
			
			logInfo(`✅ 房间类型已成功同步到数据库：${roomName} -> ${pianoType}`);
			logInfo(`📊 数据库返回:`, data);
			
		} catch (error) {
			logErr(`❌ 房间类型数据库同步失败 ${roomName}:`, error.message);
			throw error;
		}
	}

	// 💡 手动触发学生库增量同步的便捷函数
	window.syncStudentsIncremental = async function(forceFullSync = false) {
		if (!window.supabaseReady) {
			logWarn('Supabase未就绪，无法同步学生库');
			return { success: false, error: 'Supabase not ready' };
		}
		
		try {
			const beforeCount = (Store.students || []).length;
			const startTime = Date.now();
			
			if (forceFullSync) {
				logInfo('手动触发学生库全量同步');
				await fetchStudents({ forceFullSync: true });
			} else {
				const lastSyncTime = window.__studentLastSyncTime;
				if (lastSyncTime) {
					logInfo(`手动触发学生库增量同步，since: ${lastSyncTime}`);
					await fetchStudents({ incremental: true, since: lastSyncTime });
				} else {
					logInfo('无上次同步时间记录，执行全量同步');
					await fetchStudents({ forceFullSync: true });
				}
			}
			
			const afterCount = (Store.students || []).length;
			const duration = Date.now() - startTime;
			const result = {
				success: true,
				beforeCount,
				afterCount,
				changed: afterCount !== beforeCount,
				duration,
				syncType: forceFullSync ? '全量' : '增量',
				lastSyncTime: window.__studentLastSyncTime
			};
			
			logInfo(`学生库同步完成: ${result.syncType}, ${beforeCount}→${afterCount}, 耗时${duration}ms`);
			return result;
		} catch (error) {
			logErr('学生库同步失败:', error.message);
			return { success: false, error: error.message };
		}
	};

	// 💡 查看学生库同步统计信息
	window.getStudentSyncStats = function() {
		const stats = window.__studentSyncStats || { totalSyncs: 0, incrementalSyncs: 0, totalRecords: 0 };
		const lastSyncTime = window.__studentLastSyncTime;
		const currentCount = (Store.students || []).length;
		
		const result = {
			...stats,
			fullSyncs: stats.totalSyncs - stats.incrementalSyncs,
			incrementalRatio: stats.totalSyncs > 0 ? (stats.incrementalSyncs / stats.totalSyncs * 100).toFixed(1) + '%' : '0%',
			avgRecordsPerSync: stats.totalSyncs > 0 ? Math.round(stats.totalRecords / stats.totalSyncs) : 0,
			lastSyncTime,
			currentStudentCount: currentCount,
			timeSinceLastSync: lastSyncTime ? Math.round((Date.now() - new Date(lastSyncTime).getTime()) / 1000) + '秒前' : '未同步'
		};
		
		console.table(result);
		return result;
	};

	// 💡 测试房间元数据同步的便捷函数
	window.testRoomMetaSync = async function(roomName, newRemark) {
		if (!roomName) {
			console.log('用法: testRoomMetaSync("房间名", "新备注")');
			console.log('示例: testRoomMetaSync("101", "测试备注同步")');
			return;
		}
		
		const room = Store.byName.get(roomName);
		if (!room) {
			console.log(`房间 ${roomName} 不存在`);
			return { success: false, error: 'Room not found' };
		}
		
		const oldRemark = room.remark || '';
		const testRemark = newRemark || `测试同步 ${new Date().toLocaleTimeString()}`;
		
		try {
			logInfo(`开始测试房间元数据同步: ${roomName}`);
			logInfo(`原备注: "${oldRemark}" -> 新备注: "${testRemark}"`);
			
			// 更新本地
			room.remark = testRemark;
			
			// 同步到数据库
			await syncRoomRemarkToDatabase(roomName, testRemark);
			
			// 刷新显示
			setTimeout(() => {
				renderRoomCard(roomName);
			}, 100);
			
			const result = {
				success: true,
				roomName,
				oldRemark,
				newRemark: testRemark,
				message: '房间备注已更新，其他设备应该能看到变化'
			};
			
			console.log('✅ 房间元数据同步测试完成:', result);
			return result;
			
		} catch (error) {
			logErr('房间元数据同步测试失败:', error.message);
			// 恢复原备注
			room.remark = oldRemark;
			renderRoomCard(roomName);
			
			return { success: false, error: error.message };
		}
	};

	// 💡 测试房间类型同步的便捷函数
	window.testRoomTypeSync = async function(roomName, newType) {
		if (!roomName) {
			console.log('用法: testRoomTypeSync("房间名", "新类型")');
			console.log('示例: testRoomTypeSync("101", "三角钢琴")');
			console.log('支持的类型: "三角钢琴", "立式钢琴", "其他"');
			return;
		}
		
		const room = Store.byName.get(roomName);
		if (!room) {
			console.log(`房间 ${roomName} 不存在`);
			return { success: false, error: 'Room not found' };
		}
		
		const oldType = room.pianoType || '';
		let pianoType = newType;
		
		// 智能类型匹配
		if (!pianoType) {
			// 循环切换类型用于测试
			if (/三角/.test(oldType)) {
				pianoType = '立式钢琴';
			} else if (/立式/.test(oldType)) {
				pianoType = '其他';
			} else {
				pianoType = '三角钢琴';
			}
		}
		
		try {
			logInfo(`开始测试房间类型同步: ${roomName}`);
			logInfo(`原类型: "${oldType}" -> 新类型: "${pianoType}"`);
			
			// 更新本地
			room.pianoType = pianoType;
			
			// 同步到数据库
			await syncRoomTypeToDatabase(roomName, pianoType);
			
			// 刷新显示
			setTimeout(() => {
				renderRoomCard(roomName);
			}, 100);
			
			const result = {
				success: true,
				roomName,
				oldType,
				newType: pianoType,
				message: '房间类型已更新，其他设备应该能看到变化'
			};
			
			console.log('✅ 房间类型同步测试完成:', result);
			return result;
			
		} catch (error) {
			logErr('房间类型同步测试失败:', error.message);
			// 恢复原状态
			room.pianoType = oldType;
			renderRoomCard(roomName);
			
			return { success: false, error: error.message };
		}
	};

	// 💡 测试房间重命名同步的便捷函数
	window.testRoomRenameSync = async function(oldName, newName) {
		if (!oldName || !newName) {
			console.log('用法: testRoomRenameSync("旧名称", "新名称")');
			console.log('示例: testRoomRenameSync("101", "101A")');
			return;
		}
		
		const room = Store.byName.get(oldName);
		if (!room) {
			console.log(`房间 ${oldName} 不存在`);
			return { success: false, error: 'Room not found' };
		}
		
		if (Store.byName.has(newName)) {
			console.log(`房间名称 ${newName} 已存在`);
			return { success: false, error: 'Name already exists' };
		}
		
		try {
			logInfo(`🧪 开始测试房间重命名同步: ${oldName} -> ${newName}`);
			
			// 1. 更新本地Store和索引
			Store.byName.delete(oldName);
			room.name = newName;
			Store.byName.set(newName, room);
			
			// 2. 同步到数据库
			await syncRoomNameToDatabase(oldName, newName);
			
			// 3. 强制刷新UI
			setTimeout(() => {
				const grid = document.getElementById('roomGrid');
				const oldEl = grid.querySelector(`[data-room='${CSS.escape(oldName)}']`);
				if (oldEl) {
					oldEl.remove();
				}
				renderRoomCardForced(newName);
				renderRooms();
			}, 100);
			
			const result = {
				success: true,
				oldName,
				newName,
				message: '房间重命名已完成，其他设备应该能看到变化'
			};
			
			console.log('✅ 房间重命名同步测试完成:', result);
			return result;
			
		} catch (error) {
			logErr('房间重命名同步测试失败:', error.message);
			// 恢复原状态
			Store.byName.delete(newName);
			room.name = oldName;
			Store.byName.set(oldName, room);
			renderRoomCardForced(oldName);
			
			return { success: false, error: error.message };
		}
	};

	// 💡 检查房间元数据实时同步状态的调试函数
	window.checkRoomMetaSync = function() {
		const status = {
			supabaseReady: !!window.supabaseReady,
			supabaseClient: !!window.supabaseClient,
			roomMetaRealtimeInit: !!window.__roomMetaRealtimeInit,
			roomMetaRealtimeConnected: !!window.__roomMetaRealtimeConnected,
			roomsRealtimeInit: !!window.__roomsRealtimeInit,
			roomsRealtimeConnected: !window.__roomsRealtimeReconnecting
		};
		
		console.log('🔍 房间信息同步状态检查:');
		console.table(status);
		
		if (!status.supabaseReady) {
			console.warn('⚠️ Supabase未就绪，请等待连接');
		} else if (!status.roomMetaRealtimeInit) {
			console.warn('⚠️ 房间元数据实时订阅未初始化');
		} else if (!status.roomMetaRealtimeConnected) {
			console.warn('⚠️ 房间元数据实时订阅未连接');
		} else if (!status.roomsRealtimeInit) {
			console.warn('⚠️ 房间状态实时订阅未初始化');
		} else if (!status.roomsRealtimeConnected) {
			console.warn('⚠️ 房间状态实时订阅连接异常');
		} else {
			console.log('✅ 房间信息实时同步工作正常');
			console.log('📝 支持的功能: 备注修改、类型切换、房间重命名');
		}
		
		return status;
	};

	async function assignRoom(roomName, student, expectedVersion, opts = {}){
		/*
		 * 统一的房间登记函数，内置时间段检测逻辑
		 * opts.forced = true 时跳过时间检测（用于强制登记或系统操作）
		 * opts.forced = false/undefined 时进行时间检测，不在时段时弹窗确认
		 */
		// 触发多设备同步增强
		syncEnhancer.recordUserOperation();
		
		// 如果不是强制操作，需要先进行时间段检测
		if (!opts.forced) {
			logInfo(`检查学生 ${student} 的练琴时间段`);
			// 若关闭检测直接登记
			if(Store.settings && Store.settings.practiceSlotCheckEnabled===false){
				logInfo('时间段检测已关闭，直接登记');
				// 继续执行登记
			} else {
				const info = await checkPracticeSlot(student);
				if (!info.inSlot) {
					logInfo(`学生 ${student} 不在允许时间段内，需要用户确认`);
					// 不在时段 -> 弹窗确认
					const ok = await showPracticeTimeConfirm(student, info);
					if (!ok) { 
						logInfo(`用户取消了学生 ${student} 的登记操作`);
						toast('已取消登记'); 
						return { ok: false, cancelled: true }; 
					}
					// 用户确认后，将此次操作标记为forced
					logInfo(`用户确认了学生 ${student} 的时间段外登记`);
					opts.forced = true;
				} else {
					logInfo(`学生 ${student} 在允许时间段内，直接登记`);
				}
			}
		} else {
			logInfo(`强制登记模式，跳过学生 ${student} 的时间段检测`);
		}
		
		// 检查操作锁，防止重复操作
		const lockKey = `assign_${roomName}`;
		if (Store.operationLocks?.has(lockKey)) {
			logWarn(`房间 ${roomName} 正在处理中，请稍候`);
			toast(`房间 ${roomName} 正在处理中...`, 'warn');
			return { ok: false, error: '操作进行中' };
		}
		
		// 设置操作锁
		if (!Store.operationLocks) Store.operationLocks = new Set();
		Store.operationLocks.add(lockKey);
		
		try {
			// 乐观更新（立即显示效果）
			const optimisticResult = optimisticAssign(roomName, student);
			if (!optimisticResult) {
				return { ok: false, error: '乐观更新失败' };
			}
			
			// 后端同步
			if(!supabaseReady){ 
				logWarn('离线模式 - 仅本地更新');
				return {ok:true, offline:true}; 
			}
			
			const nowIso = new Date().toISOString();
			const row = Store.rooms.find(r=>r.name===roomName);
			const nextVersion = (row? row.version:0)+1;
			
			// 标记为待处理状态
			Store.pendingAssign.set(roomName, { 
				student, 
				version: nextVersion, 
				timestamp: Date.now() 
			});
			
			const { data, error } = await supabaseClient.from('rooms').upsert({
				name: roomName,
				occupant_student_name: student,
				register_time: nowIso,
				heartbeat_at: nowIso,
				version: nextVersion,
				updated_at: nowIso
			});
			
			if(error){ 
				logErr('登记失败', error.message);
				// 回滚乐观更新
				rollbackOptimisticAssign(roomName);
				return {ok:false,error}; 
			}
			
			// 写入练习记录
			await writePracticeLog(roomName, student, 'assign');
			
			logInfo(`成功登记 ${student} -> ${roomName} (v${nextVersion})`);
			return {ok:true, data};
			
		} finally {
			// 清除操作锁
			Store.operationLocks.delete(lockKey);
			// 清除待处理状态
			Store.pendingAssign.delete(roomName);
			// 清除视觉指示
			clearOperationIndicator(roomName);
		}
	}

	/*************************************************
	 * 练琴时间段检测封装
	 *************************************************/
	// 缓存: studentName+weekday -> {inSlot, slots, checkedAt}
	const PracticeSlotCache = new Map();
	// 工具：将 HH:MM / HH:MM:SS 转为分钟数
	function timeStrToMinutes(t){
		if(!t) return null; const m=t.trim().split(':');
		if(m.length<2) return null; return parseInt(m[0],10)*60+parseInt(m[1],10);
	}
	// 获取当前 weekday (1-7 但我们只用 1-5) 映射：周一=1 ... 周日=7
	function currentWeekday(){
		let d=new Date(); let w=d.getDay(); // 0=周日
		return w===0?7:w; 
	}
	// 查询学生当前时间是否在允许时段
	async function checkPracticeSlot(studentName, opts={ force:false }){
		if(!studentName) return { inSlot:true, reason:'无学生名', slots:[] };
		if(!supabaseReady){
			return { inSlot:true, offline:true, reason:'离线模式直接放行', slots:[] };
		}
		const wd=currentWeekday();
		// 只缓存 60 秒
		const cacheKey=studentName+'_'+wd; const cached=PracticeSlotCache.get(cacheKey);
		if(cached && !opts.force && (Date.now()-cached.checkedAt<60000)) return cached;
		const now=new Date(); const minutes=now.getHours()*60+now.getMinutes();
		try{
			const { data, error } = await supabaseClient.from('student_time_slots')
				.select('start_time,end_time,weekday')
				.eq('student_name', studentName)
				.eq('weekday', wd);
			if(error){
				logWarn('检测练琴时段查询失败', error.message);
				return { inSlot:true, reason:'查询失败默认放行', error };
			}
			const slots=(data||[]).map(r=>({
				start:timeStrToMinutes(r.start_time),
				end:timeStrToMinutes(r.end_time)
			})).filter(s=>s.start!=null && s.end!=null && s.end>s.start);
			let inSlot=false; let hit=null;
			for(const s of slots){ if(minutes>=s.start && minutes<s.end){ inSlot=true; hit=s; break; } }
			// 预时段宽限：距离任一未来时段开始 <= GRACE_MINUTES (默认10) 亦视为在时段内，不弹窗
			if(!inSlot){
				const GRACE_MINUTES=10;
				for(const s of slots){
					if(minutes < s.start){
						const gap=s.start - minutes;
						if(gap<=GRACE_MINUTES){ inSlot=true; hit=s; var preSlotGrace=true; break; }
					}
				}
			}
			const result={ inSlot, slots, currentMinutes:minutes, hit, checkedAt:Date.now(), cacheKey, preSlotGrace: typeof preSlotGrace!=='undefined' };
			PracticeSlotCache.set(cacheKey,result);
			return result;
		}catch(e){
			logWarn('检测练琴时段异常', e.message);
			return { inSlot:true, reason:'异常默认放行', error:e };
		}
	}

	// 弹窗：不在时段提示，用户确认后继续
	function showPracticeTimeConfirm(studentName, slotInfo){
		return new Promise(resolve=>{
			// 若已有弹窗节点复用
			let id='practiceSlotConfirmModal'; let backdrop=document.getElementById(id);
			if(backdrop){ backdrop.remove(); }
			backdrop=document.createElement('div');
			backdrop.id=id;
			backdrop.className='modal-backdrop';
			backdrop.style.display='flex';
			backdrop.innerHTML=`<div class="modal" style="max-width:520px;">
				<div class="modal-header"><h3 style="font-size:16px;">练琴时段确认</h3><button class="ghost" data-role="close" style="padding:4px 8px;">✕</button></div>
				<div class="modal-body" style="gap:16px;">
					<p style="margin:0;font-size:14px;line-height:1.6;">当前时间不在 <strong>${studentName}</strong> 设定的练琴时间段内。<br/>是否仍然要登记？</p>
					${renderSlotTable(slotInfo.slots)}
					<p style="margin:0;font-size:12px;color:#ffb347;">提示：继续登记将被记录，可用于后续统计与异常提醒。</p>
				</div>
				<div class="modal-footer">
					<button class="ghost" data-role="cancel">取消</button>
					<button class="primary" data-role="confirm">继续登记</button>
				</div>
			</div>`;
			document.body.appendChild(backdrop);
			function close(v){ backdrop.remove(); resolve(v); }
			backdrop.addEventListener('click', e=>{ if(e.target===backdrop) close(false); });
			backdrop.querySelector('[data-role=close]').onclick=()=>close(false);
			backdrop.querySelector('[data-role=cancel]').onclick=()=>close(false);
			backdrop.querySelector('[data-role=confirm]').onclick=()=>close(true);
		});
	}
	function renderSlotTable(slots){
		if(!slots || slots.length===0) return `<div style="font-size:12px;color:#999;">该学生今天没有配置任何时间段。</div>`;
		return `<table style="width:100%;border-collapse:collapse;font-size:12px;">
			<thead><tr><th style="text-align:left;padding:4px 6px;border-bottom:1px solid #2f3844;font-weight:600;color:#90a4b8;">允许时间段</th></tr></thead>
			<tbody>${slots.map(s=>`<tr><td style=\"padding:4px 6px;border-bottom:1px solid #2f3844;\">${fmtMinutes(s.start)} - ${fmtMinutes(s.end)}</td></tr>`).join('')}</tbody>
		</table>`;
	}
	function fmtMinutes(m){ const h=Math.floor(m/60), mm=String(m%60).padStart(2,'0'); return `${h}:${mm}`; }

	// 对外：尝试登记（带时段检测与确认）
	async function attemptAssignRoom(roomName, studentName){
		// 直接调用assignRoom，时间检测逻辑已内置
		return assignRoom(roomName, studentName);
	}
	
	// 内部：强制登记（跳过时间检测，用于系统操作或管理员操作）
	async function forceAssignRoom(roomName, studentName, expectedVersion){
		return assignRoom(roomName, studentName, expectedVersion, { forced: true });
	}
	
	// 转移学生从一个房间到另一个房间（带时间检测）
	async function transferStudent(fromRoom, toRoom, studentName) {
		try {
			logInfo(`🔄 开始转移学生 ${studentName} 从 ${fromRoom} 到 ${toRoom}`);
			
			// 验证转移的有效性
			const fromRoomObj = Store.rooms.find(r => r.name === fromRoom);
			const toRoomObj = Store.rooms.find(r => r.name === toRoom);
			
			if (!fromRoomObj || fromRoomObj.occupant_student_name !== studentName) {
				logWarn(`原房间 ${fromRoom} 不存在或学生不匹配`);
				return { ok: false, error: '原房间状态不匹配' };
			}
			
			if (!toRoomObj) {
				logWarn(`目标房间 ${toRoom} 不存在`);
				return { ok: false, error: '目标房间不存在' };
			}
			
			if (toRoomObj.occupant_student_name && toRoomObj.occupant_student_name !== studentName) {
				logWarn(`目标房间 ${toRoom} 已被其他学生占用`);
				return { ok: false, error: '目标房间已被占用' };
			}
			
			// 先进行时间检测，但不实际登记新房间
			if (Store.settings && Store.settings.practiceSlotCheckEnabled !== false) {
				logInfo(`⏰ 检查学生 ${studentName} 的练琴时间段`);
				const info = await checkPracticeSlot(studentName);
				if (!info.inSlot) {
					logInfo(`⚠️ 学生 ${studentName} 不在允许时间段内，需要用户确认`);
					// 不在时段 -> 弹窗确认
					const ok = await showPracticeTimeConfirm(studentName, info);
					if (!ok) { 
						logInfo(`❌ 用户取消了学生 ${studentName} 的转移操作`);
						return { ok: false, cancelled: true }; 
					}
					logInfo(`✅ 用户确认了学生 ${studentName} 的时间段外转移`);
				} else {
					logInfo(`✅ 学生 ${studentName} 在允许时间段内，可以转移`);
				}
			} else {
				logInfo('⚙️ 时间段检测已关闭，直接转移');
			}
			
			// 时间检测通过后，进行实际的转移操作
			logInfo(`🚀 开始执行转移操作：${studentName} ${fromRoom} → ${toRoom}`);
			
			// 先登记新房间（强制模式，跳过时间检测）
			const assignResult = await forceAssignRoom(toRoom, studentName);
			if (!assignResult || !assignResult.ok) {
				logWarn(`❌ 新房间 ${toRoom} 登记失败`);
				return { ok: false, error: '新房间登记失败' };
			}
			logInfo(`✅ 新房间 ${toRoom} 登记成功`);
			
			// 新房间登记成功后，清空原房间
			logInfo(`🧹 开始清空原房间 ${fromRoom}`);
			const clearResult = await clearRoom(fromRoom);
			if (!clearResult || !clearResult.ok) {
				logWarn(`⚠️ 原房间 ${fromRoom} 清空失败，但新房间已登记成功`);
				// 即使清空失败，转移也算成功，因为新房间已经登记了
			} else {
				logInfo(`✅ 原房间 ${fromRoom} 清空成功`);
			}
			
			logInfo(`🎉 转移完成：${studentName} 已从 ${fromRoom} 移至 ${toRoom}`);
			return { ok: true };
			
		} catch (error) {
			logErr(`转移学生 ${studentName} 时发生错误:`, error.message);
			return { ok: false, error: error.message };
		}
	}
	async function clearRoom(roomName){
		// 触发多设备同步增强
		syncEnhancer.recordUserOperation();
		
		// 检查操作锁，防止重复操作
		const lockKey = `clear_${roomName}`;
		if (Store.operationLocks?.has(lockKey)) {
			logWarn(`房间 ${roomName} 正在清空中，请稍候`);
			toast(`房间 ${roomName} 正在清空中...`, 'warn');
			return { ok: false, error: '操作进行中' };
		}
		
		const row = Store.rooms.find(r=>r.name===roomName);
		if(!row || !row.occupant_student_name) {
			toast('房间已为空');
			return {ok:true};
		}
		
		// 设置操作锁
		if (!Store.operationLocks) Store.operationLocks = new Set();
		Store.operationLocks.add(lockKey);
		
		try {
			// 写入练习结束记录
			await writePracticeLog(roomName, row.occupant_student_name, 'clear');
			
			// 乐观更新（立即显示效果）
			optimisticClear(roomName);
			
			if(!supabaseReady){ 
				logWarn('离线模式 - 仅本地清空');
				return {ok:true, offline:true}; 
			}
			
			const nextVersion = (row.version || 0) + 1;
			
			// 标记为待处理状态
			Store.pendingAssign.set(roomName, { 
				student: null, 
				version: nextVersion, 
				timestamp: Date.now() 
			});
			
			const { data, error } = await supabaseClient.from('rooms').upsert({
				name: roomName,
				occupant_student_name: null, 
				register_time: null,
				heartbeat_at: new Date().toISOString(),
				version: nextVersion,
				updated_at: new Date().toISOString()
			});			if(error){ 
				logErr('清空失败', error.message);
				// 清空失败时回滚本地状态
				const rollbackState = Store.rollbackStates?.get(roomName);
				if (rollbackState && row) {
					row.occupant_student_name = rollbackState.occupant_student_name;
					row.registerTime = rollbackState.registerTime;
					row.version = rollbackState.version;
					renderRoomCard(roomName);
					updateUsageStats();
					toast(`❌ 清空失败，已回滚 ${roomName}`, 'error');
				}
				return {ok:false,error}; 
			}
			
			logInfo(`成功清空 ${roomName} (v${nextVersion})`);
			
			// 🔄 单个房间清空成功后立即触发计时器更新，确保其他设备同步
			setTimeout(() => {
				if (window.updateAllRoomTimers && typeof window.updateAllRoomTimers === 'function') {
					logInfo(`🔄 房间 ${roomName} 清空成功，触发全局计时器更新`);
					window.updateAllRoomTimers();
				}
			}, 100);
			
			return {ok:true, data};
			
		} finally {
			// 清除操作锁
			Store.operationLocks.delete(lockKey);
			// 清除待处理状态
			Store.pendingAssign.delete(roomName);
			// 清除视觉指示
			clearOperationIndicator(roomName);
		}
	}

	// 一键清空所有琴房
	async function clearAllRooms() {
		// 🔄 一键清空操作时立即触发增强同步模式
		syncEnhancer.recordUserOperation();
		
		// 显示二次确认弹窗（函数内部会检查占用的房间）
		const confirmResult = await showClearAllConfirm();
		if (!confirmResult) {
			return; // 用户取消操作
		}

		// 重新获取占用的房间（确保数据最新）
		const occupiedRooms = Store.rooms.filter(room => room.occupant_student_name && room.occupant_student_name.trim() !== '');

		// 开始批量清空 - 增强一致性保障
		let successCount = 0;
		let failCount = 0;
		const startTime = Date.now();
		const clearResults = []; // 记录每个房间的清空结果

		toast(`开始清空 ${occupiedRooms.length} 个琴房...`, 'info');

		// 串行清空（避免并发导致的版本冲突和数据不一致）
		for (let i = 0; i < occupiedRooms.length; i++) {
			const room = occupiedRooms[i];
			try {
				logInfo(`正在清空房间 ${i+1}/${occupiedRooms.length}: ${room.name} (学生: ${room.occupant_student_name})`);
				
				const result = await clearRoom(room.name);
				clearResults.push({
					roomName: room.name,
					studentName: room.occupant_student_name,
					success: result.ok,
					error: result.error
				});
				
				if (result.ok) {
					successCount++;
					logInfo(`✅ 成功清空: ${room.name}`);
				} else {
					failCount++;
					logErr(`❌ 清空失败: ${room.name} - ${result.error}`);
				}
				
				// 每清空一个房间后短暂延迟，确保数据库操作完成
				await new Promise(resolve => setTimeout(resolve, 100));
				
			} catch (error) {
				failCount++;
				const errorMsg = error.message || '未知错误';
				logErr(`清空房间 ${room.name} 异常:`, errorMsg);
				clearResults.push({
					roomName: room.name,
					studentName: room.occupant_student_name,
					success: false,
					error: errorMsg
				});
			}
			
			// 显示进度
			toast(`已处理 ${i+1}/${occupiedRooms.length} 个琴房 (成功:${successCount}, 失败:${failCount})`, 'info');
		}

		const duration = Math.round((Date.now() - startTime) / 1000);
		
		// 🔄 清空完成后立即验证数据一致性
		toast('正在验证清空结果...', 'info');
		
		// 等待数据库操作完全完成
		await new Promise(resolve => setTimeout(resolve, 1000));
		
		// 🔧 使用数据一致性验证器强制同步
		if (DataConsistencyValidator) {
			try {
				await DataConsistencyValidator.forceDataSync();
				logInfo('[ClearAll] 已通过数据验证器强制同步');
			} catch (error) {
				logErr('[ClearAll] 数据验证器同步失败:', error.message);
				// 兜底：手动刷新数据
				try {
					const latestRooms = await fetchRooms();
					if (latestRooms) {
						Store.rooms = latestRooms;
						renderRooms();
						updateUsageStats();
					}
				} catch (fallbackError) {
					logErr('[ClearAll] 兜底数据刷新也失败:', fallbackError.message);
				}
			}
		} else {
			// 如果验证器不可用，使用原来的方法
			try {
				const latestRooms = await fetchRooms();
				if (latestRooms) {
					Store.rooms = latestRooms;
					renderRooms(); // 立即刷新UI
					updateUsageStats();
					logInfo('已强制刷新房间数据，确保显示最新状态');
				}
			} catch (error) {
				logErr('验证清空结果时拉取数据失败:', error.message);
			}
		}
		
		// 验证清空结果
		const stillOccupiedRooms = Store.rooms.filter(r => r.occupant_student_name && r.occupant_student_name.trim() !== '');
		const unexpectedOccupied = stillOccupiedRooms.filter(room => 
			clearResults.some(result => result.roomName === room.name && result.success)
		);
		
		// 生成详细报告
		let message = `批量清空完成！成功: ${successCount}, 失败: ${failCount}, 耗时: ${duration}秒`;
		
		if (unexpectedOccupied.length > 0) {
			message += `\n⚠️ 发现 ${unexpectedOccupied.length} 个房间状态异常，建议刷新页面`;
			logWarn('检测到数据不一致:', unexpectedOccupied.map(r => `${r.name}:${r.occupant_student_name}`));
		}
		
		if (stillOccupiedRooms.length > 0) {
			message += `\n📍 仍有 ${stillOccupiedRooms.length} 个房间占用中`;
		}
		
		if (failCount === 0 && unexpectedOccupied.length === 0) {
			toast(message, 'success');
			logInfo(message);
		} else {
			toast(message, 'warn');
			logWarn(message);
		}

		// 🔄 批量清空完成后强制触发多设备同步
		setTimeout(() => {
			if (window.updateAllRoomTimers && typeof window.updateAllRoomTimers === 'function') {
				logInfo('🔄 批量清空后强制更新所有设备的计时器状态');
				window.updateAllRoomTimers();
			}
			
			// 强制刷新索引，确保数据一致性
			rebuildIndexes();
		}, 500);

		// 更新统计信息
		updateUsageStats();
	}

	// 显示清空所有琴房的确认弹窗
	function showClearAllConfirm() {
		// 获取所有占用的琴房
		const occupiedRooms = Store.rooms.filter(room => room.occupant_student_name && room.occupant_student_name.trim() !== '');
		
		// 如果没有占用的琴房，直接提示
		if (occupiedRooms.length === 0) {
			showToast('当前没有被占用的琴房', 'info');
			return Promise.resolve(false);
		}
		
		return new Promise((resolve) => {
			// 创建弹窗元素
			const modal = document.createElement('div');
			modal.className = 'modal-backdrop';
			modal.style.cssText = 'display:flex;position:fixed;inset:0;z-index:4000;background:rgba(0,0,0,.6);backdrop-filter:blur(4px);align-items:center;justify-content:center;';
			
			const roomList = occupiedRooms.map(room => 
				`<div style="padding:4px 0;border-bottom:1px solid #eee;"><strong>${room.name}</strong> - ${room.occupant_student_name}</div>`
			).join('');

			modal.innerHTML = `
				<div style="background:#fff;border-radius:12px;padding:24px;max-width:500px;max-height:70vh;overflow:hidden;box-shadow:0 8px 32px rgba(0,0,0,.3);display:flex;flex-direction:column;">
					<div style="display:flex;align-items:center;margin-bottom:16px;">
						<span style="font-size:24px;margin-right:12px;">⚠️</span>
						<h3 style="margin:0;color:#e74c3c;font-size:18px;">确认清空所有琴房</h3>
					</div>
					<div style="margin-bottom:20px;color:#666;line-height:1.5;">
						<p style="margin:0 0 12px 0;">您即将清空 <strong style="color:#e74c3c;">${occupiedRooms.length}</strong> 个正在使用的琴房：</p>
						<div style="max-height:200px;overflow-y:auto;border:1px solid #ddd;border-radius:6px;padding:12px;background:#f9f9f9;font-size:14px;">
							${roomList}
						</div>
						<p style="margin:12px 0 0 0;font-weight:600;color:#d63031;">此操作不可撤销，请谨慎操作！</p>
					</div>
					<div style="display:flex;gap:12px;justify-content:flex-end;">
						<button id="cancelClearAll" style="padding:10px 20px;border:1px solid #ddd;background:#fff;border-radius:6px;cursor:pointer;font-weight:600;">取消</button>
						<button id="confirmClearAll" style="padding:10px 20px;border:none;background:#e74c3c;color:#fff;border-radius:6px;cursor:pointer;font-weight:600;">确认清空</button>
					</div>
				</div>
			`;

			document.body.appendChild(modal);

			// 绑定事件
			const cancelBtn = modal.querySelector('#cancelClearAll');
			const confirmBtn = modal.querySelector('#confirmClearAll');

			const cleanup = () => {
				document.body.removeChild(modal);
			};

			cancelBtn.addEventListener('click', () => {
				cleanup();
				resolve(false);
			});

			confirmBtn.addEventListener('click', () => {
				cleanup();
				resolve(true);
			});

			// 点击背景关闭
			modal.addEventListener('click', (e) => {
				if (e.target === modal) {
					cleanup();
					resolve(false);
				}
			});

			// ESC 键关闭
			const handleEsc = (e) => {
				if (e.key === 'Escape') {
					document.removeEventListener('keydown', handleEsc);
					cleanup();
					resolve(false);
				}
			};
			document.addEventListener('keydown', handleEsc);
		});
	}

	// 状态一致性检查和修复
	async function reconcileRoomState(roomName) {
		if (!supabaseReady) return;
		
		// 使用请求限流器避免频繁状态同步
		if (!requestThrottler.canExecute('reconcile', roomName)) return;
		
		try {
			const { data: cloudRoom, error } = await supabaseClient
				.from('rooms')
				.select('*')
				.eq('name', roomName)
				.single();
				
			requestStats.record('reconcile');
				
			if (error) {
				logWarn(`获取房间 ${roomName} 云端状态失败:`, error.message);
				return;
			}
			
			const localRoom = Store.rooms.find(r => r.name === roomName);
			if (!localRoom) return;
			
			const cloudVersion = cloudRoom?.version || 0;
			const localVersion = localRoom.version || 0;
			
			// 如果云端版本更新，同步到本地
			if (cloudVersion > localVersion) {
				logInfo(`同步房间 ${roomName} 状态: v${localVersion} -> v${cloudVersion}`);
				localRoom.occupant_student_name = cloudRoom.occupant_student_name;
				localRoom.registerTime = cloudRoom.register_time ? new Date(cloudRoom.register_time).getTime() : null;
				localRoom.version = cloudVersion;
				localRoom.heartbeatAt = cloudRoom.heartbeat_at;
				
				renderRoomCard(roomName);
				updateUsageStats();
				
				const action = cloudRoom.occupant_student_name ? '占用' : '释放';
				toast(`🔄 ${roomName} 状态已同步: ${action}`, 'info');
			}
		} catch (e) {
			logWarn(`房间状态同步异常 ${roomName}:`, e.message);
		}
	}
	
	// 定期状态检查
	let stateCheckInterval;
	function startPeriodicStateCheck() {
		// 防止重复创建定时器
		if (window.__periodicStateCheckInterval) {
			clearInterval(window.__periodicStateCheckInterval);
		}
		
		// 💡 状态检查频率优化 - 大幅降低或禁用
		const STATE_CHECK_ENABLED = false; // 🔧 默认禁用周期性状态检查
		const STATE_CHECK_INTERVAL = 600000; // 10分钟（如果启用的话）
		
		if (STATE_CHECK_ENABLED) {
			logInfo(`启用周期性状态检查，间隔${STATE_CHECK_INTERVAL/60000}分钟`);
			window.__periodicStateCheckInterval = setInterval(async () => {
				try {
					// 检查紧急刹车
					if (emergencyBrake.isEngaged()) return;
					
					// 只在必要时进行状态检查
					if (!supabaseReady || !supabaseClient) return;
					
					// 检查realtime连接状态，如果正常就跳过状态检查
					const timeSinceActivity = Date.now() - realtimeMonitor.lastActivity;
					if (timeSinceActivity < 300000) { // 5分钟内有realtime活动
						logInfo('Realtime连接正常，跳过周期性状态检查');
						return;
					}
					
					// 检查有占用者的房间状态
					const occupiedRooms = Store.rooms.filter(r => r.occupant_student_name && r.registerTime);
					if (occupiedRooms.length === 0) return; // 没有占用房间时跳过检查
					
					logInfo(`备用状态检查: ${occupiedRooms.length} 个占用房间（realtime异常时）`);
					
					for (let i = 0; i < occupiedRooms.length; i++) {
						const room = occupiedRooms[i];
						await reconcileRoomState(room.name);
						// 增加间隔时间，减少并发压力
						if (i < occupiedRooms.length - 1) {
							await new Promise(resolve => setTimeout(resolve, 1000));
						}
					}
				} catch (error) {
					logWarn('周期性状态检查失败:', error.message);
				}
			}, STATE_CHECK_INTERVAL);
		} else {
			logInfo('周期性状态检查已禁用，完全依赖realtime和事件触发');
		}
	}
	
	// 操作超时检测和恢复
	function setupOperationTimeoutDetection() {
		// 防止重复创建定时器
		if (window.__operationTimeoutInterval) {
			clearInterval(window.__operationTimeoutInterval);
		}
		
		window.__operationTimeoutInterval = setInterval(() => {
			try {
				if (!Store.pendingAssign || Store.pendingAssign.size === 0) return;
				
				const now = Date.now();
				const timeoutThreshold = 15000; // 延长到15秒超时，减少误判
				
				for (const [roomName, pending] of Store.pendingAssign.entries()) {
					if (now - pending.timestamp > timeoutThreshold) {
						logWarn(`房间 ${roomName} 操作超时，触发状态检查`);
						
						// 清除待处理状态
						Store.pendingAssign.delete(roomName);
						
						// 清除操作锁
						if (Store.operationLocks) {
							Store.operationLocks.delete(`assign_${roomName}`);
							Store.operationLocks.delete(`clear_${roomName}`);
						}
						
						// 触发状态同步
						reconcileRoomState(roomName);
						
						toast(`⚠️ ${roomName} 操作超时，已重新同步状态`, 'warn');
					}
				}
			} catch (error) {
				logWarn('超时检测失败:', error.message);
			}
		}, 60000); // 💡 延长到60秒检查一次，减少轮询频率
	}
	function optimisticAssign(roomName, student, version){
		let r=Store.rooms.find(r=>r.name===roomName); 
		if(!r){ 
			r=canonicalizeRoom({name:roomName}); 
			Store.rooms.push(r); 
		}
		
		// 保存原始状态用于可能的回滚
		if (!Store.rollbackStates) Store.rollbackStates = new Map();
		Store.rollbackStates.set(roomName, {
			occupant_student_name: r.occupant_student_name,
			registerTime: r.registerTime,
			version: r.version
		});
		
		r.occupant_student_name=student; 
		r.registerTime=getServerSyncedTime(); 
		r.version=version||r.version+1; 
		Store.pendingAssign.set(roomName,{occupant_student_name:student,version:r.version,ts:Date.now()});
		
		// 🔄 登记操作时立即触发增强同步模式
		syncEnhancer.recordUserOperation();
		
		// 添加视觉指示
		const card = document.querySelector(`[data-room="${roomName}"]`);
		if (card) {
			card.classList.add('pending-operation');
			card.dataset.status = 'syncing';
		}
		
		renderRoomCard(roomName); 
		updateUsageStats(); 
		toast(`✅ 已登记 ${student} -> ${roomName}`, 'success');
		
		// 🗄️ 保存计时器状态
		timerPersistence.saveTimerStates();
		
		return true;
	}
	
	function rollbackOptimisticAssign(roomName) {
		if (!Store.rollbackStates) return;
		
		const originalState = Store.rollbackStates.get(roomName);
		if (!originalState) return;
		
		const r = Store.rooms.find(r => r.name === roomName);
			if (r) {
				r.occupant_student_name = originalState.occupant_student_name;
			r.registerTime = originalState.registerTime;
			r.version = originalState.version;
			
			// 移除视觉指示
			const card = document.querySelector(`[data-room="${roomName}"]`);
			if (card) {
				card.classList.remove('pending-operation');
			}
			
			renderRoomCard(roomName);
			updateUsageStats();
			toast(`❌ 登记失败，已回滚 ${roomName}`, 'error');
		}
		
		Store.rollbackStates.delete(roomName);
		Store.pendingAssign.delete(roomName);
	}
	
	function optimisticClear(roomName, version){
		const r=Store.rooms.find(r=>r.name===roomName); 
		if(!r) return;
		
		// 保存原始状态用于可能的回滚
		if (!Store.rollbackStates) Store.rollbackStates = new Map();
		Store.rollbackStates.set(roomName, {
			occupant_student_name: r.occupant_student_name,
			registerTime: r.registerTime,
			version: r.version
		});
		
		if(r.occupant_student_name){ 
			writePracticeLogLocal(r); 
		}
		
		r.occupant_student_name=null; 
		r.registerTime=null; 
		r.version=version||r.version+1;
		
		// 🔄 释放操作时立即触发增强同步模式
		syncEnhancer.recordUserOperation(); 
		
		// 添加视觉指示
		const card = document.querySelector(`[data-room="${roomName}"]`);
		if (card) {
			card.classList.add('pending-operation');
			card.dataset.status = 'syncing';
		}
		
		renderRoomCard(roomName); 
		updateUsageStats(); 
		toast(`✅ 已清空 ${roomName}`, 'success');
		
		// 🗄️ 保存计时器状态
		timerPersistence.saveTimerStates();
		
		return true;
	}
	
	// 移除操作进行中的视觉指示
	function clearOperationIndicator(roomName) {
		const card = document.querySelector(`[data-room="${roomName}"]`);
		if (card) {
			card.classList.remove('pending-operation');
		}
	}
	
	// 彻底清理房间的所有状态
	function cleanupRoomState(roomName) {
		// 清理待处理操作
		Store.pendingAssign.delete(roomName);
		
		// 清理回滚状态
		if (Store.rollbackStates) {
			Store.rollbackStates.delete(roomName);
		}
		
		// 清理操作锁
		if (Store.operationLocks) {
			Store.operationLocks.delete(`assign_${roomName}`);
			Store.operationLocks.delete(`clear_${roomName}`);
			Store.operationLocks.delete(`renew_${roomName}`);
			Store.operationLocks.delete(`delete_${roomName}`);
		}
		
		// 💡 更彻底的DOM清理：尝试多种选择器
		const selectors = [
			`[data-room="${CSS.escape(roomName)}"]`,
			`[data-room='${CSS.escape(roomName)}']`,
			`.room-card[data-room="${CSS.escape(roomName)}"]`
		];
		
		let domCleaned = false;
		for (const selector of selectors) {
			const cards = document.querySelectorAll(selector);
			if (cards.length > 0) {
				cards.forEach(card => {
					card.remove();
					domCleaned = true;
				});
			}
		}
		
		if (domCleaned) {
			logInfo(`🧹 DOM清理完成: ${roomName}`);
		}
		
		logInfo(`已清理房间 ${roomName} 的所有状态`);
	}
	async function setupRealtime(){
		// 检查页面可见性
		if (document.hidden) {
			logInfo('页面隐藏中，跳过realtime初始化');
			return;
		}
		
		// 检查紧急刹车状态
		if (emergencyBrake.isEngaged()) {
			logWarn('紧急刹车激活中，跳过realtime初始化');
			return;
		}
		
		if(!supabaseReady) {
			logWarn('Supabase 未就绪，跳过实时订阅');
			updateSyncStatus('error', '未连接');
			return;
		}
		// 避免重复初始化（标签页多次触发）
		if(window.__roomsRealtimeInit && !window.__roomsRealtimeReconnecting){
			logInfo('setupRealtime 已初始化，跳过');
			return;
		}
		window.__roomsRealtimeInit = true;
		
		updateSyncStatus('connecting', '订阅中...');
		
		// 清理旧连接
		if(realtimeChannel){ 
			try{ 
				supabaseClient.removeChannel(realtimeChannel);
				logInfo('已移除旧的实时频道');
			}catch(e){
				logWarn('移除旧频道失败', e.message);
			} 
		}
		
		// 清理学生数据库旧连接
		if(window.studentRealtimeChannel){ 
			try{ 
				supabaseClient.removeChannel(window.studentRealtimeChannel);
				logInfo('已移除旧的学生实时频道');
			}catch(e){
				logWarn('移除旧学生频道失败', e.message);
			} 
		}
		
		// 创建新的实时频道（房间）
		window.__roomsRealtimeReconnecting = true;
		realtimeChannel = supabaseClient.channel('realtime-rooms')
			.on('postgres_changes', {
				event: '*',
				schema: 'public',
				table: 'rooms'
			}, (payload) => {
				const roomName = payload.new?.name || payload.old?.name;
				logInfo(`🔔 [ROOMS表] 收到实时事件: ${payload.eventType} - ${roomName}`);
				
				// 💡 特别标记删除事件
				if(payload.eventType === 'DELETE'){
					logInfo(`🗑️ [ROOMS表] DELETE事件详情:`, payload);
				}
				
				// 记录数据更新时间和活动
				window.__lastRealtimeDataUpdate = Date.now();
				realtimeMonitor.recordActivity(); // 记录realtime活动
				requestStats.record('realtimeEvents'); // 记录realtime事件统计
				handleRealtimeRoom(payload);
			})
			.subscribe((status) => {
				if (status === 'SUBSCRIBED') {
					// 只在首次连接或重连成功时显示详细信息
					const hadReconnectAttempts = window.__roomsRealtimeAttempts > 0;
					if (hadReconnectAttempts) {
						logInfo('✅ 房间实时同步重连成功');
						toast('实时同步已恢复');
					} else if (!window.__roomsInitialConnected) {
						logInfo('✅ 房间实时同步已连接');
						toast('实时同步已启用');
						window.__roomsInitialConnected = true;
					}
					updateSyncStatus('connected', '实时同步');
					window.__roomsRealtimeReconnecting = false;
					window.__roomsRealtimeAttempts = 0;
				} else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status==='CLOSED') {
					// 📱 页面隐藏时的智能处理
					if (realtimeMonitor.pageHidden) {
						// 页面隐藏时静默处理，不记录日志
						console.debug(`[RT][rooms] 页面隐藏中，静默处理连接状态 (${status})`);
						return;
					}
					
					// 刚从隐藏状态恢复，给连接一些恢复时间
					if ((Date.now() - (window.__lastVisibilityChange || 0)) < 5000) {
						console.debug(`[RT][rooms] 页面刚恢复可见，延迟处理 (status=${status})`);
						return;
					}
					
					// 🤖 使用智能重连策略
					if (!realtimeMonitor.shouldAttemptReconnect(status)) {
						console.debug(`[RT][rooms] 智能重连策略决定跳过重连 (${status})`);
						return;
					}
					
					// 防止重复触发重连
					if (window.__roomsRealtimeReconnectTimer) {
						logInfo(`[RT][rooms] 状态=${status} 已有重连计时器运行，跳过`);
						return;
					}
					
					const attempts = (window.__roomsRealtimeAttempts||0) + 1;
					window.__roomsRealtimeAttempts = attempts;
					
					// 区分不同错误类型的处理策略
					let shouldReconnect = true;
					let baseDelay = 1000;
					
					if (status === 'CLOSED') {
						// CLOSED状态可能是正常关闭，减少重连频率
						baseDelay = 3000;
						// 如果短时间内多次CLOSED，可能是网络问题，延长等待
						const now = Date.now();
						const lastClosedTime = window.__lastClosedTime || 0;
						if (now - lastClosedTime < 10000) { // 10秒内多次CLOSED
							baseDelay = Math.min(30000, baseDelay * attempts); // 最长30秒
						}
						window.__lastClosedTime = now;
					}
					
					// 智能重连延迟算法
					const maxDelay = status === 'CLOSED' ? 180000 : 120000; // CLOSED状态允许更长延迟
					const delay = Math.min(maxDelay, Math.round(baseDelay * Math.pow(1.4, attempts-1) + Math.random()*1000));
					
					// 超过5次重连失败后，大幅延长重连间隔
					if (attempts > 5) {
						const longDelay = Math.min(300000, delay * 2); // 最长5分钟
						// 只在第6次和每10次时输出日志
						if(attempts === 6 || attempts % 10 === 0) {
							logWarn(`[RT][rooms] 状态=${status} 重连#${attempts} 延长等待 ${Math.round(longDelay/1000)}秒 (频繁失败)`);
						}
						updateSyncStatus('error', `连接异常，${Math.round(longDelay/1000)}秒后重试`);
						
						window.__roomsRealtimeReconnectTimer = setTimeout(()=>{
							window.__roomsRealtimeReconnectTimer = null;
							window.__roomsRealtimeReconnecting = true;
							setupRealtime();
						}, longDelay);
					} else if (attempts > 3) {
						const mediumDelay = Math.min(180000, delay * 1.5); // 最长3分钟
						// 只在第4次和第8次时输出日志
						if(attempts === 4 || attempts % 4 === 0) {
							logWarn(`[RT][rooms] 状态=${status} 重连#${attempts} 延长等待 ${Math.round(mediumDelay/1000)}秒`);
						}
						updateSyncStatus('error', `重连失败，${Math.round(mediumDelay/1000)}秒后重试`);
						
						window.__roomsRealtimeReconnectTimer = setTimeout(()=>{
							window.__roomsRealtimeReconnectTimer = null;
							window.__roomsRealtimeReconnecting = true;
							setupRealtime();
						}, mediumDelay);
					} else {
						// 减少日志频率：只在前2次或每5次输出警告
						if(attempts <= 2 || attempts % 5 === 0) {
							logWarn(`[RT][rooms] 状态=${status} 重连#${attempts} 预计 ${Math.round(delay/1000)}秒`);
						}
						updateSyncStatus('error', '重连中');
						
						window.__roomsRealtimeReconnectTimer = setTimeout(()=>{
							window.__roomsRealtimeReconnectTimer = null;
							window.__roomsRealtimeReconnecting = true;
							setupRealtime();
						}, delay);
					}
				} else {
					logInfo('[RT][rooms] 状态=', status);
				}
			});
		
		// 创建学生数据库实时频道
		window.studentRealtimeChannel = supabaseClient.channel('realtime-students')
			.on('postgres_changes', {
				event: '*',
				schema: 'public',
				table: 'student_database'
			}, (payload) => {
				if(!window.__studentRealtimeSeq) window.__studentRealtimeSeq=0;
				window.__studentRealtimeSeq++;
				const seq=window.__studentRealtimeSeq;
				const name = payload.new?.name || payload.old?.name;
				const src = (payload.subscription && payload.subscription.socket) ? 'ws' : 'unknown';
				console.log(`[RT][students][${seq}] event=${payload.eventType} name=${name} origin=${src}`, payload);
				
				// 记录数据更新时间和活动
				window.__lastRealtimeDataUpdate = Date.now();
				realtimeMonitor.recordActivity(); // 记录realtime活动
				requestStats.record('realtimeEvents'); // 记录realtime事件统计
				try{ handleRealtimeStudent(payload); }catch(e){ console.warn('[RT] 处理学生事件异常', e); }
			})
			.subscribe((status) => {
				const nowTs=new Date().toISOString();
				if (status === 'SUBSCRIBED') {
					// 只在首次连接或重连成功时输出日志
					const hadReconnectAttempts = window.__studentsRealtimeAttempts > 0;
					if (hadReconnectAttempts) {
						console.log(`[RT][students] ✅ 重连成功 @${nowTs}`);
					} else if (!window.__studentsInitialConnected) {
						console.log(`[RT][students] ✅ 初次连接成功 @${nowTs}`);
						window.__studentsInitialConnected = true;
					}
					window.__studentsRealtimeAttempts = 0;
					if(window.loadFromCloud){ setTimeout(()=>{ try{ loadFromCloud(); }catch(_){ } }, 800); }
				} else if (status === 'CHANNEL_ERROR' || status==='TIMED_OUT' || status==='CLOSED') {
					// 📱 页面隐藏时的智能处理
					if (realtimeMonitor.pageHidden) {
						// 页面隐藏时静默处理，不记录日志
						console.debug(`[RT][students] 页面隐藏中，静默处理连接状态 (${status})`);
						return;
					}
					
					// 刚从隐藏状态恢复，给连接一些恢复时间
					if ((Date.now() - (window.__lastVisibilityChange || 0)) < 5000) {
						console.debug(`[RT][students] 页面刚恢复可见，延迟处理 (status=${status})`);
						return;
					}
					
					// 对于 CLOSED 状态，更加保守的处理
					if (status === 'CLOSED') {
						// 检查是否频繁出现 CLOSED 事件
						if (realtimeMonitor.checkClosedEventFrequency()) {
							console.warn(`[RT][students] 频繁的 CLOSED 事件，暂停重连 10 分钟`);
							// 10分钟后重置计数器
							setTimeout(() => {
								realtimeMonitor.closedEvents = [];
								console.log(`[RT][students] CLOSED 事件计数器已重置`);
							}, 600000);
							return;
						}
						
						const timeSinceActivity = Date.now() - realtimeMonitor.lastActivity;
						// 如果最近有活动（5分钟内），说明连接是正常的，可能是临时断开
						if (timeSinceActivity < 300000) {
							console.log(`[RT][students] CLOSED状态但最近有活动(${Math.round(timeSinceActivity/60000)}分钟前)，延迟重连`);
							// 延迟15秒后再检查是否需要重连
							setTimeout(() => {
								if (!document.hidden && !realtimeMonitor.isReconnecting && !window.studentRealtimeChannel) {
									console.log(`[RT][students] 延迟检查后确认需要重连`);
									setupRealtime();
								}
							}, 15000);
							return;
						}
					}
					
					// 检查网络状态
					if (window.RealtimeConnectionManager && !window.RealtimeConnectionManager.checkNetworkStatus()) {
						console.log(`[RT][students] 网络离线，跳过重连`);
						return;
					}
					
					// 检查是否正在强制重连中
					if (realtimeMonitor.isReconnecting) {
						console.log(`[RT][students] 强制重连进行中，跳过自动重连 (status=${status})`);
						return;
					}
					
					// 防止重复触发重连
					if (window.__studentsRealtimeReconnectTimer) {
						console.log(`[RT][students] 状态=${status} 已有重连计时器运行，跳过`);
						return;
					}
					
					// 🤖 使用智能重连策略
					if (!realtimeMonitor.shouldAttemptReconnect(status)) {
						console.debug(`[RT][students] 智能重连策略决定跳过重连 (${status})`);
						return;
					}
					
					const attempts = (window.__studentsRealtimeAttempts||0)+1;
					window.__studentsRealtimeAttempts = attempts;
					
					// 使用统一的重连延迟计算
					const delay = realtimeMonitor.calculateReconnectDelay(attempts, status);
					
					// 根据页面状态选择日志级别
					const logLevel = document.hidden || realtimeMonitor.silentMode ? 'debug' : 'warn';
					const logFunc = logLevel === 'debug' ? console.debug : console.warn;
					
					// 减少日志频率
					if (attempts <= 2 || attempts % 5 === 0) {
						logFunc(`[RT][students] 状态=${status} 重连#${attempts} in ${Math.round(delay/1000)}s`);
					}
					
					window.__studentsRealtimeReconnectTimer=setTimeout(()=>{
						window.__studentsRealtimeReconnectTimer=null;
						setupRealtime();
					}, delay);
				} else {
					const logFunc = document.hidden || realtimeMonitor.silentMode ? console.debug : console.log;
					logFunc(`[RT][students] 状态=${status} @${nowTs}`);
				}
			});
		
		// 💡 添加房间元数据实时订阅，确保备注等信息的多设备同步
		if (!window.__roomMetaRealtimeInit) {
			window.__roomMetaRealtimeInit = true;
			logInfo('初始化房间元数据实时订阅...');
			
			supabaseClient
				.channel('room_metadata_sync')
				.on('postgres_changes', {
					event: '*',
					schema: 'public',
					table: 'room_database'
				}, (payload) => {
					const roomName = payload.new?.name || payload.old?.name;
					logInfo(`🔔 [ROOM_DATABASE表] 收到实时事件: ${payload.eventType} - ${roomName}`);
					
					// 💡 特别标记删除事件
					if(payload.eventType === 'DELETE'){
						logInfo(`�️ [ROOM_DATABASE表] DELETE事件详情:`, payload);
					}
					
					realtimeMonitor.recordActivity();
					requestStats.record('realtimeEvents');
					handleRealtimeRoomMeta(payload);
				})
				.subscribe((status) => {
					if (status === 'SUBSCRIBED') {
						logInfo('✅ 房间元数据实时同步已连接');
						// 设置全局标志，便于调试
						window.__roomMetaRealtimeConnected = true;
					} else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status === 'CLOSED') {
						// 🤖 使用智能日志记录
						const logFunc = document.hidden || realtimeMonitor.silentMode ? console.debug : console.warn;
						logFunc(`[RT][room-meta] 订阅状态: ${status}`);
						
						window.__roomMetaRealtimeConnected = false;
						
						// 🤖 使用智能重连策略
						if (!realtimeMonitor.shouldAttemptReconnect(status)) {
							console.debug(`[RT][room-meta] 智能重连策略决定跳过重连 (${status})`);
							return;
						}
						
						// 使用统一的重连延迟计算
						const delay = realtimeMonitor.calculateReconnectDelay(1, status);
						
						setTimeout(() => {
							if (!document.hidden) {
								const logFunc2 = document.hidden || realtimeMonitor.silentMode ? console.debug : console.info;
								logFunc2('🔄 重新初始化房间元数据订阅...');
								window.__roomMetaRealtimeInit = false;
								setupRealtime();
							}
						}, delay);
					} else {
						logInfo(`📡 房间元数据订阅状态: ${status}`);
					}
				});
		}

		// 💡 重新评估心跳检测的必要性
		// 在有realtime的情况下，心跳主要是冗余机制
		const HEARTBEAT_ENABLED = false; // 🔧 可配置开关，默认关闭
		const HEARTBEAT_INTERVAL = 600000; // 10分钟（如果启用的话）
		
		if (HEARTBEAT_ENABLED && !window.__heartbeatInterval) {
			logInfo(`启用心跳检测，间隔${HEARTBEAT_INTERVAL/60000}分钟`);
			window.__heartbeatInterval = setInterval(async () => {
				try {
					// 检查紧急刹车和连接状态
					if (emergencyBrake.isEngaged() || !supabaseReady || !supabaseClient) return;
					
					// 只在realtime连接异常时才发送心跳
					const timeSinceActivity = Date.now() - realtimeMonitor.lastActivity;
					if (timeSinceActivity < 300000) { // 5分钟内有realtime活动就跳过心跳
						logInfo('Realtime连接正常，跳过心跳');
						return;
					}
					
					// 使用请求限流器检查是否可以执行心跳
					if (!requestThrottler.canExecute('heartbeat')) return;
					
					const occupiedRooms = Store.rooms.filter(r => r.occupant_student_name && r.registerTime);
					if (occupiedRooms.length === 0) return; // 没有占用房间时不发送心跳
					
					// 批量更新心跳，减少请求数量
					const nowIso = new Date().toISOString();
					const roomNames = occupiedRooms.map(r => r.name);
					
					await supabaseClient.from('rooms')
						.update({ heartbeat_at: nowIso })
						.in('name', roomNames);
					
					requestStats.record('heartbeat');
					logInfo(`备用心跳更新: ${roomNames.length} 个房间（realtime异常时）`);
				} catch (error) {
					logWarn('心跳更新失败:', error.message);
				}
			}, HEARTBEAT_INTERVAL);
		} else {
			logInfo('心跳检测已禁用，完全依赖realtime机制');
		}
	}

	// 💡 处理房间元数据的实时更新
	function handleRealtimeRoomMeta(payload) {
		const row = payload.new || payload.old;
		if (!row) return;
	}

	// ==================== 🧩 房间元数据 Realtime 更新（含删除/软删除）增强版 ====================
	// 重写上方函数：支持 DELETE、软删除字段检测、幂等保护、UI 强制移除
	(function(){
		const ORIGINAL_handleRealtimeRoomMeta = handleRealtimeRoomMeta; // 备份引用（如需调试）

		// 🧹 统一强制移除函数：确保 Store / 索引 / DOM / 统计 全部同步清理
		if(!window.removeRoomEverywhere){
			// 🕵️ 调试辅助：检查某个房间在各层数据/DOM 的存在情况
			window.debugRoomPresence = function(roomName){
				const inByName = Store.byName.has(roomName);
				const inRooms = Store.rooms.some(r=>r.name===roomName);
				const inMeta = !!(Store.roomMeta && Store.roomMeta[roomName]);
				const domNodes = [...document.querySelectorAll('[data-room]')].filter(n=>n.getAttribute('data-room')===roomName);
				const locks = [...(Store.operationLocks||[])].filter(k=>k.includes(roomName));
				logInfo(`🔍 debugRoomPresence(${roomName}) byName:${inByName} rooms:${inRooms} meta:${inMeta} dom:${domNodes.length} locks:${locks.length}`);
				return {inByName,inRooms,inMeta,domCount:domNodes.length,locks};
			};
			window.removeRoomEverywhere = function(roomName, ctx){
				if(!roomName) return;
				const tag = ctx||'generic';
				logInfo(`🧹 [removeRoomEverywhere] 开始 (${tag}) -> ${roomName}`);
				try {
					// 1. 删除主数据
					if(Store.byName.has(roomName)) Store.byName.delete(roomName);
					const idx = Store.rooms.findIndex(r=>r.name===roomName);
					if(idx>-1){ Store.rooms.splice(idx,1); }
					// 2. 删除 meta
					if(Store.roomMeta && Store.roomMeta[roomName]) delete Store.roomMeta[roomName];
					// 3. 删除占用/锁/缓存
					cleanupRoomState(roomName);
					// 4. 重建索引 & 统计
					try{ rebuildIndexes(); }catch(e){}
					try{ updateUsageStats && updateUsageStats(); }catch(e){}
					// 5. DOM 强制移除
					const sel = `[data-room="${CSS.escape(roomName)}"]`;
					const el = document.querySelector(sel);
					if(el){ el.remove(); logInfo(`🧼 DOM节点已移除: ${roomName}`); } else { logInfo(`(DOM不存在或已移除) ${roomName}`); }
					// 5.1 即时整体重渲染
					if(window.renderRooms){ try{ renderRooms(); logInfo('🖼️ 首次即时重渲染完成'); }catch(e){} }
					// 6. 二次延迟兜底
					setTimeout(()=>{
						const el2=document.querySelector(sel);
						if(el2){ el2.remove(); logInfo(`🛠️ 二次兜底移除DOM: ${roomName}`); }
						else { logInfo(`🛡️ 二次兜底时已无DOM: ${roomName}`); }
					},120);
					// 6.5 第三次兜底（防残留幽灵节点）
					setTimeout(()=>{
						const ghost=[...document.querySelectorAll('[data-room]')].filter(n=>n.getAttribute('data-room')===roomName);
						if(ghost.length){ ghost.forEach(g=>g.remove()); logWarn(`🧟 移除幽灵DOM(${ghost.length}) ${roomName}`); }
					},400);
					// 7. 再次重渲染确认
					setTimeout(()=>{ if(window.renderRooms){ renderRooms(); logInfo(`🔄 重渲染完成 removeRoomEverywhere(${roomName})`);} },60);
					// 8. 输出最终状态
					setTimeout(()=>{
						const stillInStore = Store.byName.has(roomName) || Store.rooms.some(r=>r.name===roomName);
						const stillDOM = !!document.querySelector(sel);
						logInfo(`✅ 清理结果 (${roomName}) Store存在:${stillInStore} DOM存在:${stillDOM}`);
					},500);
				} catch(err){
					logErr('removeRoomEverywhere 失败:', err.message);
				}
			};
		}

		function isSoftDeleteTransition(payload){
			if(payload.eventType !== 'UPDATE') return false;
			const before = payload.old||{}; const after = payload.new||{};
			// 常见软删除字段兼容：deleted / deleted_at / is_deleted
			return (
				((after.deleted===true) && before.deleted!==true) ||
				((after.is_deleted===true) && before.is_deleted!==true) ||
				((after.deleted_at && !before.deleted_at))
			);
		}

		function removeRoomImmediately(roomName, reason){
			if(!roomName) return;

			// 💡 标记检查
			const recentDeletion = Store.deletionMarkers && Store.deletionMarkers.get(roomName);
			if(recentDeletion && (Date.now() - recentDeletion) < 5000){
				logInfo(`⏭️ 跳过删除同步（本地最近删除）: ${roomName}`);
				return;
			}
			logInfo(`🧨 [MetaDELETE] 调用 removeRoomEverywhere(${roomName}) reason=${reason}`);
			removeRoomEverywhere(roomName, `meta-${reason}`);
			toast(`🗑️ 房间已被删除: ${roomName}`, 'info');
			logInfo(`🗑️ 实时删除同步 -> ${roomName} (${reason})`);
		}

		// 幂等去重：防止 UPDATE(软删除) + DELETE 双事件导致重复日志/操作
		if(!window.__roomDeletionProcessed){ window.__roomDeletionProcessed = new Set(); }

		window.handleRealtimeRoomMeta = function(payload){
			const row = payload.new || payload.old; if(!row) return;
			const roomName = row.name; if(!roomName) return;

			// 🔍 检测元数据层面的重命名 (UPDATE 且 old.name != new.name)
			if(payload.eventType==='UPDATE' && payload.old && payload.new && payload.old.name!==payload.new.name){
				const oldName = payload.old.name; const newName = payload.new.name;
				logInfo(`[META][RENAME] 检测到元数据重命名 ${oldName} -> ${newName}`);
				try { handleRoomNameChange(oldName, newName, payload); } catch(e){ logErr('元数据重命名处理失败:', e.message); }
				// 继续执行后续以确保 meta 刷新（handleRoomNameChange 已迁移索引）
			}

			try {
				// 检测软删除或硬删除
				if(payload.eventType === 'DELETE' || isSoftDeleteTransition(payload)){
					const key = `${roomName}::${payload.eventType}`;
					if(window.__roomDeletionProcessed.has(key)){
						logInfo(`(skip dup) 删除事件已处理: ${key}`);
						return;
					}
					window.__roomDeletionProcessed.add(key);
					removeRoomImmediately(roomName, payload.eventType==='DELETE'?'DELETE':'SOFT-DELETE');
					return;
				}

				// 正常 INSERT / UPDATE 走原逻辑（保留）
				if(payload.eventType === 'INSERT' || payload.eventType === 'UPDATE'){
					if (!Store.roomMeta) Store.roomMeta = {};
					Store.roomMeta[roomName] = {
						name: row.name,
						location: row.location || '',
						piano_type: row.piano_type || '',
						remark: row.remark || ''
					};
					const room = Store.byName.get(roomName);
					if(room){
						room.remark = row.remark || '';
						room.pianoType = row.piano_type || '';
						room.location = row.location || '';
						setTimeout(()=>{ renderRoomCardForced(roomName); },0);
					}
					const changes=[]; if(row.remark!==undefined) changes.push(`备注:"${row.remark}"`); if(row.piano_type!==undefined) changes.push(`类型:${row.piano_type}`); if(row.location!==undefined) changes.push(`位置:${row.location}`);
					logInfo(`✅ 房间元数据已更新 ${roomName}: ${changes.join(', ')}`);
					if(window.renderRooms){ setTimeout(()=>{ renderRooms(); },50); }
				}
			}catch(err){ logErr('处理房间元数据实时更新失败(增强版):', err.message); }
		};
	})();

	// =============== 🧪 测试辅助：房间删除同步 ===============
	if(!window.testRoomDeletionSync){
		window.testRoomDeletionSync = function(roomName){
			console.log('[TEST] testRoomDeletionSync start', roomName);
			let i=0; const max=6;
			const timer = setInterval(()=>{
				i++;
				const existsInStore = !!Store.byName.get(roomName);
				const domExists = !!document.querySelector(`[data-room="${CSS.escape(roomName)}"]`);
				console.log(`[TEST] #${i} store=${existsInStore} dom=${domExists}`);
				if(i>=max) clearInterval(timer);
			},1000);
		};
	}

	// 🧪 重命名事件观察工具：持续打印 oldName / newName 是否完成替换
	if(!window.testRoomRenameWatch){
		window.testRoomRenameWatch = function(oldName, newName, seconds=6){
			console.log('[TEST] watch rename', oldName,'->',newName,'for',seconds,'s');
			let i=0; const timer=setInterval(()=>{
				i++;
				const hasOld = Store.byName.has(oldName);
				const hasNew = Store.byName.has(newName);
				const domOld = !!document.querySelector(`[data-room='${CSS.escape(oldName)}']`);
				const domNew = !!document.querySelector(`[data-room='${CSS.escape(newName)}']`);
				console.log(`[TEST][rename] t=${i}s store(old:${hasOld} new:${hasNew}) dom(old:${domOld} new:${domNew})`);
				if(i>=seconds) clearInterval(timer);
			},1000);
		};
	}

	// 扩展 checkRoomMetaSync (若存在) 统计已删除残留
	if(window.checkRoomMetaSync){
		const originalCheck = window.checkRoomMetaSync;
		window.checkRoomMetaSync = function(){
			originalCheck();
			try{
				const domIds=[...document.querySelectorAll('[data-room]')].map(e=>e.getAttribute('data-room'));
				const orphans=domIds.filter(id=>!Store.byName.get(id));
				if(orphans.length){ console.warn('[META-SYNC] DOM 孤儿卡片:', orphans); }
			}catch(e){ /* ignore */ }
		};
	}

	// 💡 专门处理房间重命名的realtime事件
	function handleRoomNameChange(oldName, newName, payload) {
		try {
			logInfo(`🔄 处理房间重命名事件: ${oldName} -> ${newName}`);
			
			// 1. 查找旧名称的房间
			let oldRoomIndex = Store.rooms.findIndex(r => r.name === oldName);
			if (oldRoomIndex < 0) {
				// 可能本地已经提前用新名字（例如本页面就是发起方）
				const newRoomIndex = Store.rooms.findIndex(r => r.name === newName);
				if(newRoomIndex>-1){
					oldRoomIndex = newRoomIndex; // 直接用新记录继续后续同步字段
					logWarn(`旧名未找到，使用已存在的新名记录继续: ${newName}`);
				} else {
					// 创建占位以避免后续渲染缺失（等待下一次全量同步会补齐其它字段）
					const placeholder = { name:newName, pianoType:payload.new?.piano_type||'', location:payload.new?.location||'', remark:payload.new?.remark||'', occupant:null, registerTime:null, version:payload.new?.version||1 };
					Store.rooms.push(placeholder);
					Store.byName.set(newName, placeholder);
					logWarn(`旧名/新名均未找到，已创建占位房间: ${newName}`);
					// 直接渲染并退出（占位不再做迁移）
					setTimeout(()=>{ renderRoomCardForced(newName); },0);
					return;
				}
			}
			const room = Store.rooms[oldRoomIndex];
			logInfo(`📝 找到房间记录: ${room.name}, occupant: ${room.occupant_student_name || 'null'}`);
			
			// 2. 更新房间名称和其他可能变更的字段
			const newData = canonicalizeRoom(payload.new);
			room.name = newName;
			room.version = newData.version || room.version;
			room.heartbeatAt = newData.heartbeatAt || room.heartbeatAt;
			// 保持现有的占用状态不变，因为重命名不应该影响占用
			
			// 3. 更新Store.byName索引
			Store.byName.delete(oldName);
			Store.byName.set(newName, room);
			
			// 4. 更新房间元数据
			if (Store.roomMeta && Store.roomMeta[oldName]) {
				Store.roomMeta[newName] = {
					...Store.roomMeta[oldName],
					name: newName
				};
				delete Store.roomMeta[oldName];
			}
			
			// 5. 强制刷新UI显示
			setTimeout(() => {
				// 移除旧名称的DOM元素
				const grid = document.getElementById('roomGrid');
				const oldEl = grid.querySelector(`[data-room='${CSS.escape(oldName)}']`);
				if (oldEl) {
					oldEl.remove();
					logInfo(`🗑️ 移除旧房间卡片: ${oldName}`);
				}
				
				// 重新渲染新名称的房间卡片
				renderRoomCardForced(newName);
				logInfo(`🆕 渲染新房间卡片: ${newName}`);
				
				// 全局刷新确保索引和过滤器正确
				renderRooms();
			}, 0);
			
			// 6. 显示用户提示
			toast(`🏷️ 房间重命名: ${oldName} → ${newName}`, 'info');
			logInfo(`✅ 房间重命名处理完成: ${oldName} -> ${newName}`);
			
		} catch (error) {
			logErr(`❌ 处理房间重命名失败 ${oldName} -> ${newName}:`, error.message);
		}
	}

	function handleRealtimeStudent(payload) {
		const row = payload.new || payload.old; 
		if (!row) return;
		
		// 更新实时同步时间戳
		window.__studentUpdateTimestamp = Date.now();
		if(!window.__studentRealtimeHandled) window.__studentRealtimeHandled=0; window.__studentRealtimeHandled++;
		const dbgPrefix = `[RT][students][handle #${window.__studentRealtimeHandled}]`;
		try{ console.log(`${dbgPrefix} recv event=${payload.eventType} name=${row.name}`); }catch(_){ }
		
		try {
			// 更新 Store.students（兼容旧系统）
			if (window.Store && Array.isArray(window.Store.students)) {
				if (payload.eventType === 'INSERT') {
					// 检查是否已存在
					const existing = window.Store.students.find(s => s.name === row.name);
					if (!existing) {
						window.Store.students.push({
							name: row.name,
							grade: row.grade || '',
							major: row.major || ''
						});
						logInfo(`学生数据新增: ${row.name}`);
					}
				} else if (payload.eventType === 'UPDATE') {
					const student = window.Store.students.find(s => s.name === row.name);
					if (student) {
						student.grade = row.grade || '';
						student.major = row.major || '';
						logInfo(`学生数据更新: ${row.name}`);
					}
				} else if (payload.eventType === 'DELETE' && payload.old) {
					const index = window.Store.students.findIndex(s => s.name === payload.old.name);
					if (index >= 0) {
						window.Store.students.splice(index, 1);
						logInfo(`学生数据删除: ${payload.old.name}`);
					}
				}
			}
			
			// 更新 StudentLibrary（新系统）
			if (window.StudentLibrary && window.StudentLibrary.refresh) {
				if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
					// 检查是否是本地操作产生的更新（避免循环）
					const isLocalUpdate = window.__studentUpdateIgnore && 
						window.__studentUpdateIgnore.has(row.name) && 
						(Date.now() - (window.__studentUpdateTimestamp || 0)) < 5000;
					if(isLocalUpdate){ console.log(`${dbgPrefix} skip local echo name=${row.name}`); }
					
					if (!isLocalUpdate) {
						// 不是本地操作，需要同步到本地
						if (window.StudentLibrary._handleRemoteUpdate) {
							window.StudentLibrary._handleRemoteUpdate(payload);
						} else {
							// 兜底：刷新整个学生库
							window.StudentLibrary.refresh();
						}
						logInfo(`学生库同步: ${row.name} (${payload.eventType})`);
					}
				} else if (payload.eventType === 'DELETE' && payload.old) {
					// 删除事件：检查是否是本地操作产生的删除（避免循环）
					const isLocalUpdate = window.__studentUpdateIgnore && 
						window.__studentUpdateIgnore.has(payload.old.name) && 
						(Date.now() - (window.__studentUpdateTimestamp || 0)) < 5000;
					if(isLocalUpdate){ console.log(`${dbgPrefix} skip local echo delete name=${payload.old.name}`); }
					
					if (!isLocalUpdate) {
						// 不是本地操作，需要同步到本地
						if (window.StudentLibrary._handleRemoteUpdate) {
							window.StudentLibrary._handleRemoteUpdate(payload);
						} else {
							// 兜底：刷新整个学生库
							window.StudentLibrary.refresh();
						}
						logInfo(`学生库同步: ${payload.old.name} (DELETE)`);
						// DELETE 后加一层延迟对账，确保最终一致
						if(window.reconcileStudentsWithCloud){ setTimeout(()=>{ try{ window.reconcileStudentsWithCloud(); }catch(_){ } }, 1200); }
					}
				}
			}
			
			// 刷新相关UI
			if (window.rebuildStudentIndex) {
				window.rebuildStudentIndex();
			}
			
			// 刷新BTM（如果存在）
			if (window.BTM && window.BTM.buildStudents) {
				window.BTM.buildStudents();
			}
			
		} catch (error) {
			logErr('处理学生实时更新失败:', error.message);
		}
	}
	
	function handleRealtimeRoom(payload){
		const row = payload.new || payload.old; 
		if(!row) return;
		
		// 💡 检测房间名称变更的特殊处理
		if (payload.eventType === 'UPDATE' && payload.old && payload.new) {
			const oldName = payload.old.name;
			const newName = payload.new.name;
			
			if (oldName !== newName) {
				logInfo(`🏷️ 检测到房间重命名: ${oldName} -> ${newName}`);
				handleRoomNameChange(oldName, newName, payload);
				return; // 房间重命名有专门的处理流程，直接返回
			}
		}

		// 检测关键状态变更，触发增强同步
		const isImportantChange = payload.eventType === 'INSERT' || 
			(payload.eventType === 'UPDATE' && (
				payload.old?.occupant_student_name !== payload.new?.occupant_student_name ||
				payload.old?.register_time !== payload.new?.register_time
			));
		
		if (isImportantChange) {
			syncEnhancer.recordUserOperation();
		}
		
		const data = canonicalizeRoom(row); 
		const idx = Store.rooms.findIndex(r => r.name === data.name);
		
		// 防重复处理：生成唯一标识符
		const updateKey = `${data.name}_${payload.eventType}_${data.version}_${Date.now()}`;
		const recentUpdatesKey = 'recentUpdates';
		if (!Store[recentUpdatesKey]) Store[recentUpdatesKey] = new Map();
		
		// 检查是否在短时间内处理过相同的更新
		const recentUpdateTime = Store[recentUpdatesKey].get(`${data.name}_${payload.eventType}_${data.version}`);
		if (recentUpdateTime && Date.now() - recentUpdateTime < 1000) { // 1秒内的重复更新
			logInfo(`忽略重复的实时更新 ${data.name} v${data.version} (${payload.eventType})`);
			return;
		}
		
		// 记录此次更新
		Store[recentUpdatesKey].set(`${data.name}_${payload.eventType}_${data.version}`, Date.now());
		
		// 清理过期的更新记录（保留最近5秒的记录）
		setTimeout(() => {
			const expireTime = Date.now() - 5000;
			for (const [key, time] of Store[recentUpdatesKey].entries()) {
				if (time < expireTime) {
					Store[recentUpdatesKey].delete(key);
				}
			}
		}, 5000);
		
		// 检查是否为本地待处理的更新（避免重复处理）
		const pending = Store.pendingAssign.get(data.name);
		if(pending && pending.version >= data.version){ 
			logInfo(`忽略本地待处理更新 ${data.name} v${data.version}`);
			return; 
		}
		
		// 冲突检测：如果本地正在操作这个房间
		const lockKey = `assign_${data.name}`;
		const clearLockKey = `clear_${data.name}`;
		const deleteLockKey = `delete_${data.name}`;
		const isLocked = Store.operationLocks?.has(lockKey) || Store.operationLocks?.has(clearLockKey) || Store.operationLocks?.has(deleteLockKey);
		
		if (isLocked) {
			if (Store.operationLocks?.has(deleteLockKey)) {
				logInfo(`房间 ${data.name} 正在删除中，忽略实时更新`);
				return; // 删除时完全忽略所有实时更新
			}
			logWarn(`房间 ${data.name} 本地操作中，延迟处理远程更新`);
			// 延迟3秒重试
			setTimeout(() => handleRealtimeRoom(payload), 3000);
			return;
		}
		
		// 立即更新UI以减少延迟感知
		let shouldRerender = false;
		let conflictDetected = false;
		
		// 处理不同类型的更新
		if (payload.eventType === 'DELETE') {
			const recentDeletion = Store.deletionMarkers && Store.deletionMarkers.get(data.name);
			// 🔐 兜底：如果 canonicalize 后 data.name 丢失，尝试从 payload.old.name / payload.new.name 取原始名称
			if(!data.name){
				const rawName = (payload.old && payload.old.name) || (payload.new && payload.new.name);
				logWarn(`⚠️ DELETE事件 data.name 缺失，使用原始名称兜底: ${rawName}`);
				if(rawName){ data.name = rawName; }
			}
			if(!data.name){
				logErr('❌ DELETE事件无法确定房间名称，放弃处理');
				return;
			}
			if(recentDeletion && (Date.now() - recentDeletion) < 5000){
				logInfo(`⏭️ 跳过删除事件（本地最近删除）: ${data.name}`);
				return;
			}
			logInfo(`🧨 [RoomsDELETE] (no idx check) 调用 removeRoomEverywhere(${data.name})`);
			removeRoomEverywhere(data.name, 'rooms-DELETE');
			shouldRerender = false;
			toast(`🗑️ 房间 ${data.name} 已被删除`, 'info');
		} else if (payload.eventType === 'INSERT') {
			if (idx < 0) {
				Store.rooms.push(data);
				logInfo(`远程新增房间: ${data.name}`);
				// 补充该房间的静态元数据，避免名称外信息缺失
				fetchRoomMetaByName(data.name);
				shouldRerender = true;
			}
		} else if (payload.eventType === 'UPDATE') {
			// ========= 完整重渲染增强逻辑 =========
			let prevOcc = null;
			if (idx >= 0) {
				const oldRoom = Store.rooms[idx];
				prevOcc = oldRoom.occupant_student_name;
				if (oldRoom.occupant_student_name && data.occupant_student_name===null) {
					const incomingVer = data.version || 0;
					const localVer = oldRoom.version || 0;
					if (incomingVer <= localVer) {
						logWarn(`忽略可疑清空: ${data.name} incoming v${incomingVer} <= local v${localVer}`);
						return; // 丢弃该 UPDATE
					}
				}
				
				// 检查是否有正在进行的操作，如果有则延迟处理远程更新
				const lockKey = `assign_${data.name}`;
				const clearLockKey = `clear_${data.name}`;
				const hasOperationLock = Store.operationLocks?.has(lockKey) || Store.operationLocks?.has(clearLockKey);
				
				if (hasOperationLock) {
					logWarn(`房间 ${data.name} 有操作进行中，延迟处理远程更新`);
					setTimeout(() => {
						// 重新尝试处理更新
						handleRealtimeRoom(payload);
					}, 1000);
					return;
				}
				
				// 冲突检测（双方都有不同占用者）
				if (oldRoom.occupant_student_name && data.occupant_student_name && oldRoom.occupant_student_name !== data.occupant_student_name) {
					conflictDetected = true;
					logWarn(`检测到房间 ${data.name} 冲突: 本地(${oldRoom.occupant_student_name}) vs 远程(${data.occupant_student_name})`);
					
					// 冲突解决策略：使用版本号较高的，如果版本号相同则使用远程数据
					if ((data.version || 0) >= (oldRoom.version || 0)) {
						logInfo(`版本冲突解决: 采用远程数据 v${data.version} (本地 v${oldRoom.version})`);
						toast(`⚠️ 房间 ${data.name} 冲突已解决，采用最新数据`, 'warn');
					} else {
						logInfo(`版本冲突解决: 保持本地数据 v${oldRoom.version} (远程 v${data.version})`);
						toast(`⚠️ 房间 ${data.name} 版本冲突，保持本地数据`, 'warn');
						return; // 不更新本地数据
					}
				}
				// 显式字段覆盖，保证 null 不丢，同时统一时间字段格式
				const prevRegisterTime = oldRoom.registerTime;
				const prevRegisterTimeRaw = oldRoom.register_time;
				
				oldRoom.occupant_student_name = (data.occupant_student_name === null ? null : data.occupant_student_name);
				oldRoom.register_time = data.register_time || null;
				// 关键修复：统一设置 registerTime 字段（用于计时器计算）
				oldRoom.registerTime = data.registerTime || (data.register_time ? toMs(data.register_time) : null);
				oldRoom.version = data.version;
				oldRoom.heartbeat_at = data.heartbeat_at;
				
				// 详细日志记录
				logInfo(`远程更新房间: ${data.name} v${data.version}`);
				logInfo(`  占用者: ${prevOcc || 'null'} -> ${oldRoom.occupant_student_name || 'null'}`);
				if (oldRoom.registerTime) {
					const timeStr = new Date(oldRoom.registerTime).toLocaleString();
					logInfo(`  注册时间: ${timeStr} (${oldRoom.registerTime})`);
				} else {
					logInfo(`  注册时间: null`);
				}
				
				// 检查是否有实质性变化（影响UI显示的字段）
				const hasOccupantChange = prevOcc !== oldRoom.occupant_student_name;
				const hasRegisterTimeChange = prevRegisterTime !== oldRoom.registerTime;
				const hasSignificantChange = hasOccupantChange || (oldRoom.occupant_student_name && hasRegisterTimeChange);
				
				// 变化提示
				if (hasOccupantChange && !conflictDetected) {
					if (oldRoom.occupant_student_name) toast(`🎵 ${oldRoom.occupant_student_name} 开始使用 ${data.name}`, 'success'); else toast(`✅ ${data.name} 已释放`, 'success');
				}
				
				// 占用 -> 空：完整重渲染
				if (prevOcc && !oldRoom.occupant_student_name) {
					logInfo(`[FULL-RERENDER] ${data.name} cleared v${data.version} (${prevOcc} -> null)`);
					fullReRenderRoom(oldRoom);
					shouldRerender = false; // 已在 fullReRenderRoom 内处理
				} else if (hasSignificantChange) {
					logInfo(`[NORMAL-RERENDER] ${data.name} v${data.version} (${prevOcc || 'null'} -> ${oldRoom.occupant_student_name || 'null'})`);
					shouldRerender = true;
				} else {
					logInfo(`[SKIP-RERENDER] ${data.name} v${data.version} (无UI变化，仅版本/心跳更新)`);
					shouldRerender = false;
				}
			} else {
				Store.rooms.push(data);
				logInfo(`远程插入房间(补录): ${data.name}`);
				// 同步补充元数据
				fetchRoomMetaByName(data.name);
				shouldRerender = true;
			}
		}
		
		// 清理待处理状态
		Store.pendingAssign.delete(data.name);
		
		// 清理回滚状态（如果存在）
		if (Store.rollbackStates) {
			Store.rollbackStates.delete(data.name);
		}
		
		// 清除操作视觉指示
		clearOperationIndicator(data.name);
		
		// 立即重新渲染以减少延迟
		if (shouldRerender) {
			// 关键修复：先重建索引，再渲染
			rebuildIndexes();
			renderRoomCard(data.name); 
			updateUsageStats();
			
			// 强制触发计时器更新以确保状态同步
			if (window.updateAllRoomTimers && typeof window.updateAllRoomTimers === 'function') {
				setTimeout(() => {
					window.updateAllRoomTimers();
				}, 100);
			}
		}
		
		// 如果检测到冲突，触发全量同步
		if (conflictDetected) {
			setTimeout(() => {
				logInfo('冲突后触发全量数据同步');
				fetchRoomMeta();
			}, 2000);
		}
	}

	/*************************************************
	 * 云端数据库同步
	 *************************************************/
	async function syncRoomDatabaseToCloud(rooms) {
		if (!supabaseReady) {
			logWarn('Supabase 未连接，跳过琴房数据库同步');
			return;
		}
		
		try {
			const roomData = rooms.map(room => ({
				name: room.name,
				piano_type: room.pianoType || '',
				location: room.location || '',
				remark: room.remark || '',
				updated_at: new Date().toISOString()
			}));
			
			// 使用 upsert 批量插入/更新琴房基础数据
			const { data, error } = await supabaseClient
				.from('room_database')
				.upsert(roomData);
			
			if (error) {
				logErr('同步琴房数据库失败:', error.message);
				toast('琴房数据库同步失败', 'error');
			} else {
				logInfo(`✅ 成功同步 ${roomData.length} 个琴房到云端数据库`);
				toast(`已同步 ${roomData.length} 个琴房到云端`);
			}
		} catch (err) {
			logErr('琴房数据库同步异常:', err.message);
		}
	}
	
	async function syncStudentDatabaseToCloud(students) {
		if (!supabaseReady) {
			logWarn('Supabase 未连接，跳过学生数据库同步');
			return;
		}
		
		try {
			// 过滤并规范化：不上传前端生成的 UUID id，交由数据库 bigint identity 生成
			// 同时确保 major 非空（后端 NOT NULL），若为空则使用占位 '未填写'
			const cleaned = [];
			for(const s of students){
				if(!s || !s.name) continue; // 跳过无效记录
				const rec = {
					name: String(s.name).trim(),
					major: (s.major && String(s.major).trim()) || '未填写',
					grade: (s.grade && String(s.grade).trim()) || ''
				};
				cleaned.push(rec);
			}
			if(!cleaned.length){
				logInfo('无学生需要同步');
				return;
			}
			// 将数据按 name 分批（防止单批过大）
			const BATCH=200; let synced=0; let failed=0; const errors=[];
			for(let i=0;i<cleaned.length;i+=BATCH){
				const slice=cleaned.slice(i,i+BATCH);
				// 因 name 未必有唯一索引，避免 onConflict 直接失败：先查询已存在 names，再分 insert / update
				let existingNames=[];
				try{
					const { data:existData, error:existErr } = await supabaseClient
						.from('student_database')
						.select('name')
						.in('name', slice.map(r=>r.name));
					if(!existErr && Array.isArray(existData)) existingNames = existData.map(r=>r.name);
				}catch(e){ /* 忽略查询错误，继续尝试全部插入 */ }
				const toUpdate = slice.filter(r=> existingNames.includes(r.name));
				const toInsert = slice.filter(r=> !existingNames.includes(r.name));
				// 执行更新：PostgREST 没有直接批量 update by name，只能 upsert；但为避免冲突问题仍分开
				if(toInsert.length){
					const { error:insErr } = await supabaseClient.from('student_database').insert(toInsert);
					if(insErr){ failed+=toInsert.length; errors.push('insert:'+insErr.message); }
					else synced+=toInsert.length;
				}
				if(toUpdate.length){
					// upsert 仅对已有 name 行更新（因为 name 已存在），不指定 onConflict 让后端自行推断主键 id 不会匹配，所以需要逐条 update
					for(const row of toUpdate){
						try{
							const { error:updErr } = await supabaseClient.from('student_database').update({ major:row.major, grade:row.grade }).eq('name', row.name);
							if(updErr){ failed++; errors.push('update:'+updErr.message); } else synced++;
						}catch(e){ failed++; errors.push('update-ex:'+e.message); }
					}
				}
			}
			if(failed){
				logErr(`学生同步完成：成功 ${synced} 失败 ${failed}`);
				toast(`学生同步部分失败: 成功${synced} 失败${failed}`,'warn');
				if(errors.length) console.warn('[student sync errors]', errors.slice(0,5));
			}else{
				logInfo(`✅ 成功同步 ${synced} 个学生到云端数据库`);
				toast(`已同步 ${synced} 个学生到云端`);
			}
		} catch (err) {
			logErr('学生数据库同步异常:', err.message);
			toast('学生数据库同步异常: '+err.message,'error');
		}
	}
	
	async function manualSyncToCloud() {
		if (!supabaseReady) {
			toast('Supabase 未连接，无法同步', 'error');
			return;
		}
		
		try {
			toast('正在同步到云端...', 'info');
			
			// 同步琴房数据库
			if (Store.rooms.length > 0) {
				await syncRoomDatabaseToCloud(Store.rooms);
			}
			
			// 同步学生数据库  
			if (Store.students.length > 0) {
				await syncStudentDatabaseToCloud(Store.students);
			}
			
			// 同步房间实时状态
			if (Store.rooms.length > 0) {
				await syncRoomStatusToCloud(Store.rooms);
			}
			
			// 同步练习记录（如果有本地记录）
			await syncPracticeLogsToCloud();

			// 提醒数据：practice_alerts 已直接写云，无需上行；此处刷新一次以确保 UI 最新
			if(window.PracticeAlerts){ await PracticeAlerts.initAlerts?.(); }

			// 若需要将今日 slots 缓存刷新（可选）
			if(window.PracticeAlerts && window.PracticeAlerts.detectionTick){ await PracticeAlerts.detectionTick(); }
			
			// 更新云端数量显示
			const cloudRoomCountEl = document.getElementById('cloudRoomCount');
			const cloudStudentCountEl = document.getElementById('cloudStudentCount');
			if (cloudRoomCountEl) cloudRoomCountEl.textContent = Store.rooms.length;
			if (cloudStudentCountEl) cloudStudentCountEl.textContent = Store.students.length;
			
			// 更新同步时间
			updateCloudSyncInfo();
			
			toast('✅ 所有数据已同步（含提醒刷新）');
			logInfo('手动同步完成：基础数据 + 实时状态 + 练习记录 + 提醒刷新');
		} catch (error) {
			toast('同步失败', 'error');
			logErr('手动同步失败:', error.message);
		}
	}

	// 同步房间实时状态到 rooms 表
	async function syncRoomStatusToCloud(rooms) {
		if (!supabaseReady) {
			logWarn('Supabase 未连接，跳过房间状态同步');
			return;
		}
		
		try {
			const statusData = rooms.map(room => ({
				name: room.name,
				occupant_student_name: room.occupant_student_name || null,
				register_time: room.registerTime ? new Date(room.registerTime).toISOString() : null,
				heartbeat_at: new Date().toISOString(),
				version: room.version || 1,
				updated_at: new Date().toISOString()
			}));
			
			// 使用 upsert 批量更新房间实时状态
			const { data, error } = await supabaseClient
				.from('rooms')
				.upsert(statusData);
			
			if (error) {
				logErr('同步房间状态失败:', error.message);
				toast('房间状态同步失败', 'error');
			} else {
				logInfo(`✅ 成功同步 ${statusData.length} 个房间状态到云端`);
			}
		} catch (err) {
			logErr('房间状态同步异常:', err.message);
		}
	}

	// 同步练习记录到 practice_logs 表
	async function syncPracticeLogsToCloud() {
		if (!supabaseReady) {
			logWarn('Supabase 未连接，跳过练习记录同步');
			return;
		}
		
		// 检查是否有本地练习记录存储
		if (!Store.localPracticeLogs || Store.localPracticeLogs.length === 0) {
			logInfo('无本地练习记录需要同步');
			return;
		}
		
		try {
			// 过滤出尚未同步的记录
			const unsyncedLogs = Store.localPracticeLogs.filter(log => !log.synced);
			
			if (unsyncedLogs.length === 0) {
				logInfo('所有练习记录已同步');
				return;
			}
			
			// 批量插入练习记录
			const { data, error } = await supabaseClient
				.from('practice_logs')
				.insert(unsyncedLogs);
			
			if (error) {
				logErr('同步练习记录失败:', error.message);
				toast('练习记录同步失败', 'error');
			} else {
				// 标记为已同步
				unsyncedLogs.forEach(log => log.synced = true);
				logInfo(`✅ 成功同步 ${unsyncedLogs.length} 条练习记录到云端`);
			}
		} catch (err) {
			logErr('练习记录同步异常:', err.message);
		}
	}
	async function importJson(obj){
		if(Array.isArray(obj)){
			// 猜测是房间数组或学生数组
			if(obj.length && obj[0].pianoType || obj[0].piano_type || obj[0].location){
				await mergeRooms(obj.map(canonicalizeRoom), { metaOnly: true });
				toast('导入房间 '+obj.length+' 条');
			}else if(obj.length && (obj[0].major || obj[0].grade || obj[0].name)){
				await mergeStudents(obj);
				toast('导入学生 '+obj.length+' 条');
			}else{
				toast('未知数组结构，已忽略');
			}
		} else if(obj && obj.rooms && obj.students){
			if(Array.isArray(obj.rooms)) await mergeRooms(obj.rooms.map(canonicalizeRoom), { metaOnly: true });
			if(Array.isArray(obj.students)) await mergeStudents(obj.students);
			toast('导入集合完成');
		} else {
			toast('不支持的 JSON 结构');
		}
		renderRooms(); updateUsageStats(); refreshStudentModalCache();
	}
	// mergeRooms(list, options)
	// options:
	//  - skipCloudSync: 跳过云端同步（用于从云端拉取回写本地时，防递归）
	//  - metaOnly: 仅更新静态元数据（name/pianoType/location/remark），不触碰 occupant/registerTime/version/heartbeatAt
	async function mergeRooms(list, options = { skipCloudSync: false, metaOnly: false }){
		let added=0, updated=0;
		const newRooms = [];
		
		list.forEach(r=>{ 
			if(!r||!r.name) return; 
			const norm = canonicalizeRoom(r);
			let existing=Store.rooms.find(x=>x.name===norm.name); 
			if(existing){ 
				if(options.metaOnly){
					// 仅更新静态字段
					existing.name = norm.name;
					existing.pianoType = norm.pianoType;
					existing.location = norm.location;
					existing.remark = norm.remark;
				} else {
					// 全量合并（含可能的动态字段）
					Object.assign(existing,norm);
					// 统一规范并确保 version 数字（仅当此次合并包含 version 字段时）
					if('version' in norm && (existing.version==null || isNaN(existing.version))) existing.version=0;
				}
				updated++; 
			} else { 
				// 新增：若 metaOnly，补齐动态字段默认值，避免后续使用时报 undefined
				if(options.metaOnly){
					norm.occupant = norm.occupant ?? null;
					norm.registerTime = norm.registerTime ?? null;
					norm.version = norm.version ?? 0;
					norm.heartbeatAt = norm.heartbeatAt ?? null;
				}
				Store.rooms.push(norm); 
				newRooms.push(norm);
				added++; 
			}
		});
		
		rebuildIndexes();
		// 如果当前楼层过滤已不在集合中则重置
		if(Store.filters.floor!=='ALL' && !Store.floorSet.has(Store.filters.floor)) { Store.filters.floor='ALL'; }
		// 若当前过滤导致无结果则尝试自动回退
		const visible=Store.rooms.filter(roomFilter).length;
		if(!visible){ Store.filters.floor='ALL'; Store.filters.type='ALL'; }
		logInfo(`合并房间: 新增 ${added} 更新 ${updated} 总数 ${Store.rooms.length}`);
		
		// 自动同步到云端数据库（除非跳过）
		if (!options.skipCloudSync && list.length > 0) {
			await syncRoomDatabaseToCloud(list);
		}
	}
	
	async function mergeStudents(list, skipCloudSync = false){
		const newStudents = [];
		
		list.forEach(s=>{ 
			if(!s||!s.name) return; 
			let ex=Store.students.find(x=>x.name===s.name); 
			if(ex){ 
				Object.assign(ex,s); 
			} else { 
				Store.students.push(s);
				newStudents.push(s);
			} 
		});
		
		rebuildStudentIndex();
		
		// 自动同步到云端数据库（除非跳过）
		if (!skipCloudSync && list.length > 0) {
			await syncStudentDatabaseToCloud(list);
		}
	}
	function exportRooms(){
		downloadJson(Store.rooms,'rooms_export.json');
	}
	function exportStudents(){ downloadJson(Store.students,'students_export.json'); }
	function downloadJson(data, file){ const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=file; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),500); }

	// 新增: 通用 CSV 解析（支持引号、转义双引号、BOM、CRLF）
	function parseCSV(raw){
		if(!raw) return {header:[], rows:[]};
		// 去除 BOM
		if(raw.charCodeAt(0)===0xFEFF) raw=raw.slice(1);
		raw = raw.replace(/\r\n?/g,'\n');
		const rows=[]; let cur=[]; let field=''; let inQuotes=false; let i=0;
		function pushField(){ cur.push(field); field=''; }
		function pushRow(){ rows.push(cur); cur=[]; }
		while(i<raw.length){ const ch=raw[i];
			if(inQuotes){
				if(ch==='"'){
					if(raw[i+1]==='"'){ field+='"'; i++; }
					else { inQuotes=false; }
				}else{ field+=ch; }
			}else{
				if(ch==='"'){ inQuotes=true; }
				else if(ch===','){ pushField(); }
				else if(ch==='\n'){ pushField(); pushRow(); }
				else { field+=ch; }
			}
			i++;
		}
		if(field.length>0 || cur.length>0){ pushField(); pushRow(); }
		if(!rows.length) return {header:[], rows:[]};
		const header = rows.shift().map(h=>h.trim());
		return { header, rows: rows.filter(r=> r.some(c=>c.trim()!=='')) };
	}
	function normalizeHeaderKey(k){ return k.replace(/\s+/g,'').replace(/[ _-]/g,'').toLowerCase(); }
	function detectCSVType(header){
		const keys = header.map(normalizeHeaderKey);
		const roomHits = ['名称','位置','类型','备注'].map(normalizeHeaderKey).every(h=>keys.includes(h));
		const studentHits = (keys.includes('姓名')||keys.includes('name')) && keys.includes('专业');
		if(roomHits) return 'rooms'; if(studentHits) return 'students'; return 'unknown';
	}
	async function importCsvRooms(header, rows){
		const idx = Object.create(null); header.forEach((h,i)=>{ idx[normalizeHeaderKey(h)]=i; });
		const out=[]; rows.forEach(r=>{
			const name=r[idx['名称']??idx['mingcheng']??idx['name']]; if(!name) return;
			const location=r[idx['位置']]; const pianoType=r[idx['类型']]||'无钢琴'; const remark=r[idx['备注']]||'';
			out.push({ name: name.trim(), location: (location||'').trim(), pianoType: pianoType.trim(), remark: remark.trim() });
		});
		await mergeRooms(out.map(o=>({name:o.name, location:o.location, pianoType:o.pianoType, remark:o.remark})), { metaOnly: true });
		toast('CSV 导入琴房 '+out.length+' 条');
		renderRooms(); updateUsageStats();
	}
	async function importCsvStudents(header, rows){
		const idx = Object.create(null); header.forEach((h,i)=>{ idx[normalizeHeaderKey(h)]=i; });
		const out=[]; rows.forEach(r=>{
			const name=r[idx['姓名']??idx['name']]; if(!name) return;
			const major=r[idx['专业']??idx['major']]||''; const grade=r[idx['年级']??idx['grade']]||''; const idRaw=r[idx['id']]||r[idx['编号']]||'';
			out.push({ id: idRaw||undefined, name: name.trim(), major: major.trim(), grade: grade.trim() });
		});
		await mergeStudents(out);
		toast('CSV 导入学生 '+out.length+' 条');
	}

	// 按钮绑定已移至 DOMContentLoaded 事件监听器中
	
	// 🔧 页面数据一致性验证器 - 防止缓存数据污染
	const DataConsistencyValidator = {
		async validateOnPageLoad() {
			const validationId = Date.now();
			logInfo(`[DataValidator] 启动页面加载数据一致性验证 #${validationId}`);
			
			try {
				// 检查验证条件：避免在数据未完全加载时进行验证
				if (!Store.rooms || Store.rooms.length === 0) {
					logInfo(`[DataValidator] Store数据尚未加载，跳过验证 #${validationId}`);
					return { issues: 0, timerIssues: [], storeIssues: [], skipped: 'store_not_ready' };
				}
				
				// 1. 清理所有可能的旧缓存数据
				await this.cleanupStaleCache();
				
				// 2. 验证localStorage中的计时器状态
				const timerIssues = await this.validateTimerStates();
				if (timerIssues.length > 0) {
					logWarn(`[DataValidator] 发现 ${timerIssues.length} 个计时器状态问题`, timerIssues);
				}
				
				// 3. 验证Store数据与数据库的一致性
				const storeIssues = await this.validateStoreConsistency();
				if (storeIssues.length > 0) {
					logWarn(`[DataValidator] 发现 ${storeIssues.length} 个Store数据不一致`, storeIssues);
				}
				
				// 4. 如果发现问题，强制重新同步
				const totalIssues = timerIssues.length + storeIssues.length;
				if (totalIssues > 0) {
					logWarn(`[DataValidator] 检测到 ${totalIssues} 个数据一致性问题，执行强制同步`);
					await this.forceDataSync();
				} else {
					logInfo(`[DataValidator] 验证完成 #${validationId} - 数据一致性正常`);
				}
				
				return { issues: totalIssues, timerIssues, storeIssues };
				
			} catch (error) {
				logErr(`[DataValidator] 验证过程异常:`, error.message);
				// 如果验证失败，安全起见强制重新同步
				await this.forceDataSync();
				return { issues: -1, error: error.message };
			}
		},
		
		async cleanupStaleCache() {
			// 清理可能的旧计时器状态缓存
			const cacheKeys = [
				'yms_timer_states',
				'yms_room_cache',
				'yms_temp_states',
				'yms_operation_cache'
			];
			
			let cleanedCount = 0;
			cacheKeys.forEach(key => {
				if (localStorage.getItem(key)) {
					localStorage.removeItem(key);
					cleanedCount++;
				}
			});
			
			if (cleanedCount > 0) {
				logInfo(`[DataValidator] 清理了 ${cleanedCount} 个缓存项`);
			}
		},
		
		async validateTimerStates() {
			const issues = [];
			try {
				const stored = localStorage.getItem(timerPersistence.storageKey);
				if (stored) {
					const data = JSON.parse(stored);
					const states = data.states || [];
					
					// 检查每个缓存的计时器状态
					for (const state of states) {
						// 验证该房间在数据库中是否真的被占用
						const dbRoom = await this.getRoomFromDB(state.roomName);
						if (!dbRoom || !dbRoom.occupant_student_name) {
							issues.push({
								type: 'timer_ghost',
								roomName: state.roomName,
								cachedStudent: state.occupant_student_name,
								reason: '缓存显示占用但数据库为空'
							});
						}
					}
				}
			} catch (error) {
				issues.push({
					type: 'timer_cache_error',
					error: error.message
				});
			}
			return issues;
		},
		
		async validateStoreConsistency() {
			const issues = [];
			try {
				// 检查Store数据是否已完全加载
				if (!Store.rooms || Store.rooms.length === 0) {
					// Store数据尚未加载完成，跳过验证避免误报
					return issues;
				}
				
				// 获取数据库的真实数据
				const dbRooms = await fetchRooms();
				if (!dbRooms || dbRooms.length === 0) return issues;
				
				// 如果Store和数据库房间总数差异太大，可能是数据同步问题，暂不验证
				if (Math.abs(Store.rooms.length - dbRooms.length) > Store.rooms.length * 0.5) {
					logWarn(`[DataValidator] Store(${Store.rooms.length})与DB(${dbRooms.length})房间数量差异过大，跳过一致性验证`);
					return issues;
				}
				
				// 比较Store中的数据与数据库数据
				const storeOccupied = Store.rooms.filter(r => r.occupant_student_name && r.occupant_student_name.trim() !== '');
				const dbOccupied = dbRooms.filter(r => r.occupant_student_name && r.occupant_student_name.trim() !== '');
				
				// 如果双方都没有占用房间，说明数据是一致的
				if (storeOccupied.length === 0 && dbOccupied.length === 0) {
					return issues; // 没有占用房间，数据一致
				}
				
				// 检查Store中有但数据库中没有的房间（幽灵占用）
				storeOccupied.forEach(storeRoom => {
					const dbRoom = dbRooms.find(r => r.name === storeRoom.name);
					if (!dbRoom || !dbRoom.occupant_student_name || dbRoom.occupant_student_name.trim() === '') {
						// 进一步验证：检查是否是正在进行的操作
						const isRecentOperation = Store.pendingAssign.has(storeRoom.name) || 
												 (storeRoom.registerTime && (Date.now() - storeRoom.registerTime) < 30000);
						
						if (!isRecentOperation) {
							issues.push({
								type: 'store_ghost',
								roomName: storeRoom.name,
								storeStudent: storeRoom.occupant_student_name,
								reason: 'Store显示占用但数据库为空'
							});
						}
					}
				});
				
				// 检查数据库中有但Store中没有的房间（数据丢失）
				dbOccupied.forEach(dbRoom => {
					const storeRoom = Store.rooms.find(r => r.name === dbRoom.name);
					if (!storeRoom || !storeRoom.occupant_student_name || storeRoom.occupant_student_name.trim() === '') {
						issues.push({
							type: 'store_missing',
							roomName: dbRoom.name,
							dbStudent: dbRoom.occupant_student_name,
							reason: '数据库显示占用但Store为空'
						});
					}
				});
				
			} catch (error) {
				issues.push({
					type: 'store_validation_error',
					error: error.message
				});
			}
			return issues;
		},
		
		async getRoomFromDB(roomName) {
			try {
				const { data, error } = await supabaseClient
					.from('rooms')
					.select('name, occupant_student_name, register_time, version')
					.eq('name', roomName)
					.single();
				
				if (error) return null;
				return data;
			} catch (error) {
				return null;
			}
		},
		
		async forceDataSync() {
			logInfo('[DataValidator] 执行强制数据同步');
			
			try {
				// 1. 清空所有缓存
				if (typeof timerPersistence !== 'undefined' && timerPersistence.cleanup) {
					timerPersistence.cleanup();
				}
				
				// 2. 从数据库重新拉取房间数据
				if (typeof fetchRooms === 'function') {
					const freshRooms = await fetchRooms();
					if (freshRooms) {
						Store.rooms = freshRooms;
						if (typeof rebuildIndexes === 'function') {
							rebuildIndexes();
						}
						logInfo(`[DataValidator] 已重新加载 ${freshRooms.length} 个房间数据`);
					}
				}
				
				// 3. 强制刷新UI
				if (typeof renderRooms === 'function') {
					renderRooms();
				}
				if (typeof updateUsageStats === 'function') {
					updateUsageStats();
				}
				
				// 4. 重新初始化计时器系统
				if (window.updateAllRoomTimers && typeof window.updateAllRoomTimers === 'function') {
					window.updateAllRoomTimers();
				}
				
				logInfo('[DataValidator] 强制数据同步完成');
				
			} catch (error) {
				logErr('[DataValidator] 强制同步失败:', error.message);
			}
		}
	};
	
	// 编辑模式切换
	function toggleEditMode() {
		Store.editMode = !Store.editMode;
		const btn = document.getElementById('btnEditRooms');
		if (Store.editMode) {
			btn.textContent = '保存';
			btn.classList.add('active');
		} else {
			btn.textContent = '编辑';
			btn.classList.remove('active');
			// 保存模式：同步所有修改到云端
			saveAllRoomChanges();
		}
		renderRooms();
		ensureFilters();
	}
	
	// 保存所有房间修改
	async function saveAllRoomChanges() {
		try {
			toast('正在保存修改...', 'info');
			// 同步到云端
			if (Store.rooms.length > 0) {
				await syncRoomDatabaseToCloud(Store.rooms);
			}
			toast('✅ 所有修改已保存到云端');
		} catch (error) {
			toast('保存失败', 'error');
			logErr('保存房间修改失败:', error.message);
		}
	}
	
	// 删除琴房
	async function deleteRoom(roomName) {
		try {
			const room = Store.byName.get(roomName);
			if (!room) {
				toast('房间不存在', 'warn');
				return;
			}
			
			// 设置删除操作锁，防止本地重复处理
			// 💡 使用更精确的锁标识，包含随机数避免跨设备冲突
			const deleteLockKey = `delete_${roomName}_${Date.now()}_${Math.random().toString(36).substr(2,5)}`;
			if (!Store.operationLocks) Store.operationLocks = new Set();
			Store.operationLocks.add(deleteLockKey);
			
			// 💡 同时设置一个简单的删除标记供快速检查
			if (!Store.deletionMarkers) Store.deletionMarkers = new Map();
			Store.deletionMarkers.set(roomName, Date.now());
			
			try {
				// 如果房间有占用者，先清空
					if (room.occupant_student_name) {
					toast('房间有占用者，将先清空...', 'info');
					await clearRoom(roomName);
				}
				
				// 💡 立即从本地移除，触发即时 UI 更新（乐观删除）
				const index = Store.rooms.findIndex(r => r.name === roomName);
				if (index !== -1) {
					Store.rooms.splice(index, 1);
					Store.byName.delete(roomName);
				}
				cleanupRoomState(roomName); // 清理状态和DOM
				rebuildIndexes(); // 重建索引，更新楼层集合
				renderRooms(); // 立即重新渲染，房间消失
				ensureFilters();
				
				logInfo(`🗑️ 本地删除完成，开始云端同步: ${roomName}`);
				
				// 💡 云端删除：双表同时删除确保其他设备收到 DELETE 事件
				if (!Store.settings.offlineMode && supabaseReady) {
					// 并行删除两个表，确保 realtime 事件快速传播
					const deletePromises = [
						supabaseClient.from('room_database').delete().eq('name', roomName),
						supabaseClient.from('rooms').delete().eq('name', roomName)
					];
					
					try {
						await Promise.all(deletePromises);
						logInfo(`✅ 云端删除成功: ${roomName}`);
					} catch (cloudError) {
						logErr(`❌ 云端删除失败: ${roomName}`, cloudError.message);
						// 云端删除失败：考虑回滚本地删除（可选）
						if (cloudError.message.includes('network') || cloudError.message.includes('timeout')) {
							toast('网络错误，请检查连接', 'error');
							// 可以在这里实现回滚逻辑
						} else {
							toast('云端删除失败', 'error');
						}
						throw cloudError;
					}
				}
				
				toast(`✅ 已删除琴房：${roomName}`);
				logInfo(`🎉 房间删除完成(本地+云端): ${roomName}`);
				
			} finally {
				// 💡 清除删除锁和标记
				setTimeout(() => {
					Store.operationLocks.delete(deleteLockKey);
					logInfo(`🔓 删除锁已清除: ${roomName}`);
				}, 200);
				
				// 💡 延迟清除删除标记，给其他设备足够时间接收事件
				setTimeout(() => {
					if (Store.deletionMarkers) {
						Store.deletionMarkers.delete(roomName);
						logInfo(`🏷️ 删除标记已清除: ${roomName}`);
					}
				}, 8000); // 8秒后清除标记
			}
		} catch (error) {
			toast('删除失败', 'error');
			logErr('删除琴房失败:', error.message);
		}
	}

	// 🔗 将删除函数绑定到 window 对象供测试使用
	window.deleteRoom = deleteRoom;
	
	// 绑定内联编辑事件
	function bindInlineEditEvents() {
		const grid = document.getElementById('roomGrid');
		
		// 监听可编辑元素的输入事件
		grid.addEventListener('blur', e => {
			if (!e.target.hasAttribute('contenteditable')) return;
			saveInlineEdit(e.target);
		}, true);
		
		// 监听回车键保存
		grid.addEventListener('keydown', e => {
			if (!e.target.hasAttribute('contenteditable')) return;
			if (e.key === 'Enter') {
				e.preventDefault();
				e.target.blur(); // 触发blur事件保存
			}
		});
		
		// 监听琴房类型选择器变化
		grid.addEventListener('change', e => {
			if (!e.target.classList.contains('piano-type-selector')) return;
			savePianoTypeChange(e.target);
		});
		
		// 为空的备注提供占位提示，房间名称获得焦点时保持纯文本
		grid.addEventListener('focus', e => {
			if (!e.target.hasAttribute('contenteditable')) return;
			
			if (e.target.dataset.field === 'remark' && e.target.textContent === '点击添加备注...') {
				e.target.textContent = '';
			} else if (e.target.dataset.field === 'name') {
				// 房间名称获得焦点时，移除可能的HTML标签，只保留纯文本名称
				const card = e.target.closest('.room-card');
				if (card) {
					const roomName = card.dataset.room;
					e.target.textContent = roomName;
				}
			}
		}, true);
	}
	
	// 保存琴房类型变化
	function savePianoTypeChange(selectElement) {
		const roomName = selectElement.dataset.room;
		const newType = selectElement.value;
		
		const room = Store.byName.get(roomName);
		if (!room) return;
		
		// 映射选择器值到数据库格式
		let pianoType = '';
		switch(newType) {
			case '三角':
				pianoType = '三角钢琴';
				break;
			case '立式':
				pianoType = '立式钢琴';
				break;
			case '其他':
			default:
				pianoType = '其他';
				break;
		}
		
		// 更新本地数据
		room.pianoType = pianoType;
		
		// 更新卡片的 data-grand 属性
		const card = selectElement.closest('.room-card');
		if (card) {
			const isGrand = /三角/.test(pianoType);
			card.dataset.grand = isGrand ? '1' : '0';
		}
		
		logInfo(`更新房间类型：${roomName} -> ${pianoType}`);
		
		// 💡 同步房间类型到数据库，确保多设备实时同步
		if (!Store.settings.offlineMode && supabaseReady) {
			syncRoomTypeToDatabase(roomName, pianoType).catch(error => {
				logWarn(`房间类型同步失败 ${roomName}:`, error.message);
			});
		}
		
		// 强制重新渲染卡片以更新过滤状态和类型显示
		setTimeout(() => {
			renderRoomCardForced(roomName);
		}, 0);
	}
	
	// 保存内联编辑
	function saveInlineEdit(element) {
		const card = element.closest('.room-card');
		if (!card) return;
		
		const roomName = card.dataset.room;
		const field = element.dataset.field;
		const value = element.textContent.trim();
		
		const room = Store.byName.get(roomName);
		if (!room) return;
		
		// 更新本地数据
		if (field === 'name') {
			// 房间名称修改需要特殊处理（延迟乐观方案）
			if (value && value !== room.name) {
				const oldName = room.name;
				// 本地快速冲突：已有同名
				if (Store.byName.has(value)) {
					toast('房间名称已存在', 'warn');
					element.textContent = oldName;
					return;
				}
				// 并发锁判定
				if(window.__renameLocks && window.__renameLocks.size){
					toast('正在处理其它重命名, 稍候', 'warn');
					element.textContent = oldName; return;
				}
				// 先显示 "保存中..." 占位避免用户误以为成功
				const placeholder = `${value}`;
				// 发起远程检查 + 更新（不立即改 Store.byName 索引, 等成功后再改）
				if (!Store.settings.offlineMode && supabaseReady) {
					syncRoomNameToDatabase(oldName, value, { silent:false })
						.then(res=>{
							// 成功：现在才真正更新本地索引（若中途用户又改了名字需要二次校验）
							if(room.name!==oldName){
								// 已被别的流程改动，放弃（realtime 会同步）
								logWarn('本地房间名称已变化，放弃本次索引更新');
								return;
							}
							Store.byName.delete(oldName);
							room.name = value;
							Store.byName.set(value, room);
							card.dataset.room = value;
							toast('✅ 重命名成功');
							renderRoomCardForced(value);
						})
						.catch(err=>{
							if(err.message==='NAME_CONFLICT'){
								toast('名称已被占用', 'error');
							} else {
								toast('重命名失败', 'error');
							}
							element.textContent = oldName; // 回滚文本
						})
				} else {
					// 离线模式：仅本地修改
					Store.byName.delete(oldName);
					room.name = value;
					Store.byName.set(value, room);
					card.dataset.room = value;
					renderRoomCardForced(value);
				}
			}
		} else if (field === 'remark') {
			room.remark = value || '';
			logInfo(`更新房间备注：${roomName} -> ${value}`);
			
			// 💡 同步房间备注到数据库，确保多设备实时同步
			if (!Store.settings.offlineMode && supabaseReady) {
				syncRoomRemarkToDatabase(roomName, value).catch(error => {
					logWarn(`房间备注同步失败 ${roomName}:`, error.message);
				});
			}
			
			// 恢复占位文字
			if (!value) {
				element.textContent = '点击添加备注...';
			}
		}
	}
	
	// 已移除的按钮（主题 / 重置过滤 / 统计）不再硬绑定，避免因不存在导致脚本停止
	// 如果仍需重置过滤，可在其它入口调用该函数
	function resetFilters(){ Store.filters.floor='ALL'; Store.filters.type='ALL'; renderRooms(); }
	// 已移除侧栏快速导入/导出区块，以下逻辑简化：提供一个隐藏 input 复用
	let hiddenInput=document.getElementById('hiddenFileImport');
	if(!hiddenInput){ hiddenInput=document.createElement('input'); hiddenInput.type='file'; hiddenInput.id='hiddenFileImport'; hiddenInput.accept='.json,.csv'; hiddenInput.style.display='none'; document.body.appendChild(hiddenInput); }
	hiddenInput.addEventListener('change', e=>{ 
		const f=e.target.files[0]; if(!f) return; const name=f.name.toLowerCase(); const reader=new FileReader(); 
		reader.onload = async () => {
			try{
				const text=reader.result;
				if(name.endsWith('.csv')){
					const {header, rows}=parseCSV(text);
					if(!header.length){ toast('空 CSV'); return; }
					const type=detectCSVType(header);
					
					if(type==='rooms') {
						toast('正在导入琴房数据...', 'info');
						await importCsvRooms(header, rows);
					} else if(type==='students') {
						toast('正在导入学生数据...', 'info');
						await importCsvStudents(header, rows);
					} else {
						toast('无法识别的 CSV 表头');
					}
				} else { 
					await importJson(JSON.parse(text)); 
				}
			}catch(err){ 
				toast('文件解析失败'); 
				logErr('解析失败', err.message); 
			}
		}; 
		reader.readAsText(f,'utf-8'); 
		e.target.value=''; 
	});

	window.addEventListener('keydown', e=>{ if(e.key==='Escape'){ closeStudentModal(); }});

	/*************************************************
	 * 渲染 & 过滤
	 *************************************************/
	function rebuildIndexes(){
		Store.byName.clear(); Store.floorSet.clear();
		Store.rooms.forEach(r=>{ Store.byName.set(r.name,r); const floor=deriveFloor(r.location); if(floor) Store.floorSet.add(floor); });
	}
	function rebuildStudentIndex(){ Store.studentIndex.clear(); Store.students.forEach(s=>Store.studentIndex.set(s.name,s)); }
	function deriveFloor(location){ if(!location) return '未知'; const m=location.match(/[一二三四五六七八九0-9]+/); if(!m) return location; const map={一:1,二:2,三:3,四:4,五:5,六:6,七:7,八:8,九:9}; const raw=m[0]; return String(map[raw]||raw); }
	function ensureFilters(){
		const floorWrap=document.getElementById('floorFilters');
		const typeWrap=document.getElementById('typeFilters');
		
		// 获取当前过滤条件下有房间的楼层
		const currentTypeFilter = Store.filters.type;
		const availableRooms = Store.rooms.filter(r => {
			// 应用类型过滤器，检查哪些房间在当前类型过滤下可见
			if (currentTypeFilter === 'ALL') return true;
			const isGrand = /三角/.test(r.pianoType);
			if (currentTypeFilter === 'GRAND') return isGrand;
			if (currentTypeFilter === 'UPRIGHT') return !isGrand && !/无|电子/i.test(r.pianoType);
			if (currentTypeFilter === 'NONE') return !isGrand && !/立|upright|三角/.test(r.pianoType);
			return true;
		});
		
		// 构建当前可见房间的楼层集合
		const activeFloorSet = new Set();
		availableRooms.forEach(r => {
			const floor = deriveFloor(r.location);
			if (floor) activeFloorSet.add(floor);
		});
		
		const floors=['ALL',...Array.from(activeFloorSet).sort((a,b)=>a.localeCompare(b,'zh-Hans-CN',{numeric:true}))];
		logInfo(`楼层过滤器更新: 显示 ${floors.length-1} 个有房间的楼层`);
		
		// 如果当前选中的楼层在新的楼层列表中不存在，重置为ALL
		if (Store.filters.floor !== 'ALL' && !activeFloorSet.has(Store.filters.floor)) {
			logInfo(`当前楼层 ${Store.filters.floor} 无房间，重置为全部`);
			Store.filters.floor = 'ALL';
		}
		let floorHTML = floors.map(f=>`<button data-floor="${f}" data-active="${Store.filters.floor===f?1:0}">${f==='ALL'?'全部楼层':f+'楼'}</button>`).join('');
		
		// 编辑模式下添加新增房间按钮
		if (Store.editMode) {
			floorHTML += `<button id="btnAddRoom" class="add-room-btn" title="新增琴房">🎹 新增琴房</button>`;
		}
		
		floorWrap.innerHTML = floorHTML;
		typeWrap.innerHTML = ['ALL','GRAND','UPRIGHT','NONE'].map(t=>`<button data-type="${t}" data-active="${Store.filters.type===t?1:0}">${labelType(t)}</button>`).join('');
		
		floorWrap.querySelectorAll('button').forEach(b=>{
			if(b.dataset.floor) {
				b.onclick=()=>{Store.filters.floor=b.dataset.floor; renderRooms();};
			}
		});
		typeWrap.querySelectorAll('button').forEach(b=>b.onclick=()=>{Store.filters.type=b.dataset.type; renderRooms();});
		
		// 绑定新增房间按钮
		if (Store.editMode) {
			bind('btnAddRoom', showAddRoomModal);
		}
	}
	function labelType(t){ if(t==='ALL') return '全部类型'; if(t==='GRAND') return '三角'; if(t==='UPRIGHT') return '立式'; return '其它'; }
	function roomFilter(r){
		const floor=deriveFloor(r.location);
		if(Store.filters.floor!=='ALL' && floor!==Store.filters.floor) return false;
		const isGrand = /三角/.test(r.pianoType);
		if(Store.filters.type==='GRAND' && !isGrand) return false;
		if(Store.filters.type==='UPRIGHT' && (isGrand || /无|电子/i.test(r.pianoType))) return false;
		if(Store.filters.type==='NONE' && (isGrand || /立|upright|三角/.test(r.pianoType))) return false;
		return true;
	}
	function renderRooms(){
		ensureFilters();
		const grid=document.getElementById('roomGrid');
		// 自定义排序：先按琴房类型(三角 > 立式 > 其它)，再按名称“字母优先、数字其次”
		const typeRank = r => {
			if(/三角/.test(r.pianoType)) return 0; // GRAND
			if(/立式|upright/i.test(r.pianoType)) return 1; // UPRIGHT
			return 2; // OTHER
		};
		// 解析名称：提取开头的字母前缀与其后的数字，例如 A12 -> {alpha:'A', num:12}
		const parseAlphaNum = (name) => {
			const s = String(name||'').trim();
			// 模式1：字母 + 可选分隔符 + 数字
			let m = s.match(/^\s*([A-Za-z]+)\s*[-_ ]*\s*(\d+)/);
			if(m) return { alpha: m[1].toUpperCase(), num: parseInt(m[2],10), hasAlpha: true, hasNum: true };
			// 模式2：仅字母前缀
			m = s.match(/^\s*([A-Za-z]+)/);
			if(m) return { alpha: m[1].toUpperCase(), num: null, hasAlpha: true, hasNum: false };
			return { alpha: '', num: null, hasAlpha: false, hasNum: false };
		};
		const list=Store.rooms
			.filter(roomFilter)
			.slice() // 防止原数组被意外排序
			.sort((a,b)=>{
				const ta=typeRank(a), tb=typeRank(b);
				if(ta!==tb) return ta-tb;
				// 同类型：先比较字母前缀，再比较数字；都无规则时回退自然比较
				const pa = parseAlphaNum(a.name);
				const pb = parseAlphaNum(b.name);
				if(pa.alpha !== pb.alpha){
					// 字母前缀不同：按字母序（不区分大小写）
					return pa.alpha.localeCompare(pb.alpha, 'en', { sensitivity: 'base' });
				}
				// 字母前缀相同：若都有数字则比较数字
				if(pa.hasNum && pb.hasNum && pa.num !== pb.num) return pa.num - pb.num;
				// 仅一方有数字：无数字的在前
				if(pa.hasNum !== pb.hasNum) return pa.hasNum ? 1 : -1;
				// 回退：中文/其它情况使用自然比较（含数字识别）
				return a.name.localeCompare(b.name,'zh-Hans-CN',{numeric:true});
			});
		logInfo(`已按类型与字母+数字排序: total ${list.length}`);
		// 构建带分隔线的HTML
		let htmlParts=[];
		let lastType=-1;
		const typeLabelMap={0:'三角钢琴',1:'立式钢琴',2:'其他类型'};
		const typeClassMap={0:'grand',1:'upright',2:'other'};
		for(const r of list){
			const t=typeRank(r);
			if(t!==lastType){
				if(lastType!==-1) htmlParts.push(''); // 分组自然换行
				// 如果过滤后只有一种类型则不显示分隔线：延后判断
				htmlParts.push(`<div class="room-type-separator ${typeClassMap[t]}" data-type-sep="${t}"><div class="line"></div><div class="label">${typeLabelMap[t]}</div><div class="line"></div></div>`);
				lastType=t;
			}
			htmlParts.push(roomCardHTML(r));
		}
		// 如果最终只有一个分隔线且其后只有房间，且没有出现第二种类型，则移除该分隔线（单一类型不需要）
		const sepCount=htmlParts.filter(h=>/room-type-separator/.test(h)).length;
		if(sepCount===1){
			htmlParts=htmlParts.filter(h=>!/room-type-separator/.test(h));
		}
		grid.innerHTML=htmlParts.join('');
		
		// 添加内联编辑事件监听
		if (Store.editMode) {
			bindInlineEditEvents();
		}
	}
	function renderRoomCard(name){ 
		const r=Store.byName.get(name); 
		const grid=document.getElementById('roomGrid'); 
		const el=grid.querySelector(`[data-room='${CSS.escape(name)}']`); 
		
		if(!r) {
			// 房间数据不存在，移除DOM元素
			if(el) {
				logInfo(`移除已删除房间的卡片: ${name}`);
				el.remove();
			}
			return; 
		}
		
		if(!roomFilter(r)) {
			// 房间被过滤，移除DOM元素
			if(el) {
				el.remove();
			}
			return; 
		}
		
		// 防重复渲染：检查是否需要重新渲染
		const currentHTML = el ? el.outerHTML : '';
		const newHTML = roomCardHTML(r);
		
		if (currentHTML === newHTML) {
			logInfo(`跳过重复渲染: ${name} (内容未变化)`);
			return;
		}
		
		logInfo(`重新渲染房间卡片: ${name}, occupant: ${r.occupant_student_name || 'null'}, version: ${r.version || 'unknown'}`);
		
		if(el){ 
			el.outerHTML=newHTML; 
		} else { 
			renderRooms(); 
		} 
	}

	// 💡 强制渲染房间卡片，跳过防重复检查（用于realtime元数据更新）
	function renderRoomCardForced(name) {
		const r = Store.byName.get(name);
		const grid = document.getElementById('roomGrid');
		const el = grid.querySelector(`[data-room='${CSS.escape(name)}']`);
		
		if (!r) {
			// 房间数据不存在，移除DOM元素
			if (el) {
				logInfo(`移除已删除房间的卡片: ${name}`);
				el.remove();
			}
			return;
		}
		
		if (!roomFilter(r)) {
			// 房间被过滤，移除DOM元素
			if (el) {
				el.remove();
			}
			return;
		}
		
		// 强制重新渲染，不进行HTML内容比较
		logInfo(`强制重新渲染房间卡片: ${name} (元数据更新)`);
		
		const newHTML = roomCardHTML(r);
		if (el) {
			el.outerHTML = newHTML;
		} else {
			renderRooms();
		}
		
		// 强制重新应用状态 + 幂等校验
		setTimeout(() => {
			const newEl = grid.querySelector(`[data-room='${CSS.escape(name)}']`);
			if (newEl && r) {
				const st = statusInfo(r);
				newEl.dataset.status = st.state;
				const chip = newEl.querySelector('.chip');
				if (chip) {
					chip.textContent = st.chip;
					chip.className = `chip ${st.class}`;
				}
				// 幂等校验：occupant 为空时清理残留
				if(!r.occupant_student_name){
					const occLine = newEl.querySelector('.occupant-line');
					if(occLine) occLine.remove();
					const actions = newEl.querySelector('.actions');
					if(actions){
						const strayClear = actions.querySelector('[data-act="clear"]');
						if(strayClear){
							actions.innerHTML = '';
							logInfo(`[RECONCILE] 清理残留操作按钮 ${name}`);
						}
					}
					newEl.classList.remove('pending-operation');
				}
			}
		}, 10);
	}

	// === 完整重渲染辅助函数 ===
	function fullReRenderRoom(room){
		const grid=document.getElementById('roomGrid');
		if(!grid) return;
		const old = grid.querySelector(`[data-room='${CSS.escape(room.name)}']`);
		if(old) old.remove();
		// 调用标准渲染
		renderRoomCard(room.name);
		
		// 🔄 完整重渲染后立即触发计时器更新，确保其他设备看到正确状态
		if (window.updateAllRoomTimers && typeof window.updateAllRoomTimers === 'function') {
			setTimeout(() => {
				window.updateAllRoomTimers();
			}, 100);
		}
	}
	function statusInfo(r){
		if(!r.occupant_student_name) return {state:'empty',chip:'空闲',class:'good'};
		if(!r.registerTime) {
			// 添加调试信息：有学生但没有注册时间
			logWarn(`房间 ${r.name} 有占用者 ${r.occupant_student_name} 但无 registerTime`);
			return {state:'occupied',chip:'占用',class:'accent'};
		}
		
		const now=Date.now();
		const totalPrepMs = 60000; // 预备期 60 秒
		const prepEnd=r.registerTime+totalPrepMs;
		
		// 调试信息：记录时间计算详情
		const debugInfo = {
			roomName: r.name,
			student: r.occupant_student_name,
			registerTime: r.registerTime,
			registerTimeStr: new Date(r.registerTime).toLocaleString(),
			now: now,
			nowStr: new Date(now).toLocaleString(),
			prepEnd: prepEnd,
			timeDiff: now - r.registerTime,
			inPrep: now < prepEnd
		};
		
		// 每30秒记录一次详细信息，避免日志过多
		if (!window.__lastStatusDebugTime || now - window.__lastStatusDebugTime > 30000) {
			logInfo(`状态计算详情 - ${r.name}:`, debugInfo);
			window.__lastStatusDebugTime = now;
		}
		
		if(now<prepEnd){
			const remaining = prepEnd-now; // ms
			const secs = Math.ceil(remaining/1000);
			return {state:'preparing',chip:`准备中 ${secs}s`,class:'preparing',remainingPrepMs:remaining,totalPrepMs};
		}
		const used=Math.floor((now-prepEnd)/1000);
		const limit = (Store.settings.basePracticeDuration||120)*60; // 秒
		if(used<=limit) return {state:'occupied',chip:formatHMS(used),class:'accent'};
		return {state:'overtime',chip:'超时 '+formatDuration(used-limit),class:'danger'};
	}
	function roomCardHTML(r){ 
		const st=statusInfo(r); 
		const isGrand=/三角/.test(r.pianoType);
		const isUpright=/立式/.test(r.pianoType);
		const typeStr = isGrand ? 'grand' : (isUpright ? 'upright' : 'other');
		const editModeClass = Store.editMode ? 'edit-mode' : '';
		const deleteBtn = Store.editMode ? `<div class="delete-btn" data-room="${r.name}" title="删除琴房">✕</div>` : '';
		
		// 确定琴房类型标签
		let typePill = '';
		if (!Store.editMode) {
			if (isGrand) {
				typePill = '<span class="pill pill-grand">三角</span>';
			} else if (isUpright) {
				typePill = '<span class="pill pill-upright">立式</span>';
			} else {
				typePill = '<span class="pill pill-other">其他</span>';
			}
		}
		
		// 处理可编辑区域的显示内容
		const roomNameContent = Store.editMode ? r.name : `${r.name} ${typePill}`;
		const remarkContent = Store.editMode ? 
			(r.remark ? escapeHtml(r.remark) : '点击添加备注...') : 
			(r.remark ? escapeHtml(r.remark) : '');
		
		// 编辑模式下的琴房类型选择器
		let pianoTypeSelector = '';
		if (Store.editMode) {
			// 映射钢琴类型到选择器选项
			const currentType = r.pianoType || '其他';
			let selectedType = '其他'; // 默认选择
			if (/三角/.test(currentType)) {
				selectedType = '三角';
			} else if (/立式/.test(currentType)) {
				selectedType = '立式';
			}
			
			pianoTypeSelector = `<select class="piano-type-selector" data-room="${r.name}">
				<option value="立式" ${selectedType === '立式' ? 'selected' : ''}>立式</option>
				<option value="三角" ${selectedType === '三角' ? 'selected' : ''}>三角</option>
				<option value="其他" ${selectedType === '其他' ? 'selected' : ''}>其他</option>
			</select>`;
		}
		
		return `<div class="room-card ${!r.occupant_student_name?'empty':''} ${editModeClass}" data-room="${r.name}" data-grand="${isGrand?1:0}" data-type="${typeStr}" data-status="${st.state}" tabindex="0" title="${r.name}\n${r.location||''}\n${r.pianoType}">
			${deleteBtn}
			${Store.editMode ? `<div class="edit-row">
				<div class="room-name compact" contenteditable="true" data-field="name">${roomNameContent}</div>
				${pianoTypeSelector}
			</div>` : `<div class="room-name" ${Store.editMode ? 'contenteditable="true" data-field="name"' : ''}>${roomNameContent}</div>`}
			<div class="remark" ${Store.editMode ? 'contenteditable="true" data-field="remark"' : ''}>${remarkContent}</div>
			${r.occupant_student_name && !Store.editMode ?`<div class="occupant-line"><span class="dot"></span><span>${escapeHtml(r.occupant_student_name)}</span></div>`:''}
			${!Store.editMode ? `<div class="status-row">
				${r.occupant_student_name ? `<span class="chip ${st.class}" ${st.state==='preparing'?`data-preparing-chip="1" data-room-prep="${r.name}"`:''}>${st.chip}</span>` : `<span class="chip chip-dim" data-empty="1">空闲</span>`}
				<div class="actions">${r.occupant_student_name?`<button class="danger" data-act="clear" title="清空">✕</button><button class="renew-btn" data-act="renew" title="续期">⟳</button>`:``}</div>
			</div>` : ''}
		</div>`; 
	}

	/*************************************************
	 * 交互逻辑
	 *************************************************/
	function bindRoomEvents(){
		// 🕐 启动智能全局计时器系统（服务器时间同步 + 页面可见性检测）
		if(!window.__globalTimerInterval){
			// 启动计时器
			const startTimer = () => {
				if (window.__globalTimerInterval) return;
				window.__globalTimerInterval = setInterval(()=>{
					updateAllRoomTimers();
				}, 1000);
				logInfo('⏱️ 全局计时器已启动');
			};
			
			// 暂停计时器
			const pauseTimer = () => {
				if (window.__globalTimerInterval) {
					clearInterval(window.__globalTimerInterval);
					window.__globalTimerInterval = null;
					logInfo('⏸️ 全局计时器已暂停（页面不可见）');
				}
			};
			
			// 页面可见性变化检测
			document.addEventListener('visibilitychange', () => {
				if (document.hidden) {
					pauseTimer();
					// 页面隐藏前保存状态
					timerPersistence.saveTimerStates();
				} else {
					// 页面恢复可见时重新同步时间并启动计时器
					if (serverTimeSync.isInitialized) {
						serverTimeSync.manualSync();
					}
					startTimer();
					logInfo('👁️ 页面恢复可见，重新启动计时器');
				}
			});
			
			// 初始启动
			startTimer();
			logInfo('⏱️ 智能全局计时器系统已初始化（支持页面可见性检测）');
		}
		// 防抖机制的续期处理
		let lastRenewClick = {};
		
		document.getElementById('roomGrid').addEventListener('click', e=>{
			const card=e.target.closest('.room-card'); if(!card) return; const name=card.dataset.room; const room=Store.byName.get(name); if(!room) return;
			
			// 编辑模式下禁用琴房点击功能，除了特定按钮
			if (Store.editMode) {
				// 删除按钮处理
				if(e.target.closest('.delete-btn')){
					if(confirm(`确定要删除琴房 "${name}" 吗？`)){
						deleteRoom(name);
					}
					return;
				}
				
				// 琴房类型选择器处理
				if(e.target.closest('.piano-type-selector')){
					// 类型选择器由change事件处理，这里不做额外处理
					return;
				}
				
				// 其他点击事件在编辑模式下被忽略
				return;
			}
			
			// 非编辑模式下的正常点击逻辑
			if(e.target.closest('button[data-act=clear]')){ clearRoom(name); return; }
			if(e.target.closest('button[data-act=renew]')){ 
				const now = Date.now();
				// 防抖：同一房间500ms内只能触发一次续期
				if (lastRenewClick[name] && (now - lastRenewClick[name]) < 500) {
					logInfo(`房间 ${name} 续期操作被防抖限制`);
					return;
				}
				lastRenewClick[name] = now;
				
				// 检查操作锁
				const lockKey = `renew_${name}`;
				if (Store.operationLocks?.has(lockKey)) {
					toast(`房间 ${name} 正在处理中...`, 'warn');
					return;
				}
				
				renewRoom(name); 
				return; 
			}
			if(!room.occupant_student_name) openStudentModal(name);
		});
		// 防抖机制的双击清空处理
		let lastClearClick = {};
		document.getElementById('roomGrid').addEventListener('dblclick', e=>{
			// 编辑模式下禁用双击清空
			if (Store.editMode) return;
			
			const card=e.target.closest('.room-card'); 
			if(!card) return; 
			
			const roomName = card.dataset.room;
			const now = Date.now();
			
			// 防抖：同一房间500ms内只能触发一次清空
			if (lastClearClick[roomName] && (now - lastClearClick[roomName]) < 500) {
				logInfo(`房间 ${roomName} 清空操作被防抖限制`);
				return;
			}
			lastClearClick[roomName] = now;
			
			const r=Store.byName.get(roomName); 
			if(r && r.occupant_student_name) {
				// 检查是否有操作锁
				const lockKey = `clear_${roomName}`;
				if (Store.operationLocks?.has(lockKey)) {
					toast(`房间 ${roomName} 正在处理中...`, 'warn');
					return;
				}
				
				clearRoom(r.name);
			} else if (r && !r.occupant_student_name) {
				toast(`房间 ${roomName} 已为空`, 'info');
			}
		});
	}
	async function renewRoom(roomName){ 
		// 检查操作锁，防止重复操作
		const lockKey = `renew_${roomName}`;
		if (Store.operationLocks?.has(lockKey)) {
			logWarn(`房间 ${roomName} 正在续期中，请稍候`);
			toast(`房间 ${roomName} 正在续期中...`, 'warn');
			return { ok: false, error: '操作进行中' };
		}
		
		const r=Store.byName.get(roomName); 
		if(!r||!r.occupant_student_name){ 
			toast('房间为空'); 
			return {ok:false, error:'房间为空'}; 
		}
		
		// 设置操作锁
		if (!Store.operationLocks) Store.operationLocks = new Set();
		Store.operationLocks.add(lockKey);
		
		try {
				// 乐观更新（立即显示效果）
				const originalTime = r.registerTime;
				const nowMs = Date.now();
				r.registerTime = nowMs; // 新会话开始
			
			// 添加视觉指示
			const card = document.querySelector(`[data-room="${roomName}"]`);
			if (card) {
				card.classList.add('pending-operation');
				card.dataset.status = 'syncing';
			}
			
			renderRoomCard(roomName); 
			toast(`✅ 已续期 ${roomName}`, 'success');
			
			// 后端同步
			if(!supabaseReady){ 
				logWarn('离线模式 - 结束当前会话并重开（本地）');
				// 本地记录两条：clear + assign
				await writePracticeLog(roomName, r.occupant_student_name, 'clear', { startMs: originalTime });
				await writePracticeLog(roomName, r.occupant_student_name, 'assign');
				return {ok:true, offline:true}; 
			}
			
			const nowIso = new Date(nowMs).toISOString();
			const nextVersion = (r.version || 0) + 1;
			
			// 标记为待处理状态
			Store.pendingAssign.set(roomName, { 
				student: r.occupant_student_name, 
				version: nextVersion, 
				timestamp: nowMs,
				action: 'restart'
			});
			
			const { data, error } = await supabaseClient.from('rooms').upsert({
				name: roomName,
				occupant_student_name: r.occupant_student_name,
				register_time: nowIso,  // 新会话开始时间
				heartbeat_at: nowIso,
				version: nextVersion,
				updated_at: nowIso
			});
			
			if(error){ 
				logErr('续期失败', error.message);
				// 回滚乐观更新
				r.registerTime = originalTime;
				renderRoomCard(roomName);
				toast(`❌ 续期失败 ${roomName}`, 'error');
				return {ok:false,error}; 
			}
			
			// 写入练习记录：先结束上一段，再开始新一段
			await writePracticeLog(roomName, r.occupant_student_name, 'clear', { startMs: originalTime });
			await writePracticeLog(roomName, r.occupant_student_name, 'assign');
			
			logInfo(`成功结束并重开新会话 ${roomName} (v${nextVersion})`);
			return {ok:true, data};
			
		} finally {
			// 清除操作锁
			Store.operationLocks.delete(lockKey);
			// 清除待处理状态
			Store.pendingAssign.delete(roomName);
			// 清除视觉指示
			clearOperationIndicator(roomName);
		}
	}
	function openStudentModal(roomName){
		const modal=document.getElementById('studentModalBackdrop'); 
		modal.style.display='flex'; 
		modal.dataset.room=roomName; 
		const input=document.getElementById('studentSearch');
		input.value='';
		// 初始化键盘选择状态
		studentListKB.index=0; studentListKB.active=true; 
		renderStudentList();
		// 聚焦输入框方便直接打字
		setTimeout(()=>input.focus(), 0);
	}
	function closeStudentModal(){ document.getElementById('studentModalBackdrop').style.display='none'; }
	function renderStudentList(){
		const box=document.getElementById('studentList'); 
		const q=document.getElementById('studentSearch').value.trim().toLowerCase(); 
		const roomName=document.getElementById('studentModalBackdrop').dataset.room; 
		const isGrand=/三角/.test((Store.byName.get(roomName)||{}).pianoType||'');

		// 优先使用 StudentLibrary 中的活动学生列表（保持与学生库 CRUD 同步）
		let arr = [];
		if(window.getAllActiveStudents){
			try{ arr = window.getAllActiveStudents().map(s=>({ name:s.name, grade:s.grade||'', major:s.major||'' })); }catch(_){ arr = []; }
		}
		if(!arr.length){ // 回退到原始 Store.students
			arr = Store.students.slice();
		}
		if(q) arr=arr.filter(s=> matchPinyin(s.name, q) || (s.major||'').toLowerCase().includes(q));
		
		// 对于三角钢琴，完全过滤掉非钢琴教研室的学生
		if(isGrand) {
			arr = arr.filter(s => s.major === '钢琴教研室');
		}
		
		arr.sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN'));
		
		// 建立占用索引，提高查找速度
		const occupancyMap = new Map();
		for(const r of Store.rooms){ if(r.occupant_student_name){ occupancyMap.set(r.occupant_student_name, r); } }

		box.innerHTML = arr.map((s,i)=>{ 
			const occRoom = occupancyMap.get(s.name);
			const isOccupied = !!occRoom && occRoom.name !== roomName; // 已在其它房间
			let titleText = `${s.major||''} ${s.grade||''}`.trim();
			if(isOccupied){ titleText += ` (占用 ${occRoom.name})`; }

			// 计算占用状态标签（准备中/计时/超时）
			let stateTag = '';
			if(isOccupied){
				const st = statusInfo(occRoom);
				let label = '';
				switch(st.state){
					case 'preparing': label='准备中'; break;
					case 'occupied': label='占用中'; break;
					case 'overtime': label='超时'; break;
					default: label='占用';
				}
				// 动态时长（占用计时）
				if(st.state==='occupied' && /:\d{2}$/.test(st.chip)){
					label += ` ${st.chip}`; // 已有 mm:ss 或 hh:mm:ss
				}
				stateTag = `<span class="state-tag st-${st.state}">${label}</span>`;
			}

			const kbCls = (i===studentListKB.index)?' kb-selected':'';
			return `<div class="student-item${kbCls}" data-name="${s.name}" title="${titleText}">
				<div class="col-left">
					<span class="stu-name">${escapeHtml(s.name)}</span>
					<span class="tag major">${s.major||''}</span>
					${s.grade?`<span class=\"tag grade\">${s.grade}</span>`:''}
				</div>
				<div class="col-right">
					${isOccupied?`<span class=\"room-tag\" title=\"当前占用房间\">${occRoom.name}</span>`:''}
					${stateTag}
				</div>
			</div>`; 
		}).join('');
		// 越界保护 & 重新高亮
		const items = box.querySelectorAll('.student-item');
		if(items.length===0){ studentListKB.index=-1; return; }
		if(studentListKB.index>=items.length) studentListKB.index=items.length-1; 
		if(studentListKB.index<0) studentListKB.index=0;
		items.forEach((el,i)=> el.classList.toggle('kb-selected', i===studentListKB.index));
		// 确保选中项可见
		const active=items[studentListKB.index];
		if(active){ const rect=active.getBoundingClientRect(); const parent=box.getBoundingClientRect(); if(rect.top<parent.top||rect.bottom>parent.bottom){ active.scrollIntoView({block:'nearest'}); } }
	}
	function bindStudentModal(){
		// 键盘导航状态
		if(!window.studentListKB){
			window.studentListKB={ index:0, active:false };
		}
		function moveSelection(delta){
			const box=document.getElementById('studentList');
			const items=box.querySelectorAll('.student-item');
			if(items.length===0) return; 
			studentListKB.index=Math.min(items.length-1, Math.max(0, studentListKB.index+delta));
			items.forEach((el,i)=> el.classList.toggle('kb-selected', i===studentListKB.index));
			const active=items[studentListKB.index];
			if(active){ const rect=active.getBoundingClientRect(); const parent=box.getBoundingClientRect(); if(rect.top<parent.top||rect.bottom>parent.bottom){ active.scrollIntoView({block:'nearest'}); } }
		}
		function triggerSelect(){
			const box=document.getElementById('studentList');
			const items=box.querySelectorAll('.student-item');
			if(items.length===0) return;
			const target=items[studentListKB.index];
			if(target){ target.click(); }
		}
		// 监听键盘
		document.addEventListener('keydown', function studentModalKeyHandler(e){
			const modal=document.getElementById('studentModalBackdrop');
			if(modal.style.display!=='flex') return; // 只在模态打开时
			// 当焦点在输入框或 body 均可响应，上下键 & 回车
			if(['ArrowDown','ArrowUp','Enter','Escape'].includes(e.key)){
				// 避免页面整体滚动
				e.preventDefault();
				studentListKB.active=true;
				if(e.key==='ArrowDown') moveSelection(1); else if(e.key==='ArrowUp') moveSelection(-1); else if(e.key==='Enter') triggerSelect(); else if(e.key==='Escape') closeStudentModal();
			}
		}, {passive:false});
		document.getElementById('studentSearch').addEventListener('input', renderStudentList);
		// 防抖机制的学生选择处理
		let lastAssignClick = {};
		document.getElementById('studentList').addEventListener('click', async (e) => { 
			const item=e.target.closest('.student-item'); 
			if(!item) return; 
			
			const name=item.dataset.name; 
			const room=document.getElementById('studentModalBackdrop').dataset.room;
			const now = Date.now();
			const clickKey = `${room}_${name}`;
			
			// 防抖：同一房间和学生组合500ms内只能触发一次分配
			if (lastAssignClick[clickKey] && (now - lastAssignClick[clickKey]) < 500) {
				logInfo(`房间 ${room} 分配给 ${name} 的操作被防抖限制`);
				return;
			}
			lastAssignClick[clickKey] = now;
			
			// 检查操作锁
			const lockKey = `assign_${room}`;
			if (Store.operationLocks?.has(lockKey)) {
				toast(`房间 ${room} 正在处理中...`, 'warn');
				return;
			}
			
			let shouldCloseModal = true; // 控制是否关闭模态框
			
			// 检查学生是否已经占用其他琴房，如果是则进行转移操作
			const occupiedRoom = Store.rooms.find(r => r.occupant_student_name === name);
			if (occupiedRoom && occupiedRoom.name !== room) {
				// 转移场景：使用专门的转移函数
				toast(`准备将 ${name} 从 ${occupiedRoom.name} 转移到 ${room}...`, 'info');
				
				const transferResult = await transferStudent(occupiedRoom.name, room, name);
				if (transferResult && transferResult.ok) {
					toast(`✅ ${name} 已成功转移到 ${room}`, 'success');
				} else if (transferResult && transferResult.cancelled) {
					// 用户取消转移，保持原有登记，不关闭模态框
					toast(`转移已取消，${name} 保持在 ${occupiedRoom.name}`, 'info');
					shouldCloseModal = false; // 不关闭模态框，让用户可以重新选择
				} else {
					// 转移失败，保持原有登记
					toast(`转移失败，${name} 保持在 ${occupiedRoom.name}`, 'warn');
					shouldCloseModal = false; // 不关闭模态框，让用户可以重新选择
				}
			} else {
				// 非转移场景，正常登记
				const assignResult = await attemptAssignRoom(room, name);
				if (assignResult && assignResult.cancelled) {
					shouldCloseModal = false; // 用户取消了登记，不关闭模态框
				}
			}
			
			// 只有在操作成功或用户主动选择时才关闭模态框
			if (shouldCloseModal) {
				closeStudentModal();
			}
		});
		document.getElementById('btnStudentModalCancel').onclick=closeStudentModal; document.getElementById('btnCloseStudentModal').onclick=closeStudentModal; }

	/*************************************************
	 * 新增房间模态框
	 *************************************************/
	function showAddRoomModal(){
		const modal = document.getElementById('addRoomModalBackdrop');
		modal.style.display = 'flex';
		
		// 清空表单
		document.getElementById('addRoomName').value = '';
		document.getElementById('addRoomLocation').value = '';
		document.getElementById('addRoomPianoType').value = '立式';
		document.getElementById('addRoomRemark').value = '';
		
		// 重置钢琴类型选择器
		document.querySelectorAll('.piano-type-option').forEach(option => {
			option.classList.remove('selected');
		});
		document.querySelector('.piano-type-option[data-type="立式"]').classList.add('selected');
		
		// 聚焦房间名称输入框
		setTimeout(() => document.getElementById('addRoomName').focus(), 0);
		
		// 点击背景关闭模态框
		modal.addEventListener('click', function handleBackdropClick(e) {
			if (e.target === modal) {
				closeAddRoomModal();
				modal.removeEventListener('click', handleBackdropClick);
			}
		});
	}
	
	function closeAddRoomModal(){
		document.getElementById('addRoomModalBackdrop').style.display = 'none';
	}
	
	function bindAddRoomModal(){
		document.getElementById('btnCloseAddRoomModal').onclick = closeAddRoomModal;
		document.getElementById('btnAddRoomCancel').onclick = closeAddRoomModal;
		document.getElementById('btnAddRoomConfirm').onclick = createNewRoom;
		
		// 钢琴类型选择器事件
		document.querySelectorAll('.piano-type-option').forEach(option => {
			option.addEventListener('click', function() {
				// 移除其他选中状态
				document.querySelectorAll('.piano-type-option').forEach(opt => opt.classList.remove('selected'));
				// 添加当前选中状态
				this.classList.add('selected');
				// 同步到隐藏的select元素
				document.getElementById('addRoomPianoType').value = this.dataset.type;
			});
		});
		
		// 回车键提交
		document.getElementById('addRoomName').addEventListener('keydown', e => {
			if (e.key === 'Enter') {
				e.preventDefault();
				createNewRoom();
			}
		});
		
		// ESC键关闭
		document.addEventListener('keydown', function addRoomModalKeyHandler(e) {
			const modal = document.getElementById('addRoomModalBackdrop');
			if (modal.style.display === 'flex' && e.key === 'Escape') {
				closeAddRoomModal();
			}
		});
	}
	
	async function createNewRoom(){
		// 清除之前的错误状态
		document.querySelectorAll('.form-field').forEach(field => {
			field.classList.remove('error');
			const errorMsg = field.querySelector('.error-message');
			if (errorMsg) errorMsg.remove();
		});
		
		const name = document.getElementById('addRoomName').value.trim();
		const location = document.getElementById('addRoomLocation').value.trim();
		const pianoType = document.getElementById('addRoomPianoType').value;
		const remark = document.getElementById('addRoomRemark').value.trim();
		
		let hasError = false;
		
		// 验证房间名称
		if (!name) {
			const nameField = document.getElementById('addRoomName').closest('.form-field');
			nameField.classList.add('error');
			const errorDiv = document.createElement('div');
			errorDiv.className = 'error-message';
			errorDiv.textContent = '房间名称不能为空';
			nameField.appendChild(errorDiv);
			hasError = true;
		}
		
		// 检查房间名称是否已存在
		if (name && Store.byName.has(name)) {
			const nameField = document.getElementById('addRoomName').closest('.form-field');
			nameField.classList.add('error');
			const errorDiv = document.createElement('div');
			errorDiv.className = 'error-message';
			errorDiv.textContent = '房间名称已存在';
			nameField.appendChild(errorDiv);
			hasError = true;
		}
		
		if (hasError) {
			document.getElementById('addRoomName').focus();
			return;
		}
		
		try {
			// 映射选择器值到数据库格式
			let mappedPianoType = '';
			switch(pianoType) {
				case '三角':
					mappedPianoType = '三角钢琴';
					break;
				case '立式':
					mappedPianoType = '立式钢琴';
					break;
				case '其他':
				default:
					mappedPianoType = '其他';
					break;
			}
			
			const newRoom = {
				name: name,
				location: location || '',
				pianoType: mappedPianoType,
				remark: remark || '',
				occupant: null,
				registerTime: null,
				version: 1,
				heartbeatAt: null
			};
			
			// 添加到本地数据
			Store.rooms.push(newRoom);
			Store.byName.set(name, newRoom);
			
			// 更新楼层集合
			const floor = deriveFloor(location);
			if (floor) Store.floorSet.add(floor);
			
			// 同步到云端：写入静态表，并插入/更新动态表以触发他端实时订阅
			if (!Store.settings.offlineMode) {
				await supabaseClient.from('room_database').upsert({
					name: name,
					location: location || null,
					piano_type: mappedPianoType,
					remark: remark || null
				});
				// 触发 rooms 实时通道，让他端无需刷新即可看到新房间
				await supabaseClient.from('rooms').upsert({
					name: name,
					occupant_student_name: null,
					register_time: null,
					heartbeat_at: new Date().toISOString(),
					version: 1,
					updated_at: new Date().toISOString()
				});
			}
			
			// 重新渲染
			renderRooms();
			ensureFilters();
			
			toast(`✅ 已添加琴房：${name}`);
			logInfo(`新增琴房：${name}, 位置：${location}, 类型：${pianoType}`);
			
			closeAddRoomModal();
		} catch (error) {
			toast('添加失败', 'error');
			logErr('新增琴房失败:', error.message);
		}
	}

	/*************************************************
	 * 搜索
	 *************************************************/
	function initSearch(){ document.getElementById('globalSearch').addEventListener('input', ()=>{ runGlobalSearch(); }); }
	function runGlobalSearch(){ 
		const q=document.getElementById('globalSearch').value.trim().toLowerCase(); 
		const box=document.getElementById('inlineSearchResults'); 
		if(!q){ box.style.display='none'; box.innerHTML=''; return; }
		const students=Store.students.filter(s=> matchPinyin(s.name, q) || (s.major||'').toLowerCase().includes(q));
		const rooms=Store.rooms.filter(r=> r.name.toLowerCase().includes(q) || (r.location||'').toLowerCase().includes(q) || (r.pianoType||'').toLowerCase().includes(q));
		const highlight=(txt)=>{ if(!q) return escapeHtml(txt); const low=txt.toLowerCase(); const idx=low.indexOf(q); if(idx===-1) return escapeHtml(txt); return escapeHtml(txt.slice(0,idx))+`<span class="highlight">${escapeHtml(txt.slice(idx,idx+q.length))}</span>`+escapeHtml(txt.slice(idx+q.length)); };
		let html='';
		if(students.length){ 
			html+=`<div><div class="group-title">学生 (${students.length})</div>`+students.slice(0,30).map(s=>{
				const room = Store.rooms.find(r=>r.occupant_student_name===s.name);
				let occupyMeta='';
				if(room){
					const st=statusInfo(room);
					const icon = st.state==='preparing' ? '⏳' : (st.state==='overtime' ? '⚠️' : '🎹');
					occupyMeta = `<span class="occ-info ${st.state}"><span class="icon">${icon}</span><span>${room.name}</span></span>`;
				}
				return `<div class="result-item student" data-type="student" data-name="${s.name}"><span>${highlight(s.name)}</span><span class="meta">${s.major||''} ${s.grade||''} ${occupyMeta}</span></div>`; 
			}).join('')+`</div>`; 
		}
		if(rooms.length){ html+=`<div><div class="group-title">琴房 (${rooms.length})</div>`+rooms.slice(0,30).map(r=>{ const st=statusInfo(r); return `<div class="result-item room" data-type="room" data-room="${r.name}"><span>${highlight(r.name)}</span><span class="meta">${r.location||''} ${r.pianoType||''} ${st.chip}</span></div>`; }).join('')+`</div>`; }
		if(!html) html='<div class="empty">无匹配结果</div>';
		box.innerHTML=html; box.style.display='block';
		box.querySelectorAll('.result-item').forEach(el=>{
			el.onclick=()=>{ const type=el.dataset.type; if(type==='room'){ scrollToRoom(el.dataset.room); } else if(type==='student'){ focusStudent(el.dataset.name); } hideInlineSearch(); };
		});
	}
	function hideInlineSearch(){ const box=document.getElementById('inlineSearchResults'); if(box){ box.style.display='none'; } }
	// 点击页面空白或按 ESC 关闭内联搜索
	document.addEventListener('click', e=>{
		const box=document.getElementById('inlineSearchResults'); const input=document.getElementById('globalSearch');
		if(!box||box.style.display==='none') return; 
		if(!box.contains(e.target) && e.target!==input){ hideInlineSearch(); }
	});
	document.addEventListener('keydown', e=>{ if(e.key==='Escape') hideInlineSearch(); });

	/*************************************************
	 * 统计与心跳刷新
	 *************************************************/
	/*************************************************
	 * UI 状态更新
	 *************************************************/
	function updateSyncStatus(state, text) {
		const dot = document.getElementById('syncDot');
		const textEl = document.getElementById('syncText');
		const reconnectBtn = document.getElementById('btnReconnect');
		
		if (dot) {
			dot.className = `sync-dot ${state}`;
		}
		if (textEl) {
			textEl.textContent = text;
		}
		
		// 根据状态显示/隐藏重连按钮
		if (reconnectBtn) {
			reconnectBtn.style.display = (state === 'error' || state === 'offline') ? 'inline-block' : 'none';
		}
	}
	
	function updateCloudSyncInfo() {
		const localRoomCountEl = document.getElementById('localRoomCount');
		const localStudentCountEl = document.getElementById('localStudentCount');
		const lastSyncTimeEl = document.getElementById('lastSyncTime');
		
		if (localRoomCountEl) {
			localRoomCountEl.textContent = Store.rooms.length;
		}
		if (localStudentCountEl) {
			localStudentCountEl.textContent = Store.students.length;
		}
		if (lastSyncTimeEl && supabaseReady) {
			lastSyncTimeEl.textContent = new Date().toLocaleTimeString();
		}
	}
	
	function updateUsageStats(){ 
		const total=Store.rooms.length; 
		const occ=Store.rooms.filter(r=>r.occupant_student_name).length; 
		const rate= total? ((occ/total)*100).toFixed(1):'0.0'; 
		const statEl = document.getElementById('statUsage');
		if (statEl) {
			statEl.textContent=`使用率 ${rate}%`;
		}
		const metaEl = document.getElementById('metaCounts');
		if (metaEl) {
			metaEl.textContent = `共 ${total} 间 • 占用 ${occ}`;
		}
		
		// 同时更新云端同步信息
		updateCloudSyncInfo();
	}
	function startStatusTicker(){ 
		// 🚫 完全取消定时UI更新，改为事件驱动更新
		// 原来每秒更新所有房间卡片，现在只在状态实际变化时更新
		logInfo('UI状态更新已改为事件驱动模式，取消定时更新');
		
		// 清理旧的定时器（如果存在）
		if(Store.timer) {
			clearInterval(Store.timer);
			Store.timer = null;
		}
		
		// 提供手动更新所有状态的函数，供调试使用
		window.refreshAllRoomStatus = () => {
			const els=document.querySelectorAll('.room-card'); 
			els.forEach(el=>{ 
				const name=el.dataset.room; 
				const r=Store.byName.get(name); 
				if(!r) return; 
				const st=statusInfo(r); 
				const chip=el.querySelector('.chip'); 
				if(chip) { 
					chip.textContent=st.chip; 
					chip.className=`chip ${st.class}`; 
				} 
				el.dataset.status=st.state; 
			});
			logInfo('手动刷新了所有房间状态');
		};
	}
	/* ================= 练琴时段检测开关初始化 ================= */
	(function initPracticeSlotToggle(){
		try{
			const saved=localStorage.getItem('practiceSlotCheckEnabled');
			if(saved!==null){ Store.settings.practiceSlotCheckEnabled = saved==='1'; }
			const btn=document.getElementById('btnToggleSlotCheck');
			if(btn){
				function refreshLabel(){ btn.textContent='时段检测: '+(Store.settings.practiceSlotCheckEnabled?'开':'关'); }
				refreshLabel();
				btn.addEventListener('click',()=>{
					Store.settings.practiceSlotCheckEnabled=!Store.settings.practiceSlotCheckEnabled;
					localStorage.setItem('practiceSlotCheckEnabled', Store.settings.practiceSlotCheckEnabled?'1':'0');
					refreshLabel();
					toast('练琴时段检测已'+(Store.settings.practiceSlotCheckEnabled?'开启':'关闭'));
				});
			}
		}catch(e){ console.warn('初始化练琴时段检测开关失败', e); }
	})();

	/*************************************************
	 * 练习记录 (本地 / 服务器)
	 *************************************************/
	async function writePracticeLog(roomName, studentName, action, opts) {
		// 先缓存到本地
			const logEntry = createPracticeLogEntry(roomName, studentName, action, opts);
		Store.localPracticeLogs.push(logEntry);
		
		if (!supabaseReady) {
			logInfo(`本地记录: ${action} ${studentName} @ ${roomName}`);
			return;
		}
		
		try {
			let attempt = 0;
			let removed = [];
			let lastError = null;
			// 创建数据库数据副本，移除本地字段
			let currentData = { ...logEntry };
			delete currentData.synced; // 移除本地标记字段
			let summarized = false; // 是否已输出缺列汇总

			while (attempt < 5) { // 最多 5 次逐列剔除重试
				const { error } = await supabaseClient
					.from('practice_logs')
					.insert(currentData);

				if (!error) {
					// 标记为已同步
					logEntry.synced = true;
					const removedInfo = removed.length ? ` (已剔除列: ${removed.join(',')})` : '';
					logInfo(`✅ 练习记录已写入: ${action} ${studentName} @ ${roomName}${removedInfo}`);
					return;
				}

				lastError = error;
				// 仅处理缺列错误 (Postgres 42703 或 message 包含 Could not find the 'xxx' column)
				const msg = (error.message||'').toLowerCase();
				if (error.code === '42703' || msg.includes("could not find the '") ) {
					// 解析缺失列名
					let missing = '';
					const m = error.message.match(/'([^']+)' column/);
					if (m) missing = m[1];
					if (missing && currentData.hasOwnProperty(missing)) {
						delete currentData[missing];
						removed.push(missing);
						// 当缺失过多关键列时，直接降级为最小字段集合：action, student_name, timestamp
						if (!summarized && removed.length >= 2) {
							// 若基础 room_name 都缺了，说明表结构与你的预期差异很大，输出一次汇总然后降级
							if (!currentData.room_name && !removed.includes('room_name')) {
								// do nothing; room_name 原本不在 currentData 时不处理
							}
							logWarn(`practice_logs 多列缺失: ${removed.join(',')}。将降级仅写入基础: action, student_name, timestamp`);
							// 构造最小集
							// 使用原始条目的时间戳，避免未定义变量
							currentData = {
								action: action,
								student_name: studentName,
								timestamp: logEntry.timestamp
							};
							summarized = true;
						}
						else {
							logWarn(`practice_logs 缺少列 ${missing}，已剔除后重试 (第 ${attempt+1} 次)`);
						}
						attempt++;
						continue;
					}
				}
				// 其它错误或无法解析列名，结束循环
				break;
			}

			// 如果退出循环仍失败
			if (lastError) {
				const extra = removed.length?` (剔除列: ${removed.join(',')})`:'';
				logErr('写入练习记录失败:', lastError.message + extra);
				const msgLow = (lastError.message||'').toLowerCase();
				if (msgLow.includes('row-level security') || msgLow.includes('rls')) {
					toast('Supabase RLS 拒绝写入 practice_logs：请为当前角色配置插入策略或改用认证/服务端', 'error');
				}
			}
		} catch (err) {
			logErr('练习记录异常:', err.message);
		}
	}

	// 创建练习记录条目
	function createPracticeLogEntry(roomName, studentName, action, opts) {
		const room = Store.rooms.find(r => r.name === roomName);
		const student = Store.studentIndex.get(studentName);
		const now = new Date().toISOString();

		let logEntry = {
			room_name: roomName,
			student_name: studentName,
			action: action,
			timestamp: now,
			piano_type: room?.pianoType || '',
			location: room?.location || '',
			student_major: student?.major || '',
			student_grade: student?.grade || '',
			synced: false // 本地标记
		};

		if (action === 'assign') {
			logEntry.session_start = now;
		} else if (action === 'clear') {
			const startMs = opts?.startMs ?? room?.registerTime ?? null;
			if (startMs) {
				logEntry.session_start = new Date(startMs).toISOString();
				logEntry.session_end = now;
				const durationMs = Date.now() - startMs - 60000; // 减去准备时间
				logEntry.practice_duration = Math.max(0, Math.floor(durationMs / 1000));
			}
		}

		return logEntry;
	}
	
	function writePracticeLogLocal(r){ 
		if(!r||!r.occupant_student_name||!r.registerTime) return; 
		const prepEnd=r.registerTime+60000; 
		const now=Date.now(); 
		const used = Math.max(0, now - prepEnd); 
		logInfo(`本地LOG ${r.occupant_student_name} @${r.name} ${formatDuration(Math.floor(used/1000))}`); 
	}

	/*************************************************
	 * 工具 & UI 辅助
	 *************************************************/
	function formatHMS(sec){ const h=Math.floor(sec/3600); const m=Math.floor((sec%3600)/60); const s=sec%60; return (h>0?h+':':'')+String(m).padStart(2,'0')+':'+String(s).padStart(2,'0'); }
	function formatDuration(sec){ if(sec<60) return sec+'s'; const m=Math.floor(sec/60); const s=sec%60; if(m<60) return m+'m'+(s? s+'s':''); const h=Math.floor(m/60); const mm=m%60; return h+'h'+(mm?mm+'m':''); }
	function escapeHtml(s){ return String(s).replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
	function toast(msg, type){ const box=document.getElementById('toastContainer'); const el=document.createElement('div'); el.className='toast'; el.innerHTML=`<span>${escapeHtml(msg)}</span>`; box.appendChild(el); setTimeout(()=>{ el.style.opacity='0'; setTimeout(()=>el.remove(),320); }, 2800); }
	function logInfo(...a){ console.log('[INFO]',...a); appendRuntime('INFO', a.join(' ')); }
	function logWarn(...a){ console.warn('[WARN]',...a); appendRuntime('WARN', a.join(' ')); }
	function logErr(...a){ console.error('[ERR]',...a); appendRuntime('ERR', a.join(' ')); }
	function appendRuntime(level,msg){ const box=document.getElementById('runtimeInfo'); const line=document.createElement('div'); line.style.whiteSpace='pre-wrap'; line.innerHTML=`<span class="muted">${new Date().toLocaleTimeString()}</span> <span class="${level==='ERR'?'danger':level==='WARN'?'warn':'accent'}">${level}</span> <span>${escapeHtml(msg)}</span>`; box.prepend(line); const max=120; while(box.children.length>max) box.removeChild(box.lastChild); }
	function refreshStudentModalCache(){ /* 预留：可建立拼音索引 */ }

	/*************************************************
	 * 初始化流程
	 *************************************************/
	async function bootstrap(){
		try{ 
			await initSupabase(); 
		}catch(e){ 
			logWarn('Supabase 初始化失败 (离线模式)', e.message); 
			updateSyncStatus('error', '离线模式');
		}
		
		// 🔧 页面加载时先清理可能的缓存污染
		logInfo('[Bootstrap] 清理缓存以防止数据污染');
		try {
			// 清理可能导致房间状态恢复的缓存
			const cacheKeys = [
				'yms_timer_states',
				'yms_room_cache', 
				'yms_temp_states',
				'yms_operation_cache',
				'yms_room_timers'
			];
			
			let clearedCount = 0;
			cacheKeys.forEach(key => {
				if (localStorage.getItem(key)) {
					localStorage.removeItem(key);
					clearedCount++;
				}
			});
			
			if (clearedCount > 0) {
				logInfo(`[Bootstrap] 清理了 ${clearedCount} 个可能污染的缓存项`);
			}
		} catch (error) {
			logWarn('[Bootstrap] 缓存清理失败:', error.message);
		}
		
		// 🔧 页面加载时进行数据一致性验证
		if (window.supabaseReady && DataConsistencyValidator) {
			logInfo('[Bootstrap] 开始页面加载数据一致性验证');
			try {
				const validation = await DataConsistencyValidator.validateOnPageLoad();
				if (validation.issues > 0) {
					logWarn(`[Bootstrap] 数据一致性验证发现 ${validation.issues} 个问题，已自动修复`);
					toast(`检测并修复了 ${validation.issues} 个数据一致性问题`, 'warn');
				} else {
					logInfo('[Bootstrap] 数据一致性验证通过');
				}
			} catch (error) {
				logErr('[Bootstrap] 数据一致性验证失败:', error.message);
			}
		}
		
		const [rooms, roomMeta, students] = await Promise.all([
			fetchRooms(), 
			fetchRoomMeta(), 
			fetchStudents()
		]);
		
		Store.rooms = rooms; 
		Store.roomMeta = roomMeta; 
		Store.students = students; 

		// 关键修复：确保云端 room_database 的静态房间能并入 rooms 列表
		// 之前 fetchRoomMeta 内部合并会被 Promise.all 结束后的赋值覆盖，
		// 这里在完成赋值后再次做一次 metaOnly 合并，保证“新增但尚无状态”的房间也能显示/同步到他端。
		if (Store.roomMeta && Object.keys(Store.roomMeta).length > 0) {
			const metaList = Object.values(Store.roomMeta).map(r => ({
				name: r.name,
				pianoType: r.piano_type || '',
				location: r.location || '',
				remark: r.remark || ''
			}));
			await mergeRooms(metaList, { skipCloudSync: true, metaOnly: true });
		}
		
		rebuildIndexes(); 
		rebuildStudentIndex(); 
		// 🕐 恢复计时器状态（在渲染之前）
		await restoreRoomTimerStates();
		
		// 📋 规范化初始数据格式，避免运行期间的格式警告
		normalizeInitialData();
		
		renderRooms(); 
		updateUsageStats(); 
		bindRoomEvents(); 
		bindStudentModal(); 
		bindAddRoomModal();
		initSearch(); 
		startStatusTicker(); 
		
		// 只在Supabase就绪时设置实时同步
		if (supabaseReady) {
			// 🕐 初始化服务器时间同步
			await serverTimeSync.init();
			
			await setupRealtime();
			// 启动定期状态检查
			startPeriodicStateCheck();
			// 启动操作超时检测
			setupOperationTimeoutDetection();
			// 启动realtime连接监控
			realtimeMonitor.start();
			
			// 🕐 启动定期计时器状态同步（每5分钟）
			timerManager.setInterval('timerStateSync', () => {
				timerPersistence.syncStatesToCloud();
			}, 5 * 60 * 1000);
		}
		
		logInfo('初始化完成: rooms='+rooms.length+' students='+students.length);
		// 兜底：如果已登录但按钮被其它逻辑覆盖隐藏，再次显示（函数可能被移除，做安全判定）
		if(typeof showBulkTimeButton === 'function'){
			try{ showBulkTimeButton(); }catch(e){ console.warn('showBulkTimeButton 调用失败', e); }
		}

		// AB方案-A: bootstrap 完成后尝试一次学生库种子填充（仅当学生库存在且当前为空）
		if(window.seedStudentLibraryFromRoomStore){ try{ window.seedStudentLibraryFromRoomStore({ reason:'bootstrap-end' }); }catch(e){ console.warn('[SeedStudentLibrary] bootstrap 调用失败', e); } }
	}

	// 全局暴露（便于调试）
	// 🔧 数据一致性调试工具
	window.checkDataConsistency = async function() {
		console.log('=== 房间数据一致性检查 ===');
		
		try {
			// 使用新的数据验证器
			if (DataConsistencyValidator) {
				const validation = await DataConsistencyValidator.validateOnPageLoad();
				console.log('验证结果:', validation);
				
				if (validation.issues > 0) {
					console.warn(`发现 ${validation.issues} 个数据一致性问题，已自动修复`);
					toast(`检查并修复了 ${validation.issues} 个数据一致性问题`, 'success');
				} else {
					console.log('✅ 数据一致性检查通过');
					toast('数据一致性检查通过', 'success');
				}
				
				return validation;
			}
			
			// 兜底：使用原有逻辑
			const dbRooms = await fetchRooms();
			const localRooms = Store.rooms;
			
			console.log(`本地房间数据: ${localRooms.length} 个`);
			console.log(`数据库房间数据: ${dbRooms.length} 个`);
			
			// 检查占用状态
			const localOccupied = localRooms.filter(r => r.occupant_student_name && r.occupant_student_name.trim() !== '');
			const dbOccupied = dbRooms.filter(r => r.occupant_student_name && r.occupant_student_name.trim() !== '');
			
			console.log(`本地显示占用: ${localOccupied.length} 个`);
			console.log(`数据库实际占用: ${dbOccupied.length} 个`);
			
			// 找出不一致的房间
			const inconsistent = [];
			localRooms.forEach(localRoom => {
				const dbRoom = dbRooms.find(r => r.name === localRoom.name);
				if (dbRoom) {
					const localStudent = localRoom.occupant_student_name || '';
					const dbStudent = dbRoom.occupant_student_name || '';
					if (localStudent !== dbStudent) {
						inconsistent.push({
							roomName: localRoom.name,
							local: localStudent,
							database: dbStudent
						});
					}
				}
			});
			
			if (inconsistent.length > 0) {
				console.warn('发现数据不一致的房间:');
				inconsistent.forEach(item => {
					console.warn(`  ${item.roomName}: 本地="${item.local}" vs 数据库="${item.database}"`);
				});
				
				const fix = confirm(`发现 ${inconsistent.length} 个房间数据不一致，是否立即修复？`);
				if (fix) {
					Store.rooms = dbRooms;
					renderRooms();
					updateUsageStats();
					console.log('✅ 已修复数据不一致问题');
					toast('数据一致性已修复', 'success');
				}
			} else {
				console.log('✅ 数据一致性检查通过');
				toast('数据状态一致', 'success');
			}
			
			return {
				consistent: inconsistent.length === 0,
				localOccupied: localOccupied.length,
				dbOccupied: dbOccupied.length,
				inconsistentRooms: inconsistent
			};
			
		} catch (error) {
			console.error('数据一致性检查失败:', error);
			toast('检查失败: ' + error.message, 'error');
			return null;
		}
	};

	window.RoomStore=Store; window.assignRoom=assignRoom; window.forceAssignRoom=forceAssignRoom; window.transferStudent=transferStudent; window.clearRoom=clearRoom; window.clearAllRooms=clearAllRooms; window.showClearAllConfirm=showClearAllConfirm; window.renewRoom=renewRoom; window.toggleEditMode=toggleEditMode; window.manualSyncToCloud=manualSyncToCloud; window.DataConsistencyValidator=DataConsistencyValidator; 
	
	// 暴露调试函数
	window.debugRoomStatus = (roomName) => realtimeMonitor.debugRoomStatus(roomName); 
	
	// 快速测试数据库连接的调试函数
	window.testDbConnection = async function() {
		if (!supabaseReady) {
			console.log('❌ Supabase 未就绪');
			return;
		}
		try {
			console.log('🔄 测试房间数据查询...');
			const { data, error } = await supabaseClient.from('rooms').select('name,occupant_student_name,version').limit(3);
			if (error) {
				console.error('❌ 查询失败:', error);
				return false;
			}
			console.log('✅ 查询成功:', data);
			return true;
		} catch (err) {
			console.error('❌ 连接异常:', err);
			return false;
		}
	};

	// 直接调用 bootstrap 改为受登录控制
	// bootstrap();
	// 登录门控逻辑（纯前端固定密码）改为：APP_PASS_HASH = SHA256(明文密码) 无盐
	const PLAIN_PASS = 'ymsq2022';
	let APP_PASS_HASH = '';
	let appBooted = false;
	function sha256Hex(str){
		return crypto.subtle.digest('SHA-256', new TextEncoder().encode(str)).then(buf=>{
			return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
		});
	}
	function showLogin(){ document.getElementById('authOverlay').style.display='flex'; }
	function hideLogin(){ document.getElementById('authOverlay').style.display='none'; }
	// 已移除登出按钮逻辑
	async function tryAuto(){
		if(localStorage.getItem('yms_auth')==='1'){
			hideLogin(); if(!appBooted){ appBooted=true; bootstrap(); }
		}else{
			showLogin();
		}
	}
	async function handleLogin(e){
		e.preventDefault();
		const pwd=document.getElementById('loginPassword').value.trim();
		const btn=document.getElementById('loginBtn');
		const msg=document.getElementById('loginMsg');
		btn.disabled=true; msg.textContent='验证中...';
		try{
			const ok = await verifyPassword(pwd);
			if(ok){
				localStorage.setItem('yms_auth','1');
				hideLogin(); if(!appBooted){ appBooted=true; bootstrap(); }
				msg.textContent='';
			}else{
				msg.textContent='密码错误';
			}
		}finally{
			btn.disabled=false;
		}
	}
	// logout 入口移除，仍保留函数以防外部引用
	function logout(){ localStorage.removeItem('yms_auth'); appBooted=false; showLogin(); }
	async function verifyPassword(pwd){
		if(!pwd) return false;
		// 若 hash 还未准备，等待
		let waitCount=0; while(!APP_PASS_HASH && waitCount<100){ await new Promise(r=>setTimeout(r,30)); waitCount++; }
		const h = await sha256Hex(pwd);
		return h===APP_PASS_HASH;
	}
	// 预计算无盐哈希
	sha256Hex(PLAIN_PASS).then(h=>{ APP_PASS_HASH=h; console.log('APP_PASS_HASH(unsalted)=',h); });
	// 延迟到下一个事件循环，确保 DOM 已有遮罩
	setTimeout(tryAuto,0);
	document.addEventListener('DOMContentLoaded', ()=>{
		try{ restoreSilenced(); }catch(_e){}
		const f=document.getElementById('loginForm');
		if(f && !f.dataset.bound){ f.dataset.bound='1'; f.addEventListener('submit', handleLogin); }
	});

	</script>

	<!-- 登录遮罩 -->
	<div id="authOverlay" style="display:none;position:fixed;inset:0;z-index:9999;font-family:inherit;background:radial-gradient(circle at 30% 35%,#1d2530 0%,#0a0f14 70%);backdrop-filter:blur(14px);">
		<div class="login-shell">
			<div class="login-panel">
				<div class="brand-line">
					<div class="logo-mark">🎹</div>
					<div class="brand-text">
						<h1>琴房管理系统</h1>
						<span class="sub">Yehudi Menuhin School</span>
					</div>
				</div>
				<form id="loginForm" autocomplete="off" onsubmit="handleLogin(event)">
					<label class="field">
						<span class="label">密码</span>
						<input id="loginPassword" type="password" inputmode="text" autocomplete="new-password" placeholder="输入访问密码" required />
					</label>
					<button id="loginBtn" type="submit" class="login-btn">进入系统</button>
					<div id="loginMsg" class="login-msg" aria-live="polite"></div>
					<div class="hint">内部专用平台 • 未授权请勿传播</div>
				</form>
			</div>
			<div class="login-footer">© <span id="yearNow"></span> YMS Practice Rooms</div>
		</div>
	</div>

	<style>
	/* 登录界面专业简约风格 */
	#authOverlay{color:#d8e1e9;}
	#authOverlay .login-shell{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:40px 24px;}
	#authOverlay .login-panel{width:360px;max-width:92vw;padding:42px 40px 38px;background:linear-gradient(145deg,rgba(34,44,56,0.85),rgba(20,26,34,0.9));border:1px solid rgba(255,255,255,0.06);border-radius:22px;box-shadow:0 8px 42px -12px rgba(0,0,0,0.55),0 18px 80px -30px rgba(0,0,0,0.6);backdrop-filter:blur(10px);}
	#authOverlay .brand-line{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;margin-bottom:28px;text-align:center;}
	#authOverlay .logo-mark{width:54px;height:54px;border-radius:16px;background:linear-gradient(135deg,#2d72c4,#38518a 60%,#1c2d44);display:flex;align-items:center;justify-content:center;font-size:26px;box-shadow:0 4px 18px -6px rgba(45,114,196,.55),0 2px 6px -2px rgba(0,0,0,.55);margin:0 auto;}
	#authOverlay .brand-text{text-align:center;}
	#authOverlay .brand-text h1{margin:0;font-size:22px;font-weight:600;letter-spacing:.5px;background:linear-gradient(90deg,#c5d9f2,#ffffff);background-clip:text;-webkit-background-clip:text;color:transparent;}
	#authOverlay .brand-text .sub{font-size:11px;letter-spacing:1px;text-transform:uppercase;color:#7f8c98;display:inline-block;margin-top:4px;}
	#authOverlay form{display:flex;flex-direction:column;gap:20px;}
	#authOverlay .field{display:flex;flex-direction:column;gap:8px;}
	#authOverlay .field .label{font-size:13px;letter-spacing:.5px;color:#9fb1c0;font-weight:500;}
	#authOverlay .field, #authOverlay .field .label, #authOverlay .login-msg{ text-align:center; }
	#authOverlay input{background:#12181f;border:1px solid #2a3945;border-radius:14px;padding:14px 16px;font-size:15px;color:#e6edf3;outline:none;transition:.25s;font-family:inherit;}
	#authOverlay input:focus{border-color:#3d7bdc;box-shadow:0 0 0 1px #3d7bdc40,0 4px 18px -6px rgba(61,123,220,.35);}
	#authOverlay input::placeholder{color:#5b6a75;}
	#authOverlay .login-btn{background:linear-gradient(90deg,#2d72c4,#3f85e1);border:1px solid #3778d6;border-radius:14px;padding:14px 0;font-size:15px;font-weight:600;color:#fff;cursor:pointer;transition:.28s;box-shadow:0 6px 20px -8px rgba(47,118,195,.55);display:flex;align-items:center;justify-content:center;letter-spacing:.5px;}
	#authOverlay .login-btn:hover{filter:brightness(1.07);transform:translateY(-2px);box-shadow:0 10px 26px -10px rgba(47,118,195,.65);}
	#authOverlay .login-btn:active{transform:translateY(0);}
	#authOverlay .login-btn:disabled{opacity:.55;cursor:not-allowed;}
	#authOverlay .login-msg{min-height:18px;font-size:13px;color:#ff7a7a;font-weight:500;}
	#authOverlay .hint{margin-top:-6px;font-size:11px;letter-spacing:.5px;color:#667582;text-align:center;}
	#authOverlay .login-footer{margin-top:40px;font-size:11px;letter-spacing:1px;text-transform:uppercase;color:#46515a;}
	@media (max-width:520px){#authOverlay .login-panel{padding:34px 30px 30px;width:330px;border-radius:20px;}#authOverlay .logo-mark{width:50px;height:50px;font-size:24px;}#authOverlay .brand-text h1{font-size:20px;}}
	</style>

	<script>
	// 登录界面年份自动
	document.addEventListener('DOMContentLoaded',()=>{ const y=document.getElementById('yearNow'); if(y) y.textContent=new Date().getFullYear(); });
	// 绑定登录 + 回车
	document.addEventListener('DOMContentLoaded',()=>{
		const f=document.getElementById('loginForm');
		if(!f) return;
		f.addEventListener('submit', handleLogin);
		document.getElementById('loginPassword').addEventListener('keydown',e=>{ if(e.key==='Enter'){ f.requestSubmit(); }});
	});
	</script>

<!-- unified final contrast & empty-room enhancement (moved inside body) -->
<style id="room-card-contrast-final">
/* 提升整体文本与空闲房卡可见度；集中唯一覆盖，避免多层冲突 */
body{--text:#e2ebf3; --text-dim:#a5b6c6;}
.room-card{color:#eef5fa !important;}
.room-card .room-name{color:#ffffff !important; text-shadow:0 1px 3px rgba(0,0,0,.55) !important; font-weight:700 !important;}
.room-card .occupant-line span:last-child{color:#fff !important; font-weight:600 !important;}

/* 使用中房间：按类型着色并增加更深层次光影 */
.room-card[data-status="occupied"]{position:relative;transition:transform .28s ease, box-shadow .35s ease, border-color .35s ease;}
/* grand (蓝) */
.room-card[data-status="occupied"][data-type="grand"]{
	background:linear-gradient(145deg,#1b2937 0%,#152534 42%,#0e1823 100%) !important;
	border:1px solid #4a90e2 !important;
	box-shadow:
		0 0 0 1px rgba(74,144,226,0.35),
		0 4px 14px -3px rgba(0,0,0,0.65),
		0 8px 32px -6px rgba(30,80,130,0.45),
		0 14px 54px -10px rgba(30,80,130,0.38),
		inset 0 1px 0 rgba(255,255,255,0.05),
		inset 0 0 0 1px rgba(74,144,226,0.18) !important;
}
.room-card[data-status="occupied"][data-type="grand"]:hover{
	border-color:#5fa3ff !important;
	box-shadow:
		0 0 0 1px rgba(95,163,255,0.5),
		0 6px 20px -4px rgba(0,0,0,0.7),
		0 10px 40px -8px rgba(60,120,190,0.55),
		0 18px 70px -12px rgba(60,120,190,0.45),
		inset 0 1px 0 rgba(255,255,255,0.07),
		inset 0 0 0 1px rgba(95,163,255,0.25) !important;
	transform:translateY(-5px) !important;
}
.room-card[data-status="occupied"][data-type="grand"] .chip{background:rgba(74,144,226,0.18) !important; color:#87bfff !important; border:1px solid rgba(74,144,226,0.45) !important; font-weight:600 !important;}
/* upright (绿) */
.room-card[data-status="occupied"][data-type="upright"]{
	background:linear-gradient(145deg,#163b2d 0%,#123126 42%,#0c2219 100%) !important;
	border:1px solid #2aa876 !important;
	box-shadow:
		0 0 0 1px rgba(42,168,118,0.35),
		0 4px 14px -3px rgba(0,0,0,0.65),
		0 8px 30px -6px rgba(24,110,80,0.45),
		0 14px 52px -10px rgba(24,110,80,0.38),
		inset 0 1px 0 rgba(255,255,255,0.05),
		inset 0 0 0 1px rgba(42,168,118,0.18) !important;
}
.room-card[data-status="occupied"][data-type="upright"]:hover{
	border-color:#37c28e !important;
	box-shadow:
		0 0 0 1px rgba(55,194,142,0.5),
		0 6px 20px -4px rgba(0,0,0,0.7),
		0 10px 40px -8px rgba(40,150,110,0.55),
		0 18px 70px -12px rgba(40,150,110,0.45),
		inset 0 1px 0 rgba(255,255,255,0.07),
		inset 0 0 0 1px rgba(55,194,142,0.25) !important;
	transform:translateY(-5px) !important;
}
.room-card[data-status="occupied"][data-type="upright"] .chip{background:rgba(42,168,118,0.20) !important; color:#49d69b !important; border:1px solid rgba(42,168,118,0.45) !important; font-weight:600 !important;}
/* other (紫) */
.room-card[data-status="occupied"][data-type="other"]{
	background:linear-gradient(145deg,#3a244d 0%,#301d43 42%,#211430 100%) !important;
	border:1px solid #8a63d8 !important;
	box-shadow:
		0 0 0 1px rgba(138,99,216,0.36),
		0 4px 14px -3px rgba(0,0,0,0.65),
		0 8px 32px -6px rgba(90,50,160,0.48),
		0 14px 56px -10px rgba(90,50,160,0.40),
		inset 0 1px 0 rgba(255,255,255,0.05),
		inset 0 0 0 1px rgba(138,99,216,0.20) !important;
}
.room-card[data-status="occupied"][data-type="other"]:hover{
	border-color:#a37dff !important;
	box-shadow:
		0 0 0 1px rgba(163,125,255,0.55),
		0 6px 20px -4px rgba(0,0,0,0.7),
		0 10px 42px -8px rgba(125,80,220,0.55),
		0 18px 70px -12px rgba(125,80,220,0.45),
		inset 0 1px 0 rgba(255,255,255,0.07),
		inset 0 0 0 1px rgba(163,125,255,0.28) !important;
	transform:translateY(-5px) !important;
}
.room-card[data-status="occupied"][data-type="other"] .chip{background:rgba(138,99,216,0.20) !important; color:#c3a4ff !important; border:1px solid rgba(138,99,216,0.48) !important; font-weight:600 !important;}

/* 超时房间：红色警告边框与发光 */
.room-card[data-status="overtime"]{
	background:linear-gradient(135deg,#4a2728 0%,#3d1f20 40%,#2a1415 100%) !important;
	border:1px solid #ff4757 !important;
	box-shadow:
		0 0 0 1px rgba(255,71,87,0.4),
		0 2px 12px rgba(255,71,87,0.15),
		0 6px 25px rgba(255,71,87,0.08),
		inset 0 1px 0 rgba(255,255,255,0.05) !important;
}
.room-card[data-status="overtime"]:hover{
	border-color:#ff6b7a !important;
	box-shadow:
		0 0 0 1px rgba(255,107,122,0.5),
		0 3px 16px rgba(255,71,87,0.25),
		0 8px 35px rgba(255,71,87,0.12),
		inset 0 1px 0 rgba(255,255,255,0.08) !important;
	transform:translateY(-4px) !important;
}
.room-card[data-status="overtime"] .chip{
	background:rgba(255,71,87,0.15) !important;
	color:#ff7373 !important;
	border:1px solid rgba(255,71,87,0.3) !important;
	font-weight:600 !important;
}

/* 空闲房：去除亮边缘/发光，保持类型区分，整体更暗更平 */
.room-card[data-status="empty"], .room-card.empty{
	/* 更透明、降低饱和度：统一极浅底，带轻微色调 */
	background:linear-gradient(135deg, rgba(255,255,255,0.015) 0%, rgba(255,255,255,0.03) 60%, rgba(255,255,255,0.02) 100%) !important;
	border:1px solid rgba(160,170,190,0.15) !important;
	box-shadow:none !important;
}
/* 按类型提供极轻的色彩倾向（alpha 很低） */
.room-card[data-status="empty"][data-type="grand"], .room-card.empty[data-type="grand"]{
	background:linear-gradient(135deg, rgba(60,110,170,0.10) 0%, rgba(40,70,110,0.08) 55%, rgba(25,45,70,0.10) 100%) !important;
	border-color:rgba(90,140,200,0.28) !important;
}
.room-card[data-status="empty"][data-type="upright"], .room-card.empty[data-type="upright"]{
	background:linear-gradient(135deg, rgba(40,140,100,0.10) 0%, rgba(30,90,70,0.08) 55%, rgba(20,60,45,0.10) 100%) !important;
	border-color:rgba(60,170,125,0.28) !important;
}
.room-card[data-status="empty"][data-type="other"], .room-card.empty[data-type="other"]{
	background:linear-gradient(135deg, rgba(120,70,180,0.11) 0%, rgba(90,50,140,0.08) 55%, rgba(65,40,110,0.10) 100%) !important;
	border-color:rgba(130,90,190,0.30) !important;
}
.room-card[data-status="empty"]:hover{transform:translateY(-2px) !important;}
.room-card[data-status="empty"] .chip{background:rgba(255,255,255,0.05) !important; border:1px solid rgba(255,255,255,0.12) !important; color:#d0d9e2 !important;}

/* 状态色微调 */
.chip{color:#cfd8e2 !important;}
.chip.accent{color:#7fbaff !important;}
.chip.danger{color:#ff7373 !important;}
.chip.good{color:#5edc7a !important;}
.chip.warn{color:#ffbc55 !important;}
</style>

<!-- 批量时间段管理样式 -->
<style>
#bulkTimeManagerModal .btm-wrapper{width:90%;height:90%;margin:auto;background:#fff;border-radius:16px;display:flex;flex-direction:column;box-shadow:0 6px 30px rgba(0,0,0,.25);overflow:hidden;font-size:14px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;color:#1a1a1a;}
#bulkTimeManagerModal .btm-header{flex:0 0 auto;padding:14px 20px;background:linear-gradient(135deg,#007AFF,#5856D6);color:#fff;display:flex;justify-content:space-between;align-items:center;}
#bulkTimeManagerModal .btm-title{font-size:18px;font-weight:700;letter-spacing:.5px;color:#fff;}
#bulkTimeManagerModal .btm-actions{display:flex;gap:10px;flex-wrap:wrap;}
#bulkTimeManagerModal .btm-btn{padding:8px 14px;border:none;border-radius:6px;cursor:pointer;font-weight:600;font-size:13px;letter-spacing:.5px;transition:.25s;color:#fff;}
#bulkTimeManagerModal .btm-primary{background:#007AFF;}
#bulkTimeManagerModal .btm-secondary{background:#4e5d78;}
#bulkTimeManagerModal .btm-danger{background:#e74c3c;}
#bulkTimeManagerModal .btm-btn:hover{opacity:.9;transform:translateY(-2px);}
#bulkTimeManagerModal .btm-body{flex:1;display:flex;overflow:hidden;background:#f2f5f9;color:#1a1a1a;}
#bulkTimeManagerModal .btm-left{flex:1;display:flex;flex-direction:column;padding:16px;overflow:hidden;}
#bulkTimeManagerModal .btm-right{width:320px;border-left:1px solid #eee;padding:16px;display:flex;flex-direction:column;gap:12px;background:#f8f9fb;}
#bulkTimeManagerModal .btm-stu-info{font-size:13px;color:#2c3e50;margin-bottom:10px;line-height:1.5;min-height:32px;font-weight:500;}
#bulkTimeManagerModal .btm-legend{display:flex;gap:18px;flex-wrap:wrap;font-size:12px;color:#1a1a1a;padding:8px 10px;background:#f2f5f9;border:1px solid #e0e4ea;border-radius:8px;margin-bottom:10px;font-weight:500;}
#bulkTimeManagerModal .btm-table-wrap{flex:1;overflow:auto;border:1px solid #e0e4ea;border-radius:10px;background:#fff;box-shadow:0 2px 6px rgba(0,0,0,.05) inset;}
#bulkTimeManagerModal .btm-table{width:100%;border-collapse:separate;border-spacing:0;min-width:900px;font-size:12px;user-select:none;}
#bulkTimeManagerModal .btm-table thead th{background:#f0f3f7;position:sticky;top:0;z-index:2;padding:10px 8px;font-weight:700;border-bottom:1px solid #d6dae2;color:#1a1a1a;}
#bulkTimeManagerModal .btm-time-col{width:120px;}
#bulkTimeManagerModal .btm-table tbody td{text-align:center;padding:8px 6px;border-bottom:1px solid #eef1f5;border-right:1px solid #eef1f5;position:relative;line-height:1.3;transition:all .25s ease;cursor:pointer;font-weight:500;color:#1a1a1a;}
#bulkTimeManagerModal .btm-table tbody td:last-child{border-right:none;}
#bulkTimeManagerModal .btm-table tbody tr:last-child td{border-bottom:none;}
#bulkTimeManagerModal .btm-cell:not(.btm-cell-selected):not(.btm-cell-rest){background:#fff;color:#1a1a1a;border-color:#eef1f5;}
#bulkTimeManagerModal .btm-cell:hover:not(.btm-cell-rest):not(.btm-cell-selected){background:#e6f1ff;border-color:#b1d3ff;transform:translateY(-1px);box-shadow:0 2px 8px rgba(0,122,255,.15);z-index:1;color:#1a1a1a;}
#bulkTimeManagerModal .btm-cell-selected{background:linear-gradient(135deg,#007AFF,#5856D6);color:#fff;font-weight:700;border-color:#3366cc;box-shadow:0 2px 6px rgba(0,0,0,.15) inset;}
#bulkTimeManagerModal .btm-cell-rest{background:linear-gradient(135deg,#6C757D,#495057);color:#fff;cursor:not-allowed;font-weight:600;border-color:#495057;}
#bulkTimeManagerModal .btm-cell-selected:hover{opacity:.9;transform:translateY(-1px);box-shadow:0 3px 10px rgba(0,122,255,0.25);}
#bulkTimeManagerModal .btm-cell-rest:hover{transform:none;box-shadow:none;opacity:.8;}
#bulkTimeManagerModal .btm-wed-subwrap{display:flex;flex-direction:column;gap:2px;}
#bulkTimeManagerModal .btm-wed-sub{flex:1;padding:4px 2px;border:1px solid #eef1f5;border-radius:4px;transition:all .25s ease;cursor:pointer;font-weight:500;background:#fff;color:#1a1a1a;text-align:center;display:flex;align-items:center;justify-content:center;min-height:20px;}
#bulkTimeManagerModal .btm-wed-sub:hover:not(.rest):not(.selected){background:#e6f1ff;border-color:#b1d3ff;transform:translateY(-1px);box-shadow:0 2px 8px rgba(0,122,255,.15);color:#1a1a1a;}
#bulkTimeManagerModal .btm-wed-sub.selected{background:linear-gradient(135deg,#007AFF,#5856D6);color:#fff;font-weight:700;border-color:#3366cc;box-shadow:0 2px 6px rgba(0,0,0,.15) inset;}
#bulkTimeManagerModal .btm-wed-sub.rest{background:linear-gradient(135deg,#6C757D,#495057);color:#fff;cursor:not-allowed;font-weight:600;border-color:#495057;}
#bulkTimeManagerModal .btm-selected-list{flex:1;overflow:auto;background:#fff;border:1px solid #e0e4ea;border-radius:10px;padding:10px;font-size:12px;line-height:1.5;display:flex;flex-direction:column;gap:6px;color:#1a1a1a;}
#bulkTimeManagerModal .btm-chip{display:inline-block;background:#007aff22;border:1px solid #007aff88;color:#007AFF;padding:3px 8px;border-radius:14px;font-size:11px;margin:2px;font-weight:600;cursor:default;}
#bulkTimeManagerModal .btm-chip.wed{background:#5856d622;border-color:#5856d6aa;color:#4b49c8;}
#bulkTimeManagerModal .btm-note{font-size:11px;line-height:1.6;background:#fff9e6;border:1px solid #ffe3a3;padding:10px 12px;border-radius:8px;color:#8a6113;}
#bulkTimeManagerModal .btm-summary-title{font-size:14px;font-weight:600;color:#1a1a1a;margin-bottom:8px;}
#bulkTimeManagerModal .btm-select{background:#fff;border:1px solid #d1d5db;color:#1a1a1a;padding:8px 12px;border-radius:6px;font-size:13px;}
#bulkTimeManagerModal .btm-select:focus{outline:none;border-color:#007AFF;box-shadow:0 0 0 2px rgba(0,122,255,0.2);}
@media (max-width:1200px){#bulkTimeManagerModal .btm-right{width:280px;}}
@media (max-width:960px){#bulkTimeManagerModal .btm-wrapper{width:96%;height:94%;}#bulkTimeManagerModal .btm-right{display:none;}#bulkTimeManagerModal .btm-left{padding:10px;}}
</style>
<style>
.alert-filter-btn{border:1px solid #d0d7e2;background:#f5f8fc;color:#2e3b48;font-size:12px;padding:5px 12px;border-radius:18px;cursor:pointer;letter-spacing:.5px;font-weight:600;transition:.18s;line-height:1;}
.alert-filter-btn:hover{background:#e1eaf3;color:#1d2730;border-color:#c2ccd8;}
.alert-filter-btn:active{transform:translateY(1px);}
.alert-filter-btn.act{background:#007aff;color:#fff;border-color:#007aff;box-shadow:0 0 0 1px #007aff55 inset;}
.alert-filter-btn.act:hover{background:#0062d1;color:#fff;border-color:#0057bb;}
.alert-filter-btn:focus-visible{outline:2px solid #4d90fe;outline-offset:1px;}

/* 优化提醒样式 */
.alert-item {
	border-radius: 8px;
	padding: 8px 12px;
	margin-bottom: 4px;
	position: relative;
	transition: all 0.2s ease;
	border-left: 4px solid transparent;
	background: #fff;
	box-shadow: 0 1px 3px rgba(0,0,0,0.05);
	display: flex;
	align-items: center;
	justify-content: space-between;
	min-height: 36px;
}

/* 缺勤提醒 - 橙红色 */
.alert-item.absent {
	background: #fff8f8;
	border-left-color: #f56565;
}

.alert-item.absent[data-severity="2"] {
	border-left-color: #e53e3e;
	background: #fef1f1;
}

/* 异常提醒 - 黄橙色 */
.alert-item.anomaly {
	background: #fffcf8;
	border-left-color: #ed8936;
}

.alert-item.anomaly[data-severity="1"] {
	border-left-color: #dd6b20;
	background: #fff9f3;
}

/* 悬停效果 */
.alert-item:hover {
	box-shadow: 0 2px 6px rgba(0,0,0,0.1);
	background-color: #f8f9fa;
}

.alert-item.absent:hover {
	background: #fff6f6;
}

.alert-item.anomaly:hover {
	background: #fffdf8;
}

/* 内容布局 */
.alert-content {
	display: flex;
	align-items: center;
	gap: 12px;
	flex: 1;
}

.alert-student {
	font-weight: 600;
	font-size: 14px;
	color: #2d3748;
	min-width: 60px;
}

.alert-info {
	display: flex;
	align-items: center;
	gap: 8px;
	font-size: 12px;
	color: #718096;
}

.alert-time {
	font-size: 11px;
	color: #a0aec0;
}

/* 标签样式 */
.alert-tag {
	padding: 2px 6px;
	border-radius: 8px;
	font-size: 11px;
	font-weight: 500;
	letter-spacing: 0.3px;
}

.alert-tag.type-absent {
	background: #fed7d7;
	color: #c53030;
}

.alert-tag.type-anomaly {
	background: #feebc8;
	color: #c05621;
}

.alert-tag.slot-time {
	background: #e6fffa;
	color: #285e61;
	font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
}

/* 操作按钮 */
.alert-actions {
	display: flex;
	gap: 4px;
}

.alert-btn {
	padding: 4px 8px;
	border: none;
	border-radius: 4px;
	font-size: 11px;
	font-weight: 500;
	cursor: pointer;
	transition: all 0.15s ease;
}

.alert-btn.ignore {
	background: #edf2f7;
	color: #4a5568;
	border: 1px solid #cbd5e0;
}

.alert-btn.ignore:hover {
	background: #e2e8f0;
	color: #2d3748;
}

/* 已忽略状态 */
.alert-item.ignored {
	opacity: 0.7;
	filter: grayscale(0.2);
}

.alert-ignored-flag {
	font-size: 10px;
	color: #a0aec0;
	margin-left: 8px;
}

/* 一键忽略按钮 */
.alert-ignore-all-btn {
	padding: 4px 8px;
	border: 1px solid #cbd5e0;
	border-radius: 4px;
	background: #f7fafc;
	color: #4a5568;
	font-size: 11px;
	font-weight: 500;
	cursor: pointer;
	transition: all 0.15s ease;
}

.alert-ignore-all-btn:hover {
	background: #edf2f7;
	border-color: #a0aec0;
	color: #2d3748;
}

.alert-ignore-all-btn:active {
	background: #e2e8f0;
	transform: translateY(1px);
}

.alert-ignore-all-btn:disabled {
	opacity: 0.5;
	cursor: not-allowed;
	pointer-events: none;
}

/* 空状态 */
.alert-empty {
	text-align: center;
	color: #a0aec0;
	font-style: italic;
	padding: 40px 20px;
	font-size: 14px;
}
</style>

<script>
// ================= 批量时间段管理 (BTM) =================
(function(){
	if(window.BTM) return;
	function toastLite(m){ if(window.toast) toast(m); else console.log('[BTM]',m); }
	const WEEKDAY_NAMES=['monday','tuesday','wednesday','thursday','friday'];
	const CHINESE_DAY=['周一','周二','周三','周四','周五'];
	function pad2(n){return String(n).padStart(2,'0');}
	function normTime(t){const m=t.match(/^(\d{1,2}):(\d{2})$/); if(!m) return t; return pad2(+m[1])+':'+m[2];}
	function rangeNorm(r){const [a,b]=r.split('-'); return normTime(a)+'-'+normTime(b);}  
	function sameRange(a,b){return rangeNorm(a)===rangeNorm(b);}  
	function minutesDiff(s,e){const [sh,sm]=s.split(':').map(Number); const [eh,em]=e.split(':').map(Number); return (eh*60+em)-(sh*60+sm);}  
	const BTM={
		timeSlots:['8:00-8:50','9:00-9:50','9:40-10:00','10:00-10:50','11:00-11:50','11:50-13:00','13:00-13:50','14:00-14:50','14:50-15:10','15:10-16:00','16:10-17:00','17:10-18:00'],
		wednesdaySlots:['8:00-8:50','9:00-9:50','9:40-10:00','10:00-10:50','11:00-11:50',['11:50-12:50','午间音乐会'],['13:30-14:20'],['14:30-15:20'],'15:20-15:40',['15:40-16:30'],['16:40-17:30'],['17:40-18:30']],
		breakIdx:[2,8], lunchIdx:[5],
		students:[], filteredStudents:[], currentIndex:-1, selectionMap:{}, remoteSlots:{},
		dom:{},
		initDom(){this.dom.modal=document.getElementById('bulkTimeManagerModal'); this.dom.tbody=document.getElementById('btmTbody'); this.dom.studentSelect=document.getElementById('btmStudentSelect'); this.dom.selectedList=document.getElementById('btmSelectedList'); this.dom.info=document.getElementById('btmStudentInfo'); this.dom.search=document.getElementById('btmSearchInput');},
		async open(){ if(!window.supabaseClient || (typeof window.supabaseReady!=='undefined' && !window.supabaseReady)){ toastLite('Supabase 未就绪'); return; } this.initDom(); await this.loadRemote(); this.buildStudents(); this.buildSelections(); this.renderTable(); this.applyFilter(); if(this.filteredStudents.length){ this.currentIndex=0; this.dom.studentSelect.value='0'; this.updateInfo(); this.highlight(); this.refreshSelectedList(); } this.dom.modal.style.display='block'; },
		close(){ if(this.dom.modal) this.dom.modal.style.display='none'; },
		async loadRemote(){ this.remoteSlots={}; const {data,error}=await supabaseClient.from('student_time_slots').select('*'); if(error){ console.error(error); if(error.status===401){ toastLite('未授权访问 student_time_slots (401)，请检查 Supabase Key / RLS 策略'); } else if(error.code==='42P01'){ toastLite('表 student_time_slots 不存在'); } else { toastLite('加载时间段失败: '+error.message); } return;} (data||[]).forEach(r=>{ const name=r.student_name; if(!this.remoteSlots[name]) this.remoteSlots[name]={monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]}; const day=WEEKDAY_NAMES[r.weekday-1]; if(!day) return; this.remoteSlots[name][day].push({start:normTime(r.start_time), end:normTime(r.end_time)}); }); Object.values(this.remoteSlots).forEach(week=>{ Object.values(week).forEach(arr=>arr.sort((a,b)=>a.start.localeCompare(b.start))); }); },
		buildStudents(){
			if(window.getAllActiveStudents){
				this.students = window.getAllActiveStudents().map(s=>({name:s.name,major:s.major||'',grade:s.grade||''})).sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN'));
			}else{
				this.students = (window.RoomStore?.students||[]).map(s=>({name:s.name,major:s.major||'',grade:s.grade||''})).sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN'));
			}
		},
		buildSelections(){
			this.selectionMap={}; this.originalSelectionMap={};
			this.students.forEach(st=>{ 
				const cur=new Set(); this.selectionMap[st.name]=cur; 
				const week=this.remoteSlots[st.name]; if(!week){ this.originalSelectionMap[st.name]=new Set(); return; }
				WEEKDAY_NAMES.forEach((day,di)=>{ (week[day]||[]).forEach(sl=>{ const key=this.matchSlot(di, sl.start+'-'+sl.end); if(key) cur.add(key); }); });
				// 原始快照
				this.originalSelectionMap[st.name]=new Set(cur);
			});
		},
		isStudentChanged(name){
			const a=this.selectionMap?.[name]; const b=this.originalSelectionMap?.[name];
			if(!a && !b) return false; if(!a||!b) return true; if(a.size!==b.size) return true; for(const k of a){ if(!b.has(k)) return true; } return false;
		},
		applyFilter(){ const kw=(this.dom.search?.value||'').trim().toLowerCase(); this.filteredStudents=this.students.filter(s=> !kw || (window.matchPinyin?matchPinyin(s.name,kw):s.name.includes(kw))); this.renderStudentSelect(); },
		renderStudentSelect(){ const sel=this.dom.studentSelect; if(!sel) return; sel.innerHTML=this.filteredStudents.map((s,i)=>`<option value="${i}">${s.name} - ${s.major||''}</option>`).join(''); },
		renderTable(){ const tb=this.dom.tbody; if(!tb) return; tb.innerHTML=''; for(let i=0;i<this.timeSlots.length;i++){ const tr=document.createElement('tr'); const timeTd=document.createElement('td'); timeTd.className='btm-cell btm-time-col'; timeTd.textContent=this.timeSlots[i]; tr.appendChild(timeTd); for(let d=0;d<5;d++){ const td=document.createElement('td'); if(d===2){ const w=this.wednesdaySlots[i]; if(typeof w==='string'){ if(this.isRest(i,d,true)){ td.className='btm-cell-rest'; td.textContent=this.breakIdx.includes(i)?'休息':'午餐'; } else { td.className='btm-cell'; td.dataset.key=`wed-${i}-0-2`; td.textContent=w; td.onclick=()=>this.toggle(td.dataset.key); } } else { const wrap=document.createElement('div'); wrap.className='btm-wed-subwrap'; w.forEach((sub,si)=>{ const div=document.createElement('div'); const key=`wed-${i}-${si}-2`; div.dataset.key=key; if(this.isSubRest(i,si) || !/\d{1,2}:\d{2}-\d{1,2}:\d{2}/.test(sub)){ div.className='btm-wed-sub rest'; div.textContent=sub==='11:50-12:50'?'午餐':sub; } else { div.className='btm-wed-sub'; div.textContent=sub; div.onclick=()=>this.toggle(key,true); } wrap.appendChild(div); }); td.appendChild(wrap); } } else { if(this.isRest(i,d,false)){ td.className='btm-cell-rest'; td.textContent=this.breakIdx.includes(i)?'休息':'午餐'; } else { td.className='btm-cell'; td.dataset.key=`${i}-${d}`; td.textContent=this.timeSlots[i]; td.onclick=()=>this.toggle(td.dataset.key); } } tr.appendChild(td);} tb.appendChild(tr);} },
		isRest(i,day,isWed){ if(isWed){ if(i===2||i===8) return true; if(i===5) return true; } else { if(this.breakIdx.includes(i)) return true; if(this.lunchIdx.includes(i)) return true; } return false; },
		isSubRest(i){ return i===2||i===8||i===5; },
		selectStudent(){ const idx=parseInt(this.dom.studentSelect.value); if(isNaN(idx)) { this.currentIndex=-1; return;} this.currentIndex=idx; this.updateInfo(); this.highlight(); this.refreshSelectedList(); },
		updateInfo(){ if(this.currentIndex<0){ this.dom.info.innerHTML=''; return;} const st=this.filteredStudents[this.currentIndex]; this.dom.info.innerHTML=`<b>学生：</b>${st.name}　<b>专业：</b>${st.major||''}　<b>年级：</b>${st.grade||'未指定'}`; },
		toggle(key){ if(this.currentIndex<0) return; const st=this.filteredStudents[this.currentIndex]; const set=this.selectionMap[st.name]; if(set.has(key)) set.delete(key); else set.add(key); this.highlight(); this.refreshSelectedList(); },
		highlight(){ if(this.currentIndex<0) return; const st=this.filteredStudents[this.currentIndex]; const set=this.selectionMap[st.name]; this.dom.tbody.querySelectorAll('.btm-cell').forEach(c=>{ const k=c.dataset.key; if(!k) return; c.classList.toggle('btm-cell-selected', set.has(k)); }); this.dom.tbody.querySelectorAll('.btm-wed-sub:not(.rest)').forEach(s=>{ const k=s.dataset.key; if(!k) return; s.classList.toggle('selected', set.has(k)); }); },
		refreshSelectedList(){ if(!this.dom.selectedList) return; if(this.currentIndex<0){ this.dom.selectedList.innerHTML=''; return;} const st=this.filteredStudents[this.currentIndex]; const set=this.selectionMap[st.name]; if(!set.size){ this.dom.selectedList.innerHTML='<div style="color:#999;font-style:italic;">暂无选择</div>'; return;} const groups={0:[],1:[],2:[],3:[],4:[]}; set.forEach(k=>{ if(k.startsWith('wed-')){ const p=k.split('-'); groups[2].push(k); } else { const [ti,di]=k.split('-').map(Number); groups[di].push(k);} }); let html=''; Object.entries(groups).forEach(([d,arr])=>{ if(!arr.length) return; arr.sort(); html+=`<div style="margin-bottom:6px;"><b>${CHINESE_DAY[d]}:</b><br>`; arr.forEach(k=>{ if(k.startsWith('wed-')){ const p=k.split('-'); const ti=parseInt(p[1]); const si=parseInt(p[2]); const slot=this.wednesdaySlots[ti]; const txt=Array.isArray(slot)?slot[si]:slot; if(/\d{1,2}:\d{2}-\d{1,2}:\d{2}/.test(txt)) html+=`<span class="btm-chip wed">${txt}</span>`; } else { const [ti]=k.split('-'); html+=`<span class="btm-chip">${this.timeSlots[ti]}</span>`; } }); html+='</div>'; }); this.dom.selectedList.innerHTML=html; },
		matchSlot(dayIndex,range){ const norm=rangeNorm(range); if(dayIndex===2){ for(let t=0;t<this.wednesdaySlots.length;t++){ const w=this.wednesdaySlots[t]; if(Array.isArray(w)){ for(let s=0;s<w.length;s++){ const seg=w[s]; if(/^\d{1,2}:\d{2}-\d{1,2}:\d{2}$/.test(seg) && sameRange(seg,norm)) return `wed-${t}-${s}-2`; } } else { if(/^\d{1,2}:\d{2}-\d{1,2}:\d{2}$/.test(w) && sameRange(w,norm)) return `wed-${t}-0-2`; } } return null;} else { for(let i=0;i<this.timeSlots.length;i++){ if(sameRange(this.timeSlots[i],norm)) return `${i}-${dayIndex}`; } return null; } },
		clearAll(){ if(!confirm('确定清空所有学生当前选择？')) return; Object.values(this.selectionMap).forEach(set=>set.clear()); this.highlight(); this.refreshSelectedList(); toastLite('已清空'); },
		async save(){ if(!supabaseClient){ toastLite('未连接'); return;} if(!confirm('保存将覆盖所选学生周一到周五的全部时间段，确认继续？')) return; const btn=document.getElementById('btmSaveBtn'); if(btn){ btn.disabled=true; btn.textContent='保存中...'; }
			// 只收集有变更的学生
			const changedStudents = this.students.filter(st=> this.isStudentChanged(st.name));
			if(!changedStudents.length){ if(btn){ btn.disabled=false; btn.textContent='保存'; } toastLite('没有变更，无需保存'); return; }
			let changed=0; const errors=[]; const startTs=Date.now(); const total=changedStudents.length;
			try {
				let idx=0;
				for(const st of changedStudents){
					idx++;
					// 进度提示（避免过于频繁 DOM 写，可每1人更新）
					if(btn) btn.textContent=`保存中... (${idx}/${total})`;
					try {
						const set=this.selectionMap[st.name]; if(!set) continue; // 空集合也代表清空
						const delRes=await supabaseClient.from('student_time_slots').delete().eq('student_name', st.name).in('weekday',[1,2,3,4,5]);
						if(delRes.error){
							if(delRes.error.status===401) errors.push(`${st.name} 删除未授权(401)`); else errors.push(`${st.name} 删除失败:${delRes.error.message}`);
							continue;
						}
						const rows=[]; set.forEach(k=>{ if(k.startsWith('wed-')){ const p=k.split('-'); const ti=+p[1]; const si=+p[2]; const slot=this.wednesdaySlots[ti]; const txt=Array.isArray(slot)?slot[si]:slot; if(!/^\d{1,2}:\d{2}-\d{1,2}:\d{2}$/.test(txt)) return; const [s,e]=txt.split('-'); rows.push({student_name:st.name, weekday:3, start_time:normTime(s), end_time:normTime(e), duration_minutes:minutesDiff(s,e)}); } else { const [ti,di]=k.split('-').map(Number); const txt=this.timeSlots[ti]; const [s,e]=txt.split('-'); rows.push({student_name:st.name, weekday:di+1, start_time:normTime(s), end_time:normTime(e), duration_minutes:minutesDiff(s,e)}); } });
						if(rows.length){ const insRes=await supabaseClient.from('student_time_slots').insert(rows); if(insRes.error){ if(insRes.error.status===401) errors.push(`${st.name} 插入未授权(401)`); else errors.push(`${st.name} 插入失败:${insRes.error.message}`); } else { changed++; } }
						else { changed++; }
					} catch(loopErr){ errors.push(`${st.name} 异常:${loopErr.message||loopErr}`); }
				}
				// 验证
				let verifyCount='?'; try{ const {data,error}=await supabaseClient.from('student_time_slots').select('id',{count:'exact'}); if(!error){ verifyCount=data.length; } else if(error.status===401){ verifyCount='未授权'; } }catch(_e){}
				const dur=Date.now()-startTs;
				if(errors.length){ console.error('[BTM Save Errors]', errors); toastLite(`部分失败: ${errors.length} 条；成功 ${changed} 人，用时 ${dur}ms`); alert(errors.slice(0,6).join('\n') + (errors.length>6?'\n...':'') ); }
				else if(changed===0){ toastLite('没有可保存的更改'); }
				else { toastLite(`保存成功：${changed} 人，记录≈${verifyCount} (${dur}ms)`); if(btn) btn.textContent='保存成功'; }
				// 刷新本地映射
				await this.loadRemote(); this.buildSelections(); this.highlight(); this.refreshSelectedList();
				// 更新基线以避免立即再次提示变更
				// buildSelections 已刷新 originalSelectionMap
				if(window.PracticeAlerts && PracticeAlerts.refreshSlots){ PracticeAlerts.refreshSlots(true); }
			} catch(fatal){
				console.error('[BTM Save Fatal]', fatal); toastLite('保存过程出现异常:'+ (fatal.message||fatal));
			} finally {
				if(btn){
					btn.disabled=false;
					// 若不是显示“保存成功”则回退到“保存”
					if(btn.textContent!=='保存成功') btn.textContent='保存'; else setTimeout(()=>{ if(btn.textContent==='保存成功') btn.textContent='保存'; }, 1500);
				}
			}
		},
		debugAuth: async function(){ if(!supabaseClient){ console.log('无 supabaseClient'); return;} const {data,error}=await supabaseClient.from('student_time_slots').select('*').limit(1); console.log('debugAuth select result:', data, error); if(error){ alert('调试: '+ (error.status||'')+' '+error.message); } else { alert('调试成功，返回 '+data.length+' 条'); } },
		prevStudent(){ if(this.filteredStudents.length===0) return; this.currentIndex=(this.currentIndex<=0?this.filteredStudents.length-1:this.currentIndex-1); this.dom.studentSelect.value=String(this.currentIndex); this.updateInfo(); this.highlight(); this.refreshSelectedList(); },
		nextStudent(){ if(this.filteredStudents.length===0) return; this.currentIndex=(this.currentIndex>=this.filteredStudents.length-1?0:this.currentIndex+1); this.dom.studentSelect.value=String(this.currentIndex); this.updateInfo(); this.highlight(); this.refreshSelectedList(); }
	};
	window.BTM=BTM; window.openBulkTimeManager=()=>{ BTM.open(); };
	window.closeBulkTimeManager=()=>{ BTM.close(); };
	document.addEventListener('DOMContentLoaded',()=>{
		const bind=(id,fn)=>{ const el=document.getElementById(id); if(el) el.onclick=fn; };
		bind('btmCloseBtn', ()=>closeBulkTimeManager());
		bind('btmPrevBtn', ()=>{BTM.prevStudent&&BTM.prevStudent();});
		bind('btmNextBtn', ()=>{BTM.nextStudent&&BTM.nextStudent();});
		bind('btmClearAllBtn', ()=>BTM.clearAll());
		bind('btmSaveBtn', ()=>BTM.save());
		const sel=document.getElementById('btmStudentSelect'); if(sel) sel.onchange=()=>BTM.selectStudent();
		const search=document.getElementById('btmSearchInput'); if(search) search.oninput=()=>{BTM.applyFilter(); if(BTM.filteredStudents.length){BTM.currentIndex=0; BTM.dom.studentSelect.value='0'; BTM.updateInfo(); BTM.highlight(); BTM.refreshSelectedList();}};
	});
})();
</script>

<script>
// ======= StudentLibrary Seed Function (AB 方案核心) =======
// 说明：
//  - 该函数在 bootstrap() 结束后调用（A）
//  - 同时在 StudentLibrary 初始化后延迟再次调用（B）
//  - 仅在本地 StudentLibrary 为空时迁移 RoomStore.students
//  - 幂等：已有学生或已迁移则不重复；避免同名重复
//  - 若 RoomStore 尚未就绪则静默退出，可供稍后重试
window.seedStudentLibraryFromRoomStore = function(opts){
	const result = { ok:false, reason: opts?.reason||'', inserted:0, skipped:0, alreadyHad:false, roomStudents:0, error:null };
	try{
		if(!window.RoomStore || !Array.isArray(RoomStore.students)){ result.error='RoomStoreNotReady'; return result; }
		const rs = RoomStore.students; result.roomStudents = rs.length; if(!rs.length){ result.error='NoRoomStudents'; return result; }
		const LS_KEY = 'yms_students_store_v1';
		let store = { version:1, items:[] };
		try{ const raw=localStorage.getItem(LS_KEY); if(raw){ const obj=JSON.parse(raw); if(obj && obj.version===1 && Array.isArray(obj.items)) store = obj; } }catch(parseErr){ result.error='ParseError'; }
		if(store.items.length){ result.alreadyHad=true; result.ok=true; return result; }
		const now = Date.now();
		const dedup = new Set();
		rs.forEach(s=>{ const name = (s && s.name||'').trim(); if(!name){ result.skipped++; return; } if(dedup.has(name)){ result.skipped++; return; } dedup.add(name); store.items.push({ id: (crypto.randomUUID?crypto.randomUUID():('id_'+Math.random().toString(36).slice(2))), name, grade: s.grade||'', major: s.major||'', remark:'', archived:false, created_at: now, updated_at: now }); });
		if(!store.items.length){ result.error='NoValidStudents'; return result; }
		try{ localStorage.setItem(LS_KEY, JSON.stringify(store)); }catch(e){ result.error='SaveFailed'; return result; }
		result.inserted = store.items.length; result.ok=true;
		console.log('[SeedStudentLibrary] 迁移完成 inserted=', result.inserted, 'skipped=', result.skipped, 'reason=', result.reason);
		if(window.StudentLibrary && typeof StudentLibrary.refresh==='function'){ try{ StudentLibrary.refresh(); }catch(_){ } }
		if(window.BTM && typeof BTM.buildStudents==='function'){ try{ BTM.buildStudents(); BTM.buildSelections && BTM.buildSelections(); BTM.applyFilter && BTM.applyFilter(); }catch(_){ } }
	}catch(e){ console.warn('[SeedStudentLibrary] 运行异常', e); result.error='Exception'; }
	return result;
};
// 可手动在控制台执行 window.seedStudentLibraryFromRoomStore({reason:'manual'}) 进行重试

// ================= 学生库（Student Library） =================
(function(){
	if(window.StudentLibrary) return;

	// 确保学生库已被云端 / RoomStore 数据回填
	window.ensureStudentLibraryHydrated = async function(opts){
		try{
			const LS_KEY='yms_students_store_v1';
			let parsed=null; try{ const raw=localStorage.getItem(LS_KEY); if(raw){ parsed=JSON.parse(raw); } }catch(_){ }
			const empty = !parsed || !Array.isArray(parsed.items) || parsed.items.length===0;
			// 若已存在学生则不处理（避免覆盖实时同步的数据）
			if(!empty){ return { skipped:true, reason:'already-have-local' }; }
			
			// 检查是否在实时同步冷却期内（避免冲突）
			const recentRealtimeUpdate = window.__studentUpdateTimestamp && 
				(Date.now() - window.__studentUpdateTimestamp) < 10000; // 10秒内有实时更新
			if (recentRealtimeUpdate) {
				console.log('[ensureStudentLibraryHydrated] 检测到近期实时更新，跳过数据填充');
				return { skipped: true, reason: 'recent-realtime-update' };
			}
			
			// 先尝试从 RoomStore 迁移（同步函数）
			if(window.seedStudentLibraryFromRoomStore){ const r=window.seedStudentLibraryFromRoomStore({ reason: opts?.source||'ensure-hydrate' }); if(r && r.ok){ return { ok:true, method:'roomStore', inserted:r.inserted }; } }
			// 若 RoomStore 仍无，则尝试云端 fetchStudents（该函数会 merge 到 Store）
			if(typeof fetchStudents==='function' && window.supabaseReady){ 
				// 数据回填时使用全量同步确保完整性
				await fetchStudents({ forceFullSync: true }); 
			}
			// 再次检查，如果 Store.students 有而本地仍为空，则用 Store.students 回填
			try{ const raw2=localStorage.getItem(LS_KEY); if(raw2){ parsed=JSON.parse(raw2); } }catch(_){ }
			const stillEmpty = !parsed || !Array.isArray(parsed.items) || parsed.items.length===0;
			if(stillEmpty && Array.isArray(window.Store?.students) && Store.students.length){
				const now=Date.now(); const storeObj={ version:1, items: Store.students.map(s=>({ id:(crypto.randomUUID?crypto.randomUUID():('id_'+Math.random().toString(36).slice(2))), name:s.name, grade:s.grade||'', major:s.major||'', remark:'', archived:false, created_at:now, updated_at:now })) };
				try{ localStorage.setItem(LS_KEY, JSON.stringify(storeObj)); console.log('[ensureStudentLibraryHydrated] 通过 Store.students 回填', storeObj.items.length); if(window.StudentLibrary && StudentLibrary.refresh) StudentLibrary.refresh(); return { ok:true, method:'storeStudents', inserted:storeObj.items.length }; }catch(err){ return { ok:false, error:'save-failed', detail:err?.message }; }
			}
			// 最后尝试刷新 pending 队列（如果此时才连上云）
			try{ if(window.__retryStudentLibraryPending){ await window.__retryStudentLibraryPending(); } }catch(_){ }
			return { ok: !stillEmpty, method: stillEmpty? 'none':'maybe-cloud', inserted: stillEmpty?0:(parsed.items||[]).length };
		}catch(e){ return { ok:false, error:e.message||String(e) }; }
	};
	const LS_KEY = 'yms_students_store_v1';
	const store = { version:1, items:[] };
	// 待同步队列: {type:'upsert'|'delete', payload:{name,major,grade,archived?}} 离线时累积
	let pendingCloudOps = [];
	function now(){ return Date.now(); }
	function save(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(store)); }catch(e){ console.warn('[StudentLibrary] save failed', e); } }
	function load(){ try{ const raw=localStorage.getItem(LS_KEY); if(raw){ const obj=JSON.parse(raw); if(obj.version===1 && Array.isArray(obj.items)){ store.items=obj.items; } } }catch(e){ console.warn('[StudentLibrary] load failed', e); } }
	
	// 云端加载节流：首次不冷却，后续30秒冷却
	let lastCloudLoadTime = 0;
	const CLOUD_LOAD_COOLDOWN = 30000; // 30秒
	let firstCloudLoadDone = false;
	
	// 从云端加载学生数据（智能合并，避免冲突实时同步）
	async function loadFromCloud() {
		if (!window.supabaseClient || !window.supabaseReady) {
			console.log('[StudentLibrary] Supabase 未就绪，跳过云端加载');
			return false;
		}
		
		// 节流：首次强制加载，后续才进入冷却判断
		const now = Date.now();
		if(firstCloudLoadDone){
			if (now - lastCloudLoadTime < CLOUD_LOAD_COOLDOWN) {
				console.log('[StudentLibrary] 云端加载冷却中，跳过本次加载');
				return false;
			}
		}
		lastCloudLoadTime = now;
		
		try {
			console.log('[StudentLibrary] 开始从云端加载学生数据...');
			
			const { data: cloudStudents, error } = await window.supabaseClient
				.from('student_database')
				.select('*')
				.order('name');
			
			if (error) {
				console.warn('[StudentLibrary] 云端加载失败:', error.message);
				return false;
			}
			
			if (cloudStudents && cloudStudents.length > 0) {
				// 智能合并：不清空本地数据，而是基于名字合并
				let mergedCount = 0;
				let newCount = 0;
				
				cloudStudents.forEach(cloudStudent => {
					// 查找本地是否已有同名学生
					let localStudent = store.items.find(s => s.name === cloudStudent.name);
					
					if (localStudent) {
						// 已存在，更新信息（以云端为准，但保留本地ID和备注）
						localStudent.grade = cloudStudent.grade || '';
						localStudent.major = cloudStudent.major || '';
						localStudent.updated_at = cloudStudent.updated_at ? new Date(cloudStudent.updated_at).getTime() : now();
						mergedCount++;
					} else {
						// 不存在，新增学生
						const newStudent = {
							id: crypto.randomUUID ? crypto.randomUUID() : ('id_' + Math.random().toString(36).slice(2)),
							name: cloudStudent.name,
							grade: cloudStudent.grade || '',
							major: cloudStudent.major || '',
							remark: '',
							archived: false,
							created_at: cloudStudent.created_at ? new Date(cloudStudent.created_at).getTime() : now(),
							updated_at: cloudStudent.updated_at ? new Date(cloudStudent.updated_at).getTime() : now()
						};
						store.items.push(newStudent);
						newCount++;
					}
				});
				
				// 保存到本地存储
				save();
				
				firstCloudLoadDone = true;
				console.log(`[StudentLibrary] 云端合并完成: 新增${newCount}个, 更新${mergedCount}个学生 (source=cloud)`);
				return true;
			} else {
				firstCloudLoadDone = true;
				console.log('[StudentLibrary] 云端无学生数据 (source=cloud-empty)');
				return false;
			}
		} catch (error) {
			console.error('[StudentLibrary] 云端加载异常:', error);
			return false;
		}
	}

	// 等待 supabaseReady 工具
	async function waitSupabaseReady(timeout=8000){
		const start=Date.now();
		while(!window.supabaseReady){
			if(Date.now()-start>timeout) return false;
			await new Promise(r=>setTimeout(r,120));
		}
		return true;
	}
	async function flushPending(){ if(!window.supabaseReady || !window.supabaseClient || !pendingCloudOps.length) return; const upserts=[]; const deletes=[]; pendingCloudOps.forEach(op=>{ if(op.type==='upsert') upserts.push(op.payload); else if(op.type==='delete') deletes.push(op.payload); }); pendingCloudOps=[]; try{ if(upserts.length){ console.log('[StudentLibrary] 批量上行学生', upserts.length); try{ if(typeof syncStudentDatabaseToCloud==='function'){ await syncStudentDatabaseToCloud(upserts); } else { // fallback 手动 diff
				const names=[...new Set(upserts.map(s=>s.name).filter(Boolean))]; let existing=[]; try{ const {data:ex, error:exErr}=await supabaseClient.from('student_database').select('name').in('name', names); if(!exErr && Array.isArray(ex)) existing=ex.map(r=>r.name); }catch(_){ }
				const toInsert=upserts.filter(s=>!existing.includes(s.name)).map(s=>({ name:s.name, major:s.major||'未填写', grade:s.grade||'' }));
				const toUpdate=upserts.filter(s=>existing.includes(s.name));
				if(toInsert.length){ const {error:insErr}=await supabaseClient.from('student_database').insert(toInsert); if(insErr) console.warn('[StudentLibrary] insert batch error', insErr.message); }
				for(const row of toUpdate){ try{ const {error:updErr}=await supabaseClient.from('student_database').update({ major:row.major||'未填写', grade:row.grade||'' }).eq('name', row.name); if(updErr) console.warn('[StudentLibrary] update error', row.name, updErr.message); }catch(e){ console.warn('[StudentLibrary] update exception', row.name, e.message); } }
			} }catch(e){ console.warn('[StudentLibrary] upsert 执行异常', e); }
		}
		if(deletes.length){ for(const d of deletes){ try{ const {error}=await supabaseClient.from('student_database').delete().eq('name', d.name); if(error) console.warn('[StudentLibrary] delete cloud error', d.name, error.message); else console.log('[StudentLibrary] 已删除云端学生', d.name); }catch(e){ console.warn('[StudentLibrary] delete cloud exception', d.name, e); } } }
	}catch(e){ console.warn('[StudentLibrary] flushPending exception', e); }
	}
	function enqueue(op){ 
		pendingCloudOps.push(op); 
		if(pendingCloudOps.length>50) console.warn('[StudentLibrary] pendingCloudOps size', pendingCloudOps.length); 
		if(!window.supabaseReady){
			if(typeof toast==='function') toast('离线：变更已排队', 'warn');
			return; 
		}
		flushPending(); 
	}
	// 供外部在 Supabase 连接后再次尝试
	window.__retryStudentLibraryPending = flushPending;
	function migrateFromRoomStore(){ if(store.items.length) return; const rs=window.RoomStore?.students||[]; if(!rs.length) return; rs.forEach(s=>{ store.items.push({ id:crypto.randomUUID?crypto.randomUUID():('id_'+Math.random().toString(36).slice(2)), name:s.name, grade:s.grade||'', major:s.major||'', remark:'', archived:false, created_at:now(), updated_at:now() }); }); save(); console.log('[StudentLibrary] migrated', store.items.length); }
	function getAll(){ return store.items.slice().sort((a,b)=>a.name.localeCompare(b.name,'zh-Hans-CN')); }
	function findByName(name){ return store.items.find(s=>s.name===name); }
	function syncStoreItemToCloud(it){ if(!it) return; enqueue({ type:'upsert', payload:{ name:it.name, major:it.major||'', grade:it.grade||'' } }); }
	function addStudent(meta){ 
		if(!meta?.name) throw new Error('name required'); 
		if(findByName(meta.name)) throw new Error('已存在同名学生'); 
		
		// 标记本地更新，避免实时同步循环
		if (!window.__studentUpdateIgnore) window.__studentUpdateIgnore = new Set();
		window.__studentUpdateIgnore.add(meta.name);
		window.__studentUpdateTimestamp = Date.now();
		
		// 清理标记（5秒后）
		setTimeout(() => {
			if (window.__studentUpdateIgnore) {
				window.__studentUpdateIgnore.delete(meta.name);
			}
		}, 5000);
		
		const item={ 
			id:crypto.randomUUID?crypto.randomUUID():('id_'+Math.random().toString(36).slice(2)), 
			name:meta.name.trim(), 
			grade:meta.grade||'', 
			major:meta.major||'', 
			remark:meta.remark||'', 
			archived:false, 
			created_at:now(), 
			updated_at:now() 
		}; 
		store.items.push(item); 
		save(); 
		syncStoreItemToCloud(item); 
		refreshUI(); 
		refreshBTM(); 
		return item; 
	}
	function updateStudent(name, patch){ 
		const it=findByName(name); 
		if(!it) throw new Error('学生不存在'); 
		
		// 标记本地更新，避免实时同步循环
		if (!window.__studentUpdateIgnore) window.__studentUpdateIgnore = new Set();
		window.__studentUpdateIgnore.add(name);
		window.__studentUpdateTimestamp = Date.now();
		
		// 清理标记（5秒后）
		setTimeout(() => {
			if (window.__studentUpdateIgnore) {
				window.__studentUpdateIgnore.delete(name);
			}
		}, 5000);
		
		Object.assign(it, patch||{}, { updated_at:now() }); 
		save(); 
		syncStoreItemToCloud(it); 
		refreshUI(); 
		refreshBTM(); 
	}
	
	// 处理远程更新（避免循环同步）
	function handleRemoteUpdate(payload) {
		try {
			const row = payload.new || payload.old;
			if (!row) return;
			
			if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
				let student = findByName(row.name);
				let changed = false;
				
				if (!student && payload.eventType === 'INSERT') {
					// 新增学生
					student = {
						id: crypto.randomUUID ? crypto.randomUUID() : ('id_' + Math.random().toString(36).slice(2)),
						name: row.name,
						grade: row.grade || '',
						major: row.major || '',
						remark: '',
						archived: false,
						created_at: now(),
						updated_at: now()
					};
					store.items.push(student);
					changed = true;
				} else if (student && payload.eventType === 'UPDATE') {
					// 更新学生
					if (student.grade !== (row.grade || '')) {
						student.grade = row.grade || '';
						changed = true;
					}
					if (student.major !== (row.major || '')) {
						student.major = row.major || '';
						changed = true;
					}
					if (changed) {
						student.updated_at = now();
					}
				}
				
				if (changed) {
					save();
					refreshUI();
					refreshBTM();
					console.log('[StudentLibrary] 远程更新同步:', row.name);
				}
			} else if (payload.eventType === 'DELETE' && payload.old) {
				// 删除学生 - 增强处理逻辑
				const targetName = payload.old.name;
				console.log('[StudentLibrary] 处理删除事件:', { targetName, localCount: store.items.length });
				
				// 精确匹配（考虑字符串比较的问题）
				let index = store.items.findIndex(s => s.name === targetName);
				
				// 如果精确匹配失败，尝试trim后匹配（防止空格问题）
				if (index < 0) {
					index = store.items.findIndex(s => s.name?.trim() === targetName?.trim());
					if (index >= 0) {
						console.warn('[StudentLibrary] 使用trim匹配找到学生:', { original: store.items[index].name, target: targetName });
					}
				}
				
				if (index >= 0) {
					const removedStudent = store.items[index];
					store.items.splice(index, 1);
					save();
					refreshUI();
					refreshBTM();
					console.log('[StudentLibrary] 远程删除同步成功:', { name: removedStudent.name, remainingCount: store.items.length });
				} else {
					// 提供更详细的调试信息
					const localNames = store.items.map(s => s.name);
					console.warn('[StudentLibrary] 未在本地找到待删除学生:', {
						targetName,
						targetType: typeof targetName,
						targetLength: targetName?.length,
						localNames,
						localCount: localNames.length,
						exactMatches: localNames.filter(n => n === targetName),
						trimMatches: localNames.filter(n => n?.trim() === targetName?.trim())
					});
					
					// 触发对账
					if (window.reconcileStudentsWithCloud) {
						setTimeout(()=>{ try{ window.reconcileStudentsWithCloud(); }catch(_){ } }, 300);
					}
				}
			}
		} catch (error) {
			console.error('[StudentLibrary] 处理远程更新失败:', error);
		}
	}
	// 打开编辑学生弹窗（支持改名、年级、专业）
	function openEditStudent(oldName){
		const stu=findByName(oldName); if(!stu){ alert('未找到学生'); return; }
		let wrap=document.getElementById('editStudentModal');
		if(!wrap){
			wrap=document.createElement('div'); wrap.id='editStudentModal'; wrap.style.cssText='position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:6200;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);';
			wrap.innerHTML=`<div style="width:360px;max-width:92%;background:#fff;border-radius:14px;padding:20px 22px;box-shadow:0 8px 32px rgba(0,0,0,.25);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;">
				<div style="font-size:16px;font-weight:600;margin-bottom:14px;letter-spacing:.5px;color:#1f2937;">编辑学生</div>
				<div style="display:flex;flex-direction:column;gap:12px;">
					<label style="display:flex;flex-direction:column;gap:6px;font-size:13px;color:#1f2937;font-weight:500;">姓名<input id=\"esName\" type=\"text\" style=\"padding:12px 14px;border:2px solid #e5e7eb;border-radius:8px;font-size:14px;color:#1f2937;background:#fafafa;transition:all 0.2s ease;outline:none;\" onfocus=\"this.style.borderColor='#2563eb';this.style.background='#fff';\" onblur=\"this.style.borderColor='#e5e7eb';this.style.background='#fafafa';\" /></label>
					<label style="display:flex;flex-direction:column;gap:6px;font-size:13px;color:#1f2937;font-weight:500;">年级<input id=\"esGrade\" type=\"text\" style=\"padding:12px 14px;border:2px solid #e5e7eb;border-radius:8px;font-size:14px;color:#1f2937;background:#fafafa;transition:all 0.2s ease;outline:none;\" onfocus=\"this.style.borderColor='#2563eb';this.style.background='#fff';\" onblur=\"this.style.borderColor='#e5e7eb';this.style.background='#fafafa';\" /></label>
					<label style="display:flex;flex-direction:column;gap:6px;font-size:13px;color:#1f2937;font-weight:500;">专业<input id=\"esMajor\" type=\"text\" style=\"padding:12px 14px;border:2px solid #e5e7eb;border-radius:8px;font-size:14px;color:#1f2937;background:#fafafa;transition:all 0.2s ease;outline:none;\" onfocus=\"this.style.borderColor='#2563eb';this.style.background='#fff';\" onblur=\"this.style.borderColor='#e5e7eb';this.style.background='#fafafa';\" /></label>
					<div id=\"esProgress\" style=\"display:none;font-size:12px;color:#0f172a;background:#f1f5f9;border:1px solid #cbd5e1;padding:6px 8px;border-radius:6px;line-height:1.5;\">\n<span id=\"esProgText\">同步中...</span>\n<div style=\"height:6px;background:#e2e8f0;border-radius:4px;margin-top:6px;overflow:hidden;\">\n<div id=\"esProgBar\" style=\"height:100%;width:0%;background:linear-gradient(90deg,#2563eb,#3b82f6);transition:width .3s;\"></div>\n</div>\n</div>
					<div style="display:flex;gap:12px;justify-content:flex-end;margin-top:8px;">
						<button id=\"esCancel\" style=\"padding:10px 18px;border:2px solid #e5e7eb;background:#fff;color:#6b7280;border-radius:8px;font-size:14px;font-weight:500;cursor:pointer;transition:all 0.2s ease;\" onmouseover=\"this.style.borderColor='#d1d5db';this.style.color='#374151';\" onmouseout=\"this.style.borderColor='#e5e7eb';this.style.color='#6b7280';\">取消</button>
						<button id=\"esSave\" style=\"padding:10px 18px;border:2px solid #2563eb;background:#2563eb;color:#fff;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all 0.2s ease;box-shadow:0 2px 4px rgba(37,99,235,0.2);\" onmouseover=\"this.style.background='#1d4ed8';this.style.borderColor='#1d4ed8';this.style.transform='translateY(-1px)';this.style.boxShadow='0 4px 8px rgba(37,99,235,0.3)';\" onmouseout=\"this.style.background='#2563eb';this.style.borderColor='#2563eb';this.style.transform='translateY(0)';this.style.boxShadow='0 2px 4px rgba(37,99,235,0.2)';\">保存</button>
					</div>
				</div>`;
			wrap.addEventListener('click',e=>{ if(e.target===wrap) close(); });
			document.body.appendChild(wrap);
		}
		const nameInput=wrap.querySelector('#esName'); const gradeInput=wrap.querySelector('#esGrade'); const majorInput=wrap.querySelector('#esMajor'); const progBox=wrap.querySelector('#esProgress'); const progText=wrap.querySelector('#esProgText'); const progBar=wrap.querySelector('#esProgBar');
		function close(){ wrap.style.display='none'; }
		// 重置进度条状态
		progBox.style.display='none'; progText.textContent='同步中...'; progBar.style.width='0%'; progBar.style.background='linear-gradient(90deg,#2563eb,#3b82f6)';
		wrap.style.display='flex'; nameInput.value=stu.name; gradeInput.value=stu.grade||''; majorInput.value=stu.major||''; nameInput.focus();
		wrap.querySelector('#esCancel').onclick=close;
		wrap.querySelector('#esSave').onclick=async ()=>{
			const newName=nameInput.value.trim(); const newGrade=gradeInput.value.trim(); const newMajor=majorInput.value.trim(); if(!newName){ alert('姓名不能为空'); nameInput.focus(); return; }
			if(newName!==oldName && findByName(newName)){ alert('已存在同名学生'); return; }
			stu.name=newName; stu.grade=newGrade; stu.major=newMajor; stu.updated_at=now(); save(); refreshUI(); refreshBTM();
			if(!window.supabaseClient){ close(); if(window.toast) toast('离线：仅本地保存','warn'); return; }
			progBox.style.display='block'; progText.textContent='同步学生信息...'; progBar.style.width='12%';
			try{
				function step(p,msg){ progBar.style.width=p+'%'; if(msg) progText.textContent=msg; }
				const basePayload={ name:newName, grade:newGrade||'', major:newMajor||'' };
				// 查询是否已存在该 name
				let exists=false; try{ const { data:ex, error:exErr } = await supabaseClient.from('student_database').select('name').eq('name', newName).limit(1); if(!exErr && ex && ex.length) exists=true; }catch(_){ }
				if(!exists){
					// 直接插入，若违反 (name,major) 组合唯一则提示并终止
					const ins=await supabaseClient.from('student_database').insert([basePayload]); if(ins.error){ throw new Error('学生插入失败: '+ins.error.message); }
				}else{
					// 更新 major/grade，不触碰 name
					const upd=await supabaseClient.from('student_database').update({ major:basePayload.major, grade:basePayload.grade }).eq('name', newName);
					if(upd.error){ throw new Error('学生更新失败: '+upd.error.message); }
				}
				step(40,'学生信息已同步');
				if(newName!==oldName){
					// 1) 更新所有时间段引用 (RPC 优先)
					try{ const rpc=await supabaseClient.rpc('rename_student_slots',{ old_name:oldName, new_name:newName }); if(rpc.error) throw rpc.error; }
					catch(e){ const upd=await supabaseClient.from('student_time_slots').update({ student_name:newName }).eq('student_name', oldName); if(upd.error) throw new Error('时间段重命名失败: '+upd.error.message); }
					step(60,'时间段引用已更新');
					// 2) 删除旧 student_database 记录（若存在）
					const delOld=await supabaseClient.from('student_database').delete().eq('name', oldName); if(delOld.error){ console.warn('[StudentLibrary] 删除旧学生记录失败', delOld.error.message); }
					step(70,'旧名称清理完成');
				}
				setTimeout(()=>{ try{ if(typeof syncStudentDatabaseToCloud==='function'){ syncStudentDatabaseToCloud(store.items.map(s=>({ name:s.name, major:s.major||'', grade:s.grade||'' }))); } }catch(_){ } }, 20);
				step(92,'刷新界面...'); await new Promise(r=>requestAnimationFrame(r)); step(100,'完成'); setTimeout(()=>close(),500);
				if(window.toast) toast('学生已同步','success');
			}catch(err){ progBar.style.width='100%'; progBar.style.background='#dc2626'; progText.textContent=err.message||err; if(newName!==oldName){ // 回滚本地名称
				stu.name=oldName; save(); refreshUI(); }
			}
		};
	}
	// 归档功能已移除
	function deleteStudent(name){ 
		const idx=store.items.findIndex(s=>s.name===name); 
		if(idx>=0){ 
			// 标记本地更新，避免实时同步循环
			if (!window.__studentUpdateIgnore) window.__studentUpdateIgnore = new Set();
			window.__studentUpdateIgnore.add(name);
			window.__studentUpdateTimestamp = Date.now();
			
			// 清理标记（5秒后）
			setTimeout(() => {
				if (window.__studentUpdateIgnore) {
					window.__studentUpdateIgnore.delete(name);
				}
			}, 5000);
			
			const [removed]=store.items.splice(idx,1); 
			save(); 
			enqueue({ type:'delete', payload:{ name: removed.name } }); 
			refreshUI(); 
			refreshBTM(); 
		} 
	}

	// 云端对账：用于处理偶发删除遗漏（网络抖动 / 事件丢失）
	window.reconcileStudentsWithCloud = async function(){
		if(!window.supabaseClient || !window.supabaseReady) return;
		try{
			const { data, error } = await supabaseClient.from('student_database').select('name,major,grade');
			if(error){ console.warn('[StudentLibrary][reconcile] 拉取失败', error.message); return; }
			const cloudNames = new Set((data||[]).map(r=>r.name));
			const localNames = new Set(store.items.map(s=>s.name));
			// 找出本地多余（应删除）
			let removed=0;
			for(const n of [...localNames]){
				if(!cloudNames.has(n)){
					const i = store.items.findIndex(s=>s.name===n);
					if(i>=0){ store.items.splice(i,1); removed++; }
				}
			}
			if(removed>0){ save(); refreshUI(); refreshBTM(); console.log(`[StudentLibrary][reconcile] 清理本地多余 ${removed} 条`); }
		}catch(e){ console.warn('[StudentLibrary][reconcile] 异常', e.message); }
	};
	function refreshBTM(){ if(window.BTM){ try{ BTM.buildStudents(); BTM.buildSelections(); BTM.applyFilter(); }catch(e){ console.warn('[StudentLibrary] refreshBTM failed', e); } } }
	window.getAllActiveStudents = () => getAll(false).map(s=>({ name:s.name, grade:s.grade, major:s.major }));
	// UI
	let panel,listEl,searchEl,addBtn,addForm,showArchivedCb,exportBtn;
	function initDom(){ panel=document.getElementById('studentLibraryPanel'); listEl=document.getElementById('slList'); searchEl=document.getElementById('slSearch'); addBtn=document.getElementById('slAddBtn'); addForm=document.getElementById('slAddForm'); showArchivedCb=document.getElementById('slShowArchived'); }

	// ===== 含时间段导出 (无需先打开 BTM) =====
	async function fetchAllSlotsMap(){
		const map={}; if(!window.supabaseClient){ return map; }
		try{ const {data,error}=await supabaseClient.from('student_time_slots').select('*'); if(error){ console.warn('fetchAllSlotsMap error', error); return map; } (data||[]).forEach(r=>{ const name=r.student_name; if(!map[name]) map[name]={monday:[],tuesday:[],wednesday:[],thursday:[],friday:[]}; const weekdayMap=['monday','tuesday','wednesday','thursday','friday'][r.weekday-1]; if(!weekdayMap) return; map[name][weekdayMap].push({start:r.start_time,end:r.end_time}); }); Object.values(map).forEach(week=>{ Object.values(week).forEach(arr=>arr.sort((a,b)=>a.start.localeCompare(b.start))); }); }catch(e){ console.warn('fetchAllSlotsMap exception', e); }
		return map;
	}
	function weekSlotsToString(week){ if(!week) return ''; const order=['monday','tuesday','wednesday','thursday','friday']; const res={}; order.forEach(d=>{ const arr=(week[d]||[]).filter(sl=>/^\d{2}:\d{2}$/.test(sl.start)&&/^\d{2}:\d{2}$/.test(sl.end)); res[d]=arr.map(sl=>`${sl.start}-${sl.end}`).join(';'); }); return res; }
	async function exportCSVWithSlots(){
		try{
			const slotsMap=await fetchAllSlotsMap();
			const header=['name','grade','major','remark','mon','tue','wed','thu','fri'];
			const lines=[header.join(',')];
			getAll(true).forEach(s=>{ const week=weekSlotsToString(slotsMap[s.name]); const row=[s.name,s.grade||'',s.major||'',(s.remark||'').replace(/\r|\n/g,' '),week.monday||'',week.tuesday||'',week.wednesday||'',week.thursday||'',week.friday||'']; lines.push(row.map(v=>{ if(/[",\n]/.test(v)) return '"'+v.replace(/"/g,'""')+'"'; return v; }).join(',')); });
			const csv=lines.join('\n'); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='students_with_slots_'+Date.now()+'.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),500);
		}catch(e){ alert('导出失败:'+e.message); }
	}
	function parseCSV(text){
		const rows=[]; let cur=''; let inQuotes=false; let row=[]; for(let i=0;i<text.length;i++){ const ch=text[i]; if(inQuotes){ if(ch==='"'){ if(text[i+1]==='"'){ cur+='"'; i++; } else { inQuotes=false; } } else { cur+=ch; } } else { if(ch==='"'){ inQuotes=true; } else if(ch===','){ row.push(cur.trim()); cur=''; } else if(ch==='\n' || ch==='\r'){ if(ch==='\r' && text[i+1]==='\n') i++; row.push(cur.trim()); if(row.some(cell=>cell.length>0)) rows.push(row); row=[]; cur=''; } else { cur+=ch; } } } if(cur.length>0 || row.length>0){ row.push(cur.trim()); rows.push(row); }
		return rows;
	}
	// 移除普通 CSV 导入逻辑，仅保留含时间段版本
	// 含时间段导入：覆盖周一~周五全部时间段
	async function importCSVSlotsText(text){
		// 提前创建进度条，放置在学生库面板底部
		const progId='slotImportProgress'; let prog=document.getElementById(progId); if(!prog){
			prog=document.createElement('div'); prog.id=progId; prog.style.cssText='margin:8px 12px 12px; background:#f1f5f9; border:1px solid #cbd5e1; border-radius:6px; font-size:12px; line-height:1.4; color:#0f172a; padding:6px 10px; display:flex; flex-direction:column; gap:4px;';
			const bar=document.createElement('div'); bar.style.cssText='height:6px;background:#e2e8f0;border-radius:4px;overflow:hidden;position:relative;';
			const inner=document.createElement('div'); inner.style.cssText='height:100%;width:0%;background:linear-gradient(90deg,#2563eb,#3b82f6);transition:width .25s ease;'; inner.id='slotImportProgressBar'; bar.appendChild(inner);
			const text=document.createElement('div'); text.id='slotImportProgressText';
			prog.appendChild(text); prog.appendChild(bar);
			// 放在学生库面板内，若面板存在; 否则附加到 body
			const panel=document.getElementById('studentLibraryPanel'); if(panel){ panel.appendChild(prog); } else { document.body.appendChild(prog); }
		}
		function setProg(msg, percent){ const txt=prog.querySelector('#slotImportProgressText'); if(txt) txt.textContent=msg; if(typeof percent==='number'){ const bar=prog.querySelector('#slotImportProgressBar'); if(bar) bar.style.width=Math.min(100,Math.max(0,percent))+'%'; } }
		setProg('解析 CSV...',0); await new Promise(r=>requestAnimationFrame(r));
		const parseT0=performance.now();
		const rows=parseCSV(text); if(!rows.length){ prog.remove(); alert('CSV 空'); return; }
		let header=rows[0].map(h=>h.toLowerCase()); let start=1; if(!header.includes('name')){ header=['name','grade','major','remark','mon','tue','wed','thu','fri']; start=0; }
		const idxName=header.indexOf('name'); const idxGrade=header.indexOf('grade'); const idxMajor=header.indexOf('major'); const idxRemark=header.indexOf('remark'); const idxMon=header.indexOf('mon'); const idxTue=header.indexOf('tue'); const idxWed=header.indexOf('wed'); const idxThu=header.indexOf('thu'); const idxFri=header.indexOf('fri');
		if(idxName<0){ prog.remove(); alert('缺少 name 列'); return; }
		let inserted=0, updated=0, skipped=0, slotTotal=0, slotInvalid=0; const slotRows=[]; const nowTs=now();
		for(let i=start;i<rows.length;i++){
			const r=rows[i]; if(!r.length) continue; const name=(r[idxName]||'').trim(); if(!name){ skipped++; continue; }
			const grade=idxGrade>=0?(r[idxGrade]||''):''; const major=idxMajor>=0?(r[idxMajor]||''):''; const remark=idxRemark>=0?(r[idxRemark]||''):'';
			let student=findByName(name); if(!student){ student={ id:crypto.randomUUID?crypto.randomUUID():('id_'+Math.random().toString(36).slice(2)), name, grade, major, remark, archived:false, created_at:nowTs, updated_at:nowTs }; store.items.push(student); inserted++; } else { let changed=false; if(grade && grade!==student.grade){ student.grade=grade; changed=true;} if(major && major!==student.major){ student.major=major; changed=true;} if(remark && remark!==student.remark){ student.remark=remark; changed=true;} if(changed){ student.updated_at=nowTs; updated++; } }
			const dayCols=[idxMon,idxTue,idxWed,idxThu,idxFri]; dayCols.forEach((col,di)=>{ if(col<0) return; const cell=(r[col]||'').trim(); if(!cell) return; cell.split(/;|；/).forEach(seg=>{ seg=seg.trim(); if(!seg) return; if(!/^\d{1,2}:\d{2}-\d{1,2}:\d{2}$/.test(seg)){ slotInvalid++; return; } let [s,e]=seg.split('-'); const ns=s.padStart(5,'0'); const ne=e.padStart(5,'0'); if(ns>=ne){ slotInvalid++; return; } slotRows.push({ student_name:name, weekday:di+1, start_time:ns, end_time:ne }); slotTotal++; }); });
			if(i%400===0){ const p=Math.round(((i-start+1)/(rows.length-start))*15); setProg(`解析中... ${(i-start+1)}/${rows.length-start}`,p); await new Promise(r=>requestAnimationFrame(r)); }
		}
		const parseMs=Math.round(performance.now()-parseT0);
		setProg(`解析完成(${rows.length-start}行, 用时${parseMs}ms)，准备同步学生...`,18);
		save(); refreshUI(); refreshBTM();
		// 学生同步放后台，不阻塞进度条继续
		if(window.supabaseReady && window.supabaseClient){
			(async()=>{ try{ const rowsForCloud = store.items.map(s=>({ name:s.name, major:s.major||'', grade:s.grade||'' })); if(typeof syncStudentDatabaseToCloud==='function') await syncStudentDatabaseToCloud(rowsForCloud); }catch(e){ console.warn('[StudentLibrary] 学生信息同步异常', e); }})();
		}
		if(!window.supabaseClient){ setProg('无 Supabase 连接，仅本地更新',25); setTimeout(()=>prog.remove(),3000); alert(`导入完成(离线)。学生: 新增${inserted} 更新${updated} 跳过${skipped} 时间段${slotTotal} 无效${slotInvalid}`); return; }
		const t0=performance.now();
		const names=[...new Set(slotRows.map(r=>r.student_name))];
		setProg('删除旧时间段...',30);
		if(names.length){ const delRes=await supabaseClient.from('student_time_slots').delete().in('student_name', names); if(delRes.error){ setProg('删除失败: '+delRes.error.message,30); alert('删除旧时间段失败:'+delRes.error.message); return; } }
		setProg('写入新时间段准备中...',35);
		const allRows=slotRows.map(r=>{ const [sh,sm]=r.start_time.split(':').map(Number); const [eh,em]=r.end_time.split(':').map(Number); return { ...r, duration_minutes:(eh*60+em)-(sh*60+sm) }; });
		const total=allRows.length; const BATCH=600; let ok=0, fail=0; const errors=[]; let lastPercent=-1;
		for(let i=0;i<allRows.length;i+=BATCH){ const slice=allRows.slice(i,i+BATCH); const res=await supabaseClient.from('student_time_slots').insert(slice); if(res.error){ fail+=slice.length; errors.push(res.error.message); } else { ok+=slice.length; } const percent=Math.min(100,Math.round(((i+slice.length)/total)*100)); if(percent!==lastPercent){ // 将写入进度映射到 40%~95%
			const mapped=40 + Math.round(percent*0.55); setProg(`写入中 ${percent}% (${ok+fail}/${total})`, mapped); lastPercent=percent; } await new Promise(r=>requestAnimationFrame(r)); }
		const ms=Math.round(performance.now()-t0);
		setProg(`完成: 成功${ok} 失败${fail} 用时${ms}ms`+(errors.length? ' 错误:'+errors[0] : ''),100);
		setTimeout(()=>{ try{ prog.remove(); }catch(_){} }, 5000);
		if(window.BTM){ try{ await BTM.loadRemote(); BTM.buildSelections(); }catch(_){ } }
		alert(`导入完成: 学生 新增${inserted} 更新${updated} 跳过${skipped}; 时间段有效${slotTotal} 无效${slotInvalid}; 成功${ok} 失败${fail}` + (errors.length?`\n首条错误: ${errors[0]}`:''));
	}
	function openPanel(){ initDom(); if(!panel) return; panel.style.display='flex'; renderList(); updateTotal(); }
	// 修改 openPanel: 打开时尝试 hydration
	async function openPanel(){ 
		initDom(); if(!panel) return; panel.style.display='flex'; 
		const list=document.getElementById('slList'); 
		const showSkeleton=()=>{ if(!list) return; list.innerHTML=`<div style=\"display:flex;flex-direction:column;gap:8px;padding:4px;\">${Array.from({length:5}).map(()=>'<div style=\"height:44px;border:1px solid #e2e8f0;border-radius:8px;position:relative;overflow:hidden;background:linear-gradient(90deg,#f1f5f9,#e2e8f0,#f1f5f9);background-size:200% 100%;animation:slShine 1.15s infinite;\"></div>').join('')}<style>@keyframes slShine{0%{background-position:0 0}100%{background-position:-200% 0}}</style><div style=\"font-size:12px;color:#64748b;padding:4px 2px;\" id=\"slLoadingHint\">正在连接并加载学生数据...</div></div>`; };
		if(store.items.length===0) showSkeleton();
		// 并发触发 hydration
		try{ if(window.ensureStudentLibraryHydrated){ window.ensureStudentLibraryHydrated({ source:'open-panel' }); } }catch(_){ }
		// 若首次且为空：等待 supabaseReady 然后再拉一次
		if(store.items.length===0){
			await waitSupabaseReady(6000);
			try{ await loadFromCloud(); }catch(_){ }
			if(store.items.length===0){
				// 再做 2 次快速重试
				for(let i=1;i<=2 && store.items.length===0;i++){
					await new Promise(r=>setTimeout(r,300*i));
					try{ await loadFromCloud(); }catch(_){ }
				}
			}
		}
		// 最终渲染
		renderList(); updateTotal();
		const hint=document.getElementById('slLoadingHint'); if(hint && store.items.length===0){ hint.textContent='暂无学生数据，可手动添加或稍后重试'; }
	}
	function closePanel(){ if(panel) panel.style.display='none'; }
	function toggleAddForm(show){ if(!addForm) return; addForm.style.display=show?'flex':'none'; if(show){ const n=document.getElementById('slName'); n&&n.focus(); } }
	function updateTotal(){ const el=document.getElementById('slTotal'); if(el) el.textContent=getAll().length+' 人'; }
	function renderList(){ if(!listEl) return; const kw=(searchEl?.value||'').trim().toLowerCase(); const rows=getAll().filter(s=> !kw || s.name.toLowerCase().includes(kw) || (window.matchPinyin?matchPinyin(s.name,kw):false)); if(!rows.length){ listEl.innerHTML='<div style="padding:12px;color:#64748b;font-style:italic;">无数据</div>'; return;} listEl.innerHTML=rows.map(s=>{ return `<div class=\"sl-row\" data-name=\"${s.name}\" style=\"display:flex;flex-direction:column;gap:4px;padding:8px 10px;border:1px solid #e2e8f0;border-radius:8px;background:#fff;\">\n<div style=\"display:flex;align-items:center;gap:8px;\">\n<span style=\"font-weight:600;\">${s.name}</span><span style=\"font-size:11px;color:#475569;\">${s.major||'--'} · ${s.grade||'--'}</span>\n<span style=\"margin-left:auto;display:flex;gap:6px;\">\n<button data-act=\"edit\" class=\"sl-btn sl-btn-secondary sl-btn-mini\">编辑</button>\n<button data-act=\"delete\" class=\"sl-btn sl-btn-danger sl-btn-mini\">删除</button>\n</span></div>\n</div>`; }).join(''); listEl.querySelectorAll('.sl-row button').forEach(btn=>{ btn.onclick=()=>{ const act=btn.dataset.act; const name=btn.closest('.sl-row').dataset.name; if(!name) return; if(act==='delete'){ if(confirm('永久删除 '+name+' 及其时间段？此操作不可恢复')){ deleteStudent(name); try{ if(window.supabaseClient){ supabaseClient.from('student_time_slots').delete().eq('student_name', name); } }catch(_){} } } else if(act==='edit'){ openEditStudent(name); } }; }); }
	function refreshUI(){
		renderList(); updateTotal();
		// 若学生选择弹窗开启, 同步刷新里面的列表(调用上层 renderStudentList)
		try{ const modal=document.getElementById('studentModalBackdrop'); if(modal && modal.style.display==='flex' && typeof renderStudentList==='function'){ renderStudentList(); } }catch(_){ }
	}
	function bindGlobalButtons(){ if(!document.getElementById('openStudentLibraryBtn')){ const topBar=document.querySelector('header .top-actions')||document.querySelector('header'); if(topBar){ const btn=document.createElement('button'); btn.id='openStudentLibraryBtn'; btn.textContent='学生库'; btn.style.cssText='margin-left:8px;padding:6px 14px;background:#1e3a8a;color:#fff;border:1px solid #1e40af;border-radius:6px;cursor:pointer;font-size:13px;'; btn.onclick=openPanel; topBar.appendChild(btn);} } }
	function exportJSON(){} // 占位，不再暴露 JSON 导出
	document.addEventListener('DOMContentLoaded', async () => {
		// 等待 Supabase (若页面刚通过密码进入, 脚本初始化可能稍后完成)
		await waitSupabaseReady(6000);
		
		let cloudLoaded = false;
		try { cloudLoaded = await loadFromCloud(); } catch(_){ }
		
		if (!cloudLoaded) {
			console.log('[StudentLibrary] 首次云端未加载成功，尝试本地/迁移');
			load();
			migrateFromRoomStore();
		}
		
		// 首次完全空 -> 重试云端拉取（退避 5 次）
		if (store.items.length === 0) {
			console.log('[StudentLibrary] 首次列表为空，启动重试加载');
			for(let i=1;i<=5 && store.items.length===0;i++){
				await new Promise(r=>setTimeout(r, 400*i));
				if(!window.supabaseReady) continue;
				try{
					const ok = await loadFromCloud();
					if(ok && store.items.length>0){ console.log(`[StudentLibrary] 第 ${i} 次重试成功`); break; }
				}catch(e){ console.warn('[StudentLibrary] 重试加载异常', e.message); }
			}
			// 仍为空再做 hydration 兜底
			if(store.items.length===0 && window.ensureStudentLibraryHydrated){
				try{ await window.ensureStudentLibraryHydrated({ source:'retry-hydrate' }); }catch(_){ }
			}
		}
		
		// 初始化UI和绑定事件
		bindGlobalButtons(); 
		initDom(); 
		refreshUI(); 
		
		const openBtn=document.getElementById('openStudentLibraryBtn'); 
		if(openBtn && !openBtn.dataset.bound){ 
			openBtn.dataset.bound='1'; 
			openBtn.addEventListener('click', openPanel); 
		} 
		
		const closeBtn=document.getElementById('slCloseBtn'); 
		if(closeBtn) closeBtn.onclick=closePanel; 
		
		const addBtnEl=document.getElementById('slAddBtn'); 
		if(addBtnEl) addBtnEl.onclick=()=>toggleAddForm(true); 
		
		const cancel=document.getElementById('slCancelAdd'); 
		if(cancel) cancel.onclick=()=>toggleAddForm(false); 
		
		const submit=document.getElementById('slSubmitAdd'); 
		if(submit) submit.onclick=()=>{ 
			const nameEl=document.getElementById('slName'); 
			const gradeEl=document.getElementById('slGrade'); 
			const majorEl=document.getElementById('slMajor'); 
			const name=(nameEl.value||'').trim(); 
			if(!name){ 
				alert('姓名必填'); 
				nameEl.focus(); 
				return;
			} 
			try{ 
				addStudent({ name, grade:gradeEl.value.trim(), major:majorEl.value.trim() }); 
				nameEl.value=gradeEl.value=majorEl.value=''; 
				toggleAddForm(false);
			}catch(e){ 
				alert(e.message||e); 
			} 
		}; 
		
		if(searchEl) searchEl.oninput=()=>refreshUI(); 
		if(exportBtn) exportBtn.onclick=exportJSON; 
		
		const openBTM=document.getElementById('slOpenBTMBtn'); 
		if(openBTM) openBTM.onclick=()=>{ 
			if(window.openBulkTimeManager) openBulkTimeManager(); 
			else alert('BTM 未加载'); 
		}; 
		
		// 仅绑定含时间段 CSV 按钮
		const exportCsvSlotsBtn=document.getElementById('slExportCsvSlotsBtn'); 
		if(exportCsvSlotsBtn) exportCsvSlotsBtn.onclick=()=>exportCSVWithSlots();
		
		const importCsvSlotsBtn=document.getElementById('slImportCsvSlotsBtn'); 
		const importSlotsFile=document.getElementById('slImportCsvSlotsFile');
		if(importCsvSlotsBtn && importSlotsFile){ 
			importCsvSlotsBtn.onclick=()=>importSlotsFile.click(); 
			importSlotsFile.onchange=e=>{ 
				const file=e.target.files && e.target.files[0]; 
				if(!file) return; 
				const reader=new FileReader(); 
				reader.onload=async ev=>{ 
					try{ 
						await importCSVSlotsText(String(ev.target.result||'')); 
						importSlotsFile.value=''; 
					}catch(err){ 
						alert('导入失败: '+(err.message||err)); 
					} 
				}; 
				reader.readAsText(file,'utf-8'); 
			}; 
		}
		
		// 延迟再次尝试填充（如果仍然为空）
		setTimeout(async () => {
			if (store.items.length === 0) {
				console.log('[StudentLibrary] 延迟检查：学生库仍为空，再次尝试填充');
				if (window.seedStudentLibraryFromRoomStore) {
					window.seedStudentLibraryFromRoomStore({ reason: 'studentLibrary-post-init' });
				}
				// 再次尝试云端加载
				await loadFromCloud();
				refreshUI();
			}
		}, 1200);
	});
	// 手动同步学生数据功能
	window.manualSyncStudentData = async function() {
		if (!window.supabaseClient) {
			console.warn('Supabase 未连接');
			return;
		}
		
		try {
			console.log('开始手动同步学生数据...');
			
			// 获取云端最新数据
			const { data: cloudStudents, error } = await window.supabaseClient
				.from('student_database')
				.select('*')
				.order('updated_at', { ascending: false });
			
			if (error) {
				console.error('获取云端学生数据失败:', error);
				if (window.toast) window.toast('❌ 同步失败: ' + error.message, 'error');
				return;
			}
			
			let updated = 0;
			let added = 0;
			
			if (cloudStudents && cloudStudents.length > 0) {
				// 完全同步：清空本地数据，使用云端数据
				store.items = [];
				
				cloudStudents.forEach(cloudStudent => {
					const newStudent = {
						id: crypto.randomUUID ? crypto.randomUUID() : ('id_' + Math.random().toString(36).slice(2)),
						name: cloudStudent.name,
						grade: cloudStudent.grade || '',
						major: cloudStudent.major || '',
						remark: '',
						archived: false,
						created_at: cloudStudent.created_at ? new Date(cloudStudent.created_at).getTime() : now(),
						updated_at: cloudStudent.updated_at ? new Date(cloudStudent.updated_at).getTime() : now()
					};
					store.items.push(newStudent);
					added++;
				});
				
				// 保存到本地存储
				save();
				refreshUI();
				refreshBTM();
			}
			
			// 更新旧系统的 Store.students
			if (window.Store && Array.isArray(window.Store.students)) {
				window.Store.students.splice(0, window.Store.students.length);
				store.items.forEach(item => {
					window.Store.students.push({
						name: item.name,
						grade: item.grade,
						major: item.major
					});
				});
				if (window.rebuildStudentIndex) {
					window.rebuildStudentIndex();
				}
			}
			
			console.log(`学生数据同步完成: 同步了${added}个学生`);
			if (window.toast) {
				window.toast(`✅ 学生数据同步完成: 共${added}个学生`, 'success');
			}
			
		} catch (error) {
			console.error('学生数据同步失败:', error);
			if (window.toast) window.toast('❌ 学生数据同步失败', 'error');
		}
	};
	
	window.StudentLibrary={ addStudent, updateStudent, deleteStudent, list:getAll, refresh:refreshUI, _handleRemoteUpdate: handleRemoteUpdate };
})();
</script>

<script>
// ======= Practice Alerts (缺勤 / 异常) =======
(function(){
	console.log('[PracticeAlerts] IIFE 开始执行');
	// --- Practice Alerts 相关 SQL 维护指引（复制到 Supabase SQL Editor 执行，匿名 key 不能直接跑 DDL） ---
	/*
	-- 1. 字段与普通索引（幂等）
	ALTER TABLE public.practice_alerts ADD COLUMN IF NOT EXISTS severity integer;
	CREATE INDEX IF NOT EXISTS idx_practice_alerts_created_at ON public.practice_alerts(created_at DESC);
	CREATE INDEX IF NOT EXISTS idx_practice_alerts_student_type ON public.practice_alerts(student_name, type);

	-- 2. 旧唯一索引（若已存在需删除，允许被忽略后重新生成提醒）
	DROP INDEX IF EXISTS uniq_practice_alerts_day; -- 旧：不区分 ignored

	-- 3. 新条件唯一索引：只限制未忽略记录，ignored=true 后可再生成同组合新提醒
	CREATE UNIQUE INDEX IF NOT EXISTS uniq_practice_alerts_day_active
	ON public.practice_alerts (student_name, type, slot_start, slot_end, (date(created_at)))
	WHERE ignored = false;

	-- 回滚方式（若想恢复“忽略后不再出现”行为）
	-- DROP INDEX IF EXISTS uniq_practice_alerts_day_active;
	-- CREATE UNIQUE INDEX IF NOT EXISTS uniq_practice_alerts_day
	-- ON public.practice_alerts (student_name, type, slot_start, slot_end, (date(created_at)));
	*/

	// 已移除 UI 复制提醒索引 SQL 按钮
	if(window.PracticeAlerts) {
		console.log('[PracticeAlerts] 已存在，跳过初始化');
		return;
	}
		const AlertStore={ list:[], byId:new Map(), slotsToday:null, timer:null, lastSlotLoadDay:null, _lastPeriodicReload:0, dedupe:new Set(), silenced:new Map(), prevActive:new Map() };
		const ALERT_TYPES={ ABSENT:'absent', ANOMALY:'anomaly' };
		// 阈值可调（分钟）
		const THRESHOLDS={ ABSENT_WINDOW_START:5, ABSENT_WINDOW_END:15, ANOMALY_OVERRUN:15, ENDED_OVERRUN:30, ABSENT_PAST_GRACE:10, START_ABSENT_CONFIRM_DELAY:2 }; // ABSENT_PAST_GRACE: 过去 slot 结束后多少分钟仍允许补发缺勤; START_ABSENT_CONFIRM_DELAY: 开始窗口持续无重叠确认分钟数
	function now(){ return Date.now(); }
	function fmt(ts){ const d=new Date(ts); return d.toLocaleTimeString('zh-CN',{hour:'2-digit',minute:'2-digit'}); }
	function ensureSlotsLoaded(){ const todayKey=new Date().toDateString(); if(AlertStore.lastSlotLoadDay===todayKey && AlertStore.slotsToday) return Promise.resolve(); return loadTodaySlots(); }
	async function loadTodaySlots(){ if(!window.supabaseClient) return; const weekday=(new Date().getDay()+6)%7 +1; // 1-7; we only use 1-5
		try{ const {data,error}=await supabaseClient.from('student_time_slots').select('*').eq('weekday', weekday).order('start_time'); if(error){ console.warn('loadTodaySlots error', error); return; } const map={}; (data||[]).forEach(r=>{ if(!map[r.student_name]) map[r.student_name]=[]; map[r.student_name].push(r); }); AlertStore.slotsToday=map; AlertStore.lastSlotLoadDay=new Date().toDateString(); }catch(e){ console.error(e); }
	}
		function forceReloadSlots(){ AlertStore.lastSlotLoadDay=null; return ensureSlotsLoaded(); }
	function currentFilter(){ return AlertStore.filter||'all'; }
	function applyFilter(list){ const f=currentFilter(); if(f==='all') return list; if(f==='absent') return list.filter(a=>a.type==='absent'); if(f==='anomaly') return list.filter(a=>a.type==='anomaly'); return list; }
	function updateFilterButtons(){ document.querySelectorAll('.alert-filter-btn').forEach(b=>{ b.classList.toggle('act', b.dataset.filter===currentFilter()); }); }
	function renderAlerts(){ 
		console.log('[PracticeAlerts] renderAlerts 开始，AlertStore.list:', AlertStore.list.length);
		const box=document.getElementById('alertList'); 
		if(!box) {
			console.error('[PracticeAlerts] alertList 元素不存在！');
			return;
		}
		// 排序：最近时间段 -> 最远。优先使用 slot 结束时间（若无结束用开始），缺少 slot 用 created_at。
		const sorted=[...AlertStore.list].sort((a,b)=>{
			function slotKey(x){
				if(x.slot){
					// 结束时间优先，转换为今天分钟数；若只有 start_time 也用 start
					const et=x.slot.end_time||x.slot.start_time; 
					return timeStrToMinutes(et);
				}
				// 没有 slot：若有 created_at 用其时间戳；否则置极小
				return (x.created_at? new Date(x.created_at).getTime()/60000 : -1);
			}
			const ka=slotKey(a); const kb=slotKey(b);
			// 更大的(更晚的)排在前面 => 降序
			if(kb!==ka) return kb-ka;
			// 次级：同一时间段按 id 降序（新的在前）
			return (b.id||0)-(a.id||0);
		});
		const filtered=applyFilter(sorted); 
		console.log('[PracticeAlerts] 过滤后提醒数量:', filtered.length);
		if(!filtered.length){ 
			box.classList.add('alert-empty'); 
			box.innerHTML='暂无提醒'; 
			console.log('[PracticeAlerts] 显示：暂无提醒');
		} else { 
			box.classList.remove('alert-empty'); 
			box.innerHTML=filtered.map(a=>alertHtml(a)).join(''); 
			box.querySelectorAll('[data-act="ignore"]').forEach(btn=>{ btn.onclick=()=>ignoreAlert(btn.dataset.id); }); 
			console.log('[PracticeAlerts] 渲染了', filtered.length, '条提醒');
		} 
		updateFilterButtons(); 
	}
		function alertHtml(a){ 
			const tags=[`<span class="alert-tag type-${a.type}">${a.type==='absent'?'缺勤':'异常'}</span>`]; 
			if(a.slot){ 
				// 时间格式验证和修复
				let startTime = a.slot.start_time || '';
				let endTime = a.slot.end_time || '';
				
				// 如果时间格式不正确（如 "1" 而不是 "11:07"），尝试修复
				if(!/^\d{2}:\d{2}$/.test(startTime) && /^\d{1,2}$/.test(startTime)) {
					startTime = startTime.padStart(2, '0') + ':00';
				}
				if(!/^\d{2}:\d{2}$/.test(endTime) && /^\d{1,2}$/.test(endTime)) {
					endTime = endTime.padStart(2, '0') + ':00';
				}
				
				// 如果仍然不是正确格式，显示原始值
				const timeDisplay = (startTime && endTime) ? `${startTime}-${endTime}` : 
					(startTime || endTime || '时间异常');
				
				tags.push(`<span class="alert-tag slot-time">${timeDisplay}</span>`); 
			} 
			// 紧凑单行布局
			const msg = a._msg || buildAlertMessage(a) || '';
			return `<div class="alert-item ${a.type}${a.ignored?' ignored':''}" data-id="${a.id}" data-severity="${a.severity||0}" title="${escapeHtml(msg)}">
			<div class="alert-content">
				<div class="alert-student">${a.student_name||''}</div>
				<div class="alert-info">
					${tags.join('')}
					<span class="alert-time">${fmt(a.created_at||a.createdAt||Date.now())}</span>
				</div>
			</div>
			<div class="alert-actions">
				<button class="alert-btn ignore" data-act="ignore" data-id="${a.id}">${a.ignored?'已忽略':'忽略'}</button>
				${a.ignored?'<span class="alert-ignored-flag">已忽略</span>':''}
			</div>
		</div>`; 
		}
		async function ignoreAlert(id){ const a=AlertStore.byId.get(id); if(!a) return; if(a.ignored) return; a.ignored=true; // 本地先置位
			removeAlertLocal(id); renderAlerts();
			// 忽略后：设置当天静默，直到该生重新登记
			try{ setSilenced(a.student_name, a.type, a.slot||{start_time:a.slot_start,end_time:a.slot_end}); }catch(_e){}
			// 移除去重 key (允许忽略后再产生新提醒)
			try{ if(a.slot){ const k=`${a.student_name}|${a.type}|${a.slot.start_time}-${a.slot.end_time}|${(new Date()).toISOString().slice(0,10)}`; AlertStore.dedupe.delete(k); } }catch(_e){}
			// 本地广播（同浏览器其它标签页）
			try{ localStorage.setItem('practice_alerts_ignore_ping', JSON.stringify({id, t:Date.now()})); }catch(_e){}
			if(!window.supabaseClient) return; 
			try{ 
				console.log('[PracticeAlerts] 标记 ignored=true id=', id);
				const {data, error}=await supabaseClient.from('practice_alerts').update({ignored:true}).eq('id', id).select('id');
				if(error){ console.warn('ignore(update) fail', error); // 回滚恢复
					AlertStore.byId.set(String(id),a); AlertStore.list.unshift(a); renderAlerts(); 
				}else{
					console.log('[PracticeAlerts] 标记成功 rows=', data?.length||0);
					// 成功后通过 realtime UPDATE 其他端会自动移除；同时广播兜底
					try{ if(AlertStore._rtChannel){ AlertStore._rtChannel.send({type:'broadcast', event:'ignore', payload:{id}}); console.log('[PracticeAlerts][BC][ignore-update] 已发送广播 id=', id); } }catch(e){ console.warn('[PracticeAlerts][BC] send update 广播失败', e); }
				}
			}catch(e){ console.error(e); AlertStore.byId.set(String(id),a); AlertStore.list.unshift(a); renderAlerts(); }
	}

		// 一键忽略当前筛选条件下的所有提醒
		let _bulkIgnoreLock = false;
		async function ignoreAllAlerts() {
			if(_bulkIgnoreLock){ console.log('[PracticeAlerts] ignoreAll 已在执行'); return; }
			const sorted=[...AlertStore.list].sort((a,b)=>{
				function slotKey(x){
					if(x.slot){
						const et=x.slot.end_time||x.slot.start_time; 
						return timeStrToMinutes(et);
					}
					return (x.created_at? new Date(x.created_at).getTime()/60000 : -1);
				}
				const ka=slotKey(a); const kb=slotKey(b);
				if(kb!==ka) return kb-ka;
				return (b.id||0)-(a.id||0);
			});
			const candidates = applyFilter(sorted).filter(a=>!a.ignored);
			if(!candidates.length){ console.log('[PracticeAlerts] 一键忽略：无可忽略条目'); toast?.('没有可忽略的提醒'); return; }
			console.log('[PracticeAlerts] 一键忽略 开始 数量=', candidates.length);
			_bulkIgnoreLock = true;
			const todayStr=(new Date()).toISOString().slice(0,10);
			// 本地批量处理（一次渲染）
			for(const a of candidates){
				try{ a.ignored = true; removeAlertLocal(a.id); }catch(_e){}
				try{ setSilenced(a.student_name, a.type, a.slot||{start_time:a.slot_start,end_time:a.slot_end}); }catch(_e){}
				try{ if(a.slot){ const k=`${a.student_name}|${a.type}|${a.slot.start_time}-${a.slot.end_time}|${todayStr}`; AlertStore.dedupe.delete(k);} }catch(_e){}
			}
			try{ persistSilenced(); }catch(_e){}
			try{ localStorage.setItem('practice_alerts_ignore_ping', JSON.stringify({bulk: true, ids: candidates.map(c=>c.id), t:Date.now()})); }catch(_e){}
			renderAlerts();
			// 远端批量更新
			if(window.supabaseClient){
				try{
					const ids = candidates.map(c=>c.id);
					const {error} = await supabaseClient.from('practice_alerts').update({ignored:true}).in('id', ids);
					if(error){ console.warn('[PracticeAlerts] 批量忽略远端失败，回滚', error); // 回滚
						for(const a of candidates){ a.ignored=false; AlertStore.byId.set(String(a.id), a); AlertStore.list.push(a); }
						renderAlerts();
						toast?.('一键忽略失败');
					}else{
						// 广播每条，兼容现有 ignore 监听
						try{ if(AlertStore._rtChannel){ for(const id of ids){ AlertStore._rtChannel.send({type:'broadcast', event:'ignore', payload:{id}}); } } }catch(e){ console.warn('[PracticeAlerts][BC][bulk-ignore] 广播失败', e); }
						console.log('[PracticeAlerts] 一键忽略 成功 ids=', ids.length);
						toast?.(`已忽略 ${ids.length} 条提醒`);
					}
				}catch(e){ console.error('[PracticeAlerts] 批量忽略异常', e); toast?.('批量忽略异常'); }
			}
			_bulkIgnoreLock = false;
		}
		// ===== 对账：基于存在性（记录已 delete 即本地移除）======
		async function reconcileIgnored(){
			if(!window.supabaseClient) return; 
			if(!AlertStore.list.length) return; 
			try{
				const ids=AlertStore.list.map(a=>a.id);
				const {data,error}=await supabaseClient.from('practice_alerts').select('id').in('id', ids);
				if(error){ console.warn('[PracticeAlerts] reconcile query error', error); return; }
				const existSet=new Set((data||[]).map(r=>String(r.id)));
				const before=AlertStore.list.length;
				AlertStore.list=AlertStore.list.filter(a=> existSet.has(String(a.id)) );
				let removed=0; AlertStore.byId.forEach((_,k)=>{ if(!existSet.has(k)){ AlertStore.byId.delete(k); removed++; }});
				if(removed>0 || before!==AlertStore.list.length){ console.log('[PracticeAlerts] reconcileIgnored 修正本地缺失', removed, '条'); renderAlerts(); }
			}catch(e){ console.error('[PracticeAlerts] reconcileIgnored 异常', e); }
		}
		let _reconcileTimer=null; function scheduleReconcile(delay=0){ if(_reconcileTimer) clearTimeout(_reconcileTimer); _reconcileTimer=setTimeout(()=>{ reconcileIgnored(); }, delay); }
		// —— 静默控制：忽略后静默到“该生重新登记”为止 ——
		function todayKey(){ return (new Date()).toISOString().slice(0,10); }
		function silenceKey(stu,type,slot){ const d=todayKey(); const sp=slot?`${slot.start_time}-${slot.end_time}`:'none'; return `${d}|${stu}|${type}|${sp}`; }
		function setSilenced(stu,type,slot){ const k=silenceKey(stu,type,slot); AlertStore.silenced.set(k,true); try{ localStorage.setItem('practice_alerts_silence_ping', JSON.stringify({k,t:Date.now()})); }catch(_){} }
		// ---- 静默持久化支持 (A) ----
		function persistSilenced(){
			try{ const d=todayKey(); const list=Array.from(AlertStore.silenced.keys()).filter(k=>k.startsWith(d+'|')); localStorage.setItem('practice_alerts_silence_cache_'+d, JSON.stringify({d,list,ts:Date.now()})); }catch(e){ console.warn('[PracticeAlerts] persistSilenced fail', e); }
		}
		function restoreSilenced(){
			try{ const d=todayKey(); const raw=localStorage.getItem('practice_alerts_silence_cache_'+d); if(!raw) return; const obj=JSON.parse(raw); if(!obj||obj.d!==d||!Array.isArray(obj.list)) return; for(const k of obj.list){ AlertStore.silenced.set(k,true); } console.log('[PracticeAlerts] 恢复本地静默条目数', obj.list.length); }catch(e){ console.warn('[PracticeAlerts] restoreSilenced fail', e); }
		}
		// 包装 setSilenced 以自动持久化
		const __origSetSilenced = setSilenced; setSilenced = function(stu,type,slot){ __origSetSilenced(stu,type,slot); persistSilenced(); };
		function clearSilenced(stu,type,slot){ const k=silenceKey(stu,type,slot); AlertStore.silenced.delete(k); try{ localStorage.setItem('practice_alerts_silence_clear', JSON.stringify({k,t:Date.now()})); }catch(_){} }
		function clearSilencedForStudent(stu){ const d=todayKey(); const prefix=`${d}|${stu}|`; for(const k of Array.from(AlertStore.silenced.keys())){ if(k.startsWith(prefix)) AlertStore.silenced.delete(k); } }
		function isSilenced(stu,type,slot){ const k=silenceKey(stu,type,slot); return AlertStore.silenced.has(k); }
		// 本地存储广播监听（同源多标签页）
		window.addEventListener('storage', e=>{ 
			if(e.key==='practice_alerts_ignore_ping'){ scheduleReconcile(500); }
			if(e.key==='practice_alerts_silence_ping'){
				try{ const p=JSON.parse(e.newValue||'null'); if(p&&p.k){ AlertStore.silenced.set(p.k,true); } }catch(_){ }
			}
			if(e.key==='practice_alerts_silence_clear'){
				try{ const p=JSON.parse(e.newValue||'null'); if(p&&p.k){ AlertStore.silenced.delete(p.k); } }catch(_){ }
			}
		});
	async function fetchExistingAlerts(){ 
		console.log('[PracticeAlerts] fetchExistingAlerts 开始');
		if(!window.supabaseClient) {
			console.warn('[PracticeAlerts] supabaseClient 不存在');
			return;
		}
		try{ 
				const since=new Date(); since.setHours(0,0,0,0); 
				console.log('[PracticeAlerts] 查询今日提醒，since:', since.toISOString());
				// 拉取当天全部提醒 (A+B: 包含 ignored, 用于重建静默)
				const {data,error}=await supabaseClient.from('practice_alerts')
					.select('*')
					.gte('created_at', since.toISOString())
					.order('created_at',{ascending:false})
					.limit(400); 
			if(error){ 
				console.warn('[PracticeAlerts] fetch alerts error', error); 
				if(error.code === '42P01') {
					console.error('[PracticeAlerts] practice_alerts 表不存在！');
				}
				return;
			} 
			console.log('[PracticeAlerts] 获取到提醒数据:', data?.length || 0, '条');
			AlertStore.list=(data||[]).filter(a=>!a.ignored).map(a => {
				// 修复字段映射：数据库的 slot_start/slot_end → 前端的 start_time/end_time
				a.slot = a.slot_start && a.slot_end ? {
					start_time: a.slot_start,
					end_time: a.slot_end
				} : null;
				return a;
			}); 
			AlertStore.byId.clear(); 
			AlertStore.list.forEach(a=>AlertStore.byId.set(String(a.id),a)); 
			// 将 ignored 记录静默化 (B)
			try{ const ignoredList=(data||[]).filter(a=>a.ignored); for(const ig of ignoredList){ if(ig.slot_start&&ig.slot_end){ setSilenced(ig.student_name, ig.type, {start_time:ig.slot_start,end_time:ig.slot_end}); } else { setSilenced(ig.student_name, ig.type, null); } } if(ignoredList.length) console.log('[PracticeAlerts] 已从服务端 ignored 恢复静默数', ignoredList.length); }catch(e){ console.warn('[PracticeAlerts] ignored->silenced 恢复失败', e); }
			console.log('[PracticeAlerts] AlertStore.list 长度:', AlertStore.list.length);
			AlertStore._lastFullReload = Date.now();
			persistSilenced();
			renderAlerts(); 
		}catch(e){ 
			console.error('[PracticeAlerts] fetchExistingAlerts 异常:', e); 
		}
	}
		function getActivePractice(student){ // approximate current ongoing log
				// 优先使用 practiceLogs（如果有后台写入）
				if(window.practiceLogs){
					const nowTs=Date.now();
					const found=(practiceLogs[student]||[]).find(l=>!l.end_time && nowTs - (new Date(l.start_time).getTime()) < 6*60*60*1000);
					if(found) return found;
				}
				// 回退：根据当前房间占用推断（无日志情况下）
				for(const r of Store.rooms){ if(r.occupant_student_name===student && r.registerTime){
					return { start_time:new Date(r.registerTime).toISOString(), room:r.name, pseudo:true };
				} }
				return null;
			}
		function anyPracticeLogs(student){ if(!window.practiceLogs) return []; return practiceLogs[student]||[]; }
		function timeStrToMinutes(t){ const [h,m]=t.split(':').map(Number); return h*60+m; }
		function minutesNow(){ const d=new Date(); return d.getHours()*60 + d.getMinutes(); }
		// 判断是否有任意练琴日志与 slot 时间段重叠（开始早于 slot 结束，结束晚于 slot 开始）
		function hasPracticeOverlap(student, slot){
			const slotStart=toMinutes(slot.start_time); const slotEnd=toMinutes(slot.end_time);
			// 1) 先看已知练琴日志
			const logs=anyPracticeLogs(student) || []; 
			const logOverlap = logs.some(l=>{
				const startMs=new Date(l.start_time).getTime();
				const endMs = l.end_time ? new Date(l.end_time).getTime() : Date.now();
				const sMin = new Date(startMs).getHours()*60 + new Date(startMs).getMinutes();
				const eMin = new Date(endMs).getHours()*60 + new Date(endMs).getMinutes();
				return sMin < slotEnd && eMin >= slotStart; // 包含式判定，修正边界
			});
			if(logOverlap) return true;
			// 2) 无日志时，兼容实时占用：将“当前占用”视作一条 [registerTime, now] 的临时会话
			const active = getActivePractice(student);
			if(active){
				const startMs=new Date(active.start_time).getTime();
				const endMs = Date.now();
				const sMin = new Date(startMs).getHours()*60 + new Date(startMs).getMinutes();
				const eMin = new Date(endMs).getHours()*60 + new Date(endMs).getMinutes();
				if(sMin < slotEnd && eMin >= slotStart) return true;
			}
			return false;
			function toMinutes(t){ const [h,m]=t.split(':').map(Number); return h*60+m; }
		}
		function slotAt(student){ const arr=AlertStore.slotsToday?.[student]; if(!arr) return null; const nowMin=minutesNow(); return arr.find(s=>{ const st=timeStrToMinutes(s.start_time); const et=timeStrToMinutes(s.end_time); return nowMin>=st && nowMin<=et; }); }
		function nextSlot(student){ const arr=AlertStore.slotsToday?.[student]; if(!arr) return null; const nowMin=minutesNow(); return arr.find(s=> timeStrToMinutes(s.start_time) > nowMin ); }
		function findSlotByStart(student, activeLog){ // 根据活动日志开始时间所属 slot - 使用重叠判断
			if(!activeLog) return null; 
			const arr=AlertStore.slotsToday?.[student]; 
			if(!arr) return null; 
			const stTime=new Date(activeLog.start_time); 
			const practiceStartMin=stTime.getHours()*60+stTime.getMinutes(); 
			// 假设练琴至少持续1分钟来检查重叠
			const practiceEndMin = activeLog.end_time ? 
				(new Date(activeLog.end_time).getHours()*60 + new Date(activeLog.end_time).getMinutes()) : 
				(practiceStartMin + 1);
			return arr.find(s=>{ 
				const sMin=timeStrToMinutes(s.start_time); 
				const eMin=timeStrToMinutes(s.end_time); 
				// 使用重叠判断：练琴开始时间 < 时间段结束 && 练琴结束时间 > 时间段开始
				return practiceStartMin < eMin && practiceEndMin > sMin; 
			})||null; 
		}
		function anomalyShouldTrigger(student, activeLog){ // 逻辑：若当前仍占用且超过所属 slot 结束 + 阈值，且“当前不在该学生任意一个时段内”
				if(!activeLog) return false;
				const arr=AlertStore.slotsToday?.[student]||[]; 
				if(arr.length===0) return false; // 无时段，不触发
				const nowMin=minutesNow();
				// 当前在任一时段内，则不异常
				if(arr.some(s=>{ const sMin=timeStrToMinutes(s.start_time); const eMin=timeStrToMinutes(s.end_time); return nowMin>=sMin && nowMin<=eMin; })) return false;
				// 找到“已结束且最接近当前时间”的最后一个时段
				let last=null, lastEnd=-1; 
				for(const s of arr){ const e=timeStrToMinutes(s.end_time); if(e<=nowMin && e>lastEnd){ last=s; lastEnd=e; } }
				if(!last) return false; // 在首个时段之前，不触发
				// 超过最后一个已结束时段 15 分钟仍在练琴，判为异常
				return nowMin > lastEnd + THRESHOLDS.ANOMALY_OVERRUN; 
		}
		// 返回用于生成异常提醒的参考时段（若不应触发则返回 null）
		function getReferenceAnomalySlot(student, activeLog){
			if(!anomalyShouldTrigger(student, activeLog)) return null;
			const arr=AlertStore.slotsToday?.[student]||[]; const nowMin=minutesNow();
			let last=null, lastEnd=-1; for(const s of arr){ const e=timeStrToMinutes(s.end_time); if(e<=nowMin && e>lastEnd){ last=s; lastEnd=e; } }
			return last; // 可能为 null
		}
		let _lastDetectionDate=(new Date()).toDateString();
		// 记录“开始窗口内首次判定为无重叠”的时间戳，键: `${student}|${slot.start_time}-${slot.end_time}`
		const _startWindowNoOverlapSeen = new Map();
		// 观察到“该生在该时段有过任意重叠练琴”的标记（当天生效），一旦成立，永久不再对该时段生成缺勤
		const _presentSeen = new Set();
		function presentKey(stu,slot){ const d=(new Date()).toISOString().slice(0,10); return `${d}|${stu}|${slot.start_time}-${slot.end_time}`; }
		async function detectionTick(){ // 顺序: 跨日重置 -> 确保slots -> 周期刷新 -> 缺勤 -> 活动超时 -> 结束超时
			if(AlertStore.recalcLock){
				return; // 重算期间暂停检测
			}
			if(!window.supabaseClient) return; const todayStr=(new Date()).toDateString(); if(todayStr!==_lastDetectionDate){ // 跨日：重置slots与当日alerts缓存
			_lastDetectionDate=todayStr; AlertStore.slotsToday=null; AlertStore.lastSlotLoadDay=null; await fetchExistingAlerts(); }
				// 补偿：每5分钟强制刷新未忽略提醒，防止错过 UPDATE 事件导致另一端已忽略却仍显示
				if(!AlertStore._lastFullReload || (Date.now()-AlertStore._lastFullReload) > 5*60*1000){
					console.log('[PracticeAlerts] 触发周期性全量刷新 (5min)');
					await fetchExistingAlerts();
				}
				// 小频率对账：每次 tick 后排一个延迟对账（避免高并发立刻多次请求）
				scheduleReconcile(4000);
			await ensureSlotsLoaded(); const nowMin=minutesNow(); const students=Object.keys(AlertStore.slotsToday||{});
			// 周期刷新：每10分钟强制 (分钟数 %10 ==0) 且距离上次>2分钟，避免同一分钟多次
			const minute=new Date().getMinutes(); if(minute%10===0 && (now()-AlertStore._lastPeriodicReload)>120000){ forceReloadSlots().then(()=>{ AlertStore._lastPeriodicReload=now(); }); }
			for(const name of students){ 
				const arr=AlertStore.slotsToday[name]; 
				if(!arr||!arr.length) continue; 
				// 检测注册边沿：无到有，视为“重新登记”，清理该生的静默
				const wasActive = AlertStore.prevActive.get(name) === true;
				const activeLogEdge = getActivePractice(name);
				const activeNowForEdge = !!activeLogEdge;
				if(!wasActive && activeNowForEdge){
					// 仅清除当前活跃会话对应时段键（absent/anomaly）
					let curSlot=null; 
					const nowM=minutesNow();
					// 1) 优先根据 active.start_time 落在哪个 slot
					if(activeLogEdge){ 
						const stDate=new Date(activeLogEdge.start_time); const stM=stDate.getHours()*60+stDate.getMinutes();
						curSlot = arr.find(s=>{ const sM=timeStrToMinutes(s.start_time), eM=timeStrToMinutes(s.end_time); return stM>=sM && stM<=eM; }) || null;
					}
					// 2) 若未命中，使用当前时间落在哪个 slot
					if(!curSlot){ curSlot = arr.find(s=>{ const sM=timeStrToMinutes(s.start_time), eM=timeStrToMinutes(s.end_time); return nowM>=sM && nowM<=eM; }) || null; }
					if(curSlot){
						try{ clearSilenced(name,'absent',curSlot); }catch(_){ }
						try{ clearSilenced(name,'anomaly',curSlot); }catch(_){ }
					}
				}
				AlertStore.prevActive.set(name, activeNowForEdge);
				// 缺勤：时段开始窗口 + 过去补发
				for(const slot of arr){ 
					const st=timeStrToMinutes(slot.start_time); 
					const et=timeStrToMinutes(slot.end_time);
					// 若已观察到该时段出现过重叠，则之后不再对该时段生成缺勤
					const pk = presentKey(name,slot);
					// 即时检测当前是否有重叠（含占用兜底），若有则打标
					if(!_presentSeen.has(pk) && hasPracticeOverlap(name,slot)) _presentSeen.add(pk);
					if(nowMin>=st+THRESHOLDS.ABSENT_WINDOW_START && nowMin<=st+THRESHOLDS.ABSENT_WINDOW_END){ 
						// 若学生当前正处于本时段并在练琴（跨段连续练琴场景），不应判为缺勤
						const activeNow = getActivePractice(name);
						if(!(activeNow && nowMin>=st && nowMin<=et)){
							if(_presentSeen.has(pk)) continue; // 曾出现过重叠 -> 永不缺勤
							const key = `${name}|${slot.start_time}-${slot.end_time}`;
							const overlapNow = hasPracticeOverlap(name,slot);
							if(overlapNow){
								// 一旦出现重叠，清除可能存在的无重叠标记
								_startWindowNoOverlapSeen.delete(key);
								_presentSeen.add(pk);
							}else if(!hasAlert(name,'absent',slot) && !isSilenced(name,'absent',slot)){
								const firstSeen = _startWindowNoOverlapSeen.get(key);
								const nowTs = Date.now();
								if(!firstSeen){
									// 记录首次无重叠时间点，等待确认期
									_startWindowNoOverlapSeen.set(key, nowTs);
								}else{
									// 需要持续无重叠达到确认阈值才创建缺勤，减少数据新鲜度竞态误报
									const elapsedMin = (nowTs - firstSeen) / 60000;
									if(elapsedMin >= (THRESHOLDS.START_ABSENT_CONFIRM_DELAY||2)){
										await createAlert({type:ALERT_TYPES.ABSENT, student_name:name, slot, message:`${slot.start_time} 时段未登记`, severity:2});
									}
								}
							}
						}
					}else if(nowMin>et && nowMin<=et+THRESHOLDS.ABSENT_PAST_GRACE){
						if(!hasAlert(name,'absent',slot) && !isSilenced(name,'absent',slot) && !_presentSeen.has(pk) && !hasPracticeOverlap(name,slot)){
							await createAlert({type:ALERT_TYPES.ABSENT, student_name:name, slot, message:`${slot.start_time}-${slot.end_time} 时段缺勤`, severity:2});
						}
					}
				}
				// 自动消失：如果已有缺勤提醒但现在时段内有练琴，则删除缺勤提醒
				const existingAbsentAlerts = AlertStore.list.filter(a => a.student_name === name && a.type === 'absent');
				for(const alert of existingAbsentAlerts) {
					if(alert.slot && hasPracticeOverlap(name, alert.slot)) {
						// 一旦出现重叠，清理对应起始窗口无重叠标记
						const k = `${name}|${alert.slot.start_time}-${alert.slot.end_time}`;
						_startWindowNoOverlapSeen.delete(k);
						await autoResolveAlert(alert.id, `${alert.slot.start_time} 时段已开始练琴`);
					}
				}
				// 异常：活动仍在
				const active=getActivePractice(name); 
				if(active){
					const refSlot = getReferenceAnomalySlot(name, active);
					if(refSlot && !hasAlert(name,'anomaly',refSlot) && !isSilenced(name,'anomaly',refSlot)){
						console.log('[PracticeAlerts] 触发异常提醒', name, refSlot.start_time, refSlot.end_time);
						await createAlert({type:ALERT_TYPES.ANOMALY, student_name:name, slot:refSlot, message:`练琴已超过该时段 (${refSlot.end_time}) ${THRESHOLDS.ANOMALY_OVERRUN} 分钟`, severity:1}); 
					}
					if(active.pseudo && !window.practiceLogs){
						window.practiceLogs = window.practiceLogs || {}; 
						const arr2 = window.practiceLogs[name] || (window.practiceLogs[name]=[]);
						if(!arr2.some(l=>l.pseudo && !l.end_time)){
							arr2.push({start_time:active.start_time, room:active.room, pseudo:true});
						}
					}
				}
			} // end students loop
		} // end detectionTick

		// ==== 今日重算并覆盖云端 practice_alerts ====
		async function recalcToday(full=false){
			if(!window.supabaseClient){ console.warn('[PracticeAlerts][Recalc] no supabaseClient'); return; }
			if(AlertStore.recalcLock){ console.warn('[PracticeAlerts][Recalc] already running'); return; }
			AlertStore.recalcLock = true;
			console.log('[PracticeAlerts][Recalc] 开始');
			const startedAt = Date.now();
			try{
				// 1. 准备数据
				const today = new Date(); today.setHours(0,0,0,0); const todayIso = today.toISOString();
				const weekday=(new Date().getDay()+6)%7 +1; // 1-7
				const {data:slotRows, error:slotErr}=await supabaseClient.from('student_time_slots').select('*').eq('weekday', weekday);
				if(slotErr){ console.error('[PracticeAlerts][Recalc] slot fetch error', slotErr); return; }
				const slotsMap={}; (slotRows||[]).forEach(s=>{ (slotsMap[s.student_name] ||= []).push(s); });
				Object.values(slotsMap).forEach(arr=>arr.sort((a,b)=>a.start_time.localeCompare(b.start_time)));
				// ---- 获取练琴日志：兼容多版本列名 (start_time/end_time 或 session_start/session_end) ----
				let logRows=[]; let logErr=null; let variantUsed=null;
				const variants=[
					{start:'start_time', end:'end_time'},
					{start:'session_start', end:'session_end'}
				];
				for(const v of variants){
					try{
						let q=supabaseClient.from('practice_logs').select(`student_name,${v.start},${v.end}`);
						q=q.gte(v.start, todayIso);
						const {data:eRows, error:eErr}=await q;
						if(eErr){ logErr=eErr; continue; }
						if(eRows && eRows.length){ logRows=eRows; variantUsed=v; break; }
						// 若无数据尝试下一个变体
					}catch(e){ logErr=e; }
				}
				if(!variantUsed){
					console.warn('[PracticeAlerts][Recalc] 未匹配到含数据的列名变体，最后错误=', logErr); 
				}else{
					console.log('[PracticeAlerts][Recalc] 使用日志列变体', variantUsed);
				}
				// 归一化日志 -> {student_name, start_time, end_time}
				const logsByStu={};
				for(const raw of (logRows||[])){
					const stu=(raw.student_name||'').trim();
					const sCol=variantUsed? variantUsed.start : 'start_time';
					const eCol=variantUsed? variantUsed.end : 'end_time';
					const sVal=raw[sCol]; const eVal=raw[eCol];
					if(!sVal) continue; // 没有开始时间无法参与重叠
					(constArr => { constArr.push({student_name:stu,start_time:sVal,end_time:eVal}); })( (logsByStu[stu] ||= []) );
				}
				// 合并：同一 start_time 若同时存在已结束与未结束，会优先保留已结束（避免“幽灵未结束”导致整上午被视为仍在练琴）
				for(const stu of Object.keys(logsByStu)){
					const grouped = new Map();
					for(const l of logsByStu[stu]){
						const key=l.start_time; const prev=grouped.get(key);
						if(!prev) grouped.set(key,l);
						else{
							// 选择策略：优先 end_time 存在的；若都无 end_time 取最早（保持原）
							if(prev.end_time) continue; // 已有结束的，不替换
							if(l.end_time){ grouped.set(key,l); }
						}
					}
					logsByStu[stu] = Array.from(grouped.values());
				}
				console.log('[PracticeAlerts][Recalc] slots 学生数=', Object.keys(slotsMap).length, 'logs 条数(规范化)=', logRows?.length||0);
				// 2. 生成候选
				const now=new Date(); const nowMin=now.getHours()*60+now.getMinutes();
				const alerts=[]; const dedupe=new Set();
				function toMin(t){ const [h,m]=t.split(':').map(Number); return h*60+m; }
				// 复用页面实时逻辑：重叠条件与 hasPracticeOverlap 保持一致 (sMin < slotEnd && eMin >= slotStart)
				function overlap(slot,log){
					const sS=toMin(slot.start_time), sE=toMin(slot.end_time);
					const stDate=new Date(log.start_time); const enDate = log.end_time? new Date(log.end_time): now;
					const sM=stDate.getHours()*60+stDate.getMinutes();
					const eM=enDate.getHours()*60+enDate.getMinutes();
					return sM < sE && eM >= sS; // 修正 >= 边界
				}
				const T=THRESHOLDS || {ABSENT_WINDOW_START:5,ABSENT_WINDOW_END:15,ABSENT_PAST_GRACE:25, ANOMALY_OVERRUN:15};
				let absentCount=0, anomalyCount=0;
				for(const student of Object.keys(slotsMap)){
					const slots=slotsMap[student]; const logs=logsByStu[student]||[];
					for(let i=0;i<slots.length;i++){
						const slot=slots[i]; const st=toMin(slot.start_time), et=toMin(slot.end_time);
						const hasOverlap = logs.some(l=>overlap(slot,l));
						// 调试：打印跨段长会话与该 slot 的判断（仅在需要时可注释）
						// console.debug('[Recalc][OverlapDebug]', student, slot.start_time, slot.end_time, 'hasOverlap=', hasOverlap);
						if(!hasOverlap){
							const inStartWindow = nowMin>=st+T.ABSENT_WINDOW_START && nowMin<=st+T.ABSENT_WINDOW_END;
							// full=false: 结束后只要无重叠都视为缺勤（放宽），full=true 保留旧 grace
							const endedAndNoOverlap = nowMin>et && (!full ? true : nowMin<=et+T.ABSENT_PAST_GRACE);
							if(inStartWindow || endedAndNoOverlap){
								const key=`${student}|absent|${slot.start_time}-${slot.end_time}`;
								// 增加静默判断：若该学生该时段缺勤已被忽略（静默），则不再生成
								if(!dedupe.has(key) && !isSilenced(student,'absent', {start_time:slot.start_time,end_time:slot.end_time})){
									dedupe.add(key);
									alerts.push({student_name:student,type:'absent',slot_start:slot.start_time,slot_end:slot.end_time});
									absentCount++;
								}
							}
						}else{
							// 异常：若当前有进行中会话，且超出“最后一个已结束的练琴时段”15分钟，且当前不处于任何时段，则按该最后时段记异常
							const hasActive = logs.some(l=>!l.end_time);
							if(hasActive){
								const inAnySlot = slots.some(s=>{ const sM=toMin(s.start_time), eM=toMin(s.end_time); return nowMin>=sM && nowMin<=eM; });
								if(!inAnySlot){
									// 找到该学生最后一个已结束的时段
									let last=null, lastEnd=-1; for(const s of slots){ const e=toMin(s.end_time); if(e<=nowMin && e>lastEnd){ last=s; lastEnd=e; } }
									if(last && nowMin > lastEnd + T.ANOMALY_OVERRUN){
										const key=`${student}|anomaly|${last.start_time}-${last.end_time}`;
										if(!dedupe.has(key) && !isSilenced(student,'anomaly',{start_time:last.start_time,end_time:last.end_time})){
											dedupe.add(key);
											alerts.push({student_name:student,type:'anomaly',slot_start:last.start_time,slot_end:last.end_time});
											anomalyCount++;
										}
									}
								}
							}
						}
					}
				}
				console.log('[PracticeAlerts][Recalc] 生成候选', alerts.length, '缺勤=', absentCount, '异常=', anomalyCount, 'full=', full);
				// 3. 覆盖：删除今日旧数据
				const {error:delErr}=await supabaseClient.from('practice_alerts').delete().gte('created_at', todayIso);
				if(delErr){ console.error('[PracticeAlerts][Recalc] 删除旧提醒失败', delErr); return; }
				// 4. 批量插入
				const batch=120; for(let i=0;i<alerts.length;i+=batch){ const slice=alerts.slice(i,i+batch); const {error:insErr}=await supabaseClient.from('practice_alerts').insert(slice); if(insErr){ console.error('[PracticeAlerts][Recalc] 插入失败 batch', i, insErr); return; } }
				console.log('[PracticeAlerts][Recalc] 写入完成 用时(ms)=', Date.now()-startedAt);
				// 5. 重新拉取渲染
				await fetchExistingAlerts();
			}finally{
				AlertStore.recalcLock=false;
			}
		}
	function hasAlert(student,type,slot){ return AlertStore.list.some(a=> a.student_name===student && a.type===type && a.slot && slot && a.slot.start_time===slot.start_time && !a.resolved ); }
	async function autoResolveAlert(id, reason) {
		const a = AlertStore.byId.get(String(id));
		if (!a) return;
		// 本地移除
		removeAlertLocal(id);
		renderAlerts();
		// 服务端标记为 resolved 或删除
		if (!window.supabaseClient) return;
		try {
			const {error} = await supabaseClient.from('practice_alerts').delete().eq('id', id);
			if (error) {
				console.warn('auto resolve alert delete fail', error);
				// 回滚
				AlertStore.byId.set(String(id), a);
				AlertStore.list.unshift(a);
				renderAlerts();
			}
		} catch(e) {
			console.error(e);
			AlertStore.byId.set(String(id), a);
			AlertStore.list.unshift(a);
			renderAlerts();
		}
	}
		function dedupeKey(raw){ const dKey=(new Date()).toISOString().slice(0,10); const slotPart=raw.slot?`${raw.slot.start_time}-${raw.slot.end_time}`:'none'; return `${raw.student_name}|${raw.type}|${slotPart}|${dKey}`; }
		function markDedupe(key){ AlertStore.dedupe.add(key); setTimeout(()=>AlertStore.dedupe.delete(key), 60*60*1000); }
		async function createAlert(raw){ 
				const key=dedupeKey(raw); if(AlertStore.dedupe.has(key)) return; 
				
				// 调试日志：记录 slot 数据
				if(raw.slot) {
					console.log('[PracticeAlerts] createAlert slot data:', {
						student_name: raw.student_name,
						type: raw.type,
						slot_start_time: raw.slot.start_time,
						slot_end_time: raw.slot.end_time,
						slot_data: raw.slot
					});
				}
				
				// 服务器表无 message 字段：仅存结构化字段
				const payload={ 
					student_name:raw.student_name, 
					type:raw.type, 
					slot_start:raw.slot?raw.slot.start_time:null, 
					slot_end:raw.slot?raw.slot.end_time:null, 
					ignored:false, 
					severity:typeof raw.severity==='number'?raw.severity:null 
				};
				if(!supabaseClient) return; 
				// 先做同日存在性检查，避免跨端刚忽略后又因本端 tick 立即插入
				try{
					const since=new Date(); since.setHours(0,0,0,0);
					let qry=supabaseClient.from('practice_alerts')
						.select('id')
						.gte('created_at', since.toISOString())
						.eq('student_name', payload.student_name)
						.eq('type', payload.type)
						.eq('ignored', false);
					if(payload.slot_start!=null) qry = qry.eq('slot_start', payload.slot_start);
					if(payload.slot_end!=null) qry = qry.eq('slot_end', payload.slot_end);
					const {data:exists, error:exErr} = await qry.limit(1);
					if(!exErr && exists && exists.length){ markDedupe(key); return; }
				}catch(ex){ console.warn('[PracticeAlerts] existence check fail, continue insert', ex); }
				try{ 
					const {data,error}=await supabaseClient.from('practice_alerts').insert(payload).select(); 
					if(error){ 
						if(error.code==='23505'){ // 唯一约束冲突，静默忽略
							markDedupe(key); return; 
						}
						console.warn('create alert fail', error); return;
					}
					if(!data || !Array.isArray(data) || data.length===0){
						console.debug('[PracticeAlerts] insert returned no row; will rely on realtime INSERT');
						markDedupe(key); return;
					}
					const rec=data[0]; 
					if(!rec){
						console.warn('[PracticeAlerts] insert returned undefined row; skip local add');
						markDedupe(key); return;
					}
					rec.slot={start_time:payload.slot_start,end_time:payload.slot_end}; 
					if(typeof payload.severity!=='undefined') rec.severity=payload.severity; 
					// 前端动态生成 message 文案
					rec._msg = raw.message || buildAlertMessage(rec);
					AlertStore.list.unshift(rec); 
					AlertStore.byId.set(String(rec.id),rec); 
					markDedupe(key); trimAlerts(); renderAlerts(); 
				}catch(e){ console.error(e); }
	}
	function trimAlerts(){ if(AlertStore.list.length>300){ AlertStore.list.length=300; } }
	// 💡 练习时间检测频率优化 - 从1分钟延长到5分钟
	function startTimer(){ 
		if(AlertStore.timer) return; 
		const DETECTION_INTERVAL = 300000; // 5分钟间隔，减少服务器请求
		logInfo(`练习时间检测启动，间隔${DETECTION_INTERVAL/60000}分钟`);
		AlertStore.timer=setInterval(detectionTick, DETECTION_INTERVAL); 
	}
		function removeAlertLocal(id){ const idx=AlertStore.list.findIndex(i=>String(i.id)===String(id)); if(idx>=0) AlertStore.list.splice(idx,1); AlertStore.byId.delete(String(id)); }
		function buildAlertMessage(a){
			if(a.type==='absent'){
				return `${a.slot_start||a.slot?.start_time||''} 时段未登记`;
			}
			if(a.type==='anomaly'){
				return `已超过结束时间 ${(a.slot_end||a.slot?.end_time||'')}`;
			}
			return '';
		}
		function setupRealtime(){ 
			if(!window.supabaseClient) return; 
			// 防抖：已有连接在进行中就不重复
			if(AlertStore._rtConnecting) return; 
			AlertStore._rtConnecting = true;
			const MAX_RETRIES = 12;
			AlertStore._rtRetry = AlertStore._rtRetry || 0;
			try{ 
				if(AlertStore._rtChannel){
					try{ supabaseClient.removeChannel(AlertStore._rtChannel); }catch(_e){}
				}
				const channel=supabaseClient.channel('realtime-practice-alerts', { config: { broadcast: { self: false } } });
				AlertStore._rtChannel = channel;
				channel.on('broadcast', {event: 'ignore'}, payload => {
					const id = payload.payload?.id;
					console.log('[PracticeAlerts][BC][ignore] 收到广播 id=', id);
					if(id!=null){ removeAlertLocal(id); renderAlerts(); }
				});
				channel
					.on('postgres_changes',{event:'INSERT',schema:'public',table:'practice_alerts'}, payload=>{ 
						const rec=payload.new; 
						console.log('[PracticeAlerts][RT][INSERT]', rec.id, rec.type);
						window.__lastRealtimeDataUpdate = Date.now(); // 记录数据更新时间
						rec.slot={start_time:rec.slot_start,end_time:rec.slot_end}; 
						if(!AlertStore.byId.has(String(rec.id))){ 
							AlertStore.list.unshift(rec); 
							AlertStore.byId.set(String(rec.id),rec); 
							renderAlerts(); 
						}
					})
					.on('postgres_changes',{event:'DELETE',schema:'public',table:'practice_alerts'}, payload=>{
						const rec=payload.old; 
						console.log('[PracticeAlerts][RT][DELETE]', rec?.id);
						window.__lastRealtimeDataUpdate = Date.now(); // 记录数据更新时间
						if(rec?.id!=null){ removeAlertLocal(rec.id); renderAlerts(); }
					})
					.on('postgres_changes',{event:'UPDATE',schema:'public',table:'practice_alerts'}, payload=>{ 
						const rec=payload.new; 
						console.log('[PracticeAlerts][RT][UPDATE]', rec.id, 'ignored=', rec.ignored);
						window.__lastRealtimeDataUpdate = Date.now(); // 记录数据更新时间
						// 若被标记忽略，直接本地移除
						if(rec.ignored){ removeAlertLocal(rec.id); return renderAlerts(); }
						const exist=AlertStore.byId.get(String(rec.id)); 
						if(exist){ 
							Object.assign(exist,rec); 
							exist.slot={start_time:rec.slot_start,end_time:rec.slot_end}; 
							renderAlerts(); 
						} else {
							rec.slot={start_time:rec.slot_start,end_time:rec.slot_end};
							AlertStore.list.unshift(rec);
							AlertStore.byId.set(String(rec.id), rec);
							renderAlerts();
						}
					})
					.subscribe(status=>{ 
						if(status==='SUBSCRIBED'){
							AlertStore._rtRetry = 0;
							AlertStore._rtConnecting=false;
							AlertStore._lastSuccessConnect = Date.now();
							// 只在首次连接或重连成功时输出日志
							if(AlertStore._rtRetry > 0 || !AlertStore._lastSuccessConnect) {
								console.log('[PracticeAlerts][RT] ✅ 已连接');
							}
							return;
						}
						if(status==='CHANNEL_ERROR' || status==='TIMED_OUT' || status==='CLOSED'){
							AlertStore._rtConnecting=false;
							
							// 检查是否刚连接成功不久，避免频繁重连
							const timeSinceLastSuccess = Date.now() - (AlertStore._lastSuccessConnect || 0);
							if(timeSinceLastSuccess < 5000) { // 5秒内不重连
								return;
							}
							
							const MAX_RETRIES = 6; // 减少重试次数
							if(AlertStore._rtRetry < MAX_RETRIES){
								AlertStore._rtRetry++;
								// 更平缓的退避算法：2秒起步，最多30秒
								const base = 2000; 
								const delay = Math.min(30000, Math.round(base * Math.pow(1.8, AlertStore._rtRetry-1) + Math.random()*1000));
								
								// 减少日志频率：只在前3次或每5次输出一次
								if(AlertStore._rtRetry <= 3 || AlertStore._rtRetry % 5 === 0) {
									console.warn(`[PracticeAlerts][RT] 状态=${status} 重连#${AlertStore._rtRetry} in ${Math.round(delay/1000)}s`);
								}
								
								if(!AlertStore._rtTimer){
									AlertStore._rtTimer = setTimeout(()=>{ 
										AlertStore._rtTimer=null; 
										setupRealtime(); 
									}, delay);
								}
							}else{
								console.error('[PracticeAlerts][RT] 达到最大重试次数，停止重连');
								AlertStore._rtRetry = 0; // 重置计数器，允许后续手动重试
							}
						}
					}); 
			}catch(e){ 
				AlertStore._rtConnecting=false;
				console.error('realtime alerts subscribe fail', e); 
			}
	}
	
	// 手动重置连接状态并重新连接
	function resetConnection() {
		console.log('[PracticeAlerts] 手动重置连接');
		if(AlertStore._rtTimer) {
			clearTimeout(AlertStore._rtTimer);
			AlertStore._rtTimer = null;
		}
		AlertStore._rtRetry = 0;
		AlertStore._rtConnecting = false;
		AlertStore._lastSuccessConnect = null;
		
		if(AlertStore._rtChannel) {
			try{ supabaseClient.removeChannel(AlertStore._rtChannel); }catch(_e){}
			AlertStore._rtChannel = null;
		}
		
		// 延迟重连，避免立即重连
		setTimeout(() => setupRealtime(), 1000);
	}
		async function initAlerts(){ 
			console.log('[PracticeAlerts] initAlerts 开始');
			await fetchExistingAlerts(); 
			await ensureSlotsLoaded(); 
			startTimer(); 
			setupRealtime(); 
			detectionTick(); 
				// 💡 周期对账频率优化 - 从30秒延长到5分钟
				if(!AlertStore._reconcileInterval){ 
					const RECONCILE_INTERVAL = 300000; // 5分钟间隔
					logInfo(`忽略状态协调启动，间隔${RECONCILE_INTERVAL/60000}分钟`);
					AlertStore._reconcileInterval = setInterval(()=>reconcileIgnored(), RECONCILE_INTERVAL); 
				}
				scheduleReconcile(3000);
			console.log('[PracticeAlerts] initAlerts 完成');
		}
		async function refreshSlots(runDetect){ await forceReloadSlots(); if(runDetect) detectionTick(); }
		window.PracticeAlerts={ initAlerts, renderAlerts, detectionTick, ignoreAlert, ignoreAllAlerts, createAlert, refreshSlots, recalcToday, resetConnection, setFilter(f){ AlertStore.filter=f; renderAlerts(); } };
	document.addEventListener('DOMContentLoaded',()=>{ 
		console.log('[PracticeAlerts] DOMContentLoaded 触发');
		console.log('[PracticeAlerts] window.supabaseClient:', !!window.supabaseClient);
		
		// 直接检查 supabaseClient 而不是 supabaseReady
		if(window.supabaseClient) {
			console.log('[PracticeAlerts] supabaseClient 存在，1.2秒后启动');
			setTimeout(()=>initAlerts(), 1200); 
		} else { 
			console.log('[PracticeAlerts] supabaseClient 不存在，等待中...');
			const tick=setInterval(()=>{ 
				console.log('[PracticeAlerts] 检查 supabaseClient:', !!window.supabaseClient);
				if(window.supabaseClient){ 
					console.log('[PracticeAlerts] supabaseClient 已就绪，启动中...');
					clearInterval(tick); 
					initAlerts(); 
				} 
			}, 2000); // 💡 延长到2秒间隔，减少初始化检查频率 
		} 
		document.addEventListener('click',e=>{ 
			const t=e.target; 
			if(t.classList && t.classList.contains('alert-filter-btn')){ 
				PracticeAlerts.setFilter(t.dataset.filter); 
			} else if(t.id === 'ignoreAllBtn') {
				// 一键忽略功能
				const sorted=[...AlertStore.list].sort((a,b)=>{
					function slotKey(x){
						if(x.slot){
							const et=x.slot.end_time||x.slot.start_time; 
							return timeStrToMinutes(et);
						}
						return (x.created_at? new Date(x.created_at).getTime()/60000 : -1);
					}
					const ka=slotKey(a); const kb=slotKey(b);
					if(kb!==ka) return kb-ka;
					return (b.id||0)-(a.id||0);
				});
				const filtered=applyFilter(sorted);
				
				if(filtered.length === 0) {
					alert('当前筛选条件下没有可忽略的提醒');
					return;
				}
				
				if(confirm(`确定要忽略当前筛选条件下的所有 ${filtered.length} 条提醒吗？`)) {
					t.disabled = true;
					t.textContent = '忽略中...';
					PracticeAlerts.ignoreAllAlerts().then(() => {
						t.disabled = false;
						t.textContent = '一键忽略';
					}).catch(error => {
						console.error('一键忽略失败:', error);
						t.disabled = false;
						t.textContent = '一键忽略';
						alert('一键忽略操作失败，请稍后重试');
					});
				}
			}
		}); 
	});
})();
</script>

<script>
// 琴房状态同步增强功能
(function() {
	// 手动同步房间状态功能
	window.manualSyncRoomStates = async function() {
		if (!window.supabaseClient) {
			console.warn('Supabase 未连接');
			return;
		}
		
		try {
			const rooms = window.Store?.rooms || [];
			console.log(`开始手动同步 ${rooms.length} 个房间状态`);
			
			for (const room of rooms) {
				if (room.name) {
					await reconcileRoomState(room.name);
					await new Promise(resolve => setTimeout(resolve, 50));
				}
			}
			
			if (window.toast) window.toast('✅ 房间状态同步完成', 'success');
			console.log('手动房间状态同步完成');
		} catch (error) {
			console.error('房间状态同步失败:', error);
			if (window.toast) window.toast('❌ 房间状态同步失败', 'error');
		}
	};
	
	// 手动同步所有数据（房间+学生）
	window.manualSyncAllData = async function() {
		if (!window.supabaseClient) {
			console.warn('Supabase 未连接');
			if (window.toast) window.toast('❌ Supabase 未连接', 'error');
			return;
		}
		
		try {
			console.log('开始同步所有数据...');
			if (window.toast) window.toast('🔄 开始同步所有数据...', 'info');
			
			// 同步房间状态
			await window.manualSyncRoomStates();
			
			// 同步学生数据
			if (window.manualSyncStudentData) {
				await window.manualSyncStudentData();
			}
			
			console.log('所有数据同步完成');
			if (window.toast) window.toast('✅ 所有数据同步完成', 'success');
		} catch (error) {
			console.error('数据同步失败:', error);
			if (window.toast) window.toast('❌ 数据同步失败', 'error');
		}
	};
	
	// 状态一致性检查和修复
	async function reconcileRoomState(roomName) {
		if (!window.supabaseClient || !window.Store) return;
		
		try {
			const { data: cloudRoom, error } = await window.supabaseClient
				.from('rooms')
				.select('*')
				.eq('name', roomName)
				.single();
				
			if (error) {
				console.warn(`获取房间 ${roomName} 云端状态失败:`, error.message);
				return;
			}
			
			const localRoom = window.Store.rooms.find(r => r.name === roomName);
			if (!localRoom) return;
			
			const cloudVersion = cloudRoom?.version || 0;
			const localVersion = localRoom.version || 0;
			
			// 如果云端版本更新，同步到本地
			if (cloudVersion > localVersion) {
				console.log(`同步房间 ${roomName} 状态: v${localVersion} -> v${cloudVersion}`);
				localRoom.occupant_student_name = cloudRoom.occupant_student_name;
				localRoom.registerTime = cloudRoom.register_time ? new Date(cloudRoom.register_time).getTime() : null;
				localRoom.version = cloudVersion;
				localRoom.heartbeatAt = cloudRoom.heartbeat_at;
				
				// 重新渲染房间卡片
				if (window.renderRoomCard) window.renderRoomCard(roomName);
				if (window.updateUsageStats) window.updateUsageStats();
				
				const action = cloudRoom.occupant_student_name ? '占用' : '释放';
				if (window.toast) window.toast(`🔄 ${roomName} 状态已同步: ${action}`, 'info');
			}
		} catch (e) {
			console.warn(`房间状态同步异常 ${roomName}:`, e.message);
		}
	}
})();

// 主要按钮绑定初始化
document.addEventListener('DOMContentLoaded', () => {
	// 绑定顶部按钮
	function bind(id, handler){
		const el = document.getElementById(id);
		if(el){ 
			el.onclick = handler; 
			console.log(`[BIND] 成功绑定按钮: ${id}`);
		}
		else { 
			console.warn('[WARN] 按钮缺失:', id); 
		}
	}
	
	// 绑定所有按钮
	bind('btnSyncToCloud', window.manualSyncToCloud);
	bind('btnEditRooms', window.toggleEditMode);
	bind('btnCheckConsistency', window.checkDataConsistency);
	// 修改：直接绑定批量清空函数（其内部已包含二次确认 showClearAllConfirm）
	bind('btnClearAllRooms', async () => {
		if (window.__clearingAllRooms) {
			console.log('[清空全部] 操作进行中，忽略重复点击');
			return;
		}
		window.__clearingAllRooms = true;
		const btn = document.getElementById('btnClearAllRooms');
		const origText = btn ? btn.textContent : '';
		if (btn) { btn.disabled = true; btn.textContent = '处理中...'; }
		try {
			await window.clearAllRooms();
		} catch(e) {
			console.warn('[清空全部] 执行异常:', e);
			if (window.toast) window.toast('清空全部操作异常: '+ (e.message||e), 'warn');
		} finally {
			window.__clearingAllRooms = false;
			if (btn) { btn.disabled = false; btn.textContent = origText; }
		}
	});
	
	console.log('[INIT] 按钮绑定完成');
	
	// 🔧 页面完全加载后进行数据一致性检查（仅在特定条件下）
	setTimeout(async () => {
		// 只有在检测到可能的问题时才执行验证
		const shouldValidate = 
			// 有缓存残留时
			localStorage.getItem('yms_timer_states') ||
			// 页面访问时间间隔较长时（超过30分钟）
			(!window.__lastPageLoad || (Date.now() - window.__lastPageLoad) > 30 * 60 * 1000) ||
			// 强制验证标记存在时
			sessionStorage.getItem('force_consistency_check');
		
		if (shouldValidate && window.supabaseReady && window.DataConsistencyValidator) {
			try {
				logInfo('[INIT] 执行页面加载完成后的数据一致性检查');
				const validation = await window.DataConsistencyValidator.validateOnPageLoad();
				if (validation.issues > 0) {
					logWarn(`[INIT] 页面初始化发现 ${validation.issues} 个数据一致性问题，已修复`);
					toast(`页面初始化修复了 ${validation.issues} 个数据问题`, 'info');
				} else {
					logInfo('[INIT] 页面初始化数据一致性检查通过');
				}
				// 清除强制验证标记
				sessionStorage.removeItem('force_consistency_check');
			} catch (error) {
				logErr('[INIT] 页面初始化数据一致性检查失败:', error.message);
			}
		}
		
		// 记录页面加载时间
		window.__lastPageLoad = Date.now();
	}, 10000); // 页面加载10秒后执行，确保所有初始化完成
	
	// 初始化连接管理器
	if (window.RealtimeConnectionManager) {
		// 监听网络状态变化
		window.addEventListener('online', () => {
			console.log('[连接管理] 网络已上线');
			RealtimeConnectionManager.checkNetworkStatus();
		});
		
		window.addEventListener('offline', () => {
			console.log('[连接管理] 网络已离线');
			RealtimeConnectionManager.checkNetworkStatus();
		});
		
		// 页面可见性变化监听（用户切换标签页）
		document.addEventListener('visibilitychange', () => {
			if (!document.hidden) {
				// 页面重新可见时检查连接状态
				setTimeout(() => {
					if (window.RealtimeConnectionManager) {
						const status = RealtimeConnectionManager.getConnectionStatus();
						const hasActiveTimers = status.rooms.hasTimer || status.students.hasTimer;
						if (hasActiveTimers) {
							console.log('[连接管理] 页面重新激活，检查连接状态');
							RealtimeConnectionManager.checkNetworkStatus();
						}
					}
				}, 1000);
			}
		});
		
		// 定期健康检查和自动修复
		setInterval(() => {
			if (window.RealtimeConnectionManager) {
				RealtimeConnectionManager.checkNetworkStatus();
				
				const quality = RealtimeConnectionManager.assessConnectionQuality();
				const status = RealtimeConnectionManager.getConnectionStatus();
				
				// 自动修复逻辑
				if (quality === 'poor') {
					console.warn('[连接管理] 连接质量差，触发自动修复');
					
					// 检查是否有连接卡在重连状态超过5分钟
					const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
					const roomsStuck = status.rooms.hasTimer && status.rooms.attempts > 8;
					const studentsStuck = status.students.hasTimer && status.students.attempts > 8;
					const practiceStuck = status.practiceAlerts.hasTimer && status.practiceAlerts.attempts > 8;
					
					if (roomsStuck || studentsStuck || practiceStuck) {
						console.log('[连接管理] 检测到连接卡死，执行强制重置');
						RealtimeConnectionManager.resetAllConnections(true);
					}
				}
				
				// 每10分钟输出一次状态摘要（仅在有问题时）
				if (Date.now() % (10 * 60 * 1000) < 60000) {
					const totalAttempts = status.rooms.attempts + status.students.attempts + status.practiceAlerts.attempts;
					if (totalAttempts > 0) {
						console.log('[连接管理] 状态摘要 - 总重试次数:', totalAttempts, '网络质量:', quality);
					}
				}
			}
		}, 60000); // 每分钟检查一次
	}
});

// 增强的实时连接管理器
window.RealtimeConnectionManager = {
	// 连接健康监控
	_healthCheck: {
		lastCheck: 0,
		checkInterval: 30000, // 30秒检查一次
		consecutiveFailures: 0,
		maxFailures: 3,
		networkOffline: false
	},
	
	// 检测网络状态
	checkNetworkStatus: function() {
		const isOnline = navigator.onLine;
		if (!isOnline && !this._healthCheck.networkOffline) {
			console.log('[连接管理] 网络已断开，暂停重连');
			this._healthCheck.networkOffline = true;
			this.pauseAllReconnections();
		} else if (isOnline && this._healthCheck.networkOffline) {
			console.log('[连接管理] 网络已恢复，重置连接状态');
			this._healthCheck.networkOffline = false;
			this._healthCheck.consecutiveFailures = 0;
			// 延迟重连，避免网络刚恢复时立即重连
			setTimeout(() => this.resetAllConnections(true), 2000);
		}
		return isOnline;
	},
	
	// 连接质量评估
	assessConnectionQuality: function() {
		const now = Date.now();
		const roomAttempts = window.__roomsRealtimeAttempts || 0;
		const studentAttempts = window.__studentsRealtimeAttempts || 0;
		const practiceAttempts = window.PracticeAlerts?._rtRetry || 0;
		
		// 如果所有模块都在频繁重连，说明网络质量差
		const totalAttempts = roomAttempts + studentAttempts + practiceAttempts;
		if (totalAttempts > 10) {
			console.warn('[连接管理] 检测到连接质量差，调整重连策略');
			return 'poor';
		} else if (totalAttempts > 5) {
			return 'moderate';
		}
		return 'good';
	},
	
	// 暂停所有重连
	pauseAllReconnections: function() {
		console.log('[连接管理] 暂停所有自动重连');
		
		if(window.__roomsRealtimeReconnectTimer) {
			clearTimeout(window.__roomsRealtimeReconnectTimer);
			window.__roomsRealtimeReconnectTimer = null;
		}
		
		if(window.__studentsRealtimeReconnectTimer) {
			clearTimeout(window.__studentsRealtimeReconnectTimer);
			window.__studentsRealtimeReconnectTimer = null;
		}
		
		if(window.PracticeAlerts && window.PracticeAlerts._rtTimer) {
			clearTimeout(window.PracticeAlerts._rtTimer);
			window.PracticeAlerts._rtTimer = null;
		}
	},
	
	resetAllConnections: function(force = false) {
		console.log('[连接管理] 重置所有实时连接状态' + (force ? ' (强制)' : ''));
		
		// 检查网络状态
		if (!force && !this.checkNetworkStatus()) {
			console.log('[连接管理] 网络离线，跳过重置');
			return;
		}
		
		// 评估连接质量
		const quality = this.assessConnectionQuality();
		if (quality === 'poor' && !force) {
			console.log('[连接管理] 连接质量差，延迟重置');
			setTimeout(() => this.resetAllConnections(true), 10000);
			return;
		}
		
		// 重置 rooms 连接状态
		if(window.__roomsRealtimeReconnectTimer) {
			clearTimeout(window.__roomsRealtimeReconnectTimer);
			window.__roomsRealtimeReconnectTimer = null;
		}
		window.__roomsRealtimeAttempts = 0;
		window.__roomsRealtimeReconnecting = false;
		window.__roomsInitialConnected = false;
		
		// 重置 students 连接状态
		if(window.__studentsRealtimeReconnectTimer) {
			clearTimeout(window.__studentsRealtimeReconnectTimer);
			window.__studentsRealtimeReconnectTimer = null;
		}
		window.__studentsRealtimeAttempts = 0;
		window.__studentsInitialConnected = false;
		
		// 重置 PracticeAlerts 连接状态
		if(window.PracticeAlerts && window.PracticeAlerts.resetConnection) {
			window.PracticeAlerts.resetConnection();
		}
		
		// 重置健康检查状态
		this._healthCheck.consecutiveFailures = 0;
		this._healthCheck.lastCheck = Date.now();
		
		console.log('[连接管理] 重置完成');
	},
	
	getConnectionStatus: function() {
		const now = Date.now();
		return {
			network: {
				online: navigator.onLine,
				offline: this._healthCheck.networkOffline,
				quality: this.assessConnectionQuality(),
				lastCheck: new Date(this._healthCheck.lastCheck).toLocaleTimeString(),
				consecutiveFailures: this._healthCheck.consecutiveFailures
			},
			rooms: {
				attempts: window.__roomsRealtimeAttempts || 0,
				reconnecting: window.__roomsRealtimeReconnecting || false,
				initialConnected: window.__roomsInitialConnected || false,
				hasTimer: !!window.__roomsRealtimeReconnectTimer,
				lastClosedTime: window.__lastClosedTime ? new Date(window.__lastClosedTime).toLocaleTimeString() : 'N/A'
			},
			students: {
				attempts: window.__studentsRealtimeAttempts || 0,
				initialConnected: window.__studentsInitialConnected || false,
				hasTimer: !!window.__studentsRealtimeReconnectTimer,
				lastClosedTime: window.__lastStudentClosedTime ? new Date(window.__lastStudentClosedTime).toLocaleTimeString() : 'N/A'
			},
			practiceAlerts: {
				available: !!(window.PracticeAlerts && window.PracticeAlerts.resetConnection),
				attempts: window.PracticeAlerts?._rtRetry || 0,
				connecting: window.PracticeAlerts?._rtConnecting || false,
				hasTimer: window.PracticeAlerts?._rtTimer ? true : false
			},
			supabase: {
				ready: window.supabaseReady || false,
				client: !!window.supabaseClient
			}
		};
	},
	
	// 显示详细的连接诊断信息
	diagnose: function() {
		const status = this.getConnectionStatus();
		console.group('🔍 实时连接诊断报告');
		console.log('📊 网络状态:', status.network);
		console.log('🏠 房间连接:', status.rooms);
		console.log('👥 学生连接:', status.students);
		console.log('⚠️  练习提醒:', status.practiceAlerts);
		console.log('☁️  Supabase:', status.supabase);
		
		// 问题诊断
		const issues = [];
		if (!status.network.online) issues.push('网络离线');
		if (status.network.quality === 'poor') issues.push('网络质量差');
		if (status.rooms.attempts > 5) issues.push('房间连接频繁重试');
		if (status.students.attempts > 5) issues.push('学生连接频繁重试');
		if (status.practiceAlerts.attempts > 5) issues.push('练习提醒连接频繁重试');
		if (!status.supabase.ready) issues.push('Supabase未就绪');
		
		if (issues.length > 0) {
			console.warn('⚠️  发现的问题:', issues);
		} else {
			console.log('✅ 未发现明显问题');
		}
		
		console.groupEnd();
		return { status, issues };
	}
};
</script>

</body>
</html>
